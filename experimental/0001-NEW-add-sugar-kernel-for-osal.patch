From 3d902d47d04e90b0f2bf3b9e8ac80d241465a21f Mon Sep 17 00:00:00 2001
From: Leon Shan <wdxxshanlei@qq.com>
Date: Tue, 11 Jan 2022 18:34:30 +0800
Subject: [PATCH] NEW: add sugar kernel for osal

Signed-off-by: Leon Shan <wdxxshanlei@qq.com>
---
 .vscode/c_cpp_properties.json                 |    3 +-
 example/armgcc_stm32h7_demo/xmake.lua         |    8 +-
 osal/inc/freertos/FreeRTOS.h                  | 1295 ----
 osal/inc/freertos/FreeRTOSConfig_template.h   |  162 -
 osal/inc/freertos/StackMacros.h               |  133 -
 osal/inc/freertos/atomic.h                    |  414 --
 osal/inc/freertos/croutine.h                  |  720 ---
 osal/inc/freertos/deprecated_definitions.h    |  279 -
 osal/inc/freertos/event_groups.h              |  757 ---
 osal/inc/freertos/list.h                      |  412 --
 osal/inc/freertos/message_buffer.h            |  803 ---
 osal/inc/freertos/mpu_prototypes.h            |  160 -
 osal/inc/freertos/mpu_wrappers.h              |  189 -
 osal/inc/freertos/portable.h                  |  199 -
 osal/inc/freertos/projdefs.h                  |  124 -
 osal/inc/freertos/queue.h                     | 1655 -----
 osal/inc/freertos/semphr.h                    | 1140 ----
 osal/inc/freertos/stack_macros.h              |  129 -
 osal/inc/freertos/stdint.readme               |   27 -
 osal/inc/freertos/stream_buffer.h             |  859 ---
 osal/inc/freertos/task.h                      | 2543 --------
 osal/inc/freertos/timers.h                    | 1309 ----
 osal/inc/sugar/s_list.h                       |   43 +
 osal/inc/sugar/s_port_armv6m.h                |   69 +
 osal/inc/sugar/s_port_armv7m.h                |   69 +
 osal/inc/sugar/s_port_posix.h                 |   44 +
 osal/inc/sugar/s_port_riscv.h                 |   51 +
 osal/inc/sugar/s_port_windows.h               |   39 +
 osal/inc/sugar/s_rbtree.h                     |  112 +
 osal/inc/sugar/s_task.h                       |  286 +
 osal/inc/sugar/s_task_internal.h              |  131 +
 osal/src/freertos/LICENSE                     |   18 -
 osal/src/freertos/MemMang/ReadMe.url          |    5 -
 osal/src/freertos/MemMang/heap_1.c            |  146 -
 osal/src/freertos/MemMang/heap_2.c            |  272 -
 osal/src/freertos/MemMang/heap_3.c            |   97 -
 osal/src/freertos/MemMang/heap_4.c            |  492 --
 osal/src/freertos/MemMang/heap_5.c            |  547 --
 osal/src/freertos/croutine.c                  |  353 --
 osal/src/freertos/event_groups.c              |  753 ---
 osal/src/freertos/list.c                      |  198 -
 .../freertos/portable/Common/mpu_wrappers.c   | 1374 -----
 osal/src/freertos/portable/GCC/ARM_CM0/port.c |  560 --
 .../freertos/portable/GCC/ARM_CM0/portmacro.h |  124 -
 .../portable/GCC/ARM_CM23/non_secure/port.c   | 1149 ----
 .../GCC/ARM_CM23/non_secure/portasm.c         |  453 --
 .../GCC/ARM_CM23/non_secure/portasm.h         |  113 -
 .../GCC/ARM_CM23/non_secure/portmacro.h       |  310 -
 .../GCC/ARM_CM23/secure/secure_context.c      |  204 -
 .../GCC/ARM_CM23/secure/secure_context.h      |  111 -
 .../GCC/ARM_CM23/secure/secure_context_port.c |   91 -
 .../GCC/ARM_CM23/secure/secure_heap.c         |  450 --
 .../GCC/ARM_CM23/secure/secure_heap.h         |   51 -
 .../GCC/ARM_CM23/secure/secure_init.c         |  105 -
 .../GCC/ARM_CM23/secure/secure_init.h         |   53 -
 .../GCC/ARM_CM23/secure/secure_port_macros.h  |  133 -
 .../GCC/ARM_CM23_NTZ/non_secure/port.c        | 1149 ----
 .../GCC/ARM_CM23_NTZ/non_secure/portasm.c     |  366 --
 .../GCC/ARM_CM23_NTZ/non_secure/portasm.h     |  113 -
 .../GCC/ARM_CM23_NTZ/non_secure/portmacro.h   |  310 -
 osal/src/freertos/portable/GCC/ARM_CM3/port.c |  717 ---
 .../freertos/portable/GCC/ARM_CM3/portmacro.h |  245 -
 .../portable/GCC/ARM_CM33/non_secure/port.c   | 1149 ----
 .../GCC/ARM_CM33/non_secure/portasm.c         |  410 --
 .../GCC/ARM_CM33/non_secure/portasm.h         |  113 -
 .../GCC/ARM_CM33/non_secure/portmacro.h       |  310 -
 .../GCC/ARM_CM33/secure/secure_context.c      |  204 -
 .../GCC/ARM_CM33/secure/secure_context.h      |  111 -
 .../GCC/ARM_CM33/secure/secure_context_port.c |   88 -
 .../GCC/ARM_CM33/secure/secure_heap.c         |  450 --
 .../GCC/ARM_CM33/secure/secure_heap.h         |   51 -
 .../GCC/ARM_CM33/secure/secure_init.c         |  105 -
 .../GCC/ARM_CM33/secure/secure_init.h         |   53 -
 .../GCC/ARM_CM33/secure/secure_port_macros.h  |  133 -
 .../GCC/ARM_CM33_NTZ/non_secure/port.c        | 1149 ----
 .../GCC/ARM_CM33_NTZ/non_secure/portasm.c     |  316 -
 .../GCC/ARM_CM33_NTZ/non_secure/portasm.h     |  113 -
 .../GCC/ARM_CM33_NTZ/non_secure/portmacro.h   |  310 -
 .../freertos/portable/GCC/ARM_CM3_MPU/port.c  |  857 ---
 .../portable/GCC/ARM_CM3_MPU/portmacro.h      |  307 -
 .../src/freertos/portable/GCC/ARM_CM4F/port.c |  775 ---
 .../portable/GCC/ARM_CM4F/portmacro.h         |  243 -
 .../freertos/portable/GCC/ARM_CM4_MPU/port.c  |  933 ---
 .../portable/GCC/ARM_CM4_MPU/portmacro.h      |  307 -
 .../freertos/portable/GCC/ARM_CM7/ReadMe.txt  |   18 -
 .../freertos/portable/GCC/ARM_CM7/r0p1/port.c |  765 ---
 .../portable/GCC/ARM_CM7/r0p1/portmacro.h     |  247 -
 .../portable/GCC/ARM_CM7_MPU/ReadMe.txt       |   18 -
 .../portable/GCC/ARM_CM7_MPU/r0p1/port.c      |  936 ---
 .../portable/GCC/ARM_CM7_MPU/r0p1/portmacro.h |  312 -
 osal/src/freertos/portable/IAR/ARM_CM0/port.c |  424 --
 .../freertos/portable/IAR/ARM_CM0/portasm.s   |  131 -
 .../freertos/portable/IAR/ARM_CM0/portmacro.h |  129 -
 .../portable/IAR/ARM_CM23/non_secure/port.c   | 1149 ----
 .../IAR/ARM_CM23/non_secure/portasm.h         |  113 -
 .../IAR/ARM_CM23/non_secure/portasm.s         |  377 --
 .../IAR/ARM_CM23/non_secure/portmacro.h       |  317 -
 .../IAR/ARM_CM23/secure/secure_context.c      |  204 -
 .../IAR/ARM_CM23/secure/secure_context.h      |  111 -
 .../IAR/ARM_CM23/secure/secure_context_port.c |   48 -
 .../ARM_CM23/secure/secure_context_port_asm.s |   76 -
 .../IAR/ARM_CM23/secure/secure_heap.c         |  450 --
 .../IAR/ARM_CM23/secure/secure_heap.h         |   51 -
 .../IAR/ARM_CM23/secure/secure_init.c         |  105 -
 .../IAR/ARM_CM23/secure/secure_init.h         |   53 -
 .../IAR/ARM_CM23/secure/secure_port_macros.h  |  133 -
 .../IAR/ARM_CM23_NTZ/non_secure/port.c        | 1149 ----
 .../IAR/ARM_CM23_NTZ/non_secure/portasm.h     |  113 -
 .../IAR/ARM_CM23_NTZ/non_secure/portasm.s     |  303 -
 .../IAR/ARM_CM23_NTZ/non_secure/portmacro.h   |  317 -
 osal/src/freertos/portable/IAR/ARM_CM3/port.c |  619 --
 .../freertos/portable/IAR/ARM_CM3/portasm.s   |  103 -
 .../freertos/portable/IAR/ARM_CM3/portmacro.h |  208 -
 .../portable/IAR/ARM_CM33/non_secure/port.c   | 1149 ----
 .../IAR/ARM_CM33/non_secure/portasm.h         |  113 -
 .../IAR/ARM_CM33/non_secure/portasm.s         |  341 --
 .../IAR/ARM_CM33/non_secure/portmacro.h       |  317 -
 .../IAR/ARM_CM33/secure/secure_context.c      |  204 -
 .../IAR/ARM_CM33/secure/secure_context.h      |  111 -
 .../IAR/ARM_CM33/secure/secure_context_port.c |   48 -
 .../ARM_CM33/secure/secure_context_port_asm.s |   73 -
 .../IAR/ARM_CM33/secure/secure_heap.c         |  450 --
 .../IAR/ARM_CM33/secure/secure_heap.h         |   51 -
 .../IAR/ARM_CM33/secure/secure_init.c         |  105 -
 .../IAR/ARM_CM33/secure/secure_init.h         |   53 -
 .../IAR/ARM_CM33/secure/secure_port_macros.h  |  133 -
 .../IAR/ARM_CM33_NTZ/non_secure/port.c        | 1149 ----
 .../IAR/ARM_CM33_NTZ/non_secure/portasm.h     |  113 -
 .../IAR/ARM_CM33_NTZ/non_secure/portasm.s     |  257 -
 .../IAR/ARM_CM33_NTZ/non_secure/portmacro.h   |  317 -
 .../src/freertos/portable/IAR/ARM_CM4F/port.c |  656 --
 .../freertos/portable/IAR/ARM_CM4F/portasm.s  |  149 -
 .../portable/IAR/ARM_CM4F/portmacro.h         |  207 -
 .../freertos/portable/IAR/ARM_CM4_MPU/port.c  |  749 ---
 .../portable/IAR/ARM_CM4_MPU/portasm.s        |  231 -
 .../portable/IAR/ARM_CM4_MPU/portmacro.h      |  267 -
 .../freertos/portable/IAR/ARM_CM7/ReadMe.txt  |   18 -
 .../freertos/portable/IAR/ARM_CM7/r0p1/port.c |  644 --
 .../portable/IAR/ARM_CM7/r0p1/portasm.s       |  151 -
 .../portable/IAR/ARM_CM7/r0p1/portmacro.h     |  210 -
 .../portable/IAR/ARM_CM7_MPU/ReadMe.txt       |   18 -
 .../portable/IAR/ARM_CM7_MPU/r0p1/port.c      |  738 ---
 .../portable/IAR/ARM_CM7_MPU/r0p1/portasm.s   |  233 -
 .../portable/IAR/ARM_CM7_MPU/r0p1/portmacro.h |  270 -
 .../Keil/See-also-the-RVDS-directory.txt      |    1 -
 .../src/freertos/portable/RVDS/ARM_CM0/port.c |  530 --
 .../portable/RVDS/ARM_CM0/portmacro.h         |  121 -
 .../src/freertos/portable/RVDS/ARM_CM3/port.c |  698 ---
 .../portable/RVDS/ARM_CM3/portmacro.h         |  252 -
 .../freertos/portable/RVDS/ARM_CM4F/port.c    |  788 ---
 .../portable/RVDS/ARM_CM4F/portmacro.h        |  252 -
 .../freertos/portable/RVDS/ARM_CM4_MPU/port.c |  916 ---
 .../portable/RVDS/ARM_CM4_MPU/portmacro.h     |  316 -
 .../freertos/portable/RVDS/ARM_CM7/ReadMe.txt |   18 -
 .../portable/RVDS/ARM_CM7/r0p1/port.c         |  774 ---
 .../portable/RVDS/ARM_CM7/r0p1/portmacro.h    |  256 -
 .../portable/RVDS/ARM_CM7_MPU/ReadMe.txt      |   18 -
 .../portable/RVDS/ARM_CM7_MPU/r0p1/port.c     |  917 ---
 .../RVDS/ARM_CM7_MPU/r0p1/portmacro.h         |  321 -
 .../freertos/portable/Tasking/ARM_CM4F/port.c |  263 -
 .../portable/Tasking/ARM_CM4F/port_asm.asm    |  236 -
 .../portable/Tasking/ARM_CM4F/portmacro.h     |  133 -
 osal/src/freertos/portable/readme.txt         |   20 -
 osal/src/freertos/queue.c                     | 2945 ---------
 osal/src/freertos/stream_buffer.c             | 1263 ----
 osal/src/freertos/tasks.c                     | 5310 -----------------
 osal/src/freertos/timers.c                    | 1127 ----
 osal/src/sugar/asm/jump_arm64_aapcs_elf_gas.S |  114 +
 osal/src/sugar/asm/jump_arm_aapcs_elf_gas.S   |   88 +
 osal/src/sugar/asm/jump_gas.S                 |   19 +
 osal/src/sugar/asm/jump_riscv32_elf_gas.S     |  111 +
 .../src/sugar/asm/jump_riscv64_sysv_elf_gas.S |  150 +
 osal/src/sugar/asm/jump_x86_64_ms_pe_gas.asm  |  209 +
 osal/src/sugar/asm/jump_x86_64_sysv_elf_gas.S |   81 +
 osal/src/sugar/asm/make_arm64_aapcs_elf_gas.S |   85 +
 osal/src/sugar/asm/make_arm_aapcs_elf_gas.S   |   81 +
 osal/src/sugar/asm/make_gas.S                 |   19 +
 osal/src/sugar/asm/make_riscv32_elf_gas.S     |   42 +
 .../src/sugar/asm/make_riscv64_sysv_elf_gas.S |   91 +
 osal/src/sugar/asm/make_x86_64_ms_pe_gas.asm  |  174 +
 osal/src/sugar/asm/make_x86_64_sysv_elf_gas.S |   82 +
 osal/src/sugar/mm.c                           |    0
 osal/src/sugar/s_chan.c                       |  145 +
 osal/src/sugar/s_chan_embed.c                 |  164 +
 osal/src/sugar/s_event.c                      |  180 +
 osal/src/sugar/s_event_embed.c                |  135 +
 osal/src/sugar/s_list.c                       |   72 +
 osal/src/sugar/s_mutex.c                      |  110 +
 osal/src/sugar/s_port_armv6m.inc.h            |   93 +
 osal/src/sugar/s_port_armv7m.inc.h            |   68 +
 osal/src/sugar/s_port_posix.inc.h             |   52 +
 osal/src/sugar/s_port_riscv.inc.h             |   40 +
 osal/src/sugar/s_port_windows.inc.h           |   38 +
 osal/src/sugar/s_rbtree.c                     |  960 +++
 osal/src/sugar/s_task.c                       |  371 ++
 osal/src/sugar/s_timer_fast.c                 |  144 +
 osal/src/sugar/s_timer_small.c                |   88 +
 197 files changed, 4857 insertions(+), 68841 deletions(-)
 delete mode 100644 osal/inc/freertos/FreeRTOS.h
 delete mode 100644 osal/inc/freertos/FreeRTOSConfig_template.h
 delete mode 100644 osal/inc/freertos/StackMacros.h
 delete mode 100644 osal/inc/freertos/atomic.h
 delete mode 100644 osal/inc/freertos/croutine.h
 delete mode 100644 osal/inc/freertos/deprecated_definitions.h
 delete mode 100644 osal/inc/freertos/event_groups.h
 delete mode 100644 osal/inc/freertos/list.h
 delete mode 100644 osal/inc/freertos/message_buffer.h
 delete mode 100644 osal/inc/freertos/mpu_prototypes.h
 delete mode 100644 osal/inc/freertos/mpu_wrappers.h
 delete mode 100644 osal/inc/freertos/portable.h
 delete mode 100644 osal/inc/freertos/projdefs.h
 delete mode 100644 osal/inc/freertos/queue.h
 delete mode 100644 osal/inc/freertos/semphr.h
 delete mode 100644 osal/inc/freertos/stack_macros.h
 delete mode 100644 osal/inc/freertos/stdint.readme
 delete mode 100644 osal/inc/freertos/stream_buffer.h
 delete mode 100644 osal/inc/freertos/task.h
 delete mode 100644 osal/inc/freertos/timers.h
 create mode 100644 osal/inc/sugar/s_list.h
 create mode 100644 osal/inc/sugar/s_port_armv6m.h
 create mode 100644 osal/inc/sugar/s_port_armv7m.h
 create mode 100644 osal/inc/sugar/s_port_posix.h
 create mode 100644 osal/inc/sugar/s_port_riscv.h
 create mode 100644 osal/inc/sugar/s_port_windows.h
 create mode 100644 osal/inc/sugar/s_rbtree.h
 create mode 100644 osal/inc/sugar/s_task.h
 create mode 100644 osal/inc/sugar/s_task_internal.h
 delete mode 100644 osal/src/freertos/LICENSE
 delete mode 100644 osal/src/freertos/MemMang/ReadMe.url
 delete mode 100644 osal/src/freertos/MemMang/heap_1.c
 delete mode 100644 osal/src/freertos/MemMang/heap_2.c
 delete mode 100644 osal/src/freertos/MemMang/heap_3.c
 delete mode 100644 osal/src/freertos/MemMang/heap_4.c
 delete mode 100644 osal/src/freertos/MemMang/heap_5.c
 delete mode 100644 osal/src/freertos/croutine.c
 delete mode 100644 osal/src/freertos/event_groups.c
 delete mode 100644 osal/src/freertos/list.c
 delete mode 100644 osal/src/freertos/portable/Common/mpu_wrappers.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM0/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM0/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context_port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_port_macros.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM3/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM3/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context_port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_port_macros.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM3_MPU/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM3_MPU/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM4F/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM4F/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM4_MPU/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM4_MPU/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM7/ReadMe.txt
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM7/r0p1/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM7/r0p1/portmacro.h
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM7_MPU/ReadMe.txt
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/port.c
 delete mode 100644 osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM0/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM0/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM0/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port_asm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_port_macros.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM3/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM3/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM3/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port_asm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_port_macros.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM4F/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM4F/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM4F/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM4_MPU/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM4_MPU/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM4_MPU/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7/ReadMe.txt
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7/r0p1/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portmacro.h
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7_MPU/ReadMe.txt
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/port.c
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portasm.s
 delete mode 100644 osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portmacro.h
 delete mode 100644 osal/src/freertos/portable/Keil/See-also-the-RVDS-directory.txt
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM0/port.c
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM0/portmacro.h
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM3/port.c
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM3/portmacro.h
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM4F/port.c
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM4F/portmacro.h
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM4_MPU/port.c
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM4_MPU/portmacro.h
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM7/ReadMe.txt
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/port.c
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/portmacro.h
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM7_MPU/ReadMe.txt
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/port.c
 delete mode 100644 osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/portmacro.h
 delete mode 100644 osal/src/freertos/portable/Tasking/ARM_CM4F/port.c
 delete mode 100644 osal/src/freertos/portable/Tasking/ARM_CM4F/port_asm.asm
 delete mode 100644 osal/src/freertos/portable/Tasking/ARM_CM4F/portmacro.h
 delete mode 100644 osal/src/freertos/portable/readme.txt
 delete mode 100644 osal/src/freertos/queue.c
 delete mode 100644 osal/src/freertos/stream_buffer.c
 delete mode 100644 osal/src/freertos/tasks.c
 delete mode 100644 osal/src/freertos/timers.c
 create mode 100644 osal/src/sugar/asm/jump_arm64_aapcs_elf_gas.S
 create mode 100644 osal/src/sugar/asm/jump_arm_aapcs_elf_gas.S
 create mode 100644 osal/src/sugar/asm/jump_gas.S
 create mode 100644 osal/src/sugar/asm/jump_riscv32_elf_gas.S
 create mode 100644 osal/src/sugar/asm/jump_riscv64_sysv_elf_gas.S
 create mode 100644 osal/src/sugar/asm/jump_x86_64_ms_pe_gas.asm
 create mode 100644 osal/src/sugar/asm/jump_x86_64_sysv_elf_gas.S
 create mode 100644 osal/src/sugar/asm/make_arm64_aapcs_elf_gas.S
 create mode 100644 osal/src/sugar/asm/make_arm_aapcs_elf_gas.S
 create mode 100644 osal/src/sugar/asm/make_gas.S
 create mode 100644 osal/src/sugar/asm/make_riscv32_elf_gas.S
 create mode 100644 osal/src/sugar/asm/make_riscv64_sysv_elf_gas.S
 create mode 100644 osal/src/sugar/asm/make_x86_64_ms_pe_gas.asm
 create mode 100644 osal/src/sugar/asm/make_x86_64_sysv_elf_gas.S
 delete mode 100644 osal/src/sugar/mm.c
 create mode 100644 osal/src/sugar/s_chan.c
 create mode 100644 osal/src/sugar/s_chan_embed.c
 create mode 100644 osal/src/sugar/s_event.c
 create mode 100644 osal/src/sugar/s_event_embed.c
 create mode 100644 osal/src/sugar/s_list.c
 create mode 100644 osal/src/sugar/s_mutex.c
 create mode 100644 osal/src/sugar/s_port_armv6m.inc.h
 create mode 100644 osal/src/sugar/s_port_armv7m.inc.h
 create mode 100644 osal/src/sugar/s_port_posix.inc.h
 create mode 100644 osal/src/sugar/s_port_riscv.inc.h
 create mode 100644 osal/src/sugar/s_port_windows.inc.h
 create mode 100644 osal/src/sugar/s_rbtree.c
 create mode 100644 osal/src/sugar/s_task.c
 create mode 100644 osal/src/sugar/s_timer_fast.c
 create mode 100644 osal/src/sugar/s_timer_small.c

diff --git a/.vscode/c_cpp_properties.json b/.vscode/c_cpp_properties.json
index 9d4afd3..4040418 100644
--- a/.vscode/c_cpp_properties.json
+++ b/.vscode/c_cpp_properties.json
@@ -12,7 +12,8 @@
                 "${workspaceFolder}/sis/cmsis/drivers/stm32h7/inc",
                 "${workspaceFolder}/rte/inc",
                 "${workspaceFolder}/hal/inc",
-                "${workspaceFolder}/osal/inc"
+                "${workspaceFolder}/osal/inc",
+                "${workspaceFolder}/osal/inc/sugar"
             ],
             "defines": [
                 "_DEBUG",
diff --git a/example/armgcc_stm32h7_demo/xmake.lua b/example/armgcc_stm32h7_demo/xmake.lua
index 67e6516..6249e26 100644
--- a/example/armgcc_stm32h7_demo/xmake.lua
+++ b/example/armgcc_stm32h7_demo/xmake.lua
@@ -18,7 +18,8 @@ target("stm32h7_demo")
                 "../../rte/src/middleware/*.c",
                 "../../hal/src/hal.c",
                 "../../hal/src/hal_gpio_stm32h7.c",
-                "../../hal/src/hal_com_stm32h7.c")
+                "../../hal/src/hal_com_stm32h7.c",
+                "../../osal/src/sugar/*.c")
     add_files("../../sis/cmsis/device/stm32h7/src/gcc/startup_stm32h750xx.s",
                 "../../sis/cmsis/device/stm32h7/src/system_stm32h7xx.c",
                 "../../sis/cmsis/drivers/stm32h7/src/stm32h7xx_hal.c",
@@ -40,8 +41,9 @@ target("stm32h7_demo")
                     "../../sis/cmsis/device/stm32h7/inc",
                     "../../sis/cmsis/drivers/stm32h7/inc",
                     "../../rte/inc",
-                    "../../hal/inc")
-    add_cxflags("-DSTM32H750xx", "-DUSE_HAL_DRIVER",
+                    "../../hal/inc",
+                    "../../osal/inc/sugar")
+    add_cxflags("-DSTM32H750xx", "-DUSE_HAL_DRIVER","-DPLATFORM_SPECIFIC_INCLUDE=\"stm32h7xx_hal.h\"",
                 "-mcpu=cortex-m7", "-mthumb", "-mfpu=fpv5-d16",
                 "-Og",
                 "-Wall", "-fdata-sections", "-ffunction-sections")
diff --git a/osal/inc/freertos/FreeRTOS.h b/osal/inc/freertos/FreeRTOS.h
deleted file mode 100644
index ceb469a..0000000
--- a/osal/inc/freertos/FreeRTOS.h
+++ /dev/null
@@ -1,1295 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef INC_FREERTOS_H
-#define INC_FREERTOS_H
-
-/*
- * Include the generic headers required for the FreeRTOS port being used.
- */
-#include <stddef.h>
-
-/*
- * If stdint.h cannot be located then:
- *   + If using GCC ensure the -nostdint options is *not* being used.
- *   + Ensure the project's include path includes the directory in which your
- *     compiler stores stdint.h.
- *   + Set any compiler options necessary for it to support C99, as technically
- *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
- *     other way).
- *   + The FreeRTOS download includes a simple stdint.h definition that can be
- *     used in cases where none is provided by the compiler.  The files only
- *     contains the typedefs required to build FreeRTOS.  Read the instructions
- *     in FreeRTOS/source/stdint.readme for more information.
- */
-#include <stdint.h> /* READ COMMENT ABOVE. */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Application specific configuration options. */
-#include "FreeRTOSConfig.h"
-
-/* Basic FreeRTOS definitions. */
-#include "projdefs.h"
-
-/* Definitions specific to the port being used. */
-#include "portable.h"
-
-/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
-#ifndef configUSE_NEWLIB_REENTRANT
-	#define configUSE_NEWLIB_REENTRANT 0
-#endif
-
-/* Required if struct _reent is used. */
-#if ( configUSE_NEWLIB_REENTRANT == 1 )
-	#include <reent.h>
-#endif
-/*
- * Check all the required application specific macros have been defined.
- * These macros are application specific and (as downloaded) are defined
- * within FreeRTOSConfig.h.
- */
-
-#ifndef configMINIMAL_STACK_SIZE
-	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
-#endif
-
-#ifndef configMAX_PRIORITIES
-	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#if configMAX_PRIORITIES < 1
-	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
-#endif
-
-#ifndef configUSE_PREEMPTION
-	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_IDLE_HOOK
-	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_TICK_HOOK
-	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_16_BIT_TICKS
-	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_CO_ROUTINES
-	#define configUSE_CO_ROUTINES 0
-#endif
-
-#ifndef INCLUDE_vTaskPrioritySet
-	#define INCLUDE_vTaskPrioritySet 0
-#endif
-
-#ifndef INCLUDE_uxTaskPriorityGet
-	#define INCLUDE_uxTaskPriorityGet 0
-#endif
-
-#ifndef INCLUDE_vTaskDelete
-	#define INCLUDE_vTaskDelete 0
-#endif
-
-#ifndef INCLUDE_vTaskSuspend
-	#define INCLUDE_vTaskSuspend 0
-#endif
-
-#ifndef INCLUDE_vTaskDelayUntil
-	#define INCLUDE_vTaskDelayUntil 0
-#endif
-
-#ifndef INCLUDE_vTaskDelay
-	#define INCLUDE_vTaskDelay 0
-#endif
-
-#ifndef INCLUDE_xTaskGetIdleTaskHandle
-	#define INCLUDE_xTaskGetIdleTaskHandle 0
-#endif
-
-#ifndef INCLUDE_xTaskAbortDelay
-	#define INCLUDE_xTaskAbortDelay 0
-#endif
-
-#ifndef INCLUDE_xQueueGetMutexHolder
-	#define INCLUDE_xQueueGetMutexHolder 0
-#endif
-
-#ifndef INCLUDE_xSemaphoreGetMutexHolder
-	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
-#endif
-
-#ifndef INCLUDE_xTaskGetHandle
-	#define INCLUDE_xTaskGetHandle 0
-#endif
-
-#ifndef INCLUDE_uxTaskGetStackHighWaterMark
-	#define INCLUDE_uxTaskGetStackHighWaterMark 0
-#endif
-
-#ifndef INCLUDE_uxTaskGetStackHighWaterMark2
-	#define INCLUDE_uxTaskGetStackHighWaterMark2 0
-#endif
-
-#ifndef INCLUDE_eTaskGetState
-	#define INCLUDE_eTaskGetState 0
-#endif
-
-#ifndef INCLUDE_xTaskResumeFromISR
-	#define INCLUDE_xTaskResumeFromISR 1
-#endif
-
-#ifndef INCLUDE_xTimerPendFunctionCall
-	#define INCLUDE_xTimerPendFunctionCall 0
-#endif
-
-#ifndef INCLUDE_xTaskGetSchedulerState
-	#define INCLUDE_xTaskGetSchedulerState 0
-#endif
-
-#ifndef INCLUDE_xTaskGetCurrentTaskHandle
-	#define INCLUDE_xTaskGetCurrentTaskHandle 0
-#endif
-
-#if configUSE_CO_ROUTINES != 0
-	#ifndef configMAX_CO_ROUTINE_PRIORITIES
-		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
-	#endif
-#endif
-
-#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
-	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
-#endif
-
-#ifndef configUSE_APPLICATION_TASK_TAG
-	#define configUSE_APPLICATION_TASK_TAG 0
-#endif
-
-#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
-	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
-#endif
-
-#ifndef configUSE_RECURSIVE_MUTEXES
-	#define configUSE_RECURSIVE_MUTEXES 0
-#endif
-
-#ifndef configUSE_MUTEXES
-	#define configUSE_MUTEXES 0
-#endif
-
-#ifndef configUSE_TIMERS
-	#define configUSE_TIMERS 0
-#endif
-
-#ifndef configUSE_COUNTING_SEMAPHORES
-	#define configUSE_COUNTING_SEMAPHORES 0
-#endif
-
-#ifndef configUSE_ALTERNATIVE_API
-	#define configUSE_ALTERNATIVE_API 0
-#endif
-
-#ifndef portCRITICAL_NESTING_IN_TCB
-	#define portCRITICAL_NESTING_IN_TCB 0
-#endif
-
-#ifndef configMAX_TASK_NAME_LEN
-	#define configMAX_TASK_NAME_LEN 16
-#endif
-
-#ifndef configIDLE_SHOULD_YIELD
-	#define configIDLE_SHOULD_YIELD		1
-#endif
-
-#if configMAX_TASK_NAME_LEN < 1
-	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
-#endif
-
-#ifndef configASSERT
-	#define configASSERT( x )
-	#define configASSERT_DEFINED 0
-#else
-	#define configASSERT_DEFINED 1
-#endif
-
-/* configPRECONDITION should be defined as configASSERT.
-The CBMC proofs need a way to track assumptions and assertions.
-A configPRECONDITION statement should express an implicit invariant or
-assumption made.  A configASSERT statement should express an invariant that must
-hold explicit before calling the code. */
-#ifndef configPRECONDITION
-	#define configPRECONDITION( X ) configASSERT(X)
-	#define configPRECONDITION_DEFINED 0
-#else
-	#define configPRECONDITION_DEFINED 1
-#endif
-
-#ifndef portMEMORY_BARRIER
-	#define portMEMORY_BARRIER()
-#endif
-
-#ifndef portSOFTWARE_BARRIER
-	#define portSOFTWARE_BARRIER()
-#endif
-
-/* The timers module relies on xTaskGetSchedulerState(). */
-#if configUSE_TIMERS == 1
-
-	#ifndef configTIMER_TASK_PRIORITY
-		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
-	#endif /* configTIMER_TASK_PRIORITY */
-
-	#ifndef configTIMER_QUEUE_LENGTH
-		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
-	#endif /* configTIMER_QUEUE_LENGTH */
-
-	#ifndef configTIMER_TASK_STACK_DEPTH
-		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
-	#endif /* configTIMER_TASK_STACK_DEPTH */
-
-#endif /* configUSE_TIMERS */
-
-#ifndef portSET_INTERRUPT_MASK_FROM_ISR
-	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
-#endif
-
-#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
-	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
-#endif
-
-#ifndef portCLEAN_UP_TCB
-	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
-#endif
-
-#ifndef portPRE_TASK_DELETE_HOOK
-	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
-#endif
-
-#ifndef portSETUP_TCB
-	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
-#endif
-
-#ifndef configQUEUE_REGISTRY_SIZE
-	#define configQUEUE_REGISTRY_SIZE 0U
-#endif
-
-#if ( configQUEUE_REGISTRY_SIZE < 1 )
-	#define vQueueAddToRegistry( xQueue, pcName )
-	#define vQueueUnregisterQueue( xQueue )
-	#define pcQueueGetName( xQueue )
-#endif
-
-#ifndef portPOINTER_SIZE_TYPE
-	#define portPOINTER_SIZE_TYPE uint32_t
-#endif
-
-/* Remove any unused trace macros. */
-#ifndef traceSTART
-	/* Used to perform any necessary initialisation - for example, open a file
-	into which trace is to be written. */
-	#define traceSTART()
-#endif
-
-#ifndef traceEND
-	/* Use to close a trace, for example close a file into which trace has been
-	written. */
-	#define traceEND()
-#endif
-
-#ifndef traceTASK_SWITCHED_IN
-	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
-	to the task control block of the selected task. */
-	#define traceTASK_SWITCHED_IN()
-#endif
-
-#ifndef traceINCREASE_TICK_COUNT
-	/* Called before stepping the tick count after waking from tickless idle
-	sleep. */
-	#define traceINCREASE_TICK_COUNT( x )
-#endif
-
-#ifndef traceLOW_POWER_IDLE_BEGIN
-	/* Called immediately before entering tickless idle. */
-	#define traceLOW_POWER_IDLE_BEGIN()
-#endif
-
-#ifndef	traceLOW_POWER_IDLE_END
-	/* Called when returning to the Idle task after a tickless idle. */
-	#define traceLOW_POWER_IDLE_END()
-#endif
-
-#ifndef traceTASK_SWITCHED_OUT
-	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
-	to the task control block of the task being switched out. */
-	#define traceTASK_SWITCHED_OUT()
-#endif
-
-#ifndef traceTASK_PRIORITY_INHERIT
-	/* Called when a task attempts to take a mutex that is already held by a
-	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
-	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
-	will inherit (the priority of the task that is attempting to obtain the
-	muted. */
-	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
-#endif
-
-#ifndef traceTASK_PRIORITY_DISINHERIT
-	/* Called when a task releases a mutex, the holding of which had resulted in
-	the task inheriting the priority of a higher priority task.
-	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
-	mutex.  uxOriginalPriority is the task's configured (base) priority. */
-	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
-#endif
-
-#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
-	/* Task is about to block because it cannot read from a
-	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
-	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
-	task that attempted the read. */
-	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
-#endif
-
-#ifndef traceBLOCKING_ON_QUEUE_PEEK
-	/* Task is about to block because it cannot read from a
-	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
-	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
-	task that attempted the read. */
-	#define traceBLOCKING_ON_QUEUE_PEEK( pxQueue )
-#endif
-
-#ifndef traceBLOCKING_ON_QUEUE_SEND
-	/* Task is about to block because it cannot write to a
-	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
-	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
-	task that attempted the write. */
-	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
-#endif
-
-#ifndef configCHECK_FOR_STACK_OVERFLOW
-	#define configCHECK_FOR_STACK_OVERFLOW 0
-#endif
-
-#ifndef configRECORD_STACK_HIGH_ADDRESS
-	#define configRECORD_STACK_HIGH_ADDRESS 0
-#endif
-
-#ifndef configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H
-	#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
-#endif
-
-/* The following event macros are embedded in the kernel API calls. */
-
-#ifndef traceMOVED_TASK_TO_READY_STATE
-	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
-#endif
-
-#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
-	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
-#endif
-
-#ifndef traceQUEUE_CREATE
-	#define traceQUEUE_CREATE( pxNewQueue )
-#endif
-
-#ifndef traceQUEUE_CREATE_FAILED
-	#define traceQUEUE_CREATE_FAILED( ucQueueType )
-#endif
-
-#ifndef traceCREATE_MUTEX
-	#define traceCREATE_MUTEX( pxNewQueue )
-#endif
-
-#ifndef traceCREATE_MUTEX_FAILED
-	#define traceCREATE_MUTEX_FAILED()
-#endif
-
-#ifndef traceGIVE_MUTEX_RECURSIVE
-	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
-#endif
-
-#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
-	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
-#endif
-
-#ifndef traceTAKE_MUTEX_RECURSIVE
-	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
-#endif
-
-#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
-	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
-#endif
-
-#ifndef traceCREATE_COUNTING_SEMAPHORE
-	#define traceCREATE_COUNTING_SEMAPHORE()
-#endif
-
-#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
-	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
-#endif
-
-#ifndef traceQUEUE_SEND
-	#define traceQUEUE_SEND( pxQueue )
-#endif
-
-#ifndef traceQUEUE_SEND_FAILED
-	#define traceQUEUE_SEND_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE
-	#define traceQUEUE_RECEIVE( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK
-	#define traceQUEUE_PEEK( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK_FAILED
-	#define traceQUEUE_PEEK_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK_FROM_ISR
-	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE_FAILED
-	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_SEND_FROM_ISR
-	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
-#endif
-
-#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
-	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE_FROM_ISR
-	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
-	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
-	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_DELETE
-	#define traceQUEUE_DELETE( pxQueue )
-#endif
-
-#ifndef traceTASK_CREATE
-	#define traceTASK_CREATE( pxNewTCB )
-#endif
-
-#ifndef traceTASK_CREATE_FAILED
-	#define traceTASK_CREATE_FAILED()
-#endif
-
-#ifndef traceTASK_DELETE
-	#define traceTASK_DELETE( pxTaskToDelete )
-#endif
-
-#ifndef traceTASK_DELAY_UNTIL
-	#define traceTASK_DELAY_UNTIL( x )
-#endif
-
-#ifndef traceTASK_DELAY
-	#define traceTASK_DELAY()
-#endif
-
-#ifndef traceTASK_PRIORITY_SET
-	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
-#endif
-
-#ifndef traceTASK_SUSPEND
-	#define traceTASK_SUSPEND( pxTaskToSuspend )
-#endif
-
-#ifndef traceTASK_RESUME
-	#define traceTASK_RESUME( pxTaskToResume )
-#endif
-
-#ifndef traceTASK_RESUME_FROM_ISR
-	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
-#endif
-
-#ifndef traceTASK_INCREMENT_TICK
-	#define traceTASK_INCREMENT_TICK( xTickCount )
-#endif
-
-#ifndef traceTIMER_CREATE
-	#define traceTIMER_CREATE( pxNewTimer )
-#endif
-
-#ifndef traceTIMER_CREATE_FAILED
-	#define traceTIMER_CREATE_FAILED()
-#endif
-
-#ifndef traceTIMER_COMMAND_SEND
-	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
-#endif
-
-#ifndef traceTIMER_EXPIRED
-	#define traceTIMER_EXPIRED( pxTimer )
-#endif
-
-#ifndef traceTIMER_COMMAND_RECEIVED
-	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
-#endif
-
-#ifndef traceMALLOC
-    #define traceMALLOC( pvAddress, uiSize )
-#endif
-
-#ifndef traceFREE
-    #define traceFREE( pvAddress, uiSize )
-#endif
-
-#ifndef traceEVENT_GROUP_CREATE
-	#define traceEVENT_GROUP_CREATE( xEventGroup )
-#endif
-
-#ifndef traceEVENT_GROUP_CREATE_FAILED
-	#define traceEVENT_GROUP_CREATE_FAILED()
-#endif
-
-#ifndef traceEVENT_GROUP_SYNC_BLOCK
-	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
-#endif
-
-#ifndef traceEVENT_GROUP_SYNC_END
-	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
-#endif
-
-#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
-	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
-#endif
-
-#ifndef traceEVENT_GROUP_WAIT_BITS_END
-	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
-#endif
-
-#ifndef traceEVENT_GROUP_CLEAR_BITS
-	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
-#endif
-
-#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
-	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
-#endif
-
-#ifndef traceEVENT_GROUP_SET_BITS
-	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
-#endif
-
-#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
-	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
-#endif
-
-#ifndef traceEVENT_GROUP_DELETE
-	#define traceEVENT_GROUP_DELETE( xEventGroup )
-#endif
-
-#ifndef tracePEND_FUNC_CALL
-	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
-#endif
-
-#ifndef tracePEND_FUNC_CALL_FROM_ISR
-	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
-#endif
-
-#ifndef traceQUEUE_REGISTRY_ADD
-	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
-#endif
-
-#ifndef traceTASK_NOTIFY_TAKE_BLOCK
-	#define traceTASK_NOTIFY_TAKE_BLOCK()
-#endif
-
-#ifndef traceTASK_NOTIFY_TAKE
-	#define traceTASK_NOTIFY_TAKE()
-#endif
-
-#ifndef traceTASK_NOTIFY_WAIT_BLOCK
-	#define traceTASK_NOTIFY_WAIT_BLOCK()
-#endif
-
-#ifndef traceTASK_NOTIFY_WAIT
-	#define traceTASK_NOTIFY_WAIT()
-#endif
-
-#ifndef traceTASK_NOTIFY
-	#define traceTASK_NOTIFY()
-#endif
-
-#ifndef traceTASK_NOTIFY_FROM_ISR
-	#define traceTASK_NOTIFY_FROM_ISR()
-#endif
-
-#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
-	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
-#endif
-
-#ifndef traceSTREAM_BUFFER_CREATE_FAILED
-	#define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_CREATE_STATIC_FAILED
-	#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_CREATE
-	#define traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_DELETE
-	#define traceSTREAM_BUFFER_DELETE( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RESET
-	#define traceSTREAM_BUFFER_RESET( xStreamBuffer )
-#endif
-
-#ifndef traceBLOCKING_ON_STREAM_BUFFER_SEND
-	#define traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_SEND
-	#define traceSTREAM_BUFFER_SEND( xStreamBuffer, xBytesSent )
-#endif
-
-#ifndef traceSTREAM_BUFFER_SEND_FAILED
-	#define traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_SEND_FROM_ISR
-	#define traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xBytesSent )
-#endif
-
-#ifndef traceBLOCKING_ON_STREAM_BUFFER_RECEIVE
-	#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RECEIVE
-	#define traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RECEIVE_FAILED
-	#define traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RECEIVE_FROM_ISR
-	#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength )
-#endif
-
-#ifndef configGENERATE_RUN_TIME_STATS
-	#define configGENERATE_RUN_TIME_STATS 0
-#endif
-
-#if ( configGENERATE_RUN_TIME_STATS == 1 )
-
-	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
-		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
-	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
-
-	#ifndef portGET_RUN_TIME_COUNTER_VALUE
-		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
-			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
-		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
-	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
-
-#endif /* configGENERATE_RUN_TIME_STATS */
-
-#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
-	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
-#endif
-
-#ifndef configUSE_MALLOC_FAILED_HOOK
-	#define configUSE_MALLOC_FAILED_HOOK 0
-#endif
-
-#ifndef portPRIVILEGE_BIT
-	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
-#endif
-
-#ifndef portYIELD_WITHIN_API
-	#define portYIELD_WITHIN_API portYIELD
-#endif
-
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
-#endif
-
-#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
-	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
-#endif
-
-#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
-	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
-#endif
-
-#ifndef configUSE_TICKLESS_IDLE
-	#define configUSE_TICKLESS_IDLE 0
-#endif
-
-#ifndef configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING
-	#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( x )
-#endif
-
-#ifndef configPRE_SLEEP_PROCESSING
-	#define configPRE_SLEEP_PROCESSING( x )
-#endif
-
-#ifndef configPOST_SLEEP_PROCESSING
-	#define configPOST_SLEEP_PROCESSING( x )
-#endif
-
-#ifndef configUSE_QUEUE_SETS
-	#define configUSE_QUEUE_SETS 0
-#endif
-
-#ifndef portTASK_USES_FLOATING_POINT
-	#define portTASK_USES_FLOATING_POINT()
-#endif
-
-#ifndef portALLOCATE_SECURE_CONTEXT
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-#endif
-
-#ifndef portDONT_DISCARD
-	#define portDONT_DISCARD
-#endif
-
-#ifndef configUSE_TIME_SLICING
-	#define configUSE_TIME_SLICING 1
-#endif
-
-#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
-	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
-#endif
-
-#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
-	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
-#endif
-
-#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
-#endif
-
-#ifndef configUSE_TRACE_FACILITY
-	#define configUSE_TRACE_FACILITY 0
-#endif
-
-#ifndef mtCOVERAGE_TEST_MARKER
-	#define mtCOVERAGE_TEST_MARKER()
-#endif
-
-#ifndef mtCOVERAGE_TEST_DELAY
-	#define mtCOVERAGE_TEST_DELAY()
-#endif
-
-#ifndef portASSERT_IF_IN_ISR
-	#define portASSERT_IF_IN_ISR()
-#endif
-
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
-#endif
-
-#ifndef configAPPLICATION_ALLOCATED_HEAP
-	#define configAPPLICATION_ALLOCATED_HEAP 0
-#endif
-
-#ifndef configUSE_TASK_NOTIFICATIONS
-	#define configUSE_TASK_NOTIFICATIONS 1
-#endif
-
-#ifndef configUSE_POSIX_ERRNO
-	#define configUSE_POSIX_ERRNO 0
-#endif
-
-#ifndef portTICK_TYPE_IS_ATOMIC
-	#define portTICK_TYPE_IS_ATOMIC 0
-#endif
-
-#ifndef configSUPPORT_STATIC_ALLOCATION
-	/* Defaults to 0 for backward compatibility. */
-	#define configSUPPORT_STATIC_ALLOCATION 0
-#endif
-
-#ifndef configSUPPORT_DYNAMIC_ALLOCATION
-	/* Defaults to 1 for backward compatibility. */
-	#define configSUPPORT_DYNAMIC_ALLOCATION 1
-#endif
-
-#ifndef configSTACK_DEPTH_TYPE
-	/* Defaults to uint16_t for backward compatibility, but can be overridden
-	in FreeRTOSConfig.h if uint16_t is too restrictive. */
-	#define configSTACK_DEPTH_TYPE uint16_t
-#endif
-
-#ifndef configMESSAGE_BUFFER_LENGTH_TYPE
-	/* Defaults to size_t for backward compatibility, but can be overridden
-	in FreeRTOSConfig.h if lengths will always be less than the number of bytes
-	in a size_t. */
-	#define configMESSAGE_BUFFER_LENGTH_TYPE size_t
-#endif
-
-/* Sanity check the configuration. */
-#if( configUSE_TICKLESS_IDLE != 0 )
-	#if( INCLUDE_vTaskSuspend != 1 )
-		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
-	#endif /* INCLUDE_vTaskSuspend */
-#endif /* configUSE_TICKLESS_IDLE */
-
-#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
-	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
-#endif
-
-#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
-	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
-#endif
-
-#ifndef configINITIAL_TICK_COUNT
-	#define configINITIAL_TICK_COUNT 0
-#endif
-
-#if( portTICK_TYPE_IS_ATOMIC == 0 )
-	/* Either variables of tick type cannot be read atomically, or
-	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
-	the tick count is returned to the standard critical section macros. */
-	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
-	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
-	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
-	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
-#else
-	/* The tick type can be read atomically, so critical sections used when the
-	tick count is returned can be defined away. */
-	#define portTICK_TYPE_ENTER_CRITICAL()
-	#define portTICK_TYPE_EXIT_CRITICAL()
-	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
-	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
-#endif
-
-/* Definitions to allow backward compatibility with FreeRTOS versions prior to
-V8 if desired. */
-#ifndef configENABLE_BACKWARD_COMPATIBILITY
-	#define configENABLE_BACKWARD_COMPATIBILITY 1
-#endif
-
-#ifndef configPRINTF
-	/* configPRINTF() was not defined, so define it away to nothing.  To use
-	configPRINTF() then define it as follows (where MyPrintFunction() is
-	provided by the application writer):
-
-	void MyPrintFunction(const char *pcFormat, ... );
-	#define configPRINTF( X )   MyPrintFunction X
-
-	Then call like a standard printf() function, but placing brackets around
-	all parameters so they are passed as a single parameter.  For example:
-	configPRINTF( ("Value = %d", MyVariable) ); */
-	#define configPRINTF( X )
-#endif
-
-#ifndef configMAX
-	/* The application writer has not provided their own MAX macro, so define
-	the following generic implementation. */
-	#define configMAX( a, b ) ( ( ( a ) > ( b ) ) ? ( a ) : ( b ) )
-#endif
-
-#ifndef configMIN
-	/* The application writer has not provided their own MAX macro, so define
-	the following generic implementation. */
-	#define configMIN( a, b ) ( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )
-#endif
-
-#if configENABLE_BACKWARD_COMPATIBILITY == 1
-	#define eTaskStateGet eTaskGetState
-	#define portTickType TickType_t
-	#define xTaskHandle TaskHandle_t
-	#define xQueueHandle QueueHandle_t
-	#define xSemaphoreHandle SemaphoreHandle_t
-	#define xQueueSetHandle QueueSetHandle_t
-	#define xQueueSetMemberHandle QueueSetMemberHandle_t
-	#define xTimeOutType TimeOut_t
-	#define xMemoryRegion MemoryRegion_t
-	#define xTaskParameters TaskParameters_t
-	#define xTaskStatusType	TaskStatus_t
-	#define xTimerHandle TimerHandle_t
-	#define xCoRoutineHandle CoRoutineHandle_t
-	#define pdTASK_HOOK_CODE TaskHookFunction_t
-	#define portTICK_RATE_MS portTICK_PERIOD_MS
-	#define pcTaskGetTaskName pcTaskGetName
-	#define pcTimerGetTimerName pcTimerGetName
-	#define pcQueueGetQueueName pcQueueGetName
-	#define vTaskGetTaskInfo vTaskGetInfo
-	#define xTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter
-
-	/* Backward compatibility within the scheduler code only - these definitions
-	are not really required but are included for completeness. */
-	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
-	#define pdTASK_CODE TaskFunction_t
-	#define xListItem ListItem_t
-	#define xList List_t
-
-	/* For libraries that break the list data hiding, and access list structure
-	members directly (which is not supposed to be done). */
-	#define pxContainer pvContainer
-#endif /* configENABLE_BACKWARD_COMPATIBILITY */
-
-#if( configUSE_ALTERNATIVE_API != 0 )
-	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
-#endif
-
-/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
-if floating point hardware is otherwise supported by the FreeRTOS port in use.
-This constant is not supported by all FreeRTOS ports that include floating
-point support. */
-#ifndef configUSE_TASK_FPU_SUPPORT
-	#define configUSE_TASK_FPU_SUPPORT 1
-#endif
-
-/* Set configENABLE_MPU to 1 to enable MPU support and 0 to disable it. This is
-currently used in ARMv8M ports. */
-#ifndef configENABLE_MPU
-	#define configENABLE_MPU 0
-#endif
-
-/* Set configENABLE_FPU to 1 to enable FPU support and 0 to disable it. This is
-currently used in ARMv8M ports. */
-#ifndef configENABLE_FPU
-	#define configENABLE_FPU 1
-#endif
-
-/* Set configENABLE_TRUSTZONE to 1 enable TrustZone support and 0 to disable it.
-This is currently used in ARMv8M ports. */
-#ifndef configENABLE_TRUSTZONE
-	#define configENABLE_TRUSTZONE 1
-#endif
-
-/* Set configRUN_FREERTOS_SECURE_ONLY to 1 to run the FreeRTOS ARMv8M port on
-the Secure Side only. */
-#ifndef configRUN_FREERTOS_SECURE_ONLY
-	#define configRUN_FREERTOS_SECURE_ONLY 0
-#endif
-
-/* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
- * dynamically allocated RAM, in which case when any task is deleted it is known
- * that both the task's stack and TCB need to be freed.  Sometimes the
- * FreeRTOSConfig.h settings only allow a task to be created using statically
- * allocated RAM, in which case when any task is deleted it is known that neither
- * the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
- * settings allow a task to be created using either statically or dynamically
- * allocated RAM, in which case a member of the TCB is used to record whether the
- * stack and/or TCB were allocated statically or dynamically, so when a task is
- * deleted the RAM that was allocated dynamically is freed again and no attempt is
- * made to free the RAM that was allocated statically.
- * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
- * task to be created using either statically or dynamically allocated RAM.  Note
- * that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
- * a statically allocated stack and a dynamically allocated TCB.
- *
- * The following table lists various combinations of portUSING_MPU_WRAPPERS,
- * configSUPPORT_DYNAMIC_ALLOCATION and configSUPPORT_STATIC_ALLOCATION and
- * when it is possible to have both static and dynamic allocation:
- *  +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+
- * | MPU | Dynamic | Static |     Available Functions     |       Possible Allocations        | Both Dynamic and | Need Free |
- * |     |         |        |                             |                                   | Static Possible  |           |
- * +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+
- * | 0   | 0       | 1      | xTaskCreateStatic           | TCB - Static, Stack - Static      | No               | No        |
- * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
- * | 0   | 1       | 0      | xTaskCreate                 | TCB - Dynamic, Stack - Dynamic    | No               | Yes       |
- * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
- * | 0   | 1       | 1      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |
- * |     |         |        | xTaskCreateStatic           | 2. TCB - Static, Stack - Static   |                  |           |
- * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
- * | 1   | 0       | 1      | xTaskCreateStatic,          | TCB - Static, Stack - Static      | No               | No        |
- * |     |         |        | xTaskCreateRestrictedStatic |                                   |                  |           |
- * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
- * | 1   | 1       | 0      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |
- * |     |         |        | xTaskCreateRestricted       | 2. TCB - Dynamic, Stack - Static  |                  |           |
- * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
- * | 1   | 1       | 1      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |
- * |     |         |        | xTaskCreateStatic,          | 2. TCB - Dynamic, Stack - Static  |                  |           |
- * |     |         |        | xTaskCreateRestricted,      | 3. TCB - Static, Stack - Static   |                  |           |
- * |     |         |        | xTaskCreateRestrictedStatic |                                   |                  |           |
- * +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+
- */
-#define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( ( portUSING_MPU_WRAPPERS == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) || \
-													  ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) )
-
-/*
- * In line with software engineering best practice, FreeRTOS implements a strict
- * data hiding policy, so the real structures used by FreeRTOS to maintain the
- * state of tasks, queues, semaphores, etc. are not accessible to the application
- * code.  However, if the application writer wants to statically allocate such
- * an object then the size of the object needs to be know.  Dummy structures
- * that are guaranteed to have the same size and alignment requirements of the
- * real objects are used for this purpose.  The dummy list and list item
- * structures below are used for inclusion in such a dummy structure.
- */
-struct xSTATIC_LIST_ITEM
-{
-	#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )
-		TickType_t xDummy1;
-	#endif
-	TickType_t xDummy2;
-	void *pvDummy3[ 4 ];
-	#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )
-		TickType_t xDummy4;
-	#endif
-};
-typedef struct xSTATIC_LIST_ITEM StaticListItem_t;
-
-/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
-struct xSTATIC_MINI_LIST_ITEM
-{
-	#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )
-		TickType_t xDummy1;
-	#endif
-	TickType_t xDummy2;
-	void *pvDummy3[ 2 ];
-};
-typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
-
-/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
-typedef struct xSTATIC_LIST
-{
-	#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )
-		TickType_t xDummy1;
-	#endif
-	UBaseType_t uxDummy2;
-	void *pvDummy3;
-	StaticMiniListItem_t xDummy4;
-	#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )
-		TickType_t xDummy5;
-	#endif
-} StaticList_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the Task structure used internally by
- * FreeRTOS is not accessible to application code.  However, if the application
- * writer wants to statically allocate the memory required to create a task then
- * the size of the task object needs to be know.  The StaticTask_t structure
- * below is provided for this purpose.  Its sizes and alignment requirements are
- * guaranteed to match those of the genuine structure, no matter which
- * architecture is being used, and no matter how the values in FreeRTOSConfig.h
- * are set.  Its contents are somewhat obfuscated in the hope users will
- * recognise that it would be unwise to make direct use of the structure members.
- */
-typedef struct xSTATIC_TCB
-{
-	void				*pxDummy1;
-	#if ( portUSING_MPU_WRAPPERS == 1 )
-		xMPU_SETTINGS	xDummy2;
-	#endif
-	StaticListItem_t	xDummy3[ 2 ];
-	UBaseType_t			uxDummy5;
-	void				*pxDummy6;
-	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
-	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
-		void			*pxDummy8;
-	#endif
-	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
-		UBaseType_t		uxDummy9;
-	#endif
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t		uxDummy10[ 2 ];
-	#endif
-	#if ( configUSE_MUTEXES == 1 )
-		UBaseType_t		uxDummy12[ 2 ];
-	#endif
-	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-		void			*pxDummy14;
-	#endif
-	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
-		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
-	#endif
-	#if ( configGENERATE_RUN_TIME_STATS == 1 )
-		uint32_t		ulDummy16;
-	#endif
-	#if ( configUSE_NEWLIB_REENTRANT == 1 )
-		struct	_reent	xDummy17;
-	#endif
-	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
-		uint32_t 		ulDummy18;
-		uint8_t 		ucDummy19;
-	#endif
-	#if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
-		uint8_t			uxDummy20;
-	#endif
-
-	#if( INCLUDE_xTaskAbortDelay == 1 )
-		uint8_t ucDummy21;
-	#endif
-	#if ( configUSE_POSIX_ERRNO == 1 )
-		int				iDummy22;
-	#endif
-} StaticTask_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the Queue structure used internally by
- * FreeRTOS is not accessible to application code.  However, if the application
- * writer wants to statically allocate the memory required to create a queue
- * then the size of the queue object needs to be know.  The StaticQueue_t
- * structure below is provided for this purpose.  Its sizes and alignment
- * requirements are guaranteed to match those of the genuine structure, no
- * matter which architecture is being used, and no matter how the values in
- * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
- * users will recognise that it would be unwise to make direct use of the
- * structure members.
- */
-typedef struct xSTATIC_QUEUE
-{
-	void *pvDummy1[ 3 ];
-
-	union
-	{
-		void *pvDummy2;
-		UBaseType_t uxDummy2;
-	} u;
-
-	StaticList_t xDummy3[ 2 ];
-	UBaseType_t uxDummy4[ 3 ];
-	uint8_t ucDummy5[ 2 ];
-
-	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-		uint8_t ucDummy6;
-	#endif
-
-	#if ( configUSE_QUEUE_SETS == 1 )
-		void *pvDummy7;
-	#endif
-
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxDummy8;
-		uint8_t ucDummy9;
-	#endif
-
-} StaticQueue_t;
-typedef StaticQueue_t StaticSemaphore_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the event group structure used
- * internally by FreeRTOS is not accessible to application code.  However, if
- * the application writer wants to statically allocate the memory required to
- * create an event group then the size of the event group object needs to be
- * know.  The StaticEventGroup_t structure below is provided for this purpose.
- * Its sizes and alignment requirements are guaranteed to match those of the
- * genuine structure, no matter which architecture is being used, and no matter
- * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
- * obfuscated in the hope users will recognise that it would be unwise to make
- * direct use of the structure members.
- */
-typedef struct xSTATIC_EVENT_GROUP
-{
-	TickType_t xDummy1;
-	StaticList_t xDummy2;
-
-	#if( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxDummy3;
-	#endif
-
-	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-			uint8_t ucDummy4;
-	#endif
-
-} StaticEventGroup_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the software timer structure used
- * internally by FreeRTOS is not accessible to application code.  However, if
- * the application writer wants to statically allocate the memory required to
- * create a software timer then the size of the queue object needs to be know.
- * The StaticTimer_t structure below is provided for this purpose.  Its sizes
- * and alignment requirements are guaranteed to match those of the genuine
- * structure, no matter which architecture is being used, and no matter how the
- * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
- * the hope users will recognise that it would be unwise to make direct use of
- * the structure members.
- */
-typedef struct xSTATIC_TIMER
-{
-	void				*pvDummy1;
-	StaticListItem_t	xDummy2;
-	TickType_t			xDummy3;
-	void 				*pvDummy5;
-	TaskFunction_t		pvDummy6;
-	#if( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t		uxDummy7;
-	#endif
-	uint8_t 			ucDummy8;
-
-} StaticTimer_t;
-
-/*
-* In line with software engineering best practice, especially when supplying a
-* library that is likely to change in future versions, FreeRTOS implements a
-* strict data hiding policy.  This means the stream buffer structure used
-* internally by FreeRTOS is not accessible to application code.  However, if
-* the application writer wants to statically allocate the memory required to
-* create a stream buffer then the size of the stream buffer object needs to be
-* know.  The StaticStreamBuffer_t structure below is provided for this purpose.
-* Its size and alignment requirements are guaranteed to match those of the
-* genuine structure, no matter which architecture is being used, and no matter
-* how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
-* obfuscated in the hope users will recognise that it would be unwise to make
-* direct use of the structure members.
-*/
-typedef struct xSTATIC_STREAM_BUFFER
-{
-	size_t uxDummy1[ 4 ];
-	void * pvDummy2[ 3 ];
-	uint8_t ucDummy3;
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxDummy4;
-	#endif
-} StaticStreamBuffer_t;
-
-/* Message buffers are built on stream buffers. */
-typedef StaticStreamBuffer_t StaticMessageBuffer_t;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* INC_FREERTOS_H */
-
diff --git a/osal/inc/freertos/FreeRTOSConfig_template.h b/osal/inc/freertos/FreeRTOSConfig_template.h
deleted file mode 100644
index e0dff5c..0000000
--- a/osal/inc/freertos/FreeRTOSConfig_template.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * FreeRTOS Kernel V10.2.1
- * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef FREERTOS_CONFIG_H
-#define FREERTOS_CONFIG_H
-
-/*-----------------------------------------------------------
- * this is a template configuration files
- *
- * These definitions should be adjusted for your particular hardware and
- * application requirements.
- *
- * These parameters and more are described within the 'configuration' section of the
- * FreeRTOS API documentation available on the FreeRTOS.org web site.
- *
- * See http://www.freertos.org/a00110.html
- *----------------------------------------------------------*/
-
-/* Ensure stdint is only used by the compiler, and not the assembler. */
-#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
- #include <stdint.h>
- extern uint32_t SystemCoreClock;
-#endif
-
-/*  CMSIS-RTOSv2 defines 56 levels of priorities. To be able to use them
- *  all and avoid application misbehavior, configUSE_PORT_OPTIMISED_TASK_SELECTION
- *  must be set to 0 and configMAX_PRIORITIES to 56
- *
- */
-/* #define configUSE_PORT_OPTIMISED_TASK_SELECTION	0*/
-/* #define configMAX_PRIORITIES					( 56 ) */
-#define configUSE_PREEMPTION              1
-#define configUSE_IDLE_HOOK               0
-#define configUSE_TICK_HOOK               0
-#define configMAX_PRIORITIES              (7)
-#define configSUPPORT_STATIC_ALLOCATION   0
-#define configCPU_CLOCK_HZ                (SystemCoreClock)
-#define configTICK_RATE_HZ                ((TickType_t)1000)
-#define configMINIMAL_STACK_SIZE          ((uint16_t)128)
-#define configTOTAL_HEAP_SIZE             ((size_t)(15 * 1024))
-#define configMAX_TASK_NAME_LEN           (16)
-#define configUSE_TRACE_FACILITY          1
-#define configUSE_16_BIT_TICKS            0
-#define configIDLE_SHOULD_YIELD           1
-#define configUSE_MUTEXES                 1
-#define configQUEUE_REGISTRY_SIZE         8
-#define configCHECK_FOR_STACK_OVERFLOW    0
-#define configUSE_RECURSIVE_MUTEXES       1
-#define configUSE_MALLOC_FAILED_HOOK      0
-#define configUSE_APPLICATION_TASK_TAG    0
-#define configUSE_COUNTING_SEMAPHORES     1
-#define configGENERATE_RUN_TIME_STATS     0
-
-/* Co-routine definitions. */
-#define configUSE_CO_ROUTINES           0
-#define configMAX_CO_ROUTINE_PRIORITIES (2)
-
-/* Software timer definitions. */
-#define configUSE_TIMERS             0
-#define configTIMER_TASK_PRIORITY    (2)
-#define configTIMER_QUEUE_LENGTH     10
-#define configTIMER_TASK_STACK_DEPTH (configMINIMAL_STACK_SIZE * 2)
-
-/* Set the following definitions to 1 to include the API function, or zero
-to exclude the API function. */
-#define INCLUDE_vTaskPrioritySet       1
-#define INCLUDE_uxTaskPriorityGet      1
-#define INCLUDE_vTaskDelete            1
-#define INCLUDE_vTaskCleanUpResources  0
-#define INCLUDE_vTaskSuspend           1
-#define INCLUDE_vTaskDelayUntil        0
-#define INCLUDE_vTaskDelay             1
-#define INCLUDE_xTaskGetSchedulerState 1
-
-/*------------- CMSIS-RTOS V2 specific defines -----------*/
-/* When using CMSIS-RTOSv2 set configSUPPORT_STATIC_ALLOCATION to 1
- * is mandatory to avoid compile errors.
- * CMSIS-RTOS V2 implmentation requires the following defines
- *
-#define configSUPPORT_STATIC_ALLOCATION          1   <-- cmsis_os threads are created using xTaskCreateStatic() API
-#define configMAX_PRIORITIES                    (56) <-- Priority range in CMSIS-RTOS V2 is [0 .. 56]
-#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0    <-- when set to 1, configMAX_PRIORITIES can't be more than 32 which is not suitable for the new CMSIS-RTOS v2 priority range
-*/
-
-/* the CMSIS-RTOS V2 FreeRTOS wrapper is dependent on the heap implementation used
- * by the application thus the correct define need to be enabled from the list
- * below
- *
-//define USE_FreeRTOS_HEAP_1
-//define USE_FreeRTOS_HEAP_2
-//define USE_FreeRTOS_HEAP_3
-//define USE_FreeRTOS_HEAP_4
-//define USE_FreeRTOS_HEAP_5
-
-*/
-
-
-/* Cortex-M specific definitions. */
-#ifdef __NVIC_PRIO_BITS
- /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
- #define configPRIO_BITS         __NVIC_PRIO_BITS
-#else
- #define configPRIO_BITS         4        /* 15 priority levels */
-#endif
-
-/* The lowest interrupt priority that can be used in a call to a "set priority"
-function. */
-#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY   0xf
-
-/* The highest interrupt priority that can be used by any interrupt service
-routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
-INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
-PRIORITY THAN THIS! (higher priorities are lower numeric values. */
-#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5
-
-/* Interrupt priorities used by the kernel port layer itself.  These are generic
-to all Cortex-M ports, and do not rely on any particular library functions. */
-#define configKERNEL_INTERRUPT_PRIORITY   ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
-/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
-See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
-#define configMAX_SYSCALL_INTERRUPT_PRIORITY  ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
-
-/* Normal assert() semantics without relying on the provision of an assert.h
-header file. */
-#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }
-
-/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
-   standard names. */
-#define vPortSVCHandler    SVC_Handler
-#define xPortPendSVHandler PendSV_Handler
-
-/* IMPORTANT: FreeRTOS is using the SysTick as internal time base, thus make sure the system and peripherials are
-              using a different time base (TIM based for example).
- */
-#define xPortSysTickHandler SysTick_Handler
-
-#endif /* FREERTOS_CONFIG_H */
-
diff --git a/osal/inc/freertos/StackMacros.h b/osal/inc/freertos/StackMacros.h
deleted file mode 100644
index 5643991..0000000
--- a/osal/inc/freertos/StackMacros.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef STACK_MACROS_H
-#define STACK_MACROS_H
-
-#ifndef _MSC_VER /* Visual Studio doesn't support #warning. */
-	#warning The name of this file has changed to stack_macros.h.  Please update your code accordingly.  This source file (which has the original name) will be removed in future released.
-#endif
-
-/*
- * Call the stack overflow hook function if the stack of the task being swapped
- * out is currently overflowed, or looks like it might have overflowed in the
- * past.
- *
- * Setting configCHECK_FOR_STACK_OVERFLOW to 1 will cause the macro to check
- * the current stack state only - comparing the current top of stack value to
- * the stack limit.  Setting configCHECK_FOR_STACK_OVERFLOW to greater than 1
- * will also cause the last few stack bytes to be checked to ensure the value
- * to which the bytes were set when the task was created have not been
- * overwritten.  Note this second test does not guarantee that an overflowed
- * stack will always be recognised.
- */
-
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH < 0 ) )
-
-	/* Only the current stack state is to be checked. */
-	#define taskCHECK_FOR_STACK_OVERFLOW()																\
-	{																									\
-		/* Is the currently saved stack pointer within the stack limit? */								\
-		if( pxCurrentTCB->pxTopOfStack <= pxCurrentTCB->pxStack )										\
-		{																								\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
-		}																								\
-	}
-
-#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH > 0 ) )
-
-	/* Only the current stack state is to be checked. */
-	#define taskCHECK_FOR_STACK_OVERFLOW()																\
-	{																									\
-																										\
-		/* Is the currently saved stack pointer within the stack limit? */								\
-		if( pxCurrentTCB->pxTopOfStack >= pxCurrentTCB->pxEndOfStack )									\
-		{																								\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
-		}																								\
-	}
-
-#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH < 0 ) )
-
-	#define taskCHECK_FOR_STACK_OVERFLOW()																\
-	{																									\
-		const uint32_t * const pulStack = ( uint32_t * ) pxCurrentTCB->pxStack;							\
-		const uint32_t ulCheckValue = ( uint32_t ) 0xa5a5a5a5;											\
-																										\
-		if( ( pulStack[ 0 ] != ulCheckValue ) ||												\
-			( pulStack[ 1 ] != ulCheckValue ) ||												\
-			( pulStack[ 2 ] != ulCheckValue ) ||												\
-			( pulStack[ 3 ] != ulCheckValue ) )												\
-		{																								\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
-		}																								\
-	}
-
-#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH > 0 ) )
-
-	#define taskCHECK_FOR_STACK_OVERFLOW()																								\
-	{																																	\
-	int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB->pxEndOfStack;																		\
-	static const uint8_t ucExpectedStackBytes[] = {	tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };	\
-																																		\
-																																		\
-		pcEndOfStack -= sizeof( ucExpectedStackBytes );																					\
-																																		\
-		/* Has the extremity of the task stack ever been written over? */																\
-		if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )					\
-		{																																\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );									\
-		}																																\
-	}
-
-#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
-/*-----------------------------------------------------------*/
-
-/* Remove stack overflow macro if not being used. */
-#ifndef taskCHECK_FOR_STACK_OVERFLOW
-	#define taskCHECK_FOR_STACK_OVERFLOW()
-#endif
-
-
-
-#endif /* STACK_MACROS_H */
-
diff --git a/osal/inc/freertos/atomic.h b/osal/inc/freertos/atomic.h
deleted file mode 100644
index ceca696..0000000
--- a/osal/inc/freertos/atomic.h
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/**
- * @file atomic.h
- * @brief FreeRTOS atomic operation support.
- *
- * This file implements atomic functions by disabling interrupts globally.
- * Implementations with architecture specific atomic instructions can be
- * provided under each compiler directory.
- */
-
-#ifndef ATOMIC_H
-#define ATOMIC_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h must appear in source files before include atomic.h"
-#endif
-
-/* Standard includes. */
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Port specific definitions -- entering/exiting critical section.
- * Refer template -- ./lib/FreeRTOS/portable/Compiler/Arch/portmacro.h
- *
- * Every call to ATOMIC_EXIT_CRITICAL() must be closely paired with
- * ATOMIC_ENTER_CRITICAL().
- *
- */
-#if defined( portSET_INTERRUPT_MASK_FROM_ISR )
-
-	/* Nested interrupt scheme is supported in this port. */
-	#define ATOMIC_ENTER_CRITICAL()	 \
-		UBaseType_t uxCriticalSectionType = portSET_INTERRUPT_MASK_FROM_ISR()
-
-	#define ATOMIC_EXIT_CRITICAL()	  \
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxCriticalSectionType )
-
-#else
-
-	/* Nested interrupt scheme is NOT supported in this port. */
-	#define ATOMIC_ENTER_CRITICAL()	 portENTER_CRITICAL()
-	#define ATOMIC_EXIT_CRITICAL()	  portEXIT_CRITICAL()
-
-#endif /* portSET_INTERRUPT_MASK_FROM_ISR() */
-
-/*
- * Port specific definition -- "always inline".
- * Inline is compiler specific, and may not always get inlined depending on your
- * optimization level.  Also, inline is considered as performance optimization
- * for atomic.  Thus, if portFORCE_INLINE is not provided by portmacro.h,
- * instead of resulting error, simply define it away.
- */
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE
-#endif
-
-#define ATOMIC_COMPARE_AND_SWAP_SUCCESS	 0x1U		/**< Compare and swap succeeded, swapped. */
-#define ATOMIC_COMPARE_AND_SWAP_FAILURE	 0x0U		/**< Compare and swap failed, did not swap. */
-
-/*----------------------------- Swap && CAS ------------------------------*/
-
-/**
- * Atomic compare-and-swap
- *
- * @brief Performs an atomic compare-and-swap operation on the specified values.
- *
- * @param[in, out] pulDestination  Pointer to memory location from where value is
- *                               to be loaded and checked.
- * @param[in] ulExchange         If condition meets, write this value to memory.
- * @param[in] ulComparand        Swap condition.
- *
- * @return Unsigned integer of value 1 or 0. 1 for swapped, 0 for not swapped.
- *
- * @note This function only swaps *pulDestination with ulExchange, if previous
- *       *pulDestination value equals ulComparand.
- */
-static portFORCE_INLINE uint32_t Atomic_CompareAndSwap_u32( uint32_t volatile * pulDestination,
-															uint32_t ulExchange,
-															uint32_t ulComparand )
-{
-uint32_t ulReturnValue;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		if( *pulDestination == ulComparand )
-		{
-			*pulDestination = ulExchange;
-			ulReturnValue = ATOMIC_COMPARE_AND_SWAP_SUCCESS;
-		}
-		else
-		{
-			ulReturnValue = ATOMIC_COMPARE_AND_SWAP_FAILURE;
-		}
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulReturnValue;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic swap (pointers)
- *
- * @brief Atomically sets the address pointed to by *ppvDestination to the value
- *        of *pvExchange.
- *
- * @param[in, out] ppvDestination  Pointer to memory location from where a pointer
- *                                 value is to be loaded and written back to.
- * @param[in] pvExchange           Pointer value to be written to *ppvDestination.
- *
- * @return The initial value of *ppvDestination.
- */
-static portFORCE_INLINE void * Atomic_SwapPointers_p32( void * volatile * ppvDestination,
-														void * pvExchange )
-{
-void * pReturnValue;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		pReturnValue = *ppvDestination;
-		*ppvDestination = pvExchange;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return pReturnValue;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic compare-and-swap (pointers)
- *
- * @brief Performs an atomic compare-and-swap operation on the specified pointer
- *        values.
- *
- * @param[in, out] ppvDestination  Pointer to memory location from where a pointer
- *                                 value is to be loaded and checked.
- * @param[in] pvExchange           If condition meets, write this value to memory.
- * @param[in] pvComparand          Swap condition.
- *
- * @return Unsigned integer of value 1 or 0. 1 for swapped, 0 for not swapped.
- *
- * @note This function only swaps *ppvDestination with pvExchange, if previous
- *       *ppvDestination value equals pvComparand.
- */
-static portFORCE_INLINE uint32_t Atomic_CompareAndSwapPointers_p32( void * volatile * ppvDestination,
-																	void * pvExchange,
-																	void * pvComparand )
-{
-uint32_t ulReturnValue = ATOMIC_COMPARE_AND_SWAP_FAILURE;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		if( *ppvDestination == pvComparand )
-		{
-			*ppvDestination = pvExchange;
-			ulReturnValue = ATOMIC_COMPARE_AND_SWAP_SUCCESS;
-		}
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulReturnValue;
-}
-
-
-/*----------------------------- Arithmetic ------------------------------*/
-
-/**
- * Atomic add
- *
- * @brief Atomically adds count to the value of the specified pointer points to.
- *
- * @param[in,out] pulAddend  Pointer to memory location from where value is to be
- *                         loaded and written back to.
- * @param[in] ulCount      Value to be added to *pulAddend.
- *
- * @return previous *pulAddend value.
- */
-static portFORCE_INLINE uint32_t Atomic_Add_u32( uint32_t volatile * pulAddend,
-												 uint32_t ulCount )
-{
-	uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulAddend;
-		*pulAddend += ulCount;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic subtract
- *
- * @brief Atomically subtracts count from the value of the specified pointer
- *        pointers to.
- *
- * @param[in,out] pulAddend  Pointer to memory location from where value is to be
- *                         loaded and written back to.
- * @param[in] ulCount      Value to be subtract from *pulAddend.
- *
- * @return previous *pulAddend value.
- */
-static portFORCE_INLINE uint32_t Atomic_Subtract_u32( uint32_t volatile * pulAddend,
-													  uint32_t ulCount )
-{
-	uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulAddend;
-		*pulAddend -= ulCount;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic increment
- *
- * @brief Atomically increments the value of the specified pointer points to.
- *
- * @param[in,out] pulAddend  Pointer to memory location from where value is to be
- *                         loaded and written back to.
- *
- * @return *pulAddend value before increment.
- */
-static portFORCE_INLINE uint32_t Atomic_Increment_u32( uint32_t volatile * pulAddend )
-{
-uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulAddend;
-		*pulAddend += 1;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic decrement
- *
- * @brief Atomically decrements the value of the specified pointer points to
- *
- * @param[in,out] pulAddend  Pointer to memory location from where value is to be
- *                         loaded and written back to.
- *
- * @return *pulAddend value before decrement.
- */
-static portFORCE_INLINE uint32_t Atomic_Decrement_u32( uint32_t volatile * pulAddend )
-{
-uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulAddend;
-		*pulAddend -= 1;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-
-/*----------------------------- Bitwise Logical ------------------------------*/
-
-/**
- * Atomic OR
- *
- * @brief Performs an atomic OR operation on the specified values.
- *
- * @param [in, out] pulDestination  Pointer to memory location from where value is
- *                                to be loaded and written back to.
- * @param [in] ulValue            Value to be ORed with *pulDestination.
- *
- * @return The original value of *pulDestination.
- */
-static portFORCE_INLINE uint32_t Atomic_OR_u32( uint32_t volatile * pulDestination,
-												uint32_t ulValue )
-{
-uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulDestination;
-		*pulDestination |= ulValue;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic AND
- *
- * @brief Performs an atomic AND operation on the specified values.
- *
- * @param [in, out] pulDestination  Pointer to memory location from where value is
- *                                to be loaded and written back to.
- * @param [in] ulValue            Value to be ANDed with *pulDestination.
- *
- * @return The original value of *pulDestination.
- */
-static portFORCE_INLINE uint32_t Atomic_AND_u32( uint32_t volatile * pulDestination,
-												 uint32_t ulValue )
-{
-uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulDestination;
-		*pulDestination &= ulValue;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic NAND
- *
- * @brief Performs an atomic NAND operation on the specified values.
- *
- * @param [in, out] pulDestination  Pointer to memory location from where value is
- *                                to be loaded and written back to.
- * @param [in] ulValue            Value to be NANDed with *pulDestination.
- *
- * @return The original value of *pulDestination.
- */
-static portFORCE_INLINE uint32_t Atomic_NAND_u32( uint32_t volatile * pulDestination,
-												  uint32_t ulValue )
-{
-uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulDestination;
-		*pulDestination = ~( ulCurrent & ulValue );
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-/*-----------------------------------------------------------*/
-
-/**
- * Atomic XOR
- *
- * @brief Performs an atomic XOR operation on the specified values.
- *
- * @param [in, out] pulDestination  Pointer to memory location from where value is
- *                                to be loaded and written back to.
- * @param [in] ulValue            Value to be XORed with *pulDestination.
- *
- * @return The original value of *pulDestination.
- */
-static portFORCE_INLINE uint32_t Atomic_XOR_u32( uint32_t volatile * pulDestination,
-												 uint32_t ulValue )
-{
-uint32_t ulCurrent;
-
-	ATOMIC_ENTER_CRITICAL();
-	{
-		ulCurrent = *pulDestination;
-		*pulDestination ^= ulValue;
-	}
-	ATOMIC_EXIT_CRITICAL();
-
-	return ulCurrent;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ATOMIC_H */
diff --git a/osal/inc/freertos/croutine.h b/osal/inc/freertos/croutine.h
deleted file mode 100644
index 8d7069c..0000000
--- a/osal/inc/freertos/croutine.h
+++ /dev/null
@@ -1,720 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef CO_ROUTINE_H
-#define CO_ROUTINE_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h must appear in source files before include croutine.h"
-#endif
-
-#include "list.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Used to hide the implementation of the co-routine control block.  The
-control block structure however has to be included in the header due to
-the macro implementation of the co-routine functionality. */
-typedef void * CoRoutineHandle_t;
-
-/* Defines the prototype to which co-routine functions must conform. */
-typedef void (*crCOROUTINE_CODE)( CoRoutineHandle_t, UBaseType_t );
-
-typedef struct corCoRoutineControlBlock
-{
-	crCOROUTINE_CODE 	pxCoRoutineFunction;
-	ListItem_t			xGenericListItem;	/*< List item used to place the CRCB in ready and blocked queues. */
-	ListItem_t			xEventListItem;		/*< List item used to place the CRCB in event lists. */
-	UBaseType_t 		uxPriority;			/*< The priority of the co-routine in relation to other co-routines. */
-	UBaseType_t 		uxIndex;			/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. */
-	uint16_t 			uxState;			/*< Used internally by the co-routine implementation. */
-} CRCB_t; /* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. */
-
-/**
- * croutine. h
- *<pre>
- BaseType_t xCoRoutineCreate(
-                                 crCOROUTINE_CODE pxCoRoutineCode,
-                                 UBaseType_t uxPriority,
-                                 UBaseType_t uxIndex
-                               );</pre>
- *
- * Create a new co-routine and add it to the list of co-routines that are
- * ready to run.
- *
- * @param pxCoRoutineCode Pointer to the co-routine function.  Co-routine
- * functions require special syntax - see the co-routine section of the WEB
- * documentation for more information.
- *
- * @param uxPriority The priority with respect to other co-routines at which
- *  the co-routine will run.
- *
- * @param uxIndex Used to distinguish between different co-routines that
- * execute the same function.  See the example below and the co-routine section
- * of the WEB documentation for further information.
- *
- * @return pdPASS if the co-routine was successfully created and added to a ready
- * list, otherwise an error code defined with ProjDefs.h.
- *
- * Example usage:
-   <pre>
- // Co-routine to be created.
- void vFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- // Variables in co-routines must be declared static if they must maintain value across a blocking call.
- // This may not be necessary for const variables.
- static const char cLedToFlash[ 2 ] = { 5, 6 };
- static const TickType_t uxFlashRates[ 2 ] = { 200, 400 };
-
-     // Must start every co-routine with a call to crSTART();
-     crSTART( xHandle );
-
-     for( ;; )
-     {
-         // This co-routine just delays for a fixed period, then toggles
-         // an LED.  Two co-routines are created using this function, so
-         // the uxIndex parameter is used to tell the co-routine which
-         // LED to flash and how int32_t to delay.  This assumes xQueue has
-         // already been created.
-         vParTestToggleLED( cLedToFlash[ uxIndex ] );
-         crDELAY( xHandle, uxFlashRates[ uxIndex ] );
-     }
-
-     // Must end every co-routine with a call to crEND();
-     crEND();
- }
-
- // Function that creates two co-routines.
- void vOtherFunction( void )
- {
- uint8_t ucParameterToPass;
- TaskHandle_t xHandle;
-
-     // Create two co-routines at priority 0.  The first is given index 0
-     // so (from the code above) toggles LED 5 every 200 ticks.  The second
-     // is given index 1 so toggles LED 6 every 400 ticks.
-     for( uxIndex = 0; uxIndex < 2; uxIndex++ )
-     {
-         xCoRoutineCreate( vFlashCoRoutine, 0, uxIndex );
-     }
- }
-   </pre>
- * \defgroup xCoRoutineCreate xCoRoutineCreate
- * \ingroup Tasks
- */
-BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex );
-
-
-/**
- * croutine. h
- *<pre>
- void vCoRoutineSchedule( void );</pre>
- *
- * Run a co-routine.
- *
- * vCoRoutineSchedule() executes the highest priority co-routine that is able
- * to run.  The co-routine will execute until it either blocks, yields or is
- * preempted by a task.  Co-routines execute cooperatively so one
- * co-routine cannot be preempted by another, but can be preempted by a task.
- *
- * If an application comprises of both tasks and co-routines then
- * vCoRoutineSchedule should be called from the idle task (in an idle task
- * hook).
- *
- * Example usage:
-   <pre>
- // This idle task hook will schedule a co-routine each time it is called.
- // The rest of the idle task will execute between co-routine calls.
- void vApplicationIdleHook( void )
- {
-	vCoRoutineSchedule();
- }
-
- // Alternatively, if you do not require any other part of the idle task to
- // execute, the idle task hook can call vCoRoutineSchedule() within an
- // infinite loop.
- void vApplicationIdleHook( void )
- {
-    for( ;; )
-    {
-        vCoRoutineSchedule();
-    }
- }
- </pre>
- * \defgroup vCoRoutineSchedule vCoRoutineSchedule
- * \ingroup Tasks
- */
-void vCoRoutineSchedule( void );
-
-/**
- * croutine. h
- * <pre>
- crSTART( CoRoutineHandle_t xHandle );</pre>
- *
- * This macro MUST always be called at the start of a co-routine function.
- *
- * Example usage:
-   <pre>
- // Co-routine to be created.
- void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- // Variables in co-routines must be declared static if they must maintain value across a blocking call.
- static int32_t ulAVariable;
-
-     // Must start every co-routine with a call to crSTART();
-     crSTART( xHandle );
-
-     for( ;; )
-     {
-          // Co-routine functionality goes here.
-     }
-
-     // Must end every co-routine with a call to crEND();
-     crEND();
- }</pre>
- * \defgroup crSTART crSTART
- * \ingroup Tasks
- */
-#define crSTART( pxCRCB ) switch( ( ( CRCB_t * )( pxCRCB ) )->uxState ) { case 0:
-
-/**
- * croutine. h
- * <pre>
- crEND();</pre>
- *
- * This macro MUST always be called at the end of a co-routine function.
- *
- * Example usage:
-   <pre>
- // Co-routine to be created.
- void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- // Variables in co-routines must be declared static if they must maintain value across a blocking call.
- static int32_t ulAVariable;
-
-     // Must start every co-routine with a call to crSTART();
-     crSTART( xHandle );
-
-     for( ;; )
-     {
-          // Co-routine functionality goes here.
-     }
-
-     // Must end every co-routine with a call to crEND();
-     crEND();
- }</pre>
- * \defgroup crSTART crSTART
- * \ingroup Tasks
- */
-#define crEND() }
-
-/*
- * These macros are intended for internal use by the co-routine implementation
- * only.  The macros should not be used directly by application writers.
- */
-#define crSET_STATE0( xHandle ) ( ( CRCB_t * )( xHandle ) )->uxState = (__LINE__ * 2); return; case (__LINE__ * 2):
-#define crSET_STATE1( xHandle ) ( ( CRCB_t * )( xHandle ) )->uxState = ((__LINE__ * 2)+1); return; case ((__LINE__ * 2)+1):
-
-/**
- * croutine. h
- *<pre>
- crDELAY( CoRoutineHandle_t xHandle, TickType_t xTicksToDelay );</pre>
- *
- * Delay a co-routine for a fixed period of time.
- *
- * crDELAY can only be called from the co-routine function itself - not
- * from within a function called by the co-routine function.  This is because
- * co-routines do not maintain their own stack.
- *
- * @param xHandle The handle of the co-routine to delay.  This is the xHandle
- * parameter of the co-routine function.
- *
- * @param xTickToDelay The number of ticks that the co-routine should delay
- * for.  The actual amount of time this equates to is defined by
- * configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant portTICK_PERIOD_MS
- * can be used to convert ticks to milliseconds.
- *
- * Example usage:
-   <pre>
- // Co-routine to be created.
- void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- // Variables in co-routines must be declared static if they must maintain value across a blocking call.
- // This may not be necessary for const variables.
- // We are to delay for 200ms.
- static const xTickType xDelayTime = 200 / portTICK_PERIOD_MS;
-
-     // Must start every co-routine with a call to crSTART();
-     crSTART( xHandle );
-
-     for( ;; )
-     {
-        // Delay for 200ms.
-        crDELAY( xHandle, xDelayTime );
-
-        // Do something here.
-     }
-
-     // Must end every co-routine with a call to crEND();
-     crEND();
- }</pre>
- * \defgroup crDELAY crDELAY
- * \ingroup Tasks
- */
-#define crDELAY( xHandle, xTicksToDelay )												\
-	if( ( xTicksToDelay ) > 0 )															\
-	{																					\
-		vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL );							\
-	}																					\
-	crSET_STATE0( ( xHandle ) );
-
-/**
- * <pre>
- crQUEUE_SEND(
-                  CoRoutineHandle_t xHandle,
-                  QueueHandle_t pxQueue,
-                  void *pvItemToQueue,
-                  TickType_t xTicksToWait,
-                  BaseType_t *pxResult
-             )</pre>
- *
- * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
- * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
- *
- * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
- * xQueueSend() and xQueueReceive() can only be used from tasks.
- *
- * crQUEUE_SEND can only be called from the co-routine function itself - not
- * from within a function called by the co-routine function.  This is because
- * co-routines do not maintain their own stack.
- *
- * See the co-routine section of the WEB documentation for information on
- * passing data between tasks and co-routines and between ISR's and
- * co-routines.
- *
- * @param xHandle The handle of the calling co-routine.  This is the xHandle
- * parameter of the co-routine function.
- *
- * @param pxQueue The handle of the queue on which the data will be posted.
- * The handle is obtained as the return value when the queue is created using
- * the xQueueCreate() API function.
- *
- * @param pvItemToQueue A pointer to the data being posted onto the queue.
- * The number of bytes of each queued item is specified when the queue is
- * created.  This number of bytes is copied from pvItemToQueue into the queue
- * itself.
- *
- * @param xTickToDelay The number of ticks that the co-routine should block
- * to wait for space to become available on the queue, should space not be
- * available immediately. The actual amount of time this equates to is defined
- * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
- * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see example
- * below).
- *
- * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
- * data was successfully posted onto the queue, otherwise it will be set to an
- * error defined within ProjDefs.h.
- *
- * Example usage:
-   <pre>
- // Co-routine function that blocks for a fixed period then posts a number onto
- // a queue.
- static void prvCoRoutineFlashTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- // Variables in co-routines must be declared static if they must maintain value across a blocking call.
- static BaseType_t xNumberToPost = 0;
- static BaseType_t xResult;
-
-    // Co-routines must begin with a call to crSTART().
-    crSTART( xHandle );
-
-    for( ;; )
-    {
-        // This assumes the queue has already been created.
-        crQUEUE_SEND( xHandle, xCoRoutineQueue, &xNumberToPost, NO_DELAY, &xResult );
-
-        if( xResult != pdPASS )
-        {
-            // The message was not posted!
-        }
-
-        // Increment the number to be posted onto the queue.
-        xNumberToPost++;
-
-        // Delay for 100 ticks.
-        crDELAY( xHandle, 100 );
-    }
-
-    // Co-routines must end with a call to crEND().
-    crEND();
- }</pre>
- * \defgroup crQUEUE_SEND crQUEUE_SEND
- * \ingroup Tasks
- */
-#define crQUEUE_SEND( xHandle, pxQueue, pvItemToQueue, xTicksToWait, pxResult )			\
-{																						\
-	*( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) );	\
-	if( *( pxResult ) == errQUEUE_BLOCKED )												\
-	{																					\
-		crSET_STATE0( ( xHandle ) );													\
-		*pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 );					\
-	}																					\
-	if( *pxResult == errQUEUE_YIELD )													\
-	{																					\
-		crSET_STATE1( ( xHandle ) );													\
-		*pxResult = pdPASS;																\
-	}																					\
-}
-
-/**
- * croutine. h
- * <pre>
-  crQUEUE_RECEIVE(
-                     CoRoutineHandle_t xHandle,
-                     QueueHandle_t pxQueue,
-                     void *pvBuffer,
-                     TickType_t xTicksToWait,
-                     BaseType_t *pxResult
-                 )</pre>
- *
- * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
- * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
- *
- * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
- * xQueueSend() and xQueueReceive() can only be used from tasks.
- *
- * crQUEUE_RECEIVE can only be called from the co-routine function itself - not
- * from within a function called by the co-routine function.  This is because
- * co-routines do not maintain their own stack.
- *
- * See the co-routine section of the WEB documentation for information on
- * passing data between tasks and co-routines and between ISR's and
- * co-routines.
- *
- * @param xHandle The handle of the calling co-routine.  This is the xHandle
- * parameter of the co-routine function.
- *
- * @param pxQueue The handle of the queue from which the data will be received.
- * The handle is obtained as the return value when the queue is created using
- * the xQueueCreate() API function.
- *
- * @param pvBuffer The buffer into which the received item is to be copied.
- * The number of bytes of each queued item is specified when the queue is
- * created.  This number of bytes is copied into pvBuffer.
- *
- * @param xTickToDelay The number of ticks that the co-routine should block
- * to wait for data to become available from the queue, should data not be
- * available immediately. The actual amount of time this equates to is defined
- * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
- * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see the
- * crQUEUE_SEND example).
- *
- * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
- * data was successfully retrieved from the queue, otherwise it will be set to
- * an error code as defined within ProjDefs.h.
- *
- * Example usage:
- <pre>
- // A co-routine receives the number of an LED to flash from a queue.  It
- // blocks on the queue until the number is received.
- static void prvCoRoutineFlashWorkTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- // Variables in co-routines must be declared static if they must maintain value across a blocking call.
- static BaseType_t xResult;
- static UBaseType_t uxLEDToFlash;
-
-    // All co-routines must start with a call to crSTART().
-    crSTART( xHandle );
-
-    for( ;; )
-    {
-        // Wait for data to become available on the queue.
-        crQUEUE_RECEIVE( xHandle, xCoRoutineQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
-
-        if( xResult == pdPASS )
-        {
-            // We received the LED to flash - flash it!
-            vParTestToggleLED( uxLEDToFlash );
-        }
-    }
-
-    crEND();
- }</pre>
- * \defgroup crQUEUE_RECEIVE crQUEUE_RECEIVE
- * \ingroup Tasks
- */
-#define crQUEUE_RECEIVE( xHandle, pxQueue, pvBuffer, xTicksToWait, pxResult )			\
-{																						\
-	*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) );		\
-	if( *( pxResult ) == errQUEUE_BLOCKED ) 											\
-	{																					\
-		crSET_STATE0( ( xHandle ) );													\
-		*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 );				\
-	}																					\
-	if( *( pxResult ) == errQUEUE_YIELD )												\
-	{																					\
-		crSET_STATE1( ( xHandle ) );													\
-		*( pxResult ) = pdPASS;															\
-	}																					\
-}
-
-/**
- * croutine. h
- * <pre>
-  crQUEUE_SEND_FROM_ISR(
-                            QueueHandle_t pxQueue,
-                            void *pvItemToQueue,
-                            BaseType_t xCoRoutinePreviouslyWoken
-                       )</pre>
- *
- * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
- * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
- * functions used by tasks.
- *
- * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
- * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
- * xQueueReceiveFromISR() can only be used to pass data between a task and and
- * ISR.
- *
- * crQUEUE_SEND_FROM_ISR can only be called from an ISR to send data to a queue
- * that is being used from within a co-routine.
- *
- * See the co-routine section of the WEB documentation for information on
- * passing data between tasks and co-routines and between ISR's and
- * co-routines.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param xCoRoutinePreviouslyWoken This is included so an ISR can post onto
- * the same queue multiple times from a single interrupt.  The first call
- * should always pass in pdFALSE.  Subsequent calls should pass in
- * the value returned from the previous call.
- *
- * @return pdTRUE if a co-routine was woken by posting onto the queue.  This is
- * used by the ISR to determine if a context switch may be required following
- * the ISR.
- *
- * Example usage:
- <pre>
- // A co-routine that blocks on a queue waiting for characters to be received.
- static void vReceivingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- char cRxedChar;
- BaseType_t xResult;
-
-     // All co-routines must start with a call to crSTART().
-     crSTART( xHandle );
-
-     for( ;; )
-     {
-         // Wait for data to become available on the queue.  This assumes the
-         // queue xCommsRxQueue has already been created!
-         crQUEUE_RECEIVE( xHandle, xCommsRxQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
-
-         // Was a character received?
-         if( xResult == pdPASS )
-         {
-             // Process the character here.
-         }
-     }
-
-     // All co-routines must end with a call to crEND().
-     crEND();
- }
-
- // An ISR that uses a queue to send characters received on a serial port to
- // a co-routine.
- void vUART_ISR( void )
- {
- char cRxedChar;
- BaseType_t xCRWokenByPost = pdFALSE;
-
-     // We loop around reading characters until there are none left in the UART.
-     while( UART_RX_REG_NOT_EMPTY() )
-     {
-         // Obtain the character from the UART.
-         cRxedChar = UART_RX_REG;
-
-         // Post the character onto a queue.  xCRWokenByPost will be pdFALSE
-         // the first time around the loop.  If the post causes a co-routine
-         // to be woken (unblocked) then xCRWokenByPost will be set to pdTRUE.
-         // In this manner we can ensure that if more than one co-routine is
-         // blocked on the queue only one is woken by this ISR no matter how
-         // many characters are posted to the queue.
-         xCRWokenByPost = crQUEUE_SEND_FROM_ISR( xCommsRxQueue, &cRxedChar, xCRWokenByPost );
-     }
- }</pre>
- * \defgroup crQUEUE_SEND_FROM_ISR crQUEUE_SEND_FROM_ISR
- * \ingroup Tasks
- */
-#define crQUEUE_SEND_FROM_ISR( pxQueue, pvItemToQueue, xCoRoutinePreviouslyWoken ) xQueueCRSendFromISR( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) )
-
-
-/**
- * croutine. h
- * <pre>
-  crQUEUE_SEND_FROM_ISR(
-                            QueueHandle_t pxQueue,
-                            void *pvBuffer,
-                            BaseType_t * pxCoRoutineWoken
-                       )</pre>
- *
- * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
- * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
- * functions used by tasks.
- *
- * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
- * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
- * xQueueReceiveFromISR() can only be used to pass data between a task and and
- * ISR.
- *
- * crQUEUE_RECEIVE_FROM_ISR can only be called from an ISR to receive data
- * from a queue that is being used from within a co-routine (a co-routine
- * posted to the queue).
- *
- * See the co-routine section of the WEB documentation for information on
- * passing data between tasks and co-routines and between ISR's and
- * co-routines.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvBuffer A pointer to a buffer into which the received item will be
- * placed.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from the queue into
- * pvBuffer.
- *
- * @param pxCoRoutineWoken A co-routine may be blocked waiting for space to become
- * available on the queue.  If crQUEUE_RECEIVE_FROM_ISR causes such a
- * co-routine to unblock *pxCoRoutineWoken will get set to pdTRUE, otherwise
- * *pxCoRoutineWoken will remain unchanged.
- *
- * @return pdTRUE an item was successfully received from the queue, otherwise
- * pdFALSE.
- *
- * Example usage:
- <pre>
- // A co-routine that posts a character to a queue then blocks for a fixed
- // period.  The character is incremented each time.
- static void vSendingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
- {
- // cChar holds its value while this co-routine is blocked and must therefore
- // be declared static.
- static char cCharToTx = 'a';
- BaseType_t xResult;
-
-     // All co-routines must start with a call to crSTART().
-     crSTART( xHandle );
-
-     for( ;; )
-     {
-         // Send the next character to the queue.
-         crQUEUE_SEND( xHandle, xCoRoutineQueue, &cCharToTx, NO_DELAY, &xResult );
-
-         if( xResult == pdPASS )
-         {
-             // The character was successfully posted to the queue.
-         }
-		 else
-		 {
-			// Could not post the character to the queue.
-		 }
-
-         // Enable the UART Tx interrupt to cause an interrupt in this
-		 // hypothetical UART.  The interrupt will obtain the character
-		 // from the queue and send it.
-		 ENABLE_RX_INTERRUPT();
-
-		 // Increment to the next character then block for a fixed period.
-		 // cCharToTx will maintain its value across the delay as it is
-		 // declared static.
-		 cCharToTx++;
-		 if( cCharToTx > 'x' )
-		 {
-			cCharToTx = 'a';
-		 }
-		 crDELAY( 100 );
-     }
-
-     // All co-routines must end with a call to crEND().
-     crEND();
- }
-
- // An ISR that uses a queue to receive characters to send on a UART.
- void vUART_ISR( void )
- {
- char cCharToTx;
- BaseType_t xCRWokenByPost = pdFALSE;
-
-     while( UART_TX_REG_EMPTY() )
-     {
-         // Are there any characters in the queue waiting to be sent?
-		 // xCRWokenByPost will automatically be set to pdTRUE if a co-routine
-		 // is woken by the post - ensuring that only a single co-routine is
-		 // woken no matter how many times we go around this loop.
-         if( crQUEUE_RECEIVE_FROM_ISR( pxQueue, &cCharToTx, &xCRWokenByPost ) )
-		 {
-			 SEND_CHARACTER( cCharToTx );
-		 }
-     }
- }</pre>
- * \defgroup crQUEUE_RECEIVE_FROM_ISR crQUEUE_RECEIVE_FROM_ISR
- * \ingroup Tasks
- */
-#define crQUEUE_RECEIVE_FROM_ISR( pxQueue, pvBuffer, pxCoRoutineWoken ) xQueueCRReceiveFromISR( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) )
-
-/*
- * This function is intended for internal use by the co-routine macros only.
- * The macro nature of the co-routine implementation requires that the
- * prototype appears here.  The function should not be used by application
- * writers.
- *
- * Removes the current co-routine from its ready list and places it in the
- * appropriate delayed list.
- */
-void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList );
-
-/*
- * This function is intended for internal use by the queue implementation only.
- * The function should not be used by application writers.
- *
- * Removes the highest priority co-routine from the event list and places it in
- * the pending ready list.
- */
-BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList );
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CO_ROUTINE_H */
diff --git a/osal/inc/freertos/deprecated_definitions.h b/osal/inc/freertos/deprecated_definitions.h
deleted file mode 100644
index 21657b9..0000000
--- a/osal/inc/freertos/deprecated_definitions.h
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef DEPRECATED_DEFINITIONS_H
-#define DEPRECATED_DEFINITIONS_H
-
-
-/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
-pre-processor definition was used to ensure the pre-processor found the correct
-portmacro.h file for the port being used.  That scheme was deprecated in favour
-of setting the compiler's include path such that it found the correct
-portmacro.h file - removing the need for the constant and allowing the
-portmacro.h file to be located anywhere in relation to the port being used.  The
-definitions below remain in the code for backward compatibility only.  New
-projects should not use them. */
-
-#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
-	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
-	typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
-	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
-	typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef GCC_MEGA_AVR
-	#include "../portable/GCC/ATMega323/portmacro.h"
-#endif
-
-#ifdef IAR_MEGA_AVR
-	#include "../portable/IAR/ATMega323/portmacro.h"
-#endif
-
-#ifdef MPLAB_PIC24_PORT
-	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
-#endif
-
-#ifdef MPLAB_DSPIC_PORT
-	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
-#endif
-
-#ifdef MPLAB_PIC18F_PORT
-	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
-#endif
-
-#ifdef MPLAB_PIC32MX_PORT
-	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
-#endif
-
-#ifdef _FEDPICC
-	#include "libFreeRTOS/Include/portmacro.h"
-#endif
-
-#ifdef SDCC_CYGNAL
-	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
-#endif
-
-#ifdef GCC_ARM7
-	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
-#endif
-
-#ifdef GCC_ARM7_ECLIPSE
-	#include "portmacro.h"
-#endif
-
-#ifdef ROWLEY_LPC23xx
-	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
-#endif
-
-#ifdef IAR_MSP430
-	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
-#endif
-
-#ifdef GCC_MSP430
-	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
-#endif
-
-#ifdef ROWLEY_MSP430
-	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
-#endif
-
-#ifdef ARM7_LPC21xx_KEIL_RVDS
-	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
-#endif
-
-#ifdef SAM7_GCC
-	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
-#endif
-
-#ifdef SAM7_IAR
-	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
-#endif
-
-#ifdef SAM9XE_IAR
-	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
-#endif
-
-#ifdef LPC2000_IAR
-	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
-#endif
-
-#ifdef STR71X_IAR
-	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
-#endif
-
-#ifdef STR75X_IAR
-	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
-#endif
-
-#ifdef STR75X_GCC
-	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
-#endif
-
-#ifdef STR91X_IAR
-	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
-#endif
-
-#ifdef GCC_H8S
-	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
-#endif
-
-#ifdef GCC_AT91FR40008
-	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
-#endif
-
-#ifdef RVDS_ARMCM3_LM3S102
-	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef GCC_ARMCM3_LM3S102
-	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef GCC_ARMCM3
-	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef IAR_ARM_CM3
-	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef IAR_ARMCM3_LM
-	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef HCS12_CODE_WARRIOR
-	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
-#endif
-
-#ifdef MICROBLAZE_GCC
-	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
-#endif
-
-#ifdef TERN_EE
-	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
-#endif
-
-#ifdef GCC_HCS12
-	#include "../../Source/portable/GCC/HCS12/portmacro.h"
-#endif
-
-#ifdef GCC_MCF5235
-    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
-#endif
-
-#ifdef COLDFIRE_V2_GCC
-	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
-#endif
-
-#ifdef COLDFIRE_V2_CODEWARRIOR
-	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
-#endif
-
-#ifdef GCC_PPC405
-	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
-#endif
-
-#ifdef GCC_PPC440
-	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
-#endif
-
-#ifdef _16FX_SOFTUNE
-	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
-#endif
-
-#ifdef BCC_INDUSTRIAL_PC_PORT
-	/* A short file name has to be used in place of the normal
-	FreeRTOSConfig.h when using the Borland compiler. */
-	#include "frconfig.h"
-	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
-    typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef BCC_FLASH_LITE_186_PORT
-	/* A short file name has to be used in place of the normal
-	FreeRTOSConfig.h when using the Borland compiler. */
-	#include "frconfig.h"
-	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
-    typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef __GNUC__
-   #ifdef __AVR32_AVR32A__
-	   #include "portmacro.h"
-   #endif
-#endif
-
-#ifdef __ICCAVR32__
-   #ifdef __CORE__
-      #if __CORE__ == __AVR32A__
-	      #include "portmacro.h"
-      #endif
-   #endif
-#endif
-
-#ifdef __91467D
-	#include "portmacro.h"
-#endif
-
-#ifdef __96340
-	#include "portmacro.h"
-#endif
-
-
-#ifdef __IAR_V850ES_Fx3__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Jx3__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Jx3_L__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Jx2__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Hx2__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_78K0R_Kx3__
-	#include "../../Source/portable/IAR/78K0R/portmacro.h"
-#endif
-
-#ifdef __IAR_78K0R_Kx3L__
-	#include "../../Source/portable/IAR/78K0R/portmacro.h"
-#endif
-
-#endif /* DEPRECATED_DEFINITIONS_H */
-
diff --git a/osal/inc/freertos/event_groups.h b/osal/inc/freertos/event_groups.h
deleted file mode 100644
index a87fdf3..0000000
--- a/osal/inc/freertos/event_groups.h
+++ /dev/null
@@ -1,757 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef EVENT_GROUPS_H
-#define EVENT_GROUPS_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h" must appear in source files before "include event_groups.h"
-#endif
-
-/* FreeRTOS includes. */
-#include "timers.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * An event group is a collection of bits to which an application can assign a
- * meaning.  For example, an application may create an event group to convey
- * the status of various CAN bus related events in which bit 0 might mean "A CAN
- * message has been received and is ready for processing", bit 1 might mean "The
- * application has queued a message that is ready for sending onto the CAN
- * network", and bit 2 might mean "It is time to send a SYNC message onto the
- * CAN network" etc.  A task can then test the bit values to see which events
- * are active, and optionally enter the Blocked state to wait for a specified
- * bit or a group of specified bits to be active.  To continue the CAN bus
- * example, a CAN controlling task can enter the Blocked state (and therefore
- * not consume any processing time) until either bit 0, bit 1 or bit 2 are
- * active, at which time the bit that was actually active would inform the task
- * which action it had to take (process a received message, send a message, or
- * send a SYNC).
- *
- * The event groups implementation contains intelligence to avoid race
- * conditions that would otherwise occur were an application to use a simple
- * variable for the same purpose.  This is particularly important with respect
- * to when a bit within an event group is to be cleared, and when bits have to
- * be set and then tested atomically - as is the case where event groups are
- * used to create a synchronisation point between multiple tasks (a
- * 'rendezvous').
- *
- * \defgroup EventGroup
- */
-
-
-
-/**
- * event_groups.h
- *
- * Type by which event groups are referenced.  For example, a call to
- * xEventGroupCreate() returns an EventGroupHandle_t variable that can then
- * be used as a parameter to other event group functions.
- *
- * \defgroup EventGroupHandle_t EventGroupHandle_t
- * \ingroup EventGroup
- */
-struct EventGroupDef_t;
-typedef struct EventGroupDef_t * EventGroupHandle_t;
-
-/*
- * The type that holds event bits always matches TickType_t - therefore the
- * number of bits it holds is set by configUSE_16_BIT_TICKS (16 bits if set to 1,
- * 32 bits if set to 0.
- *
- * \defgroup EventBits_t EventBits_t
- * \ingroup EventGroup
- */
-typedef TickType_t EventBits_t;
-
-/**
- * event_groups.h
- *<pre>
- EventGroupHandle_t xEventGroupCreate( void );
- </pre>
- *
- * Create a new event group.
- *
- * Internally, within the FreeRTOS implementation, event groups use a [small]
- * block of memory, in which the event group's structure is stored.  If an event
- * groups is created using xEventGropuCreate() then the required memory is
- * automatically dynamically allocated inside the xEventGroupCreate() function.
- * (see http://www.freertos.org/a00111.html).  If an event group is created
- * using xEventGropuCreateStatic() then the application writer must instead
- * provide the memory that will get used by the event group.
- * xEventGroupCreateStatic() therefore allows an event group to be created
- * without using any dynamic memory allocation.
- *
- * Although event groups are not related to ticks, for internal implementation
- * reasons the number of bits available for use in an event group is dependent
- * on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h.  If
- * configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit
- * 0 to bit 7).  If configUSE_16_BIT_TICKS is set to 0 then each event group has
- * 24 usable bits (bit 0 to bit 23).  The EventBits_t type is used to store
- * event bits within an event group.
- *
- * @return If the event group was created then a handle to the event group is
- * returned.  If there was insufficient FreeRTOS heap available to create the
- * event group then NULL is returned.  See http://www.freertos.org/a00111.html
- *
- * Example usage:
-   <pre>
-	// Declare a variable to hold the created event group.
-	EventGroupHandle_t xCreatedEventGroup;
-
-	// Attempt to create the event group.
-	xCreatedEventGroup = xEventGroupCreate();
-
-	// Was the event group created successfully?
-	if( xCreatedEventGroup == NULL )
-	{
-		// The event group was not created because there was insufficient
-		// FreeRTOS heap available.
-	}
-	else
-	{
-		// The event group was created.
-	}
-   </pre>
- * \defgroup xEventGroupCreate xEventGroupCreate
- * \ingroup EventGroup
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	EventGroupHandle_t xEventGroupCreate( void ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * event_groups.h
- *<pre>
- EventGroupHandle_t xEventGroupCreateStatic( EventGroupHandle_t * pxEventGroupBuffer );
- </pre>
- *
- * Create a new event group.
- *
- * Internally, within the FreeRTOS implementation, event groups use a [small]
- * block of memory, in which the event group's structure is stored.  If an event
- * groups is created using xEventGropuCreate() then the required memory is
- * automatically dynamically allocated inside the xEventGroupCreate() function.
- * (see http://www.freertos.org/a00111.html).  If an event group is created
- * using xEventGropuCreateStatic() then the application writer must instead
- * provide the memory that will get used by the event group.
- * xEventGroupCreateStatic() therefore allows an event group to be created
- * without using any dynamic memory allocation.
- *
- * Although event groups are not related to ticks, for internal implementation
- * reasons the number of bits available for use in an event group is dependent
- * on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h.  If
- * configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit
- * 0 to bit 7).  If configUSE_16_BIT_TICKS is set to 0 then each event group has
- * 24 usable bits (bit 0 to bit 23).  The EventBits_t type is used to store
- * event bits within an event group.
- *
- * @param pxEventGroupBuffer pxEventGroupBuffer must point to a variable of type
- * StaticEventGroup_t, which will be then be used to hold the event group's data
- * structures, removing the need for the memory to be allocated dynamically.
- *
- * @return If the event group was created then a handle to the event group is
- * returned.  If pxEventGroupBuffer was NULL then NULL is returned.
- *
- * Example usage:
-   <pre>
-	// StaticEventGroup_t is a publicly accessible structure that has the same
-	// size and alignment requirements as the real event group structure.  It is
-	// provided as a mechanism for applications to know the size of the event
-	// group (which is dependent on the architecture and configuration file
-	// settings) without breaking the strict data hiding policy by exposing the
-	// real event group internals.  This StaticEventGroup_t variable is passed
-	// into the xSemaphoreCreateEventGroupStatic() function and is used to store
-	// the event group's data structures
-	StaticEventGroup_t xEventGroupBuffer;
-
-	// Create the event group without dynamically allocating any memory.
-	xEventGroup = xEventGroupCreateStatic( &xEventGroupBuffer );
-   </pre>
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * event_groups.h
- *<pre>
-	EventBits_t xEventGroupWaitBits( 	EventGroupHandle_t xEventGroup,
-										const EventBits_t uxBitsToWaitFor,
-										const BaseType_t xClearOnExit,
-										const BaseType_t xWaitForAllBits,
-										const TickType_t xTicksToWait );
- </pre>
- *
- * [Potentially] block to wait for one or more bits to be set within a
- * previously created event group.
- *
- * This function cannot be called from an interrupt.
- *
- * @param xEventGroup The event group in which the bits are being tested.  The
- * event group must have previously been created using a call to
- * xEventGroupCreate().
- *
- * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
- * inside the event group.  For example, to wait for bit 0 and/or bit 2 set
- * uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set
- * uxBitsToWaitFor to 0x07.  Etc.
- *
- * @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within
- * uxBitsToWaitFor that are set within the event group will be cleared before
- * xEventGroupWaitBits() returns if the wait condition was met (if the function
- * returns for a reason other than a timeout).  If xClearOnExit is set to
- * pdFALSE then the bits set in the event group are not altered when the call to
- * xEventGroupWaitBits() returns.
- *
- * @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then
- * xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor
- * are set or the specified block time expires.  If xWaitForAllBits is set to
- * pdFALSE then xEventGroupWaitBits() will return when any one of the bits set
- * in uxBitsToWaitFor is set or the specified block time expires.  The block
- * time is specified by the xTicksToWait parameter.
- *
- * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
- * for one/all (depending on the xWaitForAllBits value) of the bits specified by
- * uxBitsToWaitFor to become set.
- *
- * @return The value of the event group at the time either the bits being waited
- * for became set, or the block time expired.  Test the return value to know
- * which bits were set.  If xEventGroupWaitBits() returned because its timeout
- * expired then not all the bits being waited for will be set.  If
- * xEventGroupWaitBits() returned because the bits it was waiting for were set
- * then the returned value is the event group value before any bits were
- * automatically cleared in the case that xClearOnExit parameter was set to
- * pdTRUE.
- *
- * Example usage:
-   <pre>
-   #define BIT_0	( 1 << 0 )
-   #define BIT_4	( 1 << 4 )
-
-   void aFunction( EventGroupHandle_t xEventGroup )
-   {
-   EventBits_t uxBits;
-   const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
-
-		// Wait a maximum of 100ms for either bit 0 or bit 4 to be set within
-		// the event group.  Clear the bits before exiting.
-		uxBits = xEventGroupWaitBits(
-					xEventGroup,	// The event group being tested.
-					BIT_0 | BIT_4,	// The bits within the event group to wait for.
-					pdTRUE,			// BIT_0 and BIT_4 should be cleared before returning.
-					pdFALSE,		// Don't wait for both bits, either bit will do.
-					xTicksToWait );	// Wait a maximum of 100ms for either bit to be set.
-
-		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
-		{
-			// xEventGroupWaitBits() returned because both bits were set.
-		}
-		else if( ( uxBits & BIT_0 ) != 0 )
-		{
-			// xEventGroupWaitBits() returned because just BIT_0 was set.
-		}
-		else if( ( uxBits & BIT_4 ) != 0 )
-		{
-			// xEventGroupWaitBits() returned because just BIT_4 was set.
-		}
-		else
-		{
-			// xEventGroupWaitBits() returned because xTicksToWait ticks passed
-			// without either BIT_0 or BIT_4 becoming set.
-		}
-   }
-   </pre>
- * \defgroup xEventGroupWaitBits xEventGroupWaitBits
- * \ingroup EventGroup
- */
-EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * event_groups.h
- *<pre>
-	EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear );
- </pre>
- *
- * Clear bits within an event group.  This function cannot be called from an
- * interrupt.
- *
- * @param xEventGroup The event group in which the bits are to be cleared.
- *
- * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear
- * in the event group.  For example, to clear bit 3 only, set uxBitsToClear to
- * 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09.
- *
- * @return The value of the event group before the specified bits were cleared.
- *
- * Example usage:
-   <pre>
-   #define BIT_0	( 1 << 0 )
-   #define BIT_4	( 1 << 4 )
-
-   void aFunction( EventGroupHandle_t xEventGroup )
-   {
-   EventBits_t uxBits;
-
-		// Clear bit 0 and bit 4 in xEventGroup.
-		uxBits = xEventGroupClearBits(
-								xEventGroup,	// The event group being updated.
-								BIT_0 | BIT_4 );// The bits being cleared.
-
-		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
-		{
-			// Both bit 0 and bit 4 were set before xEventGroupClearBits() was
-			// called.  Both will now be clear (not set).
-		}
-		else if( ( uxBits & BIT_0 ) != 0 )
-		{
-			// Bit 0 was set before xEventGroupClearBits() was called.  It will
-			// now be clear.
-		}
-		else if( ( uxBits & BIT_4 ) != 0 )
-		{
-			// Bit 4 was set before xEventGroupClearBits() was called.  It will
-			// now be clear.
-		}
-		else
-		{
-			// Neither bit 0 nor bit 4 were set in the first place.
-		}
-   }
-   </pre>
- * \defgroup xEventGroupClearBits xEventGroupClearBits
- * \ingroup EventGroup
- */
-EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;
-
-/**
- * event_groups.h
- *<pre>
-	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
- </pre>
- *
- * A version of xEventGroupClearBits() that can be called from an interrupt.
- *
- * Setting bits in an event group is not a deterministic operation because there
- * are an unknown number of tasks that may be waiting for the bit or bits being
- * set.  FreeRTOS does not allow nondeterministic operations to be performed
- * while interrupts are disabled, so protects event groups that are accessed
- * from tasks by suspending the scheduler rather than disabling interrupts.  As
- * a result event groups cannot be accessed directly from an interrupt service
- * routine.  Therefore xEventGroupClearBitsFromISR() sends a message to the
- * timer task to have the clear operation performed in the context of the timer
- * task.
- *
- * @param xEventGroup The event group in which the bits are to be cleared.
- *
- * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear.
- * For example, to clear bit 3 only, set uxBitsToClear to 0x08.  To clear bit 3
- * and bit 0 set uxBitsToClear to 0x09.
- *
- * @return If the request to execute the function was posted successfully then
- * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned
- * if the timer service queue was full.
- *
- * Example usage:
-   <pre>
-   #define BIT_0	( 1 << 0 )
-   #define BIT_4	( 1 << 4 )
-
-   // An event group which it is assumed has already been created by a call to
-   // xEventGroupCreate().
-   EventGroupHandle_t xEventGroup;
-
-   void anInterruptHandler( void )
-   {
-		// Clear bit 0 and bit 4 in xEventGroup.
-		xResult = xEventGroupClearBitsFromISR(
-							xEventGroup,	 // The event group being updated.
-							BIT_0 | BIT_4 ); // The bits being set.
-
-		if( xResult == pdPASS )
-		{
-			// The message was posted successfully.
-		}
-  }
-   </pre>
- * \defgroup xEventGroupClearBitsFromISR xEventGroupClearBitsFromISR
- * \ingroup EventGroup
- */
-#if( configUSE_TRACE_FACILITY == 1 )
-	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;
-#else
-	#define xEventGroupClearBitsFromISR( xEventGroup, uxBitsToClear ) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL )
-#endif
-
-/**
- * event_groups.h
- *<pre>
-	EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
- </pre>
- *
- * Set bits within an event group.
- * This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()
- * is a version that can be called from an interrupt.
- *
- * Setting bits in an event group will automatically unblock tasks that are
- * blocked waiting for the bits.
- *
- * @param xEventGroup The event group in which the bits are to be set.
- *
- * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
- * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
- * and bit 0 set uxBitsToSet to 0x09.
- *
- * @return The value of the event group at the time the call to
- * xEventGroupSetBits() returns.  There are two reasons why the returned value
- * might have the bits specified by the uxBitsToSet parameter cleared.  First,
- * if setting a bit results in a task that was waiting for the bit leaving the
- * blocked state then it is possible the bit will be cleared automatically
- * (see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any
- * unblocked (or otherwise Ready state) task that has a priority above that of
- * the task that called xEventGroupSetBits() will execute and may change the
- * event group value before the call to xEventGroupSetBits() returns.
- *
- * Example usage:
-   <pre>
-   #define BIT_0	( 1 << 0 )
-   #define BIT_4	( 1 << 4 )
-
-   void aFunction( EventGroupHandle_t xEventGroup )
-   {
-   EventBits_t uxBits;
-
-		// Set bit 0 and bit 4 in xEventGroup.
-		uxBits = xEventGroupSetBits(
-							xEventGroup,	// The event group being updated.
-							BIT_0 | BIT_4 );// The bits being set.
-
-		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
-		{
-			// Both bit 0 and bit 4 remained set when the function returned.
-		}
-		else if( ( uxBits & BIT_0 ) != 0 )
-		{
-			// Bit 0 remained set when the function returned, but bit 4 was
-			// cleared.  It might be that bit 4 was cleared automatically as a
-			// task that was waiting for bit 4 was removed from the Blocked
-			// state.
-		}
-		else if( ( uxBits & BIT_4 ) != 0 )
-		{
-			// Bit 4 remained set when the function returned, but bit 0 was
-			// cleared.  It might be that bit 0 was cleared automatically as a
-			// task that was waiting for bit 0 was removed from the Blocked
-			// state.
-		}
-		else
-		{
-			// Neither bit 0 nor bit 4 remained set.  It might be that a task
-			// was waiting for both of the bits to be set, and the bits were
-			// cleared as the task left the Blocked state.
-		}
-   }
-   </pre>
- * \defgroup xEventGroupSetBits xEventGroupSetBits
- * \ingroup EventGroup
- */
-EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
-
-/**
- * event_groups.h
- *<pre>
-	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken );
- </pre>
- *
- * A version of xEventGroupSetBits() that can be called from an interrupt.
- *
- * Setting bits in an event group is not a deterministic operation because there
- * are an unknown number of tasks that may be waiting for the bit or bits being
- * set.  FreeRTOS does not allow nondeterministic operations to be performed in
- * interrupts or from critical sections.  Therefore xEventGroupSetBitsFromISR()
- * sends a message to the timer task to have the set operation performed in the
- * context of the timer task - where a scheduler lock is used in place of a
- * critical section.
- *
- * @param xEventGroup The event group in which the bits are to be set.
- *
- * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
- * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
- * and bit 0 set uxBitsToSet to 0x09.
- *
- * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
- * will result in a message being sent to the timer daemon task.  If the
- * priority of the timer daemon task is higher than the priority of the
- * currently running task (the task the interrupt interrupted) then
- * *pxHigherPriorityTaskWoken will be set to pdTRUE by
- * xEventGroupSetBitsFromISR(), indicating that a context switch should be
- * requested before the interrupt exits.  For that reason
- * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
- * example code below.
- *
- * @return If the request to execute the function was posted successfully then
- * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned
- * if the timer service queue was full.
- *
- * Example usage:
-   <pre>
-   #define BIT_0	( 1 << 0 )
-   #define BIT_4	( 1 << 4 )
-
-   // An event group which it is assumed has already been created by a call to
-   // xEventGroupCreate().
-   EventGroupHandle_t xEventGroup;
-
-   void anInterruptHandler( void )
-   {
-   BaseType_t xHigherPriorityTaskWoken, xResult;
-
-		// xHigherPriorityTaskWoken must be initialised to pdFALSE.
-		xHigherPriorityTaskWoken = pdFALSE;
-
-		// Set bit 0 and bit 4 in xEventGroup.
-		xResult = xEventGroupSetBitsFromISR(
-							xEventGroup,	// The event group being updated.
-							BIT_0 | BIT_4   // The bits being set.
-							&xHigherPriorityTaskWoken );
-
-		// Was the message posted successfully?
-		if( xResult == pdPASS )
-		{
-			// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
-			// switch should be requested.  The macro used is port specific and
-			// will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -
-			// refer to the documentation page for the port being used.
-			portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
-		}
-  }
-   </pre>
- * \defgroup xEventGroupSetBitsFromISR xEventGroupSetBitsFromISR
- * \ingroup EventGroup
- */
-#if( configUSE_TRACE_FACILITY == 1 )
-	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-#else
-	#define xEventGroupSetBitsFromISR( xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken ) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )
-#endif
-
-/**
- * event_groups.h
- *<pre>
-	EventBits_t xEventGroupSync(	EventGroupHandle_t xEventGroup,
-									const EventBits_t uxBitsToSet,
-									const EventBits_t uxBitsToWaitFor,
-									TickType_t xTicksToWait );
- </pre>
- *
- * Atomically set bits within an event group, then wait for a combination of
- * bits to be set within the same event group.  This functionality is typically
- * used to synchronise multiple tasks, where each task has to wait for the other
- * tasks to reach a synchronisation point before proceeding.
- *
- * This function cannot be used from an interrupt.
- *
- * The function will return before its block time expires if the bits specified
- * by the uxBitsToWait parameter are set, or become set within that time.  In
- * this case all the bits specified by uxBitsToWait will be automatically
- * cleared before the function returns.
- *
- * @param xEventGroup The event group in which the bits are being tested.  The
- * event group must have previously been created using a call to
- * xEventGroupCreate().
- *
- * @param uxBitsToSet The bits to set in the event group before determining
- * if, and possibly waiting for, all the bits specified by the uxBitsToWait
- * parameter are set.
- *
- * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
- * inside the event group.  For example, to wait for bit 0 and bit 2 set
- * uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set
- * uxBitsToWaitFor to 0x07.  Etc.
- *
- * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
- * for all of the bits specified by uxBitsToWaitFor to become set.
- *
- * @return The value of the event group at the time either the bits being waited
- * for became set, or the block time expired.  Test the return value to know
- * which bits were set.  If xEventGroupSync() returned because its timeout
- * expired then not all the bits being waited for will be set.  If
- * xEventGroupSync() returned because all the bits it was waiting for were
- * set then the returned value is the event group value before any bits were
- * automatically cleared.
- *
- * Example usage:
- <pre>
- // Bits used by the three tasks.
- #define TASK_0_BIT		( 1 << 0 )
- #define TASK_1_BIT		( 1 << 1 )
- #define TASK_2_BIT		( 1 << 2 )
-
- #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )
-
- // Use an event group to synchronise three tasks.  It is assumed this event
- // group has already been created elsewhere.
- EventGroupHandle_t xEventBits;
-
- void vTask0( void *pvParameters )
- {
- EventBits_t uxReturn;
- TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
-
-	 for( ;; )
-	 {
-		// Perform task functionality here.
-
-		// Set bit 0 in the event flag to note this task has reached the
-		// sync point.  The other two tasks will set the other two bits defined
-		// by ALL_SYNC_BITS.  All three tasks have reached the synchronisation
-		// point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms
-		// for this to happen.
-		uxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );
-
-		if( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )
-		{
-			// All three tasks reached the synchronisation point before the call
-			// to xEventGroupSync() timed out.
-		}
-	}
- }
-
- void vTask1( void *pvParameters )
- {
-	 for( ;; )
-	 {
-		// Perform task functionality here.
-
-		// Set bit 1 in the event flag to note this task has reached the
-		// synchronisation point.  The other two tasks will set the other two
-		// bits defined by ALL_SYNC_BITS.  All three tasks have reached the
-		// synchronisation point when all the ALL_SYNC_BITS are set.  Wait
-		// indefinitely for this to happen.
-		xEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );
-
-		// xEventGroupSync() was called with an indefinite block time, so
-		// this task will only reach here if the syncrhonisation was made by all
-		// three tasks, so there is no need to test the return value.
-	 }
- }
-
- void vTask2( void *pvParameters )
- {
-	 for( ;; )
-	 {
-		// Perform task functionality here.
-
-		// Set bit 2 in the event flag to note this task has reached the
-		// synchronisation point.  The other two tasks will set the other two
-		// bits defined by ALL_SYNC_BITS.  All three tasks have reached the
-		// synchronisation point when all the ALL_SYNC_BITS are set.  Wait
-		// indefinitely for this to happen.
-		xEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );
-
-		// xEventGroupSync() was called with an indefinite block time, so
-		// this task will only reach here if the syncrhonisation was made by all
-		// three tasks, so there is no need to test the return value.
-	}
- }
-
- </pre>
- * \defgroup xEventGroupSync xEventGroupSync
- * \ingroup EventGroup
- */
-EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-
-/**
- * event_groups.h
- *<pre>
-	EventBits_t xEventGroupGetBits( EventGroupHandle_t xEventGroup );
- </pre>
- *
- * Returns the current value of the bits in an event group.  This function
- * cannot be used from an interrupt.
- *
- * @param xEventGroup The event group being queried.
- *
- * @return The event group bits at the time xEventGroupGetBits() was called.
- *
- * \defgroup xEventGroupGetBits xEventGroupGetBits
- * \ingroup EventGroup
- */
-#define xEventGroupGetBits( xEventGroup ) xEventGroupClearBits( xEventGroup, 0 )
-
-/**
- * event_groups.h
- *<pre>
-	EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup );
- </pre>
- *
- * A version of xEventGroupGetBits() that can be called from an ISR.
- *
- * @param xEventGroup The event group being queried.
- *
- * @return The event group bits at the time xEventGroupGetBitsFromISR() was called.
- *
- * \defgroup xEventGroupGetBitsFromISR xEventGroupGetBitsFromISR
- * \ingroup EventGroup
- */
-EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
-
-/**
- * event_groups.h
- *<pre>
-	void xEventGroupDelete( EventGroupHandle_t xEventGroup );
- </pre>
- *
- * Delete an event group that was previously created by a call to
- * xEventGroupCreate().  Tasks that are blocked on the event group will be
- * unblocked and obtain 0 as the event group's value.
- *
- * @param xEventGroup The event group being deleted.
- */
-void vEventGroupDelete( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
-
-/* For internal use only. */
-void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet ) PRIVILEGED_FUNCTION;
-void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;
-
-
-#if (configUSE_TRACE_FACILITY == 1)
-	UBaseType_t uxEventGroupGetNumber( void* xEventGroup ) PRIVILEGED_FUNCTION;
-	void vEventGroupSetNumber( void* xEventGroup, UBaseType_t uxEventGroupNumber ) PRIVILEGED_FUNCTION;
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* EVENT_GROUPS_H */
-
-
diff --git a/osal/inc/freertos/list.h b/osal/inc/freertos/list.h
deleted file mode 100644
index a3e3024..0000000
--- a/osal/inc/freertos/list.h
+++ /dev/null
@@ -1,412 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * This is the list implementation used by the scheduler.  While it is tailored
- * heavily for the schedulers needs, it is also available for use by
- * application code.
- *
- * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
- * numeric value (xItemValue).  Most of the time the lists are sorted in
- * descending item value order.
- *
- * Lists are created already containing one list item.  The value of this
- * item is the maximum possible that can be stored, it is therefore always at
- * the end of the list and acts as a marker.  The list member pxHead always
- * points to this marker - even though it is at the tail of the list.  This
- * is because the tail contains a wrap back pointer to the true head of
- * the list.
- *
- * In addition to it's value, each list item contains a pointer to the next
- * item in the list (pxNext), a pointer to the list it is in (pxContainer)
- * and a pointer to back to the object that contains it.  These later two
- * pointers are included for efficiency of list manipulation.  There is
- * effectively a two way link between the object containing the list item and
- * the list item itself.
- *
- *
- * \page ListIntroduction List Implementation
- * \ingroup FreeRTOSIntro
- */
-
-#ifndef INC_FREERTOS_H
-	#error FreeRTOS.h must be included before list.h
-#endif
-
-#ifndef LIST_H
-#define LIST_H
-
-/*
- * The list structure members are modified from within interrupts, and therefore
- * by rights should be declared volatile.  However, they are only modified in a
- * functionally atomic way (within critical sections of with the scheduler
- * suspended) and are either passed by reference into a function or indexed via
- * a volatile variable.  Therefore, in all use cases tested so far, the volatile
- * qualifier can be omitted in order to provide a moderate performance
- * improvement without adversely affecting functional behaviour.  The assembly
- * instructions generated by the IAR, ARM and GCC compilers when the respective
- * compiler's options were set for maximum optimisation has been inspected and
- * deemed to be as intended.  That said, as compiler technology advances, and
- * especially if aggressive cross module optimisation is used (a use case that
- * has not been exercised to any great extend) then it is feasible that the
- * volatile qualifier will be needed for correct optimisation.  It is expected
- * that a compiler removing essential code because, without the volatile
- * qualifier on the list structure members and with aggressive cross module
- * optimisation, the compiler deemed the code unnecessary will result in
- * complete and obvious failure of the scheduler.  If this is ever experienced
- * then the volatile qualifier can be inserted in the relevant places within the
- * list structures by simply defining configLIST_VOLATILE to volatile in
- * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
- * If configLIST_VOLATILE is not defined then the preprocessor directives below
- * will simply #define configLIST_VOLATILE away completely.
- *
- * To use volatile list structure members then add the following line to
- * FreeRTOSConfig.h (without the quotes):
- * "#define configLIST_VOLATILE volatile"
- */
-#ifndef configLIST_VOLATILE
-	#define configLIST_VOLATILE
-#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Macros that can be used to place known values within the list structures,
-then check that the known values do not get corrupted during the execution of
-the application.   These may catch the list data structures being overwritten in
-memory.  They will not catch data errors caused by incorrect configuration or
-use of FreeRTOS.*/
-#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
-	/* Define the macros to do nothing. */
-	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
-	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
-	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
-	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
-	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
-	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
-	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
-	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
-	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
-	#define listTEST_LIST_INTEGRITY( pxList )
-#else
-	/* Define macros that add new members into the list structures. */
-	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
-	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
-	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
-	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
-
-	/* Define macros that set the new structure members to known values. */
-	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
-	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
-	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
-	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
-
-	/* Define macros that will assert if one of the structure members does not
-	contain its expected value. */
-	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
-	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
-#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
-
-
-/*
- * Definition of the only type of object that a list can contain.
- */
-struct xLIST;
-struct xLIST_ITEM
-{
-	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
-	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
-	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
-	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
-	struct xLIST * configLIST_VOLATILE pxContainer;		/*< Pointer to the list in which this list item is placed (if any). */
-	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-};
-typedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
-
-struct xMINI_LIST_ITEM
-{
-	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	configLIST_VOLATILE TickType_t xItemValue;
-	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
-	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
-};
-typedef struct xMINI_LIST_ITEM MiniListItem_t;
-
-/*
- * Definition of the type of queue used by the scheduler.
- */
-typedef struct xLIST
-{
-	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	volatile UBaseType_t uxNumberOfItems;
-	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
-	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
-	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-} List_t;
-
-/*
- * Access macro to set the owner of a list item.  The owner of a list item
- * is the object (usually a TCB) that contains the list item.
- *
- * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
- * \ingroup LinkedList
- */
-#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
-
-/*
- * Access macro to get the owner of a list item.  The owner of a list item
- * is the object (usually a TCB) that contains the list item.
- *
- * \page listGET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
- * \ingroup LinkedList
- */
-#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
-
-/*
- * Access macro to set the value of the list item.  In most cases the value is
- * used to sort the list in descending order.
- *
- * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
- * \ingroup LinkedList
- */
-#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
-
-/*
- * Access macro to retrieve the value of the list item.  The value can
- * represent anything - for example the priority of a task, or the time at
- * which a task should be unblocked.
- *
- * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
- * \ingroup LinkedList
- */
-#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
-
-/*
- * Access macro to retrieve the value of the list item at the head of a given
- * list.
- *
- * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
- * \ingroup LinkedList
- */
-#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
-
-/*
- * Return the list item at the head of the list.
- *
- * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
- * \ingroup LinkedList
- */
-#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
-
-/*
- * Return the next list item.
- *
- * \page listGET_NEXT listGET_NEXT
- * \ingroup LinkedList
- */
-#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
-
-/*
- * Return the list item that marks the end of the list
- *
- * \page listGET_END_MARKER listGET_END_MARKER
- * \ingroup LinkedList
- */
-#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
-
-/*
- * Access macro to determine if a list contains any items.  The macro will
- * only have the value true if the list is empty.
- *
- * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
- * \ingroup LinkedList
- */
-#define listLIST_IS_EMPTY( pxList )	( ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE )
-
-/*
- * Access macro to return the number of items in the list.
- */
-#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
-
-/*
- * Access function to obtain the owner of the next entry in a list.
- *
- * The list member pxIndex is used to walk through a list.  Calling
- * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
- * and returns that entry's pxOwner parameter.  Using multiple calls to this
- * function it is therefore possible to move through every item contained in
- * a list.
- *
- * The pxOwner parameter of a list item is a pointer to the object that owns
- * the list item.  In the scheduler this is normally a task control block.
- * The pxOwner parameter effectively creates a two way link between the list
- * item and its owner.
- *
- * @param pxTCB pxTCB is set to the address of the owner of the next list item.
- * @param pxList The list from which the next item owner is to be returned.
- *
- * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
- * \ingroup LinkedList
- */
-#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
-{																							\
-List_t * const pxConstList = ( pxList );													\
-	/* Increment the index to the next item and return the item, ensuring */				\
-	/* we don't return the marker used at the end of the list.  */							\
-	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
-	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
-	{																						\
-		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
-	}																						\
-	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
-}
-
-
-/*
- * Access function to obtain the owner of the first entry in a list.  Lists
- * are normally sorted in ascending item value order.
- *
- * This function returns the pxOwner member of the first item in the list.
- * The pxOwner parameter of a list item is a pointer to the object that owns
- * the list item.  In the scheduler this is normally a task control block.
- * The pxOwner parameter effectively creates a two way link between the list
- * item and its owner.
- *
- * @param pxList The list from which the owner of the head item is to be
- * returned.
- *
- * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
- * \ingroup LinkedList
- */
-#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
-
-/*
- * Check to see if a list item is within a list.  The list item maintains a
- * "container" pointer that points to the list it is in.  All this macro does
- * is check to see if the container and the list match.
- *
- * @param pxList The list we want to know if the list item is within.
- * @param pxListItem The list item we want to know if is in the list.
- * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
- */
-#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( ( pxListItem )->pxContainer == ( pxList ) ) ? ( pdTRUE ) : ( pdFALSE ) )
-
-/*
- * Return the list a list item is contained within (referenced from).
- *
- * @param pxListItem The list item being queried.
- * @return A pointer to the List_t object that references the pxListItem
- */
-#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pxContainer )
-
-/*
- * This provides a crude means of knowing if a list has been initialised, as
- * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
- * function.
- */
-#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
-
-/*
- * Must be called before a list is used!  This initialises all the members
- * of the list structure and inserts the xListEnd item into the list as a
- * marker to the back of the list.
- *
- * @param pxList Pointer to the list being initialised.
- *
- * \page vListInitialise vListInitialise
- * \ingroup LinkedList
- */
-void vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
-
-/*
- * Must be called before a list item is used.  This sets the list container to
- * null so the item does not think that it is already contained in a list.
- *
- * @param pxItem Pointer to the list item being initialised.
- *
- * \page vListInitialiseItem vListInitialiseItem
- * \ingroup LinkedList
- */
-void vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
-
-/*
- * Insert a list item into a list.  The item will be inserted into the list in
- * a position determined by its item value (descending item value order).
- *
- * @param pxList The list into which the item is to be inserted.
- *
- * @param pxNewListItem The item that is to be placed in the list.
- *
- * \page vListInsert vListInsert
- * \ingroup LinkedList
- */
-void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
-
-/*
- * Insert a list item into a list.  The item will be inserted in a position
- * such that it will be the last item within the list returned by multiple
- * calls to listGET_OWNER_OF_NEXT_ENTRY.
- *
- * The list member pxIndex is used to walk through a list.  Calling
- * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
- * Placing an item in a list using vListInsertEnd effectively places the item
- * in the list position pointed to by pxIndex.  This means that every other
- * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
- * the pxIndex parameter again points to the item being inserted.
- *
- * @param pxList The list into which the item is to be inserted.
- *
- * @param pxNewListItem The list item to be inserted into the list.
- *
- * \page vListInsertEnd vListInsertEnd
- * \ingroup LinkedList
- */
-void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
-
-/*
- * Remove an item from a list.  The list item has a pointer to the list that
- * it is in, so only the list item need be passed into the function.
- *
- * @param uxListRemove The item to be removed.  The item will remove itself from
- * the list pointed to by it's pxContainer parameter.
- *
- * @return The number of items that remain in the list after the list item has
- * been removed.
- *
- * \page uxListRemove uxListRemove
- * \ingroup LinkedList
- */
-UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
diff --git a/osal/inc/freertos/message_buffer.h b/osal/inc/freertos/message_buffer.h
deleted file mode 100644
index 0c3edb9..0000000
--- a/osal/inc/freertos/message_buffer.h
+++ /dev/null
@@ -1,803 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-/*
- * Message buffers build functionality on top of FreeRTOS stream buffers.
- * Whereas stream buffers are used to send a continuous stream of data from one
- * task or interrupt to another, message buffers are used to send variable
- * length discrete messages from one task or interrupt to another.  Their
- * implementation is light weight, making them particularly suited for interrupt
- * to task and core to core communication scenarios.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xMessageBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xMessageBufferRead()) inside a critical section and set the receive
- * timeout to 0.
- *
- * Message buffers hold variable length messages.  To enable that, when a
- * message is written to the message buffer an additional sizeof( size_t ) bytes
- * are also written to store the message's length (that happens internally, with
- * the API function).  sizeof( size_t ) is typically 4 bytes on a 32-bit
- * architecture, so writing a 10 byte message to a message buffer on a 32-bit
- * architecture will actually reduce the available space in the message buffer
- * by 14 bytes (10 byte are used by the message, and 4 bytes to hold the length
- * of the message).
- */
-
-#ifndef FREERTOS_MESSAGE_BUFFER_H
-#define FREERTOS_MESSAGE_BUFFER_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h must appear in source files before include message_buffer.h"
-#endif
-
-/* Message buffers are built onto of stream buffers. */
-#include "stream_buffer.h"
-
-#if defined( __cplusplus )
-extern "C" {
-#endif
-
-/**
- * Type by which message buffers are referenced.  For example, a call to
- * xMessageBufferCreate() returns an MessageBufferHandle_t variable that can
- * then be used as a parameter to xMessageBufferSend(), xMessageBufferReceive(),
- * etc.
- */
-typedef void * MessageBufferHandle_t;
-
-/*-----------------------------------------------------------*/
-
-/**
- * message_buffer.h
- *
-<pre>
-MessageBufferHandle_t xMessageBufferCreate( size_t xBufferSizeBytes );
-</pre>
- *
- * Creates a new message buffer using dynamically allocated memory.  See
- * xMessageBufferCreateStatic() for a version that uses statically allocated
- * memory (memory that is allocated at compile time).
- *
- * configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in
- * FreeRTOSConfig.h for xMessageBufferCreate() to be available.
- *
- * @param xBufferSizeBytes The total number of bytes (not messages) the message
- * buffer will be able to hold at any one time.  When a message is written to
- * the message buffer an additional sizeof( size_t ) bytes are also written to
- * store the message's length.  sizeof( size_t ) is typically 4 bytes on a
- * 32-bit architecture, so on most 32-bit architectures a 10 byte message will
- * take up 14 bytes of message buffer space.
- *
- * @return If NULL is returned, then the message buffer cannot be created
- * because there is insufficient heap memory available for FreeRTOS to allocate
- * the message buffer data structures and storage area.  A non-NULL value being
- * returned indicates that the message buffer has been created successfully -
- * the returned value should be stored as the handle to the created message
- * buffer.
- *
- * Example use:
-<pre>
-
-void vAFunction( void )
-{
-MessageBufferHandle_t xMessageBuffer;
-const size_t xMessageBufferSizeBytes = 100;
-
-    // Create a message buffer that can hold 100 bytes.  The memory used to hold
-    // both the message buffer structure and the messages themselves is allocated
-    // dynamically.  Each message added to the buffer consumes an additional 4
-    // bytes which are used to hold the lengh of the message.
-    xMessageBuffer = xMessageBufferCreate( xMessageBufferSizeBytes );
-
-    if( xMessageBuffer == NULL )
-    {
-        // There was not enough heap memory space available to create the
-        // message buffer.
-    }
-    else
-    {
-        // The message buffer was created successfully and can now be used.
-    }
-
-</pre>
- * \defgroup xMessageBufferCreate xMessageBufferCreate
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferCreate( xBufferSizeBytes ) ( MessageBufferHandle_t ) xStreamBufferGenericCreate( xBufferSizeBytes, ( size_t ) 0, pdTRUE )
-
-/**
- * message_buffer.h
- *
-<pre>
-MessageBufferHandle_t xMessageBufferCreateStatic( size_t xBufferSizeBytes,
-                                                  uint8_t *pucMessageBufferStorageArea,
-                                                  StaticMessageBuffer_t *pxStaticMessageBuffer );
-</pre>
- * Creates a new message buffer using statically allocated memory.  See
- * xMessageBufferCreate() for a version that uses dynamically allocated memory.
- *
- * @param xBufferSizeBytes The size, in bytes, of the buffer pointed to by the
- * pucMessageBufferStorageArea parameter.  When a message is written to the
- * message buffer an additional sizeof( size_t ) bytes are also written to store
- * the message's length.  sizeof( size_t ) is typically 4 bytes on a 32-bit
- * architecture, so on most 32-bit architecture a 10 byte message will take up
- * 14 bytes of message buffer space.  The maximum number of bytes that can be
- * stored in the message buffer is actually (xBufferSizeBytes - 1).
- *
- * @param pucMessageBufferStorageArea Must point to a uint8_t array that is at
- * least xBufferSizeBytes + 1 big.  This is the array to which messages are
- * copied when they are written to the message buffer.
- *
- * @param pxStaticMessageBuffer Must point to a variable of type
- * StaticMessageBuffer_t, which will be used to hold the message buffer's data
- * structure.
- *
- * @return If the message buffer is created successfully then a handle to the
- * created message buffer is returned. If either pucMessageBufferStorageArea or
- * pxStaticmessageBuffer are NULL then NULL is returned.
- *
- * Example use:
-<pre>
-
-// Used to dimension the array used to hold the messages.  The available space
-// will actually be one less than this, so 999.
-#define STORAGE_SIZE_BYTES 1000
-
-// Defines the memory that will actually hold the messages within the message
-// buffer.
-static uint8_t ucStorageBuffer[ STORAGE_SIZE_BYTES ];
-
-// The variable used to hold the message buffer structure.
-StaticMessageBuffer_t xMessageBufferStruct;
-
-void MyFunction( void )
-{
-MessageBufferHandle_t xMessageBuffer;
-
-    xMessageBuffer = xMessageBufferCreateStatic( sizeof( ucBufferStorage ),
-                                                 ucBufferStorage,
-                                                 &xMessageBufferStruct );
-
-    // As neither the pucMessageBufferStorageArea or pxStaticMessageBuffer
-    // parameters were NULL, xMessageBuffer will not be NULL, and can be used to
-    // reference the created message buffer in other message buffer API calls.
-
-    // Other code that uses the message buffer can go here.
-}
-
-</pre>
- * \defgroup xMessageBufferCreateStatic xMessageBufferCreateStatic
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferCreateStatic( xBufferSizeBytes, pucMessageBufferStorageArea, pxStaticMessageBuffer ) ( MessageBufferHandle_t ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, 0, pdTRUE, pucMessageBufferStorageArea, pxStaticMessageBuffer )
-
-/**
- * message_buffer.h
- *
-<pre>
-size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer,
-                           const void *pvTxData,
-                           size_t xDataLengthBytes,
-                           TickType_t xTicksToWait );
-<pre>
- *
- * Sends a discrete message to the message buffer.  The message can be any
- * length that fits within the buffer's free space, and is copied into the
- * buffer.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xMessageBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xMessageBufferRead()) inside a critical section and set the receive
- * block time to 0.
- *
- * Use xMessageBufferSend() to write to a message buffer from a task.  Use
- * xMessageBufferSendFromISR() to write to a message buffer from an interrupt
- * service routine (ISR).
- *
- * @param xMessageBuffer The handle of the message buffer to which a message is
- * being sent.
- *
- * @param pvTxData A pointer to the message that is to be copied into the
- * message buffer.
- *
- * @param xDataLengthBytes The length of the message.  That is, the number of
- * bytes to copy from pvTxData into the message buffer.  When a message is
- * written to the message buffer an additional sizeof( size_t ) bytes are also
- * written to store the message's length.  sizeof( size_t ) is typically 4 bytes
- * on a 32-bit architecture, so on most 32-bit architecture setting
- * xDataLengthBytes to 20 will reduce the free space in the message buffer by 24
- * bytes (20 bytes of message data and 4 bytes to hold the message length).
- *
- * @param xTicksToWait The maximum amount of time the calling task should remain
- * in the Blocked state to wait for enough space to become available in the
- * message buffer, should the message buffer have insufficient space when
- * xMessageBufferSend() is called.  The calling task will never block if
- * xTicksToWait is zero.  The block time is specified in tick periods, so the
- * absolute time it represents is dependent on the tick frequency.  The macro
- * pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into
- * a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will cause
- * the task to wait indefinitely (without timing out), provided
- * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  Tasks do not use any
- * CPU time when they are in the Blocked state.
- *
- * @return The number of bytes written to the message buffer.  If the call to
- * xMessageBufferSend() times out before there was enough space to write the
- * message into the message buffer then zero is returned.  If the call did not
- * time out then xDataLengthBytes is returned.
- *
- * Example use:
-<pre>
-void vAFunction( MessageBufferHandle_t xMessageBuffer )
-{
-size_t xBytesSent;
-uint8_t ucArrayToSend[] = { 0, 1, 2, 3 };
-char *pcStringToSend = "String to send";
-const TickType_t x100ms = pdMS_TO_TICKS( 100 );
-
-    // Send an array to the message buffer, blocking for a maximum of 100ms to
-    // wait for enough space to be available in the message buffer.
-    xBytesSent = xMessageBufferSend( xMessageBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );
-
-    if( xBytesSent != sizeof( ucArrayToSend ) )
-    {
-        // The call to xMessageBufferSend() times out before there was enough
-        // space in the buffer for the data to be written.
-    }
-
-    // Send the string to the message buffer.  Return immediately if there is
-    // not enough space in the buffer.
-    xBytesSent = xMessageBufferSend( xMessageBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );
-
-    if( xBytesSent != strlen( pcStringToSend ) )
-    {
-        // The string could not be added to the message buffer because there was
-        // not enough free space in the buffer.
-    }
-}
-</pre>
- * \defgroup xMessageBufferSend xMessageBufferSend
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferSend( xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait ) xStreamBufferSend( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait )
-
-/**
- * message_buffer.h
- *
-<pre>
-size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,
-                                  const void *pvTxData,
-                                  size_t xDataLengthBytes,
-                                  BaseType_t *pxHigherPriorityTaskWoken );
-<pre>
- *
- * Interrupt safe version of the API function that sends a discrete message to
- * the message buffer.  The message can be any length that fits within the
- * buffer's free space, and is copied into the buffer.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xMessageBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xMessageBufferRead()) inside a critical section and set the receive
- * block time to 0.
- *
- * Use xMessageBufferSend() to write to a message buffer from a task.  Use
- * xMessageBufferSendFromISR() to write to a message buffer from an interrupt
- * service routine (ISR).
- *
- * @param xMessageBuffer The handle of the message buffer to which a message is
- * being sent.
- *
- * @param pvTxData A pointer to the message that is to be copied into the
- * message buffer.
- *
- * @param xDataLengthBytes The length of the message.  That is, the number of
- * bytes to copy from pvTxData into the message buffer.  When a message is
- * written to the message buffer an additional sizeof( size_t ) bytes are also
- * written to store the message's length.  sizeof( size_t ) is typically 4 bytes
- * on a 32-bit architecture, so on most 32-bit architecture setting
- * xDataLengthBytes to 20 will reduce the free space in the message buffer by 24
- * bytes (20 bytes of message data and 4 bytes to hold the message length).
- *
- * @param pxHigherPriorityTaskWoken  It is possible that a message buffer will
- * have a task blocked on it waiting for data.  Calling
- * xMessageBufferSendFromISR() can make data available, and so cause a task that
- * was waiting for data to leave the Blocked state.  If calling
- * xMessageBufferSendFromISR() causes a task to leave the Blocked state, and the
- * unblocked task has a priority higher than the currently executing task (the
- * task that was interrupted), then, internally, xMessageBufferSendFromISR()
- * will set *pxHigherPriorityTaskWoken to pdTRUE.  If
- * xMessageBufferSendFromISR() sets this value to pdTRUE, then normally a
- * context switch should be performed before the interrupt is exited.  This will
- * ensure that the interrupt returns directly to the highest priority Ready
- * state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it
- * is passed into the function.  See the code example below for an example.
- *
- * @return The number of bytes actually written to the message buffer.  If the
- * message buffer didn't have enough free space for the message to be stored
- * then 0 is returned, otherwise xDataLengthBytes is returned.
- *
- * Example use:
-<pre>
-// A message buffer that has already been created.
-MessageBufferHandle_t xMessageBuffer;
-
-void vAnInterruptServiceRoutine( void )
-{
-size_t xBytesSent;
-char *pcStringToSend = "String to send";
-BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.
-
-    // Attempt to send the string to the message buffer.
-    xBytesSent = xMessageBufferSendFromISR( xMessageBuffer,
-                                            ( void * ) pcStringToSend,
-                                            strlen( pcStringToSend ),
-                                            &xHigherPriorityTaskWoken );
-
-    if( xBytesSent != strlen( pcStringToSend ) )
-    {
-        // The string could not be added to the message buffer because there was
-        // not enough free space in the buffer.
-    }
-
-    // If xHigherPriorityTaskWoken was set to pdTRUE inside
-    // xMessageBufferSendFromISR() then a task that has a priority above the
-    // priority of the currently executing task was unblocked and a context
-    // switch should be performed to ensure the ISR returns to the unblocked
-    // task.  In most FreeRTOS ports this is done by simply passing
-    // xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the
-    // variables value, and perform the context switch if necessary.  Check the
-    // documentation for the port in use for port specific instructions.
-    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
-}
-</pre>
- * \defgroup xMessageBufferSendFromISR xMessageBufferSendFromISR
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferSendFromISR( xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken ) xStreamBufferSendFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken )
-
-/**
- * message_buffer.h
- *
-<pre>
-size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer,
-                              void *pvRxData,
-                              size_t xBufferLengthBytes,
-                              TickType_t xTicksToWait );
-</pre>
- *
- * Receives a discrete message from a message buffer.  Messages can be of
- * variable length and are copied out of the buffer.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xMessageBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xMessageBufferRead()) inside a critical section and set the receive
- * block time to 0.
- *
- * Use xMessageBufferReceive() to read from a message buffer from a task.  Use
- * xMessageBufferReceiveFromISR() to read from a message buffer from an
- * interrupt service routine (ISR).
- *
- * @param xMessageBuffer The handle of the message buffer from which a message
- * is being received.
- *
- * @param pvRxData A pointer to the buffer into which the received message is
- * to be copied.
- *
- * @param xBufferLengthBytes The length of the buffer pointed to by the pvRxData
- * parameter.  This sets the maximum length of the message that can be received.
- * If xBufferLengthBytes is too small to hold the next message then the message
- * will be left in the message buffer and 0 will be returned.
- *
- * @param xTicksToWait The maximum amount of time the task should remain in the
- * Blocked state to wait for a message, should the message buffer be empty.
- * xMessageBufferReceive() will return immediately if xTicksToWait is zero and
- * the message buffer is empty.  The block time is specified in tick periods, so
- * the absolute time it represents is dependent on the tick frequency.  The
- * macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds
- * into a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will
- * cause the task to wait indefinitely (without timing out), provided
- * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  Tasks do not use any
- * CPU time when they are in the Blocked state.
- *
- * @return The length, in bytes, of the message read from the message buffer, if
- * any.  If xMessageBufferReceive() times out before a message became available
- * then zero is returned.  If the length of the message is greater than
- * xBufferLengthBytes then the message will be left in the message buffer and
- * zero is returned.
- *
- * Example use:
-<pre>
-void vAFunction( MessageBuffer_t xMessageBuffer )
-{
-uint8_t ucRxData[ 20 ];
-size_t xReceivedBytes;
-const TickType_t xBlockTime = pdMS_TO_TICKS( 20 );
-
-    // Receive the next message from the message buffer.  Wait in the Blocked
-    // state (so not using any CPU processing time) for a maximum of 100ms for
-    // a message to become available.
-    xReceivedBytes = xMessageBufferReceive( xMessageBuffer,
-                                            ( void * ) ucRxData,
-                                            sizeof( ucRxData ),
-                                            xBlockTime );
-
-    if( xReceivedBytes > 0 )
-    {
-        // A ucRxData contains a message that is xReceivedBytes long.  Process
-        // the message here....
-    }
-}
-</pre>
- * \defgroup xMessageBufferReceive xMessageBufferReceive
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferReceive( xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait ) xStreamBufferReceive( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait )
-
-
-/**
- * message_buffer.h
- *
-<pre>
-size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer,
-                                     void *pvRxData,
-                                     size_t xBufferLengthBytes,
-                                     BaseType_t *pxHigherPriorityTaskWoken );
-</pre>
- *
- * An interrupt safe version of the API function that receives a discrete
- * message from a message buffer.  Messages can be of variable length and are
- * copied out of the buffer.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xMessageBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xMessageBufferRead()) inside a critical section and set the receive
- * block time to 0.
- *
- * Use xMessageBufferReceive() to read from a message buffer from a task.  Use
- * xMessageBufferReceiveFromISR() to read from a message buffer from an
- * interrupt service routine (ISR).
- *
- * @param xMessageBuffer The handle of the message buffer from which a message
- * is being received.
- *
- * @param pvRxData A pointer to the buffer into which the received message is
- * to be copied.
- *
- * @param xBufferLengthBytes The length of the buffer pointed to by the pvRxData
- * parameter.  This sets the maximum length of the message that can be received.
- * If xBufferLengthBytes is too small to hold the next message then the message
- * will be left in the message buffer and 0 will be returned.
- *
- * @param pxHigherPriorityTaskWoken  It is possible that a message buffer will
- * have a task blocked on it waiting for space to become available.  Calling
- * xMessageBufferReceiveFromISR() can make space available, and so cause a task
- * that is waiting for space to leave the Blocked state.  If calling
- * xMessageBufferReceiveFromISR() causes a task to leave the Blocked state, and
- * the unblocked task has a priority higher than the currently executing task
- * (the task that was interrupted), then, internally,
- * xMessageBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.
- * If xMessageBufferReceiveFromISR() sets this value to pdTRUE, then normally a
- * context switch should be performed before the interrupt is exited.  That will
- * ensure the interrupt returns directly to the highest priority Ready state
- * task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is
- * passed into the function.  See the code example below for an example.
- *
- * @return The length, in bytes, of the message read from the message buffer, if
- * any.
- *
- * Example use:
-<pre>
-// A message buffer that has already been created.
-MessageBuffer_t xMessageBuffer;
-
-void vAnInterruptServiceRoutine( void )
-{
-uint8_t ucRxData[ 20 ];
-size_t xReceivedBytes;
-BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.
-
-    // Receive the next message from the message buffer.
-    xReceivedBytes = xMessageBufferReceiveFromISR( xMessageBuffer,
-                                                  ( void * ) ucRxData,
-                                                  sizeof( ucRxData ),
-                                                  &xHigherPriorityTaskWoken );
-
-    if( xReceivedBytes > 0 )
-    {
-        // A ucRxData contains a message that is xReceivedBytes long.  Process
-        // the message here....
-    }
-
-    // If xHigherPriorityTaskWoken was set to pdTRUE inside
-    // xMessageBufferReceiveFromISR() then a task that has a priority above the
-    // priority of the currently executing task was unblocked and a context
-    // switch should be performed to ensure the ISR returns to the unblocked
-    // task.  In most FreeRTOS ports this is done by simply passing
-    // xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the
-    // variables value, and perform the context switch if necessary.  Check the
-    // documentation for the port in use for port specific instructions.
-    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
-}
-</pre>
- * \defgroup xMessageBufferReceiveFromISR xMessageBufferReceiveFromISR
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferReceiveFromISR( xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken ) xStreamBufferReceiveFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken )
-
-/**
- * message_buffer.h
- *
-<pre>
-void vMessageBufferDelete( MessageBufferHandle_t xMessageBuffer );
-</pre>
- *
- * Deletes a message buffer that was previously created using a call to
- * xMessageBufferCreate() or xMessageBufferCreateStatic().  If the message
- * buffer was created using dynamic memory (that is, by xMessageBufferCreate()),
- * then the allocated memory is freed.
- *
- * A message buffer handle must not be used after the message buffer has been
- * deleted.
- *
- * @param xMessageBuffer The handle of the message buffer to be deleted.
- *
- */
-#define vMessageBufferDelete( xMessageBuffer ) vStreamBufferDelete( ( StreamBufferHandle_t ) xMessageBuffer )
-
-/**
- * message_buffer.h
-<pre>
-BaseType_t xMessageBufferIsFull( MessageBufferHandle_t xMessageBuffer ) );
-</pre>
- *
- * Tests to see if a message buffer is full.  A message buffer is full if it
- * cannot accept any more messages, of any size, until space is made available
- * by a message being removed from the message buffer.
- *
- * @param xMessageBuffer The handle of the message buffer being queried.
- *
- * @return If the message buffer referenced by xMessageBuffer is full then
- * pdTRUE is returned.  Otherwise pdFALSE is returned.
- */
-#define xMessageBufferIsFull( xMessageBuffer ) xStreamBufferIsFull( ( StreamBufferHandle_t ) xMessageBuffer )
-
-/**
- * message_buffer.h
-<pre>
-BaseType_t xMessageBufferIsEmpty( MessageBufferHandle_t xMessageBuffer ) );
-</pre>
- *
- * Tests to see if a message buffer is empty (does not contain any messages).
- *
- * @param xMessageBuffer The handle of the message buffer being queried.
- *
- * @return If the message buffer referenced by xMessageBuffer is empty then
- * pdTRUE is returned.  Otherwise pdFALSE is returned.
- *
- */
-#define xMessageBufferIsEmpty( xMessageBuffer ) xStreamBufferIsEmpty( ( StreamBufferHandle_t ) xMessageBuffer )
-
-/**
- * message_buffer.h
-<pre>
-BaseType_t xMessageBufferReset( MessageBufferHandle_t xMessageBuffer );
-</pre>
- *
- * Resets a message buffer to its initial empty state, discarding any message it
- * contained.
- *
- * A message buffer can only be reset if there are no tasks blocked on it.
- *
- * @param xMessageBuffer The handle of the message buffer being reset.
- *
- * @return If the message buffer was reset then pdPASS is returned.  If the
- * message buffer could not be reset because either there was a task blocked on
- * the message queue to wait for space to become available, or to wait for a
- * a message to be available, then pdFAIL is returned.
- *
- * \defgroup xMessageBufferReset xMessageBufferReset
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferReset( xMessageBuffer ) xStreamBufferReset( ( StreamBufferHandle_t ) xMessageBuffer )
-
-
-/**
- * message_buffer.h
-<pre>
-size_t xMessageBufferSpaceAvailable( MessageBufferHandle_t xMessageBuffer ) );
-</pre>
- * Returns the number of bytes of free space in the message buffer.
- *
- * @param xMessageBuffer The handle of the message buffer being queried.
- *
- * @return The number of bytes that can be written to the message buffer before
- * the message buffer would be full.  When a message is written to the message
- * buffer an additional sizeof( size_t ) bytes are also written to store the
- * message's length.  sizeof( size_t ) is typically 4 bytes on a 32-bit
- * architecture, so if xMessageBufferSpacesAvailable() returns 10, then the size
- * of the largest message that can be written to the message buffer is 6 bytes.
- *
- * \defgroup xMessageBufferSpaceAvailable xMessageBufferSpaceAvailable
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferSpaceAvailable( xMessageBuffer ) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer )
-#define xMessageBufferSpacesAvailable( xMessageBuffer ) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer ) /* Corrects typo in original macro name. */
-
-/**
- * message_buffer.h
- <pre>
- size_t xMessageBufferNextLengthBytes( MessageBufferHandle_t xMessageBuffer ) );
- </pre>
- * Returns the length (in bytes) of the next message in a message buffer.
- * Useful if xMessageBufferReceive() returned 0 because the size of the buffer
- * passed into xMessageBufferReceive() was too small to hold the next message.
- *
- * @param xMessageBuffer The handle of the message buffer being queried.
- *
- * @return The length (in bytes) of the next message in the message buffer, or 0
- * if the message buffer is empty.
- *
- * \defgroup xMessageBufferNextLengthBytes xMessageBufferNextLengthBytes
- * \ingroup MessageBufferManagement
- */
-#define xMessageBufferNextLengthBytes( xMessageBuffer ) xStreamBufferNextMessageLengthBytes( ( StreamBufferHandle_t ) xMessageBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * message_buffer.h
- *
-<pre>
-BaseType_t xMessageBufferSendCompletedFromISR( MessageBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
-</pre>
- *
- * For advanced users only.
- *
- * The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when
- * data is sent to a message buffer or stream buffer.  If there was a task that
- * was blocked on the message or stream buffer waiting for data to arrive then
- * the sbSEND_COMPLETED() macro sends a notification to the task to remove it
- * from the Blocked state.  xMessageBufferSendCompletedFromISR() does the same
- * thing.  It is provided to enable application writers to implement their own
- * version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.
- *
- * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
- * additional information.
- *
- * @param xStreamBuffer The handle of the stream buffer to which data was
- * written.
- *
- * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
- * initialised to pdFALSE before it is passed into
- * xMessageBufferSendCompletedFromISR().  If calling
- * xMessageBufferSendCompletedFromISR() removes a task from the Blocked state,
- * and the task has a priority above the priority of the currently running task,
- * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
- * context switch should be performed before exiting the ISR.
- *
- * @return If a task was removed from the Blocked state then pdTRUE is returned.
- * Otherwise pdFALSE is returned.
- *
- * \defgroup xMessageBufferSendCompletedFromISR xMessageBufferSendCompletedFromISR
- * \ingroup StreamBufferManagement
- */
-#define xMessageBufferSendCompletedFromISR( xMessageBuffer, pxHigherPriorityTaskWoken ) xStreamBufferSendCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )
-
-/**
- * message_buffer.h
- *
-<pre>
-BaseType_t xMessageBufferReceiveCompletedFromISR( MessageBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
-</pre>
- *
- * For advanced users only.
- *
- * The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when
- * data is read out of a message buffer or stream buffer.  If there was a task
- * that was blocked on the message or stream buffer waiting for data to arrive
- * then the sbRECEIVE_COMPLETED() macro sends a notification to the task to
- * remove it from the Blocked state.  xMessageBufferReceiveCompletedFromISR()
- * does the same thing.  It is provided to enable application writers to
- * implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT
- * ANY OTHER TIME.
- *
- * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
- * additional information.
- *
- * @param xStreamBuffer The handle of the stream buffer from which data was
- * read.
- *
- * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
- * initialised to pdFALSE before it is passed into
- * xMessageBufferReceiveCompletedFromISR().  If calling
- * xMessageBufferReceiveCompletedFromISR() removes a task from the Blocked state,
- * and the task has a priority above the priority of the currently running task,
- * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
- * context switch should be performed before exiting the ISR.
- *
- * @return If a task was removed from the Blocked state then pdTRUE is returned.
- * Otherwise pdFALSE is returned.
- *
- * \defgroup xMessageBufferReceiveCompletedFromISR xMessageBufferReceiveCompletedFromISR
- * \ingroup StreamBufferManagement
- */
-#define xMessageBufferReceiveCompletedFromISR( xMessageBuffer, pxHigherPriorityTaskWoken ) xStreamBufferReceiveCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )
-
-#if defined( __cplusplus )
-} /* extern "C" */
-#endif
-
-#endif	/* !defined( FREERTOS_MESSAGE_BUFFER_H ) */
diff --git a/osal/inc/freertos/mpu_prototypes.h b/osal/inc/freertos/mpu_prototypes.h
deleted file mode 100644
index a21b7a6..0000000
--- a/osal/inc/freertos/mpu_prototypes.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * When the MPU is used the standard (non MPU) API functions are mapped to
- * equivalents that start "MPU_", the prototypes for which are defined in this
- * header files.  This will cause the application code to call the MPU_ version
- * which wraps the non-MPU version with privilege promoting then demoting code,
- * so the kernel code always runs will full privileges.
- */
-
-
-#ifndef MPU_PROTOTYPES_H
-#define MPU_PROTOTYPES_H
-
-/* MPU versions of tasks.h API functions. */
-BaseType_t MPU_xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask ) FREERTOS_SYSTEM_CALL;
-TaskHandle_t MPU_xTaskCreateStatic( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskDelete( TaskHandle_t xTaskToDelete ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskDelay( const TickType_t xTicksToDelay ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskAbortDelay( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;
-eTaskState MPU_eTaskGetState( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskSuspend( TaskHandle_t xTaskToSuspend ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskResume( TaskHandle_t xTaskToResume ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskStartScheduler( void ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskSuspendAll( void ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskResumeAll( void ) FREERTOS_SYSTEM_CALL;
-TickType_t MPU_xTaskGetTickCount( void ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxTaskGetNumberOfTasks( void ) FREERTOS_SYSTEM_CALL;
-char * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery ) FREERTOS_SYSTEM_CALL;
-TaskHandle_t MPU_xTaskGetHandle( const char *pcNameToQuery ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;
-configSTACK_DEPTH_TYPE MPU_uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) FREERTOS_SYSTEM_CALL;
-TaskHookFunction_t MPU_xTaskGetApplicationTaskTag( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) FREERTOS_SYSTEM_CALL;
-void * MPU_pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) FREERTOS_SYSTEM_CALL;
-TaskHandle_t MPU_xTaskGetIdleTaskHandle( void ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) FREERTOS_SYSTEM_CALL;
-uint32_t MPU_ulTaskGetIdleRunTimeCounter( void ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskList( char * pcWriteBuffer ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskGetRunTimeStats( char *pcWriteBuffer ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-uint32_t MPU_ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskNotifyStateClear( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;
-uint32_t MPU_ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskIncrementTick( void ) FREERTOS_SYSTEM_CALL;
-TaskHandle_t MPU_xTaskGetCurrentTaskHandle( void ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) FREERTOS_SYSTEM_CALL;
-void MPU_vTaskMissedYield( void ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskGetSchedulerState( void ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) FREERTOS_SYSTEM_CALL;
-
-/* MPU versions of queue.h API functions. */
-BaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxQueueMessagesWaiting( const QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxQueueSpacesAvailable( const QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;
-void MPU_vQueueDelete( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;
-QueueHandle_t MPU_xQueueCreateMutex( const uint8_t ucQueueType ) FREERTOS_SYSTEM_CALL;
-QueueHandle_t MPU_xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) FREERTOS_SYSTEM_CALL;
-QueueHandle_t MPU_xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) FREERTOS_SYSTEM_CALL;
-QueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) FREERTOS_SYSTEM_CALL;
-TaskHandle_t MPU_xQueueGetMutexHolder( QueueHandle_t xSemaphore ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) FREERTOS_SYSTEM_CALL;
-void MPU_vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) FREERTOS_SYSTEM_CALL;
-void MPU_vQueueUnregisterQueue( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;
-const char * MPU_pcQueueGetName( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;
-QueueHandle_t MPU_xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) FREERTOS_SYSTEM_CALL;
-QueueHandle_t MPU_xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) FREERTOS_SYSTEM_CALL;
-QueueSetHandle_t MPU_xQueueCreateSet( const UBaseType_t uxEventQueueLength ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) FREERTOS_SYSTEM_CALL;
-QueueSetMemberHandle_t MPU_xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) FREERTOS_SYSTEM_CALL;
-void MPU_vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxQueueGetQueueNumber( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;
-uint8_t MPU_ucQueueGetQueueType( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;
-
-/* MPU versions of timers.h API functions. */
-TimerHandle_t MPU_xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) FREERTOS_SYSTEM_CALL;
-TimerHandle_t MPU_xTimerCreateStatic( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer ) FREERTOS_SYSTEM_CALL;
-void * MPU_pvTimerGetTimerID( const TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;
-void MPU_vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTimerIsTimerActive( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;
-TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle( void ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-const char * MPU_pcTimerGetName( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;
-void MPU_vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxTimerGetReloadMode( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;
-TickType_t MPU_xTimerGetPeriod( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;
-TickType_t MPU_xTimerGetExpiryTime( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTimerCreateTimerTask( void ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-
-/* MPU versions of event_group.h API functions. */
-EventGroupHandle_t MPU_xEventGroupCreate( void ) FREERTOS_SYSTEM_CALL;
-EventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) FREERTOS_SYSTEM_CALL;
-EventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-EventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) FREERTOS_SYSTEM_CALL;
-EventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) FREERTOS_SYSTEM_CALL;
-EventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-void MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup ) FREERTOS_SYSTEM_CALL;
-UBaseType_t MPU_uxEventGroupGetNumber( void* xEventGroup ) FREERTOS_SYSTEM_CALL;
-
-/* MPU versions of message/stream_buffer.h API functions. */
-size_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-size_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;
-size_t MPU_xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;
-void MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;
-size_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;
-size_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;
-BaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel ) FREERTOS_SYSTEM_CALL;
-StreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer ) FREERTOS_SYSTEM_CALL;
-StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer ) FREERTOS_SYSTEM_CALL;
-
-
-
-#endif /* MPU_PROTOTYPES_H */
-
diff --git a/osal/inc/freertos/mpu_wrappers.h b/osal/inc/freertos/mpu_wrappers.h
deleted file mode 100644
index 5f63d4f..0000000
--- a/osal/inc/freertos/mpu_wrappers.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef MPU_WRAPPERS_H
-#define MPU_WRAPPERS_H
-
-/* This file redefines API functions to be called through a wrapper macro, but
-only for ports that are using the MPU. */
-#ifdef portUSING_MPU_WRAPPERS
-
-	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
-	included from queue.c or task.c to prevent it from having an effect within
-	those files. */
-	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-		/*
-		 * Map standard (non MPU) API functions to equivalents that start
-		 * "MPU_".  This will cause the application code to call the MPU_
-		 * version, which wraps the non-MPU version with privilege promoting
-		 * then demoting code, so the kernel code always runs will full
-		 * privileges.
-		 */
-
-		/* Map standard tasks.h API functions to the MPU equivalents. */
-		#define xTaskCreate								MPU_xTaskCreate
-		#define xTaskCreateStatic						MPU_xTaskCreateStatic
-		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
-		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
-		#define vTaskDelete								MPU_vTaskDelete
-		#define vTaskDelay								MPU_vTaskDelay
-		#define vTaskDelayUntil							MPU_vTaskDelayUntil
-		#define xTaskAbortDelay							MPU_xTaskAbortDelay
-		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
-		#define eTaskGetState							MPU_eTaskGetState
-		#define vTaskGetInfo							MPU_vTaskGetInfo
-		#define vTaskPrioritySet						MPU_vTaskPrioritySet
-		#define vTaskSuspend							MPU_vTaskSuspend
-		#define vTaskResume								MPU_vTaskResume
-		#define vTaskSuspendAll							MPU_vTaskSuspendAll
-		#define xTaskResumeAll							MPU_xTaskResumeAll
-		#define xTaskGetTickCount						MPU_xTaskGetTickCount
-		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
-		#define pcTaskGetName							MPU_pcTaskGetName
-		#define xTaskGetHandle							MPU_xTaskGetHandle
-		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
-		#define uxTaskGetStackHighWaterMark2			MPU_uxTaskGetStackHighWaterMark2
-		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
-		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
-		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
-		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
-		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
-		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
-		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
-		#define vTaskList								MPU_vTaskList
-		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
-		#define ulTaskGetIdleRunTimeCounter				MPU_ulTaskGetIdleRunTimeCounter
-		#define xTaskGenericNotify						MPU_xTaskGenericNotify
-		#define xTaskNotifyWait							MPU_xTaskNotifyWait
-		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
-		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
-		#define ulTaskNotifyValueClear					MPU_ulTaskNotifyValueClear
-		#define xTaskCatchUpTicks						MPU_xTaskCatchUpTicks
-
-		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
-		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
-		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
-		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
-
-		/* Map standard queue.h API functions to the MPU equivalents. */
-		#define xQueueGenericSend						MPU_xQueueGenericSend
-		#define xQueueReceive							MPU_xQueueReceive
-		#define xQueuePeek								MPU_xQueuePeek
-		#define xQueueSemaphoreTake						MPU_xQueueSemaphoreTake
-		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
-		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
-		#define vQueueDelete							MPU_vQueueDelete
-		#define xQueueCreateMutex						MPU_xQueueCreateMutex
-		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
-		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
-		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
-		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
-		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
-		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
-		#define xQueueGenericCreate						MPU_xQueueGenericCreate
-		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
-		#define xQueueCreateSet							MPU_xQueueCreateSet
-		#define xQueueAddToSet							MPU_xQueueAddToSet
-		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
-		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
-		#define xQueueGenericReset						MPU_xQueueGenericReset
-
-		#if( configQUEUE_REGISTRY_SIZE > 0 )
-			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
-			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
-			#define pcQueueGetName							MPU_pcQueueGetName
-		#endif
-
-		/* Map standard timer.h API functions to the MPU equivalents. */
-		#define xTimerCreate							MPU_xTimerCreate
-		#define xTimerCreateStatic						MPU_xTimerCreateStatic
-		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
-		#define vTimerSetTimerID						MPU_vTimerSetTimerID
-		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
-		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
-		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
-		#define pcTimerGetName							MPU_pcTimerGetName
-		#define vTimerSetReloadMode						MPU_vTimerSetReloadMode
-		#define uxTimerGetReloadMode					MPU_uxTimerGetReloadMode
-		#define xTimerGetPeriod							MPU_xTimerGetPeriod
-		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
-		#define xTimerGenericCommand					MPU_xTimerGenericCommand
-
-		/* Map standard event_group.h API functions to the MPU equivalents. */
-		#define xEventGroupCreate						MPU_xEventGroupCreate
-		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
-		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
-		#define xEventGroupClearBits					MPU_xEventGroupClearBits
-		#define xEventGroupSetBits						MPU_xEventGroupSetBits
-		#define xEventGroupSync							MPU_xEventGroupSync
-		#define vEventGroupDelete						MPU_vEventGroupDelete
-
-		/* Map standard message/stream_buffer.h API functions to the MPU
-		equivalents. */
-		#define xStreamBufferSend						MPU_xStreamBufferSend
-		#define xStreamBufferReceive					MPU_xStreamBufferReceive
-		#define xStreamBufferNextMessageLengthBytes		MPU_xStreamBufferNextMessageLengthBytes
-		#define vStreamBufferDelete						MPU_vStreamBufferDelete
-		#define xStreamBufferIsFull						MPU_xStreamBufferIsFull
-		#define xStreamBufferIsEmpty					MPU_xStreamBufferIsEmpty
-		#define xStreamBufferReset						MPU_xStreamBufferReset
-		#define xStreamBufferSpacesAvailable			MPU_xStreamBufferSpacesAvailable
-		#define xStreamBufferBytesAvailable				MPU_xStreamBufferBytesAvailable
-		#define xStreamBufferSetTriggerLevel			MPU_xStreamBufferSetTriggerLevel
-		#define xStreamBufferGenericCreate				MPU_xStreamBufferGenericCreate
-		#define xStreamBufferGenericCreateStatic		MPU_xStreamBufferGenericCreateStatic
-
-
-		/* Remove the privileged function macro, but keep the PRIVILEGED_DATA
-		macro so applications can place data in privileged access sections
-		(useful when using statically allocated objects). */
-		#define PRIVILEGED_FUNCTION
-		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
-		#define FREERTOS_SYSTEM_CALL
-
-	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
-
-		/* Ensure API functions go in the privileged execution section. */
-		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
-		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
-		#define FREERTOS_SYSTEM_CALL __attribute__((section( "freertos_system_calls")))
-
-	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
-
-#else /* portUSING_MPU_WRAPPERS */
-
-	#define PRIVILEGED_FUNCTION
-	#define PRIVILEGED_DATA
-	#define FREERTOS_SYSTEM_CALL
-	#define portUSING_MPU_WRAPPERS 0
-
-#endif /* portUSING_MPU_WRAPPERS */
-
-
-#endif /* MPU_WRAPPERS_H */
-
diff --git a/osal/inc/freertos/portable.h b/osal/inc/freertos/portable.h
deleted file mode 100644
index a2099c3..0000000
--- a/osal/inc/freertos/portable.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Portable layer API.  Each function must be defined for each port.
- *----------------------------------------------------------*/
-
-#ifndef PORTABLE_H
-#define PORTABLE_H
-
-/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
-pre-processor definition was used to ensure the pre-processor found the correct
-portmacro.h file for the port being used.  That scheme was deprecated in favour
-of setting the compiler's include path such that it found the correct
-portmacro.h file - removing the need for the constant and allowing the
-portmacro.h file to be located anywhere in relation to the port being used.
-Purely for reasons of backward compatibility the old method is still valid, but
-to make it clear that new projects should not use it, support for the port
-specific constants has been moved into the deprecated_definitions.h header
-file. */
-#include "deprecated_definitions.h"
-
-/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
-did not result in a portmacro.h header file being included - and it should be
-included here.  In this case the path to the correct portmacro.h header file
-must be set in the compiler's include path. */
-#ifndef portENTER_CRITICAL
-	#include "portmacro.h"
-#endif
-
-#if portBYTE_ALIGNMENT == 32
-	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
-#endif
-
-#if portBYTE_ALIGNMENT == 16
-	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
-#endif
-
-#if portBYTE_ALIGNMENT == 8
-	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
-#endif
-
-#if portBYTE_ALIGNMENT == 4
-	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
-#endif
-
-#if portBYTE_ALIGNMENT == 2
-	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
-#endif
-
-#if portBYTE_ALIGNMENT == 1
-	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
-#endif
-
-#ifndef portBYTE_ALIGNMENT_MASK
-	#error "Invalid portBYTE_ALIGNMENT definition"
-#endif
-
-#ifndef portNUM_CONFIGURABLE_REGIONS
-	#define portNUM_CONFIGURABLE_REGIONS 1
-#endif
-
-#ifndef portHAS_STACK_OVERFLOW_CHECKING
-	#define portHAS_STACK_OVERFLOW_CHECKING 0
-#endif
-
-#ifndef portARCH_NAME
-	#define portARCH_NAME NULL
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "mpu_wrappers.h"
-
-/*
- * Setup the stack of a new task so it is ready to be placed under the
- * scheduler control.  The registers have to be placed on the stack in
- * the order that the port expects to find them.
- *
- */
-#if( portUSING_MPU_WRAPPERS == 1 )
-	#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
-		StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
-	#else
-		StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
-	#endif
-#else
-	#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
-		StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
-	#else
-		StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
-	#endif
-#endif
-
-/* Used by heap_5.c to define the start address and size of each memory region
-that together comprise the total FreeRTOS heap space. */
-typedef struct HeapRegion
-{
-	uint8_t *pucStartAddress;
-	size_t xSizeInBytes;
-} HeapRegion_t;
-
-/* Used to pass information about the heap out of vPortGetHeapStats(). */
-typedef struct xHeapStats
-{
-	size_t xAvailableHeapSpaceInBytes;		/* The total heap size currently available - this is the sum of all the free blocks, not the largest block that can be allocated. */
-	size_t xSizeOfLargestFreeBlockInBytes; 	/* The maximum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. */
-	size_t xSizeOfSmallestFreeBlockInBytes; /* The minimum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. */
-	size_t xNumberOfFreeBlocks;				/* The number of free memory blocks within the heap at the time vPortGetHeapStats() is called. */
-	size_t xMinimumEverFreeBytesRemaining;	/* The minimum amount of total free memory (sum of all free blocks) there has been in the heap since the system booted. */
-	size_t xNumberOfSuccessfulAllocations;	/* The number of calls to pvPortMalloc() that have returned a valid memory block. */
-	size_t xNumberOfSuccessfulFrees;		/* The number of calls to vPortFree() that has successfully freed a block of memory. */
-} HeapStats_t;
-
-/*
- * Used to define multiple heap regions for use by heap_5.c.  This function
- * must be called before any calls to pvPortMalloc() - not creating a task,
- * queue, semaphore, mutex, software timer, event group, etc. will result in
- * pvPortMalloc being called.
- *
- * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
- * defines a region of memory that can be used as the heap.  The array is
- * terminated by a HeapRegions_t structure that has a size of 0.  The region
- * with the lowest start address must appear first in the array.
- */
-void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
-
-/*
- * Returns a HeapStats_t structure filled with information about the current
- * heap state.
- */
-void vPortGetHeapStats( HeapStats_t *pxHeapStats );
-
-/*
- * Map to the memory management routines required for the port.
- */
-void *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
-void vPortFree( void *pv ) PRIVILEGED_FUNCTION;
-void vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
-size_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
-size_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Setup the hardware ready for the scheduler to take control.  This generally
- * sets up a tick interrupt and sets timers for the correct tick frequency.
- */
-BaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
- * the hardware is left in its original condition after the scheduler stops
- * executing.
- */
-void vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * The structures and methods of manipulating the MPU are contained within the
- * port layer.
- *
- * Fills the xMPUSettings structure with the memory region information
- * contained in xRegions.
- */
-#if( portUSING_MPU_WRAPPERS == 1 )
-	struct xMEMORY_REGION;
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTABLE_H */
-
diff --git a/osal/inc/freertos/projdefs.h b/osal/inc/freertos/projdefs.h
deleted file mode 100644
index 0d95130..0000000
--- a/osal/inc/freertos/projdefs.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PROJDEFS_H
-#define PROJDEFS_H
-
-/*
- * Defines the prototype to which task functions must conform.  Defined in this
- * file to ensure the type is known before portable.h is included.
- */
-typedef void (*TaskFunction_t)( void * );
-
-/* Converts a time in milliseconds to a time in ticks.  This macro can be
-overridden by a macro of the same name defined in FreeRTOSConfig.h in case the
-definition here is not suitable for your application. */
-#ifndef pdMS_TO_TICKS
-	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
-#endif
-
-#define pdFALSE			( ( BaseType_t ) 0 )
-#define pdTRUE			( ( BaseType_t ) 1 )
-
-#define pdPASS			( pdTRUE )
-#define pdFAIL			( pdFALSE )
-#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
-#define errQUEUE_FULL	( ( BaseType_t ) 0 )
-
-/* FreeRTOS error definitions. */
-#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
-#define errQUEUE_BLOCKED						( -4 )
-#define errQUEUE_YIELD							( -5 )
-
-/* Macros used for basic data corruption checks. */
-#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
-	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
-#endif
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
-#else
-	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
-#endif
-
-/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
-itself. */
-#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
-#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
-#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
-#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
-#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
-#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
-#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
-#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
-#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
-#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
-#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
-#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
-#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
-#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
-#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
-#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
-#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
-#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
-#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
-#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
-#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
-#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
-#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
-#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
-#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
-#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
-#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
-#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
-#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
-#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
-#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
-#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
-#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
-#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
-#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
-#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
-#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
-#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
-#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
-#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
-
-/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
-itself. */
-#define pdFREERTOS_LITTLE_ENDIAN		0
-#define pdFREERTOS_BIG_ENDIAN			1
-
-/* Re-defining endian values for generic naming. */
-#define pdLITTLE_ENDIAN					pdFREERTOS_LITTLE_ENDIAN
-#define pdBIG_ENDIAN					pdFREERTOS_BIG_ENDIAN
-
-
-#endif /* PROJDEFS_H */
-
-
-
diff --git a/osal/inc/freertos/queue.h b/osal/inc/freertos/queue.h
deleted file mode 100644
index 52ccca5..0000000
--- a/osal/inc/freertos/queue.h
+++ /dev/null
@@ -1,1655 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef QUEUE_H
-#define QUEUE_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "task.h"
-
-/**
- * Type by which queues are referenced.  For example, a call to xQueueCreate()
- * returns an QueueHandle_t variable that can then be used as a parameter to
- * xQueueSend(), xQueueReceive(), etc.
- */
-struct QueueDefinition; /* Using old naming convention so as not to break kernel aware debuggers. */
-typedef struct QueueDefinition * QueueHandle_t;
-
-/**
- * Type by which queue sets are referenced.  For example, a call to
- * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
- * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
- */
-typedef struct QueueDefinition * QueueSetHandle_t;
-
-/**
- * Queue sets can contain both queues and semaphores, so the
- * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
- * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
- */
-typedef struct QueueDefinition * QueueSetMemberHandle_t;
-
-/* For internal use only. */
-#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
-#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
-#define queueOVERWRITE			( ( BaseType_t ) 2 )
-
-/* For internal use only.  These definitions *must* match those in queue.c. */
-#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
-#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
-#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
-#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
-#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
-#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
-
-/**
- * queue. h
- * <pre>
- QueueHandle_t xQueueCreate(
-							  UBaseType_t uxQueueLength,
-							  UBaseType_t uxItemSize
-						  );
- * </pre>
- *
- * Creates a new queue instance, and returns a handle by which the new queue
- * can be referenced.
- *
- * Internally, within the FreeRTOS implementation, queues use two blocks of
- * memory.  The first block is used to hold the queue's data structures.  The
- * second block is used to hold items placed into the queue.  If a queue is
- * created using xQueueCreate() then both blocks of memory are automatically
- * dynamically allocated inside the xQueueCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a queue is created using
- * xQueueCreateStatic() then the application writer must provide the memory that
- * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
- * be created without using any dynamic memory allocation.
- *
- * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
- *
- * @param uxQueueLength The maximum number of items that the queue can contain.
- *
- * @param uxItemSize The number of bytes each item in the queue will require.
- * Items are queued by copy, not by reference, so this is the number of bytes
- * that will be copied for each posted item.  Each item on the queue must be
- * the same size.
- *
- * @return If the queue is successfully create then a handle to the newly
- * created queue is returned.  If the queue cannot be created then 0 is
- * returned.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- };
-
- void vATask( void *pvParameters )
- {
- QueueHandle_t xQueue1, xQueue2;
-
-	// Create a queue capable of containing 10 uint32_t values.
-	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
-	if( xQueue1 == 0 )
-	{
-		// Queue was not created and must not be used.
-	}
-
-	// Create a queue capable of containing 10 pointers to AMessage structures.
-	// These should be passed by pointer as they contain a lot of data.
-	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
-	if( xQueue2 == 0 )
-	{
-		// Queue was not created and must not be used.
-	}
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueueCreate xQueueCreate
- * \ingroup QueueManagement
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
-#endif
-
-/**
- * queue. h
- * <pre>
- QueueHandle_t xQueueCreateStatic(
-							  UBaseType_t uxQueueLength,
-							  UBaseType_t uxItemSize,
-							  uint8_t *pucQueueStorageBuffer,
-							  StaticQueue_t *pxQueueBuffer
-						  );
- * </pre>
- *
- * Creates a new queue instance, and returns a handle by which the new queue
- * can be referenced.
- *
- * Internally, within the FreeRTOS implementation, queues use two blocks of
- * memory.  The first block is used to hold the queue's data structures.  The
- * second block is used to hold items placed into the queue.  If a queue is
- * created using xQueueCreate() then both blocks of memory are automatically
- * dynamically allocated inside the xQueueCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a queue is created using
- * xQueueCreateStatic() then the application writer must provide the memory that
- * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
- * be created without using any dynamic memory allocation.
- *
- * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
- *
- * @param uxQueueLength The maximum number of items that the queue can contain.
- *
- * @param uxItemSize The number of bytes each item in the queue will require.
- * Items are queued by copy, not by reference, so this is the number of bytes
- * that will be copied for each posted item.  Each item on the queue must be
- * the same size.
- *
- * @param pucQueueStorageBuffer If uxItemSize is not zero then
- * pucQueueStorageBuffer must point to a uint8_t array that is at least large
- * enough to hold the maximum number of items that can be in the queue at any
- * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
- * zero then pucQueueStorageBuffer can be NULL.
- *
- * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
- * will be used to hold the queue's data structure.
- *
- * @return If the queue is created then a handle to the created queue is
- * returned.  If pxQueueBuffer is NULL then NULL is returned.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- };
-
- #define QUEUE_LENGTH 10
- #define ITEM_SIZE sizeof( uint32_t )
-
- // xQueueBuffer will hold the queue structure.
- StaticQueue_t xQueueBuffer;
-
- // ucQueueStorage will hold the items posted to the queue.  Must be at least
- // [(queue length) * ( queue item size)] bytes long.
- uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
-
- void vATask( void *pvParameters )
- {
- QueueHandle_t xQueue1;
-
-	// Create a queue capable of containing 10 uint32_t values.
-	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
-							ITEM_SIZE	  // The size of each item in the queue
-							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
-							&xQueueBuffer ); // The buffer that will hold the queue structure.
-
-	// The queue is guaranteed to be created successfully as no dynamic memory
-	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueueCreateStatic xQueueCreateStatic
- * \ingroup QueueManagement
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueSendToToFront(
-								   QueueHandle_t	xQueue,
-								   const void		*pvItemToQueue,
-								   TickType_t		xTicksToWait
-							   );
- * </pre>
- *
- * Post an item to the front of a queue.  The item is queued by copy, not by
- * reference.  This function must not be called from an interrupt service
- * routine.  See xQueueSendFromISR () for an alternative which may be used
- * in an ISR.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param xTicksToWait The maximum amount of time the task should block
- * waiting for space to become available on the queue, should it already
- * be full.  The call will return immediately if this is set to 0 and the
- * queue is full.  The time is defined in tick periods so the constant
- * portTICK_PERIOD_MS should be used to convert to real time if this is required.
- *
- * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- } xMessage;
-
- uint32_t ulVar = 10UL;
-
- void vATask( void *pvParameters )
- {
- QueueHandle_t xQueue1, xQueue2;
- struct AMessage *pxMessage;
-
-	// Create a queue capable of containing 10 uint32_t values.
-	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
-
-	// Create a queue capable of containing 10 pointers to AMessage structures.
-	// These should be passed by pointer as they contain a lot of data.
-	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
-
-	// ...
-
-	if( xQueue1 != 0 )
-	{
-		// Send an uint32_t.  Wait for 10 ticks for space to become
-		// available if necessary.
-		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
-		{
-			// Failed to post the message, even after 10 ticks.
-		}
-	}
-
-	if( xQueue2 != 0 )
-	{
-		// Send a pointer to a struct AMessage object.  Don't block if the
-		// queue is already full.
-		pxMessage = & xMessage;
-		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
-	}
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueueSend xQueueSend
- * \ingroup QueueManagement
- */
-#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueSendToBack(
-								   QueueHandle_t	xQueue,
-								   const void		*pvItemToQueue,
-								   TickType_t		xTicksToWait
-							   );
- * </pre>
- *
- * This is a macro that calls xQueueGenericSend().
- *
- * Post an item to the back of a queue.  The item is queued by copy, not by
- * reference.  This function must not be called from an interrupt service
- * routine.  See xQueueSendFromISR () for an alternative which may be used
- * in an ISR.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param xTicksToWait The maximum amount of time the task should block
- * waiting for space to become available on the queue, should it already
- * be full.  The call will return immediately if this is set to 0 and the queue
- * is full.  The  time is defined in tick periods so the constant
- * portTICK_PERIOD_MS should be used to convert to real time if this is required.
- *
- * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- } xMessage;
-
- uint32_t ulVar = 10UL;
-
- void vATask( void *pvParameters )
- {
- QueueHandle_t xQueue1, xQueue2;
- struct AMessage *pxMessage;
-
-	// Create a queue capable of containing 10 uint32_t values.
-	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
-
-	// Create a queue capable of containing 10 pointers to AMessage structures.
-	// These should be passed by pointer as they contain a lot of data.
-	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
-
-	// ...
-
-	if( xQueue1 != 0 )
-	{
-		// Send an uint32_t.  Wait for 10 ticks for space to become
-		// available if necessary.
-		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
-		{
-			// Failed to post the message, even after 10 ticks.
-		}
-	}
-
-	if( xQueue2 != 0 )
-	{
-		// Send a pointer to a struct AMessage object.  Don't block if the
-		// queue is already full.
-		pxMessage = & xMessage;
-		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
-	}
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueueSend xQueueSend
- * \ingroup QueueManagement
- */
-#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueSend(
-							  QueueHandle_t xQueue,
-							  const void * pvItemToQueue,
-							  TickType_t xTicksToWait
-						 );
- * </pre>
- *
- * This is a macro that calls xQueueGenericSend().  It is included for
- * backward compatibility with versions of FreeRTOS.org that did not
- * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
- * equivalent to xQueueSendToBack().
- *
- * Post an item on a queue.  The item is queued by copy, not by reference.
- * This function must not be called from an interrupt service routine.
- * See xQueueSendFromISR () for an alternative which may be used in an ISR.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param xTicksToWait The maximum amount of time the task should block
- * waiting for space to become available on the queue, should it already
- * be full.  The call will return immediately if this is set to 0 and the
- * queue is full.  The time is defined in tick periods so the constant
- * portTICK_PERIOD_MS should be used to convert to real time if this is required.
- *
- * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- } xMessage;
-
- uint32_t ulVar = 10UL;
-
- void vATask( void *pvParameters )
- {
- QueueHandle_t xQueue1, xQueue2;
- struct AMessage *pxMessage;
-
-	// Create a queue capable of containing 10 uint32_t values.
-	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
-
-	// Create a queue capable of containing 10 pointers to AMessage structures.
-	// These should be passed by pointer as they contain a lot of data.
-	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
-
-	// ...
-
-	if( xQueue1 != 0 )
-	{
-		// Send an uint32_t.  Wait for 10 ticks for space to become
-		// available if necessary.
-		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
-		{
-			// Failed to post the message, even after 10 ticks.
-		}
-	}
-
-	if( xQueue2 != 0 )
-	{
-		// Send a pointer to a struct AMessage object.  Don't block if the
-		// queue is already full.
-		pxMessage = & xMessage;
-		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
-	}
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueueSend xQueueSend
- * \ingroup QueueManagement
- */
-#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueOverwrite(
-							  QueueHandle_t xQueue,
-							  const void * pvItemToQueue
-						 );
- * </pre>
- *
- * Only for use with queues that have a length of one - so the queue is either
- * empty or full.
- *
- * Post an item on a queue.  If the queue is already full then overwrite the
- * value held in the queue.  The item is queued by copy, not by reference.
- *
- * This function must not be called from an interrupt service routine.
- * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
- *
- * @param xQueue The handle of the queue to which the data is being sent.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
- * therefore has the same return values as xQueueSendToFront().  However, pdPASS
- * is the only value that can be returned because xQueueOverwrite() will write
- * to the queue even when the queue is already full.
- *
- * Example usage:
-   <pre>
-
- void vFunction( void *pvParameters )
- {
- QueueHandle_t xQueue;
- uint32_t ulVarToSend, ulValReceived;
-
-	// Create a queue to hold one uint32_t value.  It is strongly
-	// recommended *not* to use xQueueOverwrite() on queues that can
-	// contain more than one value, and doing so will trigger an assertion
-	// if configASSERT() is defined.
-	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
-
-	// Write the value 10 to the queue using xQueueOverwrite().
-	ulVarToSend = 10;
-	xQueueOverwrite( xQueue, &ulVarToSend );
-
-	// Peeking the queue should now return 10, but leave the value 10 in
-	// the queue.  A block time of zero is used as it is known that the
-	// queue holds a value.
-	ulValReceived = 0;
-	xQueuePeek( xQueue, &ulValReceived, 0 );
-
-	if( ulValReceived != 10 )
-	{
-		// Error unless the item was removed by a different task.
-	}
-
-	// The queue is still full.  Use xQueueOverwrite() to overwrite the
-	// value held in the queue with 100.
-	ulVarToSend = 100;
-	xQueueOverwrite( xQueue, &ulVarToSend );
-
-	// This time read from the queue, leaving the queue empty once more.
-	// A block time of 0 is used again.
-	xQueueReceive( xQueue, &ulValReceived, 0 );
-
-	// The value read should be the last value written, even though the
-	// queue was already full when the value was written.
-	if( ulValReceived != 100 )
-	{
-		// Error!
-	}
-
-	// ...
-}
- </pre>
- * \defgroup xQueueOverwrite xQueueOverwrite
- * \ingroup QueueManagement
- */
-#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
-
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueGenericSend(
-									QueueHandle_t xQueue,
-									const void * pvItemToQueue,
-									TickType_t xTicksToWait
-									BaseType_t xCopyPosition
-								);
- * </pre>
- *
- * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
- * xQueueSendToBack() are used in place of calling this function directly.
- *
- * Post an item on a queue.  The item is queued by copy, not by reference.
- * This function must not be called from an interrupt service routine.
- * See xQueueSendFromISR () for an alternative which may be used in an ISR.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param xTicksToWait The maximum amount of time the task should block
- * waiting for space to become available on the queue, should it already
- * be full.  The call will return immediately if this is set to 0 and the
- * queue is full.  The time is defined in tick periods so the constant
- * portTICK_PERIOD_MS should be used to convert to real time if this is required.
- *
- * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
- * item at the back of the queue, or queueSEND_TO_FRONT to place the item
- * at the front of the queue (for high priority messages).
- *
- * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- } xMessage;
-
- uint32_t ulVar = 10UL;
-
- void vATask( void *pvParameters )
- {
- QueueHandle_t xQueue1, xQueue2;
- struct AMessage *pxMessage;
-
-	// Create a queue capable of containing 10 uint32_t values.
-	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
-
-	// Create a queue capable of containing 10 pointers to AMessage structures.
-	// These should be passed by pointer as they contain a lot of data.
-	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
-
-	// ...
-
-	if( xQueue1 != 0 )
-	{
-		// Send an uint32_t.  Wait for 10 ticks for space to become
-		// available if necessary.
-		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
-		{
-			// Failed to post the message, even after 10 ticks.
-		}
-	}
-
-	if( xQueue2 != 0 )
-	{
-		// Send a pointer to a struct AMessage object.  Don't block if the
-		// queue is already full.
-		pxMessage = & xMessage;
-		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
-	}
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueueSend xQueueSend
- * \ingroup QueueManagement
- */
-BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueuePeek(
-							 QueueHandle_t xQueue,
-							 void * const pvBuffer,
-							 TickType_t xTicksToWait
-						 );</pre>
- *
- * Receive an item from a queue without removing the item from the queue.
- * The item is received by copy so a buffer of adequate size must be
- * provided.  The number of bytes copied into the buffer was defined when
- * the queue was created.
- *
- * Successfully received items remain on the queue so will be returned again
- * by the next call, or a call to xQueueReceive().
- *
- * This macro must not be used in an interrupt service routine.  See
- * xQueuePeekFromISR() for an alternative that can be called from an interrupt
- * service routine.
- *
- * @param xQueue The handle to the queue from which the item is to be
- * received.
- *
- * @param pvBuffer Pointer to the buffer into which the received item will
- * be copied.
- *
- * @param xTicksToWait The maximum amount of time the task should block
- * waiting for an item to receive should the queue be empty at the time
- * of the call.	 The time is defined in tick periods so the constant
- * portTICK_PERIOD_MS should be used to convert to real time if this is required.
- * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
- * is empty.
- *
- * @return pdTRUE if an item was successfully received from the queue,
- * otherwise pdFALSE.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- } xMessage;
-
- QueueHandle_t xQueue;
-
- // Task to create a queue and post a value.
- void vATask( void *pvParameters )
- {
- struct AMessage *pxMessage;
-
-	// Create a queue capable of containing 10 pointers to AMessage structures.
-	// These should be passed by pointer as they contain a lot of data.
-	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
-	if( xQueue == 0 )
-	{
-		// Failed to create the queue.
-	}
-
-	// ...
-
-	// Send a pointer to a struct AMessage object.  Don't block if the
-	// queue is already full.
-	pxMessage = & xMessage;
-	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
-
-	// ... Rest of task code.
- }
-
- // Task to peek the data from the queue.
- void vADifferentTask( void *pvParameters )
- {
- struct AMessage *pxRxedMessage;
-
-	if( xQueue != 0 )
-	{
-		// Peek a message on the created queue.  Block for 10 ticks if a
-		// message is not immediately available.
-		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
-		{
-			// pcRxedMessage now points to the struct AMessage variable posted
-			// by vATask, but the item still remains on the queue.
-		}
-	}
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueuePeek xQueuePeek
- * \ingroup QueueManagement
- */
-BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueuePeekFromISR(
-									QueueHandle_t xQueue,
-									void *pvBuffer,
-								);</pre>
- *
- * A version of xQueuePeek() that can be called from an interrupt service
- * routine (ISR).
- *
- * Receive an item from a queue without removing the item from the queue.
- * The item is received by copy so a buffer of adequate size must be
- * provided.  The number of bytes copied into the buffer was defined when
- * the queue was created.
- *
- * Successfully received items remain on the queue so will be returned again
- * by the next call, or a call to xQueueReceive().
- *
- * @param xQueue The handle to the queue from which the item is to be
- * received.
- *
- * @param pvBuffer Pointer to the buffer into which the received item will
- * be copied.
- *
- * @return pdTRUE if an item was successfully received from the queue,
- * otherwise pdFALSE.
- *
- * \defgroup xQueuePeekFromISR xQueuePeekFromISR
- * \ingroup QueueManagement
- */
-BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueReceive(
-								 QueueHandle_t xQueue,
-								 void *pvBuffer,
-								 TickType_t xTicksToWait
-							);</pre>
- *
- * Receive an item from a queue.  The item is received by copy so a buffer of
- * adequate size must be provided.  The number of bytes copied into the buffer
- * was defined when the queue was created.
- *
- * Successfully received items are removed from the queue.
- *
- * This function must not be used in an interrupt service routine.  See
- * xQueueReceiveFromISR for an alternative that can.
- *
- * @param xQueue The handle to the queue from which the item is to be
- * received.
- *
- * @param pvBuffer Pointer to the buffer into which the received item will
- * be copied.
- *
- * @param xTicksToWait The maximum amount of time the task should block
- * waiting for an item to receive should the queue be empty at the time
- * of the call.	 xQueueReceive() will return immediately if xTicksToWait
- * is zero and the queue is empty.  The time is defined in tick periods so the
- * constant portTICK_PERIOD_MS should be used to convert to real time if this is
- * required.
- *
- * @return pdTRUE if an item was successfully received from the queue,
- * otherwise pdFALSE.
- *
- * Example usage:
-   <pre>
- struct AMessage
- {
-	char ucMessageID;
-	char ucData[ 20 ];
- } xMessage;
-
- QueueHandle_t xQueue;
-
- // Task to create a queue and post a value.
- void vATask( void *pvParameters )
- {
- struct AMessage *pxMessage;
-
-	// Create a queue capable of containing 10 pointers to AMessage structures.
-	// These should be passed by pointer as they contain a lot of data.
-	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
-	if( xQueue == 0 )
-	{
-		// Failed to create the queue.
-	}
-
-	// ...
-
-	// Send a pointer to a struct AMessage object.  Don't block if the
-	// queue is already full.
-	pxMessage = & xMessage;
-	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
-
-	// ... Rest of task code.
- }
-
- // Task to receive from the queue.
- void vADifferentTask( void *pvParameters )
- {
- struct AMessage *pxRxedMessage;
-
-	if( xQueue != 0 )
-	{
-		// Receive a message on the created queue.  Block for 10 ticks if a
-		// message is not immediately available.
-		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
-		{
-			// pcRxedMessage now points to the struct AMessage variable posted
-			// by vATask.
-		}
-	}
-
-	// ... Rest of task code.
- }
- </pre>
- * \defgroup xQueueReceive xQueueReceive
- * \ingroup QueueManagement
- */
-BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
- *
- * Return the number of messages stored in a queue.
- *
- * @param xQueue A handle to the queue being queried.
- *
- * @return The number of messages available in the queue.
- *
- * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
- * \ingroup QueueManagement
- */
-UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
- *
- * Return the number of free spaces available in a queue.  This is equal to the
- * number of items that can be sent to the queue before the queue becomes full
- * if no items are removed.
- *
- * @param xQueue A handle to the queue being queried.
- *
- * @return The number of spaces available in the queue.
- *
- * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
- * \ingroup QueueManagement
- */
-UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
- *
- * Delete a queue - freeing all the memory allocated for storing of items
- * placed on the queue.
- *
- * @param xQueue A handle to the queue to be deleted.
- *
- * \defgroup vQueueDelete vQueueDelete
- * \ingroup QueueManagement
- */
-void vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueSendToFrontFromISR(
-										 QueueHandle_t xQueue,
-										 const void *pvItemToQueue,
-										 BaseType_t *pxHigherPriorityTaskWoken
-									  );
- </pre>
- *
- * This is a macro that calls xQueueGenericSendFromISR().
- *
- * Post an item to the front of a queue.  It is safe to use this macro from
- * within an interrupt service routine.
- *
- * Items are queued by copy not reference so it is preferable to only
- * queue small items, especially when called from an ISR.  In most cases
- * it would be preferable to store a pointer to the item being queued.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
- * to unblock, and the unblocked task has a priority higher than the currently
- * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
- * a context switch should be requested before the interrupt is exited.
- *
- * @return pdTRUE if the data was successfully sent to the queue, otherwise
- * errQUEUE_FULL.
- *
- * Example usage for buffered IO (where the ISR can obtain more than one value
- * per call):
-   <pre>
- void vBufferISR( void )
- {
- char cIn;
- BaseType_t xHigherPrioritTaskWoken;
-
-	// We have not woken a task at the start of the ISR.
-	xHigherPriorityTaskWoken = pdFALSE;
-
-	// Loop until the buffer is empty.
-	do
-	{
-		// Obtain a byte from the buffer.
-		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
-
-		// Post the byte.
-		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
-
-	} while( portINPUT_BYTE( BUFFER_COUNT ) );
-
-	// Now the buffer is empty we can switch context if necessary.
-	if( xHigherPriorityTaskWoken )
-	{
-		taskYIELD ();
-	}
- }
- </pre>
- *
- * \defgroup xQueueSendFromISR xQueueSendFromISR
- * \ingroup QueueManagement
- */
-#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
-
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueSendToBackFromISR(
-										 QueueHandle_t xQueue,
-										 const void *pvItemToQueue,
-										 BaseType_t *pxHigherPriorityTaskWoken
-									  );
- </pre>
- *
- * This is a macro that calls xQueueGenericSendFromISR().
- *
- * Post an item to the back of a queue.  It is safe to use this macro from
- * within an interrupt service routine.
- *
- * Items are queued by copy not reference so it is preferable to only
- * queue small items, especially when called from an ISR.  In most cases
- * it would be preferable to store a pointer to the item being queued.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
- * to unblock, and the unblocked task has a priority higher than the currently
- * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
- * a context switch should be requested before the interrupt is exited.
- *
- * @return pdTRUE if the data was successfully sent to the queue, otherwise
- * errQUEUE_FULL.
- *
- * Example usage for buffered IO (where the ISR can obtain more than one value
- * per call):
-   <pre>
- void vBufferISR( void )
- {
- char cIn;
- BaseType_t xHigherPriorityTaskWoken;
-
-	// We have not woken a task at the start of the ISR.
-	xHigherPriorityTaskWoken = pdFALSE;
-
-	// Loop until the buffer is empty.
-	do
-	{
-		// Obtain a byte from the buffer.
-		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
-
-		// Post the byte.
-		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
-
-	} while( portINPUT_BYTE( BUFFER_COUNT ) );
-
-	// Now the buffer is empty we can switch context if necessary.
-	if( xHigherPriorityTaskWoken )
-	{
-		taskYIELD ();
-	}
- }
- </pre>
- *
- * \defgroup xQueueSendFromISR xQueueSendFromISR
- * \ingroup QueueManagement
- */
-#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueOverwriteFromISR(
-							  QueueHandle_t xQueue,
-							  const void * pvItemToQueue,
-							  BaseType_t *pxHigherPriorityTaskWoken
-						 );
- * </pre>
- *
- * A version of xQueueOverwrite() that can be used in an interrupt service
- * routine (ISR).
- *
- * Only for use with queues that can hold a single item - so the queue is either
- * empty or full.
- *
- * Post an item on a queue.  If the queue is already full then overwrite the
- * value held in the queue.  The item is queued by copy, not by reference.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
- * to unblock, and the unblocked task has a priority higher than the currently
- * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
- * a context switch should be requested before the interrupt is exited.
- *
- * @return xQueueOverwriteFromISR() is a macro that calls
- * xQueueGenericSendFromISR(), and therefore has the same return values as
- * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
- * returned because xQueueOverwriteFromISR() will write to the queue even when
- * the queue is already full.
- *
- * Example usage:
-   <pre>
-
- QueueHandle_t xQueue;
-
- void vFunction( void *pvParameters )
- {
- 	// Create a queue to hold one uint32_t value.  It is strongly
-	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
-	// contain more than one value, and doing so will trigger an assertion
-	// if configASSERT() is defined.
-	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
-}
-
-void vAnInterruptHandler( void )
-{
-// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
-BaseType_t xHigherPriorityTaskWoken = pdFALSE;
-uint32_t ulVarToSend, ulValReceived;
-
-	// Write the value 10 to the queue using xQueueOverwriteFromISR().
-	ulVarToSend = 10;
-	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
-
-	// The queue is full, but calling xQueueOverwriteFromISR() again will still
-	// pass because the value held in the queue will be overwritten with the
-	// new value.
-	ulVarToSend = 100;
-	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
-
-	// Reading from the queue will now return 100.
-
-	// ...
-
-	if( xHigherPrioritytaskWoken == pdTRUE )
-	{
-		// Writing to the queue caused a task to unblock and the unblocked task
-		// has a priority higher than or equal to the priority of the currently
-		// executing task (the task this interrupt interrupted).  Perform a context
-		// switch so this interrupt returns directly to the unblocked task.
-		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
-	}
-}
- </pre>
- * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
- * \ingroup QueueManagement
- */
-#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueSendFromISR(
-									 QueueHandle_t xQueue,
-									 const void *pvItemToQueue,
-									 BaseType_t *pxHigherPriorityTaskWoken
-								);
- </pre>
- *
- * This is a macro that calls xQueueGenericSendFromISR().  It is included
- * for backward compatibility with versions of FreeRTOS.org that did not
- * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
- * macros.
- *
- * Post an item to the back of a queue.  It is safe to use this function from
- * within an interrupt service routine.
- *
- * Items are queued by copy not reference so it is preferable to only
- * queue small items, especially when called from an ISR.  In most cases
- * it would be preferable to store a pointer to the item being queued.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
- * to unblock, and the unblocked task has a priority higher than the currently
- * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
- * a context switch should be requested before the interrupt is exited.
- *
- * @return pdTRUE if the data was successfully sent to the queue, otherwise
- * errQUEUE_FULL.
- *
- * Example usage for buffered IO (where the ISR can obtain more than one value
- * per call):
-   <pre>
- void vBufferISR( void )
- {
- char cIn;
- BaseType_t xHigherPriorityTaskWoken;
-
-	// We have not woken a task at the start of the ISR.
-	xHigherPriorityTaskWoken = pdFALSE;
-
-	// Loop until the buffer is empty.
-	do
-	{
-		// Obtain a byte from the buffer.
-		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
-
-		// Post the byte.
-		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
-
-	} while( portINPUT_BYTE( BUFFER_COUNT ) );
-
-	// Now the buffer is empty we can switch context if necessary.
-	if( xHigherPriorityTaskWoken )
-	{
-		// Actual macro used here is port specific.
-		portYIELD_FROM_ISR ();
-	}
- }
- </pre>
- *
- * \defgroup xQueueSendFromISR xQueueSendFromISR
- * \ingroup QueueManagement
- */
-#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueGenericSendFromISR(
-										   QueueHandle_t		xQueue,
-										   const	void	*pvItemToQueue,
-										   BaseType_t	*pxHigherPriorityTaskWoken,
-										   BaseType_t	xCopyPosition
-									   );
- </pre>
- *
- * It is preferred that the macros xQueueSendFromISR(),
- * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
- * of calling this function directly.  xQueueGiveFromISR() is an
- * equivalent for use by semaphores that don't actually copy any data.
- *
- * Post an item on a queue.  It is safe to use this function from within an
- * interrupt service routine.
- *
- * Items are queued by copy not reference so it is preferable to only
- * queue small items, especially when called from an ISR.  In most cases
- * it would be preferable to store a pointer to the item being queued.
- *
- * @param xQueue The handle to the queue on which the item is to be posted.
- *
- * @param pvItemToQueue A pointer to the item that is to be placed on the
- * queue.  The size of the items the queue will hold was defined when the
- * queue was created, so this many bytes will be copied from pvItemToQueue
- * into the queue storage area.
- *
- * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
- * to unblock, and the unblocked task has a priority higher than the currently
- * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
- * a context switch should be requested before the interrupt is exited.
- *
- * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
- * item at the back of the queue, or queueSEND_TO_FRONT to place the item
- * at the front of the queue (for high priority messages).
- *
- * @return pdTRUE if the data was successfully sent to the queue, otherwise
- * errQUEUE_FULL.
- *
- * Example usage for buffered IO (where the ISR can obtain more than one value
- * per call):
-   <pre>
- void vBufferISR( void )
- {
- char cIn;
- BaseType_t xHigherPriorityTaskWokenByPost;
-
-	// We have not woken a task at the start of the ISR.
-	xHigherPriorityTaskWokenByPost = pdFALSE;
-
-	// Loop until the buffer is empty.
-	do
-	{
-		// Obtain a byte from the buffer.
-		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
-
-		// Post each byte.
-		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
-
-	} while( portINPUT_BYTE( BUFFER_COUNT ) );
-
-	// Now the buffer is empty we can switch context if necessary.  Note that the
-	// name of the yield function required is port specific.
-	if( xHigherPriorityTaskWokenByPost )
-	{
-		portYIELD_FROM_ISR();
-	}
- }
- </pre>
- *
- * \defgroup xQueueSendFromISR xQueueSendFromISR
- * \ingroup QueueManagement
- */
-BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
-BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/**
- * queue. h
- * <pre>
- BaseType_t xQueueReceiveFromISR(
-									   QueueHandle_t	xQueue,
-									   void	*pvBuffer,
-									   BaseType_t *pxTaskWoken
-								   );
- * </pre>
- *
- * Receive an item from a queue.  It is safe to use this function from within an
- * interrupt service routine.
- *
- * @param xQueue The handle to the queue from which the item is to be
- * received.
- *
- * @param pvBuffer Pointer to the buffer into which the received item will
- * be copied.
- *
- * @param pxTaskWoken A task may be blocked waiting for space to become
- * available on the queue.  If xQueueReceiveFromISR causes such a task to
- * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
- * remain unchanged.
- *
- * @return pdTRUE if an item was successfully received from the queue,
- * otherwise pdFALSE.
- *
- * Example usage:
-   <pre>
-
- QueueHandle_t xQueue;
-
- // Function to create a queue and post some values.
- void vAFunction( void *pvParameters )
- {
- char cValueToPost;
- const TickType_t xTicksToWait = ( TickType_t )0xff;
-
-	// Create a queue capable of containing 10 characters.
-	xQueue = xQueueCreate( 10, sizeof( char ) );
-	if( xQueue == 0 )
-	{
-		// Failed to create the queue.
-	}
-
-	// ...
-
-	// Post some characters that will be used within an ISR.  If the queue
-	// is full then this task will block for xTicksToWait ticks.
-	cValueToPost = 'a';
-	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
-	cValueToPost = 'b';
-	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
-
-	// ... keep posting characters ... this task may block when the queue
-	// becomes full.
-
-	cValueToPost = 'c';
-	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
- }
-
- // ISR that outputs all the characters received on the queue.
- void vISR_Routine( void )
- {
- BaseType_t xTaskWokenByReceive = pdFALSE;
- char cRxedChar;
-
-	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
-	{
-		// A character was received.  Output the character now.
-		vOutputCharacter( cRxedChar );
-
-		// If removing the character from the queue woke the task that was
-		// posting onto the queue cTaskWokenByReceive will have been set to
-		// pdTRUE.  No matter how many times this loop iterates only one
-		// task will be woken.
-	}
-
-	if( cTaskWokenByPost != ( char ) pdFALSE;
-	{
-		taskYIELD ();
-	}
- }
- </pre>
- * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
- * \ingroup QueueManagement
- */
-BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/*
- * Utilities to query queues that are safe to use from an ISR.  These utilities
- * should be used only from witin an ISR, or within a critical section.
- */
-BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-
-/*
- * The functions defined above are for passing data to and from tasks.  The
- * functions below are the equivalents for passing data to and from
- * co-routines.
- *
- * These functions are called from the co-routine macro implementation and
- * should not be called directly from application code.  Instead use the macro
- * wrappers defined within croutine.h.
- */
-BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
-BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
-BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
-BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
-
-/*
- * For internal use only.  Use xSemaphoreCreateMutex(),
- * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
- * these functions directly.
- */
-QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
-QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
-QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
-QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
-BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
-TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
-
-/*
- * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
- * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
- */
-BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex ) PRIVILEGED_FUNCTION;
-
-/*
- * Reset a queue back to its original empty state.  The return value is now
- * obsolete and is always set to pdPASS.
- */
-#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
-
-/*
- * The registry is provided as a means for kernel aware debuggers to
- * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
- * a queue, semaphore or mutex handle to the registry if you want the handle
- * to be available to a kernel aware debugger.  If you are not using a kernel
- * aware debugger then this function can be ignored.
- *
- * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
- * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
- * within FreeRTOSConfig.h for the registry to be available.  Its value
- * does not effect the number of queues, semaphores and mutexes that can be
- * created - just the number that the registry can hold.
- *
- * @param xQueue The handle of the queue being added to the registry.  This
- * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
- * handles can also be passed in here.
- *
- * @param pcName The name to be associated with the handle.  This is the
- * name that the kernel aware debugger will display.  The queue registry only
- * stores a pointer to the string - so the string must be persistent (global or
- * preferably in ROM/Flash), not on the stack.
- */
-#if( configQUEUE_REGISTRY_SIZE > 0 )
-	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-#endif
-
-/*
- * The registry is provided as a means for kernel aware debuggers to
- * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
- * a queue, semaphore or mutex handle to the registry if you want the handle
- * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
- * remove the queue, semaphore or mutex from the register.  If you are not using
- * a kernel aware debugger then this function can be ignored.
- *
- * @param xQueue The handle of the queue being removed from the registry.
- */
-#if( configQUEUE_REGISTRY_SIZE > 0 )
-	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-#endif
-
-/*
- * The queue registry is provided as a means for kernel aware debuggers to
- * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
- * up and return the name of a queue in the queue registry from the queue's
- * handle.
- *
- * @param xQueue The handle of the queue the name of which will be returned.
- * @return If the queue is in the registry then a pointer to the name of the
- * queue is returned.  If the queue is not in the registry then NULL is
- * returned.
- */
-#if( configQUEUE_REGISTRY_SIZE > 0 )
-	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-#endif
-
-/*
- * Generic version of the function used to creaet a queue using dynamic memory
- * allocation.  This is called by other functions and macros that create other
- * RTOS objects that use the queue structure as their base.
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
-#endif
-
-/*
- * Generic version of the function used to creaet a queue using dynamic memory
- * allocation.  This is called by other functions and macros that create other
- * RTOS objects that use the queue structure as their base.
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
-#endif
-
-/*
- * Queue sets provide a mechanism to allow a task to block (pend) on a read
- * operation from multiple queues or semaphores simultaneously.
- *
- * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
- * function.
- *
- * A queue set must be explicitly created using a call to xQueueCreateSet()
- * before it can be used.  Once created, standard FreeRTOS queues and semaphores
- * can be added to the set using calls to xQueueAddToSet().
- * xQueueSelectFromSet() is then used to determine which, if any, of the queues
- * or semaphores contained in the set is in a state where a queue read or
- * semaphore take operation would be successful.
- *
- * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
- * for reasons why queue sets are very rarely needed in practice as there are
- * simpler methods of blocking on multiple objects.
- *
- * Note 2:  Blocking on a queue set that contains a mutex will not cause the
- * mutex holder to inherit the priority of the blocked task.
- *
- * Note 3:  An additional 4 bytes of RAM is required for each space in a every
- * queue added to a queue set.  Therefore counting semaphores that have a high
- * maximum count value should not be added to a queue set.
- *
- * Note 4:  A receive (in the case of a queue) or take (in the case of a
- * semaphore) operation must not be performed on a member of a queue set unless
- * a call to xQueueSelectFromSet() has first returned a handle to that set member.
- *
- * @param uxEventQueueLength Queue sets store events that occur on
- * the queues and semaphores contained in the set.  uxEventQueueLength specifies
- * the maximum number of events that can be queued at once.  To be absolutely
- * certain that events are not lost uxEventQueueLength should be set to the
- * total sum of the length of the queues added to the set, where binary
- * semaphores and mutexes have a length of 1, and counting semaphores have a
- * length set by their maximum count value.  Examples:
- *  + If a queue set is to hold a queue of length 5, another queue of length 12,
- *    and a binary semaphore, then uxEventQueueLength should be set to
- *    (5 + 12 + 1), or 18.
- *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
- *    should be set to (1 + 1 + 1 ), or 3.
- *  + If a queue set is to hold a counting semaphore that has a maximum count of
- *    5, and a counting semaphore that has a maximum count of 3, then
- *    uxEventQueueLength should be set to (5 + 3), or 8.
- *
- * @return If the queue set is created successfully then a handle to the created
- * queue set is returned.  Otherwise NULL is returned.
- */
-QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
-
-/*
- * Adds a queue or semaphore to a queue set that was previously created by a
- * call to xQueueCreateSet().
- *
- * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
- * function.
- *
- * Note 1:  A receive (in the case of a queue) or take (in the case of a
- * semaphore) operation must not be performed on a member of a queue set unless
- * a call to xQueueSelectFromSet() has first returned a handle to that set member.
- *
- * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
- * the queue set (cast to an QueueSetMemberHandle_t type).
- *
- * @param xQueueSet The handle of the queue set to which the queue or semaphore
- * is being added.
- *
- * @return If the queue or semaphore was successfully added to the queue set
- * then pdPASS is returned.  If the queue could not be successfully added to the
- * queue set because it is already a member of a different queue set then pdFAIL
- * is returned.
- */
-BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
-
-/*
- * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
- * be removed from a set if the queue or semaphore is empty.
- *
- * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
- * function.
- *
- * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
- * from the queue set (cast to an QueueSetMemberHandle_t type).
- *
- * @param xQueueSet The handle of the queue set in which the queue or semaphore
- * is included.
- *
- * @return If the queue or semaphore was successfully removed from the queue set
- * then pdPASS is returned.  If the queue was not in the queue set, or the
- * queue (or semaphore) was not empty, then pdFAIL is returned.
- */
-BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
-
-/*
- * xQueueSelectFromSet() selects from the members of a queue set a queue or
- * semaphore that either contains data (in the case of a queue) or is available
- * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
- * allows a task to block (pend) on a read operation on all the queues and
- * semaphores in a queue set simultaneously.
- *
- * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
- * function.
- *
- * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
- * for reasons why queue sets are very rarely needed in practice as there are
- * simpler methods of blocking on multiple objects.
- *
- * Note 2:  Blocking on a queue set that contains a mutex will not cause the
- * mutex holder to inherit the priority of the blocked task.
- *
- * Note 3:  A receive (in the case of a queue) or take (in the case of a
- * semaphore) operation must not be performed on a member of a queue set unless
- * a call to xQueueSelectFromSet() has first returned a handle to that set member.
- *
- * @param xQueueSet The queue set on which the task will (potentially) block.
- *
- * @param xTicksToWait The maximum time, in ticks, that the calling task will
- * remain in the Blocked state (with other tasks executing) to wait for a member
- * of the queue set to be ready for a successful queue read or semaphore take
- * operation.
- *
- * @return xQueueSelectFromSet() will return the handle of a queue (cast to
- * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
- * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
- * in the queue set that is available, or NULL if no such queue or semaphore
- * exists before before the specified block time expires.
- */
-QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/*
- * A version of xQueueSelectFromSet() that can be used from an ISR.
- */
-QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
-
-/* Not public API functions. */
-void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
-BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
-void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
-UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-uint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* QUEUE_H */
-
diff --git a/osal/inc/freertos/semphr.h b/osal/inc/freertos/semphr.h
deleted file mode 100644
index 787c791..0000000
--- a/osal/inc/freertos/semphr.h
+++ /dev/null
@@ -1,1140 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef SEMAPHORE_H
-#define SEMAPHORE_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h" must appear in source files before "include semphr.h"
-#endif
-
-#include "queue.h"
-
-typedef QueueHandle_t SemaphoreHandle_t;
-
-#define semBINARY_SEMAPHORE_QUEUE_LENGTH	( ( uint8_t ) 1U )
-#define semSEMAPHORE_QUEUE_ITEM_LENGTH		( ( uint8_t ) 0U )
-#define semGIVE_BLOCK_TIME					( ( TickType_t ) 0U )
-
-
-/**
- * semphr. h
- * <pre>vSemaphoreCreateBinary( SemaphoreHandle_t xSemaphore )</pre>
- *
- * In many usage scenarios it is faster and more memory efficient to use a
- * direct to task notification in place of a binary semaphore!
- * http://www.freertos.org/RTOS-task-notifications.html
- *
- * This old vSemaphoreCreateBinary() macro is now deprecated in favour of the
- * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
- * the vSemaphoreCreateBinary() macro are created in a state such that the
- * first call to 'take' the semaphore would pass, whereas binary semaphores
- * created using xSemaphoreCreateBinary() are created in a state such that the
- * the semaphore must first be 'given' before it can be 'taken'.
- *
- * <i>Macro</i> that implements a semaphore by using the existing queue mechanism.
- * The queue length is 1 as this is a binary semaphore.  The data size is 0
- * as we don't want to actually store any data - we just want to know if the
- * queue is empty or full.
- *
- * This type of semaphore can be used for pure synchronisation between tasks or
- * between an interrupt and a task.  The semaphore need not be given back once
- * obtained, so one task/interrupt can continuously 'give' the semaphore while
- * another continuously 'takes' the semaphore.  For this reason this type of
- * semaphore does not use a priority inheritance mechanism.  For an alternative
- * that does use priority inheritance see xSemaphoreCreateMutex().
- *
- * @param xSemaphore Handle to the created semaphore.  Should be of type SemaphoreHandle_t.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore = NULL;
-
- void vATask( void * pvParameters )
- {
-    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
-    // This is a macro so pass the variable in directly.
-    vSemaphoreCreateBinary( xSemaphore );
-
-    if( xSemaphore != NULL )
-    {
-        // The semaphore was created successfully.
-        // The semaphore can now be used.
-    }
- }
- </pre>
- * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
- * \ingroup Semaphores
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	#define vSemaphoreCreateBinary( xSemaphore )																							\
-		{																																	\
-			( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );	\
-			if( ( xSemaphore ) != NULL )																									\
-			{																																\
-				( void ) xSemaphoreGive( ( xSemaphore ) );																					\
-			}																																\
-		}
-#endif
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateBinary( void )</pre>
- *
- * Creates a new binary semaphore instance, and returns a handle by which the
- * new semaphore can be referenced.
- *
- * In many usage scenarios it is faster and more memory efficient to use a
- * direct to task notification in place of a binary semaphore!
- * http://www.freertos.org/RTOS-task-notifications.html
- *
- * Internally, within the FreeRTOS implementation, binary semaphores use a block
- * of memory, in which the semaphore structure is stored.  If a binary semaphore
- * is created using xSemaphoreCreateBinary() then the required memory is
- * automatically dynamically allocated inside the xSemaphoreCreateBinary()
- * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
- * is created using xSemaphoreCreateBinaryStatic() then the application writer
- * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
- * binary semaphore to be created without using any dynamic memory allocation.
- *
- * The old vSemaphoreCreateBinary() macro is now deprecated in favour of this
- * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
- * the vSemaphoreCreateBinary() macro are created in a state such that the
- * first call to 'take' the semaphore would pass, whereas binary semaphores
- * created using xSemaphoreCreateBinary() are created in a state such that the
- * the semaphore must first be 'given' before it can be 'taken'.
- *
- * This type of semaphore can be used for pure synchronisation between tasks or
- * between an interrupt and a task.  The semaphore need not be given back once
- * obtained, so one task/interrupt can continuously 'give' the semaphore while
- * another continuously 'takes' the semaphore.  For this reason this type of
- * semaphore does not use a priority inheritance mechanism.  For an alternative
- * that does use priority inheritance see xSemaphoreCreateMutex().
- *
- * @return Handle to the created semaphore, or NULL if the memory required to
- * hold the semaphore's data structures could not be allocated.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore = NULL;
-
- void vATask( void * pvParameters )
- {
-    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
-    // This is a macro so pass the variable in directly.
-    xSemaphore = xSemaphoreCreateBinary();
-
-    if( xSemaphore != NULL )
-    {
-        // The semaphore was created successfully.
-        // The semaphore can now be used.
-    }
- }
- </pre>
- * \defgroup xSemaphoreCreateBinary xSemaphoreCreateBinary
- * \ingroup Semaphores
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )
-#endif
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer )</pre>
- *
- * Creates a new binary semaphore instance, and returns a handle by which the
- * new semaphore can be referenced.
- *
- * NOTE: In many usage scenarios it is faster and more memory efficient to use a
- * direct to task notification in place of a binary semaphore!
- * http://www.freertos.org/RTOS-task-notifications.html
- *
- * Internally, within the FreeRTOS implementation, binary semaphores use a block
- * of memory, in which the semaphore structure is stored.  If a binary semaphore
- * is created using xSemaphoreCreateBinary() then the required memory is
- * automatically dynamically allocated inside the xSemaphoreCreateBinary()
- * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
- * is created using xSemaphoreCreateBinaryStatic() then the application writer
- * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
- * binary semaphore to be created without using any dynamic memory allocation.
- *
- * This type of semaphore can be used for pure synchronisation between tasks or
- * between an interrupt and a task.  The semaphore need not be given back once
- * obtained, so one task/interrupt can continuously 'give' the semaphore while
- * another continuously 'takes' the semaphore.  For this reason this type of
- * semaphore does not use a priority inheritance mechanism.  For an alternative
- * that does use priority inheritance see xSemaphoreCreateMutex().
- *
- * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
- * which will then be used to hold the semaphore's data structure, removing the
- * need for the memory to be allocated dynamically.
- *
- * @return If the semaphore is created then a handle to the created semaphore is
- * returned.  If pxSemaphoreBuffer is NULL then NULL is returned.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore = NULL;
- StaticSemaphore_t xSemaphoreBuffer;
-
- void vATask( void * pvParameters )
- {
-    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
-    // The semaphore's data structures will be placed in the xSemaphoreBuffer
-    // variable, the address of which is passed into the function.  The
-    // function's parameter is not NULL, so the function will not attempt any
-    // dynamic memory allocation, and therefore the function will not return
-    // return NULL.
-    xSemaphore = xSemaphoreCreateBinary( &xSemaphoreBuffer );
-
-    // Rest of task code goes here.
- }
- </pre>
- * \defgroup xSemaphoreCreateBinaryStatic xSemaphoreCreateBinaryStatic
- * \ingroup Semaphores
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	#define xSemaphoreCreateBinaryStatic( pxStaticSemaphore ) xQueueGenericCreateStatic( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticSemaphore, queueQUEUE_TYPE_BINARY_SEMAPHORE )
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-/**
- * semphr. h
- * <pre>xSemaphoreTake(
- *                   SemaphoreHandle_t xSemaphore,
- *                   TickType_t xBlockTime
- *               )</pre>
- *
- * <i>Macro</i> to obtain a semaphore.  The semaphore must have previously been
- * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
- * xSemaphoreCreateCounting().
- *
- * @param xSemaphore A handle to the semaphore being taken - obtained when
- * the semaphore was created.
- *
- * @param xBlockTime The time in ticks to wait for the semaphore to become
- * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
- * real time.  A block time of zero can be used to poll the semaphore.  A block
- * time of portMAX_DELAY can be used to block indefinitely (provided
- * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
- *
- * @return pdTRUE if the semaphore was obtained.  pdFALSE
- * if xBlockTime expired without the semaphore becoming available.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore = NULL;
-
- // A task that creates a semaphore.
- void vATask( void * pvParameters )
- {
-    // Create the semaphore to guard a shared resource.
-    xSemaphore = xSemaphoreCreateBinary();
- }
-
- // A task that uses the semaphore.
- void vAnotherTask( void * pvParameters )
- {
-    // ... Do other things.
-
-    if( xSemaphore != NULL )
-    {
-        // See if we can obtain the semaphore.  If the semaphore is not available
-        // wait 10 ticks to see if it becomes free.
-        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
-        {
-            // We were able to obtain the semaphore and can now access the
-            // shared resource.
-
-            // ...
-
-            // We have finished accessing the shared resource.  Release the
-            // semaphore.
-            xSemaphoreGive( xSemaphore );
-        }
-        else
-        {
-            // We could not obtain the semaphore and can therefore not access
-            // the shared resource safely.
-        }
-    }
- }
- </pre>
- * \defgroup xSemaphoreTake xSemaphoreTake
- * \ingroup Semaphores
- */
-#define xSemaphoreTake( xSemaphore, xBlockTime )		xQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) )
-
-/**
- * semphr. h
- * xSemaphoreTakeRecursive(
- *                          SemaphoreHandle_t xMutex,
- *                          TickType_t xBlockTime
- *                        )
- *
- * <i>Macro</i> to recursively obtain, or 'take', a mutex type semaphore.
- * The mutex must have previously been created using a call to
- * xSemaphoreCreateRecursiveMutex();
- *
- * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
- * macro to be available.
- *
- * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
- *
- * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
- * doesn't become available again until the owner has called
- * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
- * if a task successfully 'takes' the same mutex 5 times then the mutex will
- * not be available to any other task until it has also  'given' the mutex back
- * exactly five times.
- *
- * @param xMutex A handle to the mutex being obtained.  This is the
- * handle returned by xSemaphoreCreateRecursiveMutex();
- *
- * @param xBlockTime The time in ticks to wait for the semaphore to become
- * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
- * real time.  A block time of zero can be used to poll the semaphore.  If
- * the task already owns the semaphore then xSemaphoreTakeRecursive() will
- * return immediately no matter what the value of xBlockTime.
- *
- * @return pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime
- * expired without the semaphore becoming available.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xMutex = NULL;
-
- // A task that creates a mutex.
- void vATask( void * pvParameters )
- {
-    // Create the mutex to guard a shared resource.
-    xMutex = xSemaphoreCreateRecursiveMutex();
- }
-
- // A task that uses the mutex.
- void vAnotherTask( void * pvParameters )
- {
-    // ... Do other things.
-
-    if( xMutex != NULL )
-    {
-        // See if we can obtain the mutex.  If the mutex is not available
-        // wait 10 ticks to see if it becomes free.
-        if( xSemaphoreTakeRecursive( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
-        {
-            // We were able to obtain the mutex and can now access the
-            // shared resource.
-
-            // ...
-            // For some reason due to the nature of the code further calls to
-            // xSemaphoreTakeRecursive() are made on the same mutex.  In real
-            // code these would not be just sequential calls as this would make
-            // no sense.  Instead the calls are likely to be buried inside
-            // a more complex call structure.
-            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
-            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
-
-            // The mutex has now been 'taken' three times, so will not be
-            // available to another task until it has also been given back
-            // three times.  Again it is unlikely that real code would have
-            // these calls sequentially, but instead buried in a more complex
-            // call structure.  This is just for illustrative purposes.
-            xSemaphoreGiveRecursive( xMutex );
-            xSemaphoreGiveRecursive( xMutex );
-            xSemaphoreGiveRecursive( xMutex );
-
-            // Now the mutex can be taken by other tasks.
-        }
-        else
-        {
-            // We could not obtain the mutex and can therefore not access
-            // the shared resource safely.
-        }
-    }
- }
- </pre>
- * \defgroup xSemaphoreTakeRecursive xSemaphoreTakeRecursive
- * \ingroup Semaphores
- */
-#if( configUSE_RECURSIVE_MUTEXES == 1 )
-	#define xSemaphoreTakeRecursive( xMutex, xBlockTime )	xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )
-#endif
-
-/**
- * semphr. h
- * <pre>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</pre>
- *
- * <i>Macro</i> to release a semaphore.  The semaphore must have previously been
- * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
- * xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().
- *
- * This macro must not be used from an ISR.  See xSemaphoreGiveFromISR () for
- * an alternative which can be used from an ISR.
- *
- * This macro must also not be used on semaphores created using
- * xSemaphoreCreateRecursiveMutex().
- *
- * @param xSemaphore A handle to the semaphore being released.  This is the
- * handle returned when the semaphore was created.
- *
- * @return pdTRUE if the semaphore was released.  pdFALSE if an error occurred.
- * Semaphores are implemented using queues.  An error can occur if there is
- * no space on the queue to post a message - indicating that the
- * semaphore was not first obtained correctly.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore = NULL;
-
- void vATask( void * pvParameters )
- {
-    // Create the semaphore to guard a shared resource.
-    xSemaphore = vSemaphoreCreateBinary();
-
-    if( xSemaphore != NULL )
-    {
-        if( xSemaphoreGive( xSemaphore ) != pdTRUE )
-        {
-            // We would expect this call to fail because we cannot give
-            // a semaphore without first "taking" it!
-        }
-
-        // Obtain the semaphore - don't block if the semaphore is not
-        // immediately available.
-        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
-        {
-            // We now have the semaphore and can access the shared resource.
-
-            // ...
-
-            // We have finished accessing the shared resource so can free the
-            // semaphore.
-            if( xSemaphoreGive( xSemaphore ) != pdTRUE )
-            {
-                // We would not expect this call to fail because we must have
-                // obtained the semaphore to get here.
-            }
-        }
-    }
- }
- </pre>
- * \defgroup xSemaphoreGive xSemaphoreGive
- * \ingroup Semaphores
- */
-#define xSemaphoreGive( xSemaphore )		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
-
-/**
- * semphr. h
- * <pre>xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</pre>
- *
- * <i>Macro</i> to recursively release, or 'give', a mutex type semaphore.
- * The mutex must have previously been created using a call to
- * xSemaphoreCreateRecursiveMutex();
- *
- * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
- * macro to be available.
- *
- * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
- *
- * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
- * doesn't become available again until the owner has called
- * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
- * if a task successfully 'takes' the same mutex 5 times then the mutex will
- * not be available to any other task until it has also  'given' the mutex back
- * exactly five times.
- *
- * @param xMutex A handle to the mutex being released, or 'given'.  This is the
- * handle returned by xSemaphoreCreateMutex();
- *
- * @return pdTRUE if the semaphore was given.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xMutex = NULL;
-
- // A task that creates a mutex.
- void vATask( void * pvParameters )
- {
-    // Create the mutex to guard a shared resource.
-    xMutex = xSemaphoreCreateRecursiveMutex();
- }
-
- // A task that uses the mutex.
- void vAnotherTask( void * pvParameters )
- {
-    // ... Do other things.
-
-    if( xMutex != NULL )
-    {
-        // See if we can obtain the mutex.  If the mutex is not available
-        // wait 10 ticks to see if it becomes free.
-        if( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 ) == pdTRUE )
-        {
-            // We were able to obtain the mutex and can now access the
-            // shared resource.
-
-            // ...
-            // For some reason due to the nature of the code further calls to
-			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
-			// code these would not be just sequential calls as this would make
-			// no sense.  Instead the calls are likely to be buried inside
-			// a more complex call structure.
-            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
-            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
-
-            // The mutex has now been 'taken' three times, so will not be
-			// available to another task until it has also been given back
-			// three times.  Again it is unlikely that real code would have
-			// these calls sequentially, it would be more likely that the calls
-			// to xSemaphoreGiveRecursive() would be called as a call stack
-			// unwound.  This is just for demonstrative purposes.
-            xSemaphoreGiveRecursive( xMutex );
-			xSemaphoreGiveRecursive( xMutex );
-			xSemaphoreGiveRecursive( xMutex );
-
-			// Now the mutex can be taken by other tasks.
-        }
-        else
-        {
-            // We could not obtain the mutex and can therefore not access
-            // the shared resource safely.
-        }
-    }
- }
- </pre>
- * \defgroup xSemaphoreGiveRecursive xSemaphoreGiveRecursive
- * \ingroup Semaphores
- */
-#if( configUSE_RECURSIVE_MUTEXES == 1 )
-	#define xSemaphoreGiveRecursive( xMutex )	xQueueGiveMutexRecursive( ( xMutex ) )
-#endif
-
-/**
- * semphr. h
- * <pre>
- xSemaphoreGiveFromISR(
-                          SemaphoreHandle_t xSemaphore,
-                          BaseType_t *pxHigherPriorityTaskWoken
-                      )</pre>
- *
- * <i>Macro</i> to  release a semaphore.  The semaphore must have previously been
- * created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().
- *
- * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
- * must not be used with this macro.
- *
- * This macro can be used from an ISR.
- *
- * @param xSemaphore A handle to the semaphore being released.  This is the
- * handle returned when the semaphore was created.
- *
- * @param pxHigherPriorityTaskWoken xSemaphoreGiveFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task
- * to unblock, and the unblocked task has a priority higher than the currently
- * running task.  If xSemaphoreGiveFromISR() sets this value to pdTRUE then
- * a context switch should be requested before the interrupt is exited.
- *
- * @return pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.
- *
- * Example usage:
- <pre>
- \#define LONG_TIME 0xffff
- \#define TICKS_TO_WAIT	10
- SemaphoreHandle_t xSemaphore = NULL;
-
- // Repetitive task.
- void vATask( void * pvParameters )
- {
-    for( ;; )
-    {
-        // We want this task to run every 10 ticks of a timer.  The semaphore
-        // was created before this task was started.
-
-        // Block waiting for the semaphore to become available.
-        if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
-        {
-            // It is time to execute.
-
-            // ...
-
-            // We have finished our task.  Return to the top of the loop where
-            // we will block on the semaphore until it is time to execute
-            // again.  Note when using the semaphore for synchronisation with an
-			// ISR in this manner there is no need to 'give' the semaphore back.
-        }
-    }
- }
-
- // Timer ISR
- void vTimerISR( void * pvParameters )
- {
- static uint8_t ucLocalTickCount = 0;
- static BaseType_t xHigherPriorityTaskWoken;
-
-    // A timer tick has occurred.
-
-    // ... Do other time functions.
-
-    // Is it time for vATask () to run?
-	xHigherPriorityTaskWoken = pdFALSE;
-    ucLocalTickCount++;
-    if( ucLocalTickCount >= TICKS_TO_WAIT )
-    {
-        // Unblock the task by releasing the semaphore.
-        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
-
-        // Reset the count so we release the semaphore again in 10 ticks time.
-        ucLocalTickCount = 0;
-    }
-
-    if( xHigherPriorityTaskWoken != pdFALSE )
-    {
-        // We can force a context switch here.  Context switching from an
-        // ISR uses port specific syntax.  Check the demo task for your port
-        // to find the syntax required.
-    }
- }
- </pre>
- * \defgroup xSemaphoreGiveFromISR xSemaphoreGiveFromISR
- * \ingroup Semaphores
- */
-#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )
-
-/**
- * semphr. h
- * <pre>
- xSemaphoreTakeFromISR(
-                          SemaphoreHandle_t xSemaphore,
-                          BaseType_t *pxHigherPriorityTaskWoken
-                      )</pre>
- *
- * <i>Macro</i> to  take a semaphore from an ISR.  The semaphore must have
- * previously been created with a call to xSemaphoreCreateBinary() or
- * xSemaphoreCreateCounting().
- *
- * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
- * must not be used with this macro.
- *
- * This macro can be used from an ISR, however taking a semaphore from an ISR
- * is not a common operation.  It is likely to only be useful when taking a
- * counting semaphore when an interrupt is obtaining an object from a resource
- * pool (when the semaphore count indicates the number of resources available).
- *
- * @param xSemaphore A handle to the semaphore being taken.  This is the
- * handle returned when the semaphore was created.
- *
- * @param pxHigherPriorityTaskWoken xSemaphoreTakeFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task
- * to unblock, and the unblocked task has a priority higher than the currently
- * running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then
- * a context switch should be requested before the interrupt is exited.
- *
- * @return pdTRUE if the semaphore was successfully taken, otherwise
- * pdFALSE
- */
-#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateMutex( void )</pre>
- *
- * Creates a new mutex type semaphore instance, and returns a handle by which
- * the new mutex can be referenced.
- *
- * Internally, within the FreeRTOS implementation, mutex semaphores use a block
- * of memory, in which the mutex structure is stored.  If a mutex is created
- * using xSemaphoreCreateMutex() then the required memory is automatically
- * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
- * http://www.freertos.org/a00111.html).  If a mutex is created using
- * xSemaphoreCreateMutexStatic() then the application writer must provided the
- * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
- * without using any dynamic memory allocation.
- *
- * Mutexes created using this function can be accessed using the xSemaphoreTake()
- * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
- * xSemaphoreGiveRecursive() macros must not be used.
- *
- * This type of semaphore uses a priority inheritance mechanism so a task
- * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
- * semaphore it is no longer required.
- *
- * Mutex type semaphores cannot be used from within interrupt service routines.
- *
- * See xSemaphoreCreateBinary() for an alternative implementation that can be
- * used for pure synchronisation (where one task or interrupt always 'gives' the
- * semaphore and another always 'takes' the semaphore) and from within interrupt
- * service routines.
- *
- * @return If the mutex was successfully created then a handle to the created
- * semaphore is returned.  If there was not enough heap to allocate the mutex
- * data structures then NULL is returned.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore;
-
- void vATask( void * pvParameters )
- {
-    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
-    // This is a macro so pass the variable in directly.
-    xSemaphore = xSemaphoreCreateMutex();
-
-    if( xSemaphore != NULL )
-    {
-        // The semaphore was created successfully.
-        // The semaphore can now be used.
-    }
- }
- </pre>
- * \defgroup xSemaphoreCreateMutex xSemaphoreCreateMutex
- * \ingroup Semaphores
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
-#endif
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
- *
- * Creates a new mutex type semaphore instance, and returns a handle by which
- * the new mutex can be referenced.
- *
- * Internally, within the FreeRTOS implementation, mutex semaphores use a block
- * of memory, in which the mutex structure is stored.  If a mutex is created
- * using xSemaphoreCreateMutex() then the required memory is automatically
- * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
- * http://www.freertos.org/a00111.html).  If a mutex is created using
- * xSemaphoreCreateMutexStatic() then the application writer must provided the
- * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
- * without using any dynamic memory allocation.
- *
- * Mutexes created using this function can be accessed using the xSemaphoreTake()
- * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
- * xSemaphoreGiveRecursive() macros must not be used.
- *
- * This type of semaphore uses a priority inheritance mechanism so a task
- * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
- * semaphore it is no longer required.
- *
- * Mutex type semaphores cannot be used from within interrupt service routines.
- *
- * See xSemaphoreCreateBinary() for an alternative implementation that can be
- * used for pure synchronisation (where one task or interrupt always 'gives' the
- * semaphore and another always 'takes' the semaphore) and from within interrupt
- * service routines.
- *
- * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
- * which will be used to hold the mutex's data structure, removing the need for
- * the memory to be allocated dynamically.
- *
- * @return If the mutex was successfully created then a handle to the created
- * mutex is returned.  If pxMutexBuffer was NULL then NULL is returned.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore;
- StaticSemaphore_t xMutexBuffer;
-
- void vATask( void * pvParameters )
- {
-    // A mutex cannot be used before it has been created.  xMutexBuffer is
-    // into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is
-    // attempted.
-    xSemaphore = xSemaphoreCreateMutexStatic( &xMutexBuffer );
-
-    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
-    // so there is no need to check it.
- }
- </pre>
- * \defgroup xSemaphoreCreateMutexStatic xSemaphoreCreateMutexStatic
- * \ingroup Semaphores
- */
- #if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	#define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) )
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void )</pre>
- *
- * Creates a new recursive mutex type semaphore instance, and returns a handle
- * by which the new recursive mutex can be referenced.
- *
- * Internally, within the FreeRTOS implementation, recursive mutexs use a block
- * of memory, in which the mutex structure is stored.  If a recursive mutex is
- * created using xSemaphoreCreateRecursiveMutex() then the required memory is
- * automatically dynamically allocated inside the
- * xSemaphoreCreateRecursiveMutex() function.  (see
- * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
- * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
- * provide the memory that will get used by the mutex.
- * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
- * be created without using any dynamic memory allocation.
- *
- * Mutexes created using this macro can be accessed using the
- * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
- * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
- *
- * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
- * doesn't become available again until the owner has called
- * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
- * if a task successfully 'takes' the same mutex 5 times then the mutex will
- * not be available to any other task until it has also  'given' the mutex back
- * exactly five times.
- *
- * This type of semaphore uses a priority inheritance mechanism so a task
- * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
- * semaphore it is no longer required.
- *
- * Mutex type semaphores cannot be used from within interrupt service routines.
- *
- * See xSemaphoreCreateBinary() for an alternative implementation that can be
- * used for pure synchronisation (where one task or interrupt always 'gives' the
- * semaphore and another always 'takes' the semaphore) and from within interrupt
- * service routines.
- *
- * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
- * SemaphoreHandle_t.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore;
-
- void vATask( void * pvParameters )
- {
-    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
-    // This is a macro so pass the variable in directly.
-    xSemaphore = xSemaphoreCreateRecursiveMutex();
-
-    if( xSemaphore != NULL )
-    {
-        // The semaphore was created successfully.
-        // The semaphore can now be used.
-    }
- }
- </pre>
- * \defgroup xSemaphoreCreateRecursiveMutex xSemaphoreCreateRecursiveMutex
- * \ingroup Semaphores
- */
-#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
-	#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )
-#endif
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
- *
- * Creates a new recursive mutex type semaphore instance, and returns a handle
- * by which the new recursive mutex can be referenced.
- *
- * Internally, within the FreeRTOS implementation, recursive mutexs use a block
- * of memory, in which the mutex structure is stored.  If a recursive mutex is
- * created using xSemaphoreCreateRecursiveMutex() then the required memory is
- * automatically dynamically allocated inside the
- * xSemaphoreCreateRecursiveMutex() function.  (see
- * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
- * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
- * provide the memory that will get used by the mutex.
- * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
- * be created without using any dynamic memory allocation.
- *
- * Mutexes created using this macro can be accessed using the
- * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
- * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
- *
- * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
- * doesn't become available again until the owner has called
- * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
- * if a task successfully 'takes' the same mutex 5 times then the mutex will
- * not be available to any other task until it has also  'given' the mutex back
- * exactly five times.
- *
- * This type of semaphore uses a priority inheritance mechanism so a task
- * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
- * semaphore it is no longer required.
- *
- * Mutex type semaphores cannot be used from within interrupt service routines.
- *
- * See xSemaphoreCreateBinary() for an alternative implementation that can be
- * used for pure synchronisation (where one task or interrupt always 'gives' the
- * semaphore and another always 'takes' the semaphore) and from within interrupt
- * service routines.
- *
- * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
- * which will then be used to hold the recursive mutex's data structure,
- * removing the need for the memory to be allocated dynamically.
- *
- * @return If the recursive mutex was successfully created then a handle to the
- * created recursive mutex is returned.  If pxMutexBuffer was NULL then NULL is
- * returned.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore;
- StaticSemaphore_t xMutexBuffer;
-
- void vATask( void * pvParameters )
- {
-    // A recursive semaphore cannot be used before it is created.  Here a
-    // recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic().
-    // The address of xMutexBuffer is passed into the function, and will hold
-    // the mutexes data structures - so no dynamic memory allocation will be
-    // attempted.
-    xSemaphore = xSemaphoreCreateRecursiveMutexStatic( &xMutexBuffer );
-
-    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
-    // so there is no need to check it.
- }
- </pre>
- * \defgroup xSemaphoreCreateRecursiveMutexStatic xSemaphoreCreateRecursiveMutexStatic
- * \ingroup Semaphores
- */
-#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
-	#define xSemaphoreCreateRecursiveMutexStatic( pxStaticSemaphore ) xQueueCreateMutexStatic( queueQUEUE_TYPE_RECURSIVE_MUTEX, pxStaticSemaphore )
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )</pre>
- *
- * Creates a new counting semaphore instance, and returns a handle by which the
- * new counting semaphore can be referenced.
- *
- * In many usage scenarios it is faster and more memory efficient to use a
- * direct to task notification in place of a counting semaphore!
- * http://www.freertos.org/RTOS-task-notifications.html
- *
- * Internally, within the FreeRTOS implementation, counting semaphores use a
- * block of memory, in which the counting semaphore structure is stored.  If a
- * counting semaphore is created using xSemaphoreCreateCounting() then the
- * required memory is automatically dynamically allocated inside the
- * xSemaphoreCreateCounting() function.  (see
- * http://www.freertos.org/a00111.html).  If a counting semaphore is created
- * using xSemaphoreCreateCountingStatic() then the application writer can
- * instead optionally provide the memory that will get used by the counting
- * semaphore.  xSemaphoreCreateCountingStatic() therefore allows a counting
- * semaphore to be created without using any dynamic memory allocation.
- *
- * Counting semaphores are typically used for two things:
- *
- * 1) Counting events.
- *
- *    In this usage scenario an event handler will 'give' a semaphore each time
- *    an event occurs (incrementing the semaphore count value), and a handler
- *    task will 'take' a semaphore each time it processes an event
- *    (decrementing the semaphore count value).  The count value is therefore
- *    the difference between the number of events that have occurred and the
- *    number that have been processed.  In this case it is desirable for the
- *    initial count value to be zero.
- *
- * 2) Resource management.
- *
- *    In this usage scenario the count value indicates the number of resources
- *    available.  To obtain control of a resource a task must first obtain a
- *    semaphore - decrementing the semaphore count value.  When the count value
- *    reaches zero there are no free resources.  When a task finishes with the
- *    resource it 'gives' the semaphore back - incrementing the semaphore count
- *    value.  In this case it is desirable for the initial count value to be
- *    equal to the maximum count value, indicating that all resources are free.
- *
- * @param uxMaxCount The maximum count value that can be reached.  When the
- *        semaphore reaches this value it can no longer be 'given'.
- *
- * @param uxInitialCount The count value assigned to the semaphore when it is
- *        created.
- *
- * @return Handle to the created semaphore.  Null if the semaphore could not be
- *         created.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore;
-
- void vATask( void * pvParameters )
- {
- SemaphoreHandle_t xSemaphore = NULL;
-
-    // Semaphore cannot be used before a call to xSemaphoreCreateCounting().
-    // The max value to which the semaphore can count should be 10, and the
-    // initial value assigned to the count should be 0.
-    xSemaphore = xSemaphoreCreateCounting( 10, 0 );
-
-    if( xSemaphore != NULL )
-    {
-        // The semaphore was created successfully.
-        // The semaphore can now be used.
-    }
- }
- </pre>
- * \defgroup xSemaphoreCreateCounting xSemaphoreCreateCounting
- * \ingroup Semaphores
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )
-#endif
-
-/**
- * semphr. h
- * <pre>SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer )</pre>
- *
- * Creates a new counting semaphore instance, and returns a handle by which the
- * new counting semaphore can be referenced.
- *
- * In many usage scenarios it is faster and more memory efficient to use a
- * direct to task notification in place of a counting semaphore!
- * http://www.freertos.org/RTOS-task-notifications.html
- *
- * Internally, within the FreeRTOS implementation, counting semaphores use a
- * block of memory, in which the counting semaphore structure is stored.  If a
- * counting semaphore is created using xSemaphoreCreateCounting() then the
- * required memory is automatically dynamically allocated inside the
- * xSemaphoreCreateCounting() function.  (see
- * http://www.freertos.org/a00111.html).  If a counting semaphore is created
- * using xSemaphoreCreateCountingStatic() then the application writer must
- * provide the memory.  xSemaphoreCreateCountingStatic() therefore allows a
- * counting semaphore to be created without using any dynamic memory allocation.
- *
- * Counting semaphores are typically used for two things:
- *
- * 1) Counting events.
- *
- *    In this usage scenario an event handler will 'give' a semaphore each time
- *    an event occurs (incrementing the semaphore count value), and a handler
- *    task will 'take' a semaphore each time it processes an event
- *    (decrementing the semaphore count value).  The count value is therefore
- *    the difference between the number of events that have occurred and the
- *    number that have been processed.  In this case it is desirable for the
- *    initial count value to be zero.
- *
- * 2) Resource management.
- *
- *    In this usage scenario the count value indicates the number of resources
- *    available.  To obtain control of a resource a task must first obtain a
- *    semaphore - decrementing the semaphore count value.  When the count value
- *    reaches zero there are no free resources.  When a task finishes with the
- *    resource it 'gives' the semaphore back - incrementing the semaphore count
- *    value.  In this case it is desirable for the initial count value to be
- *    equal to the maximum count value, indicating that all resources are free.
- *
- * @param uxMaxCount The maximum count value that can be reached.  When the
- *        semaphore reaches this value it can no longer be 'given'.
- *
- * @param uxInitialCount The count value assigned to the semaphore when it is
- *        created.
- *
- * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
- * which will then be used to hold the semaphore's data structure, removing the
- * need for the memory to be allocated dynamically.
- *
- * @return If the counting semaphore was successfully created then a handle to
- * the created counting semaphore is returned.  If pxSemaphoreBuffer was NULL
- * then NULL is returned.
- *
- * Example usage:
- <pre>
- SemaphoreHandle_t xSemaphore;
- StaticSemaphore_t xSemaphoreBuffer;
-
- void vATask( void * pvParameters )
- {
- SemaphoreHandle_t xSemaphore = NULL;
-
-    // Counting semaphore cannot be used before they have been created.  Create
-    // a counting semaphore using xSemaphoreCreateCountingStatic().  The max
-    // value to which the semaphore can count is 10, and the initial value
-    // assigned to the count will be 0.  The address of xSemaphoreBuffer is
-    // passed in and will be used to hold the semaphore structure, so no dynamic
-    // memory allocation will be used.
-    xSemaphore = xSemaphoreCreateCounting( 10, 0, &xSemaphoreBuffer );
-
-    // No memory allocation was attempted so xSemaphore cannot be NULL, so there
-    // is no need to check its value.
- }
- </pre>
- * \defgroup xSemaphoreCreateCountingStatic xSemaphoreCreateCountingStatic
- * \ingroup Semaphores
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-/**
- * semphr. h
- * <pre>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</pre>
- *
- * Delete a semaphore.  This function must be used with care.  For example,
- * do not delete a mutex type semaphore if the mutex is held by a task.
- *
- * @param xSemaphore A handle to the semaphore to be deleted.
- *
- * \defgroup vSemaphoreDelete vSemaphoreDelete
- * \ingroup Semaphores
- */
-#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )
-
-/**
- * semphr.h
- * <pre>TaskHandle_t xSemaphoreGetMutexHolder( SemaphoreHandle_t xMutex );</pre>
- *
- * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
- * If xMutex is not a mutex type semaphore, or the mutex is available (not held
- * by a task), return NULL.
- *
- * Note: This is a good way of determining if the calling task is the mutex
- * holder, but not a good way of determining the identity of the mutex holder as
- * the holder may change between the function exiting and the returned value
- * being tested.
- */
-#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )
-
-/**
- * semphr.h
- * <pre>TaskHandle_t xSemaphoreGetMutexHolderFromISR( SemaphoreHandle_t xMutex );</pre>
- *
- * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
- * If xMutex is not a mutex type semaphore, or the mutex is available (not held
- * by a task), return NULL.
- *
- */
-#define xSemaphoreGetMutexHolderFromISR( xSemaphore ) xQueueGetMutexHolderFromISR( ( xSemaphore ) )
-
-/**
- * semphr.h
- * <pre>UBaseType_t uxSemaphoreGetCount( SemaphoreHandle_t xSemaphore );</pre>
- *
- * If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns
- * its current count value.  If the semaphore is a binary semaphore then
- * uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the
- * semaphore is not available.
- *
- */
-#define uxSemaphoreGetCount( xSemaphore ) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )
-
-#endif /* SEMAPHORE_H */
-
-
diff --git a/osal/inc/freertos/stack_macros.h b/osal/inc/freertos/stack_macros.h
deleted file mode 100644
index b5bac08..0000000
--- a/osal/inc/freertos/stack_macros.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef STACK_MACROS_H
-#define STACK_MACROS_H
-
-/*
- * Call the stack overflow hook function if the stack of the task being swapped
- * out is currently overflowed, or looks like it might have overflowed in the
- * past.
- *
- * Setting configCHECK_FOR_STACK_OVERFLOW to 1 will cause the macro to check
- * the current stack state only - comparing the current top of stack value to
- * the stack limit.  Setting configCHECK_FOR_STACK_OVERFLOW to greater than 1
- * will also cause the last few stack bytes to be checked to ensure the value
- * to which the bytes were set when the task was created have not been
- * overwritten.  Note this second test does not guarantee that an overflowed
- * stack will always be recognised.
- */
-
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH < 0 ) )
-
-	/* Only the current stack state is to be checked. */
-	#define taskCHECK_FOR_STACK_OVERFLOW()																\
-	{																									\
-		/* Is the currently saved stack pointer within the stack limit? */								\
-		if( pxCurrentTCB->pxTopOfStack <= pxCurrentTCB->pxStack )										\
-		{																								\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
-		}																								\
-	}
-
-#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH > 0 ) )
-
-	/* Only the current stack state is to be checked. */
-	#define taskCHECK_FOR_STACK_OVERFLOW()																\
-	{																									\
-																										\
-		/* Is the currently saved stack pointer within the stack limit? */								\
-		if( pxCurrentTCB->pxTopOfStack >= pxCurrentTCB->pxEndOfStack )									\
-		{																								\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
-		}																								\
-	}
-
-#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH < 0 ) )
-
-	#define taskCHECK_FOR_STACK_OVERFLOW()																\
-	{																									\
-		const uint32_t * const pulStack = ( uint32_t * ) pxCurrentTCB->pxStack;							\
-		const uint32_t ulCheckValue = ( uint32_t ) 0xa5a5a5a5;											\
-																										\
-		if( ( pulStack[ 0 ] != ulCheckValue ) ||														\
-			( pulStack[ 1 ] != ulCheckValue ) ||														\
-			( pulStack[ 2 ] != ulCheckValue ) ||														\
-			( pulStack[ 3 ] != ulCheckValue ) )															\
-		{																								\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
-		}																								\
-	}
-
-#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
-/*-----------------------------------------------------------*/
-
-#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH > 0 ) )
-
-	#define taskCHECK_FOR_STACK_OVERFLOW()																								\
-	{																																	\
-	int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB->pxEndOfStack;																		\
-	static const uint8_t ucExpectedStackBytes[] = {	tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
-													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };	\
-																																		\
-																																		\
-		pcEndOfStack -= sizeof( ucExpectedStackBytes );																					\
-																																		\
-		/* Has the extremity of the task stack ever been written over? */																\
-		if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )					\
-		{																																\
-			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );									\
-		}																																\
-	}
-
-#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
-/*-----------------------------------------------------------*/
-
-/* Remove stack overflow macro if not being used. */
-#ifndef taskCHECK_FOR_STACK_OVERFLOW
-	#define taskCHECK_FOR_STACK_OVERFLOW()
-#endif
-
-
-
-#endif /* STACK_MACROS_H */
-
diff --git a/osal/inc/freertos/stdint.readme b/osal/inc/freertos/stdint.readme
deleted file mode 100644
index 4414c29..0000000
--- a/osal/inc/freertos/stdint.readme
+++ /dev/null
@@ -1,27 +0,0 @@
-
-#ifndef FREERTOS_STDINT
-#define FREERTOS_STDINT
-
-/*******************************************************************************
- * THIS IS NOT A FULL stdint.h IMPLEMENTATION - It only contains the definitions
- * necessary to build the FreeRTOS code.  It is provided to allow FreeRTOS to be
- * built using compilers that do not provide their own stdint.h definition.
- *
- * To use this file:
- *
- *    1) Copy this file into the directory that contains your FreeRTOSConfig.h
- *       header file, as that directory will already be in the compilers include
- *       path.
- *
- *    2) Rename the copied file stdint.h.
- *
- */
-
-typedef signed char int8_t;
-typedef unsigned char uint8_t;
-typedef short int16_t;
-typedef unsigned short uint16_t;
-typedef long int32_t;
-typedef unsigned long uint32_t;
-
-#endif /* FREERTOS_STDINT */
diff --git a/osal/inc/freertos/stream_buffer.h b/osal/inc/freertos/stream_buffer.h
deleted file mode 100644
index a8b68ad..0000000
--- a/osal/inc/freertos/stream_buffer.h
+++ /dev/null
@@ -1,859 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * Stream buffers are used to send a continuous stream of data from one task or
- * interrupt to another.  Their implementation is light weight, making them
- * particularly suited for interrupt to task and core to core communication
- * scenarios.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xStreamBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xStreamBufferReceive()) inside a critical section section and set the
- * receive block time to 0.
- *
- */
-
-#ifndef STREAM_BUFFER_H
-#define STREAM_BUFFER_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h must appear in source files before include stream_buffer.h"
-#endif
-
-#if defined( __cplusplus )
-extern "C" {
-#endif
-
-/**
- * Type by which stream buffers are referenced.  For example, a call to
- * xStreamBufferCreate() returns an StreamBufferHandle_t variable that can
- * then be used as a parameter to xStreamBufferSend(), xStreamBufferReceive(),
- * etc.
- */
-struct StreamBufferDef_t;
-typedef struct StreamBufferDef_t * StreamBufferHandle_t;
-
-
-/**
- * message_buffer.h
- *
-<pre>
-StreamBufferHandle_t xStreamBufferCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes );
-</pre>
- *
- * Creates a new stream buffer using dynamically allocated memory.  See
- * xStreamBufferCreateStatic() for a version that uses statically allocated
- * memory (memory that is allocated at compile time).
- *
- * configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in
- * FreeRTOSConfig.h for xStreamBufferCreate() to be available.
- *
- * @param xBufferSizeBytes The total number of bytes the stream buffer will be
- * able to hold at any one time.
- *
- * @param xTriggerLevelBytes The number of bytes that must be in the stream
- * buffer before a task that is blocked on the stream buffer to wait for data is
- * moved out of the blocked state.  For example, if a task is blocked on a read
- * of an empty stream buffer that has a trigger level of 1 then the task will be
- * unblocked when a single byte is written to the buffer or the task's block
- * time expires.  As another example, if a task is blocked on a read of an empty
- * stream buffer that has a trigger level of 10 then the task will not be
- * unblocked until the stream buffer contains at least 10 bytes or the task's
- * block time expires.  If a reading task's block time expires before the
- * trigger level is reached then the task will still receive however many bytes
- * are actually available.  Setting a trigger level of 0 will result in a
- * trigger level of 1 being used.  It is not valid to specify a trigger level
- * that is greater than the buffer size.
- *
- * @return If NULL is returned, then the stream buffer cannot be created
- * because there is insufficient heap memory available for FreeRTOS to allocate
- * the stream buffer data structures and storage area.  A non-NULL value being
- * returned indicates that the stream buffer has been created successfully -
- * the returned value should be stored as the handle to the created stream
- * buffer.
- *
- * Example use:
-<pre>
-
-void vAFunction( void )
-{
-StreamBufferHandle_t xStreamBuffer;
-const size_t xStreamBufferSizeBytes = 100, xTriggerLevel = 10;
-
-    // Create a stream buffer that can hold 100 bytes.  The memory used to hold
-    // both the stream buffer structure and the data in the stream buffer is
-    // allocated dynamically.
-    xStreamBuffer = xStreamBufferCreate( xStreamBufferSizeBytes, xTriggerLevel );
-
-    if( xStreamBuffer == NULL )
-    {
-        // There was not enough heap memory space available to create the
-        // stream buffer.
-    }
-    else
-    {
-        // The stream buffer was created successfully and can now be used.
-    }
-}
-</pre>
- * \defgroup xStreamBufferCreate xStreamBufferCreate
- * \ingroup StreamBufferManagement
- */
-#define xStreamBufferCreate( xBufferSizeBytes, xTriggerLevelBytes ) xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE )
-
-/**
- * stream_buffer.h
- *
-<pre>
-StreamBufferHandle_t xStreamBufferCreateStatic( size_t xBufferSizeBytes,
-                                                size_t xTriggerLevelBytes,
-                                                uint8_t *pucStreamBufferStorageArea,
-                                                StaticStreamBuffer_t *pxStaticStreamBuffer );
-</pre>
- * Creates a new stream buffer using statically allocated memory.  See
- * xStreamBufferCreate() for a version that uses dynamically allocated memory.
- *
- * configSUPPORT_STATIC_ALLOCATION must be set to 1 in FreeRTOSConfig.h for
- * xStreamBufferCreateStatic() to be available.
- *
- * @param xBufferSizeBytes The size, in bytes, of the buffer pointed to by the
- * pucStreamBufferStorageArea parameter.
- *
- * @param xTriggerLevelBytes The number of bytes that must be in the stream
- * buffer before a task that is blocked on the stream buffer to wait for data is
- * moved out of the blocked state.  For example, if a task is blocked on a read
- * of an empty stream buffer that has a trigger level of 1 then the task will be
- * unblocked when a single byte is written to the buffer or the task's block
- * time expires.  As another example, if a task is blocked on a read of an empty
- * stream buffer that has a trigger level of 10 then the task will not be
- * unblocked until the stream buffer contains at least 10 bytes or the task's
- * block time expires.  If a reading task's block time expires before the
- * trigger level is reached then the task will still receive however many bytes
- * are actually available.  Setting a trigger level of 0 will result in a
- * trigger level of 1 being used.  It is not valid to specify a trigger level
- * that is greater than the buffer size.
- *
- * @param pucStreamBufferStorageArea Must point to a uint8_t array that is at
- * least xBufferSizeBytes + 1 big.  This is the array to which streams are
- * copied when they are written to the stream buffer.
- *
- * @param pxStaticStreamBuffer Must point to a variable of type
- * StaticStreamBuffer_t, which will be used to hold the stream buffer's data
- * structure.
- *
- * @return If the stream buffer is created successfully then a handle to the
- * created stream buffer is returned. If either pucStreamBufferStorageArea or
- * pxStaticstreamBuffer are NULL then NULL is returned.
- *
- * Example use:
-<pre>
-
-// Used to dimension the array used to hold the streams.  The available space
-// will actually be one less than this, so 999.
-#define STORAGE_SIZE_BYTES 1000
-
-// Defines the memory that will actually hold the streams within the stream
-// buffer.
-static uint8_t ucStorageBuffer[ STORAGE_SIZE_BYTES ];
-
-// The variable used to hold the stream buffer structure.
-StaticStreamBuffer_t xStreamBufferStruct;
-
-void MyFunction( void )
-{
-StreamBufferHandle_t xStreamBuffer;
-const size_t xTriggerLevel = 1;
-
-    xStreamBuffer = xStreamBufferCreateStatic( sizeof( ucBufferStorage ),
-                                               xTriggerLevel,
-                                               ucBufferStorage,
-                                               &xStreamBufferStruct );
-
-    // As neither the pucStreamBufferStorageArea or pxStaticStreamBuffer
-    // parameters were NULL, xStreamBuffer will not be NULL, and can be used to
-    // reference the created stream buffer in other stream buffer API calls.
-
-    // Other code that uses the stream buffer can go here.
-}
-
-</pre>
- * \defgroup xStreamBufferCreateStatic xStreamBufferCreateStatic
- * \ingroup StreamBufferManagement
- */
-#define xStreamBufferCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pucStreamBufferStorageArea, pxStaticStreamBuffer ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE, pucStreamBufferStorageArea, pxStaticStreamBuffer )
-
-/**
- * stream_buffer.h
- *
-<pre>
-size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
-                          const void *pvTxData,
-                          size_t xDataLengthBytes,
-                          TickType_t xTicksToWait );
-</pre>
- *
- * Sends bytes to a stream buffer.  The bytes are copied into the stream buffer.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xStreamBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xStreamBufferReceive()) inside a critical section and set the receive
- * block time to 0.
- *
- * Use xStreamBufferSend() to write to a stream buffer from a task.  Use
- * xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
- * service routine (ISR).
- *
- * @param xStreamBuffer The handle of the stream buffer to which a stream is
- * being sent.
- *
- * @param pvTxData A pointer to the buffer that holds the bytes to be copied
- * into the stream buffer.
- *
- * @param xDataLengthBytes   The maximum number of bytes to copy from pvTxData
- * into the stream buffer.
- *
- * @param xTicksToWait The maximum amount of time the task should remain in the
- * Blocked state to wait for enough space to become available in the stream
- * buffer, should the stream buffer contain too little space to hold the
- * another xDataLengthBytes bytes.  The block time is specified in tick periods,
- * so the absolute time it represents is dependent on the tick frequency.  The
- * macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds
- * into a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will
- * cause the task to wait indefinitely (without timing out), provided
- * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  If a task times out
- * before it can write all xDataLengthBytes into the buffer it will still write
- * as many bytes as possible.  A task does not use any CPU time when it is in
- * the blocked state.
- *
- * @return The number of bytes written to the stream buffer.  If a task times
- * out before it can write all xDataLengthBytes into the buffer it will still
- * write as many bytes as possible.
- *
- * Example use:
-<pre>
-void vAFunction( StreamBufferHandle_t xStreamBuffer )
-{
-size_t xBytesSent;
-uint8_t ucArrayToSend[] = { 0, 1, 2, 3 };
-char *pcStringToSend = "String to send";
-const TickType_t x100ms = pdMS_TO_TICKS( 100 );
-
-    // Send an array to the stream buffer, blocking for a maximum of 100ms to
-    // wait for enough space to be available in the stream buffer.
-    xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );
-
-    if( xBytesSent != sizeof( ucArrayToSend ) )
-    {
-        // The call to xStreamBufferSend() times out before there was enough
-        // space in the buffer for the data to be written, but it did
-        // successfully write xBytesSent bytes.
-    }
-
-    // Send the string to the stream buffer.  Return immediately if there is not
-    // enough space in the buffer.
-    xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );
-
-    if( xBytesSent != strlen( pcStringToSend ) )
-    {
-        // The entire string could not be added to the stream buffer because
-        // there was not enough free space in the buffer, but xBytesSent bytes
-        // were sent.  Could try again to send the remaining bytes.
-    }
-}
-</pre>
- * \defgroup xStreamBufferSend xStreamBufferSend
- * \ingroup StreamBufferManagement
- */
-size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
-						  const void *pvTxData,
-						  size_t xDataLengthBytes,
-						  TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
-                                 const void *pvTxData,
-                                 size_t xDataLengthBytes,
-                                 BaseType_t *pxHigherPriorityTaskWoken );
-</pre>
- *
- * Interrupt safe version of the API function that sends a stream of bytes to
- * the stream buffer.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xStreamBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xStreamBufferReceive()) inside a critical section and set the receive
- * block time to 0.
- *
- * Use xStreamBufferSend() to write to a stream buffer from a task.  Use
- * xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
- * service routine (ISR).
- *
- * @param xStreamBuffer The handle of the stream buffer to which a stream is
- * being sent.
- *
- * @param pvTxData A pointer to the data that is to be copied into the stream
- * buffer.
- *
- * @param xDataLengthBytes The maximum number of bytes to copy from pvTxData
- * into the stream buffer.
- *
- * @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
- * have a task blocked on it waiting for data.  Calling
- * xStreamBufferSendFromISR() can make data available, and so cause a task that
- * was waiting for data to leave the Blocked state.  If calling
- * xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the
- * unblocked task has a priority higher than the currently executing task (the
- * task that was interrupted), then, internally, xStreamBufferSendFromISR()
- * will set *pxHigherPriorityTaskWoken to pdTRUE.  If
- * xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a
- * context switch should be performed before the interrupt is exited.  This will
- * ensure that the interrupt returns directly to the highest priority Ready
- * state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it
- * is passed into the function.  See the example code below for an example.
- *
- * @return The number of bytes actually written to the stream buffer, which will
- * be less than xDataLengthBytes if the stream buffer didn't have enough free
- * space for all the bytes to be written.
- *
- * Example use:
-<pre>
-// A stream buffer that has already been created.
-StreamBufferHandle_t xStreamBuffer;
-
-void vAnInterruptServiceRoutine( void )
-{
-size_t xBytesSent;
-char *pcStringToSend = "String to send";
-BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.
-
-    // Attempt to send the string to the stream buffer.
-    xBytesSent = xStreamBufferSendFromISR( xStreamBuffer,
-                                           ( void * ) pcStringToSend,
-                                           strlen( pcStringToSend ),
-                                           &xHigherPriorityTaskWoken );
-
-    if( xBytesSent != strlen( pcStringToSend ) )
-    {
-        // There was not enough free space in the stream buffer for the entire
-        // string to be written, ut xBytesSent bytes were written.
-    }
-
-    // If xHigherPriorityTaskWoken was set to pdTRUE inside
-    // xStreamBufferSendFromISR() then a task that has a priority above the
-    // priority of the currently executing task was unblocked and a context
-    // switch should be performed to ensure the ISR returns to the unblocked
-    // task.  In most FreeRTOS ports this is done by simply passing
-    // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the
-    // variables value, and perform the context switch if necessary.  Check the
-    // documentation for the port in use for port specific instructions.
-    taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );
-}
-</pre>
- * \defgroup xStreamBufferSendFromISR xStreamBufferSendFromISR
- * \ingroup StreamBufferManagement
- */
-size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
-								 const void *pvTxData,
-								 size_t xDataLengthBytes,
-								 BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
-                             void *pvRxData,
-                             size_t xBufferLengthBytes,
-                             TickType_t xTicksToWait );
-</pre>
- *
- * Receives bytes from a stream buffer.
- *
- * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
- * implementation (so also the message buffer implementation, as message buffers
- * are built on top of stream buffers) assumes there is only one task or
- * interrupt that will write to the buffer (the writer), and only one task or
- * interrupt that will read from the buffer (the reader).  It is safe for the
- * writer and reader to be different tasks or interrupts, but, unlike other
- * FreeRTOS objects, it is not safe to have multiple different writers or
- * multiple different readers.  If there are to be multiple different writers
- * then the application writer must place each call to a writing API function
- * (such as xStreamBufferSend()) inside a critical section and set the send
- * block time to 0.  Likewise, if there are to be multiple different readers
- * then the application writer must place each call to a reading API function
- * (such as xStreamBufferReceive()) inside a critical section and set the receive
- * block time to 0.
- *
- * Use xStreamBufferReceive() to read from a stream buffer from a task.  Use
- * xStreamBufferReceiveFromISR() to read from a stream buffer from an
- * interrupt service routine (ISR).
- *
- * @param xStreamBuffer The handle of the stream buffer from which bytes are to
- * be received.
- *
- * @param pvRxData A pointer to the buffer into which the received bytes will be
- * copied.
- *
- * @param xBufferLengthBytes The length of the buffer pointed to by the
- * pvRxData parameter.  This sets the maximum number of bytes to receive in one
- * call.  xStreamBufferReceive will return as many bytes as possible up to a
- * maximum set by xBufferLengthBytes.
- *
- * @param xTicksToWait The maximum amount of time the task should remain in the
- * Blocked state to wait for data to become available if the stream buffer is
- * empty.  xStreamBufferReceive() will return immediately if xTicksToWait is
- * zero.  The block time is specified in tick periods, so the absolute time it
- * represents is dependent on the tick frequency.  The macro pdMS_TO_TICKS() can
- * be used to convert a time specified in milliseconds into a time specified in
- * ticks.  Setting xTicksToWait to portMAX_DELAY will cause the task to wait
- * indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1
- * in FreeRTOSConfig.h.  A task does not use any CPU time when it is in the
- * Blocked state.
- *
- * @return The number of bytes actually read from the stream buffer, which will
- * be less than xBufferLengthBytes if the call to xStreamBufferReceive() timed
- * out before xBufferLengthBytes were available.
- *
- * Example use:
-<pre>
-void vAFunction( StreamBuffer_t xStreamBuffer )
-{
-uint8_t ucRxData[ 20 ];
-size_t xReceivedBytes;
-const TickType_t xBlockTime = pdMS_TO_TICKS( 20 );
-
-    // Receive up to another sizeof( ucRxData ) bytes from the stream buffer.
-    // Wait in the Blocked state (so not using any CPU processing time) for a
-    // maximum of 100ms for the full sizeof( ucRxData ) number of bytes to be
-    // available.
-    xReceivedBytes = xStreamBufferReceive( xStreamBuffer,
-                                           ( void * ) ucRxData,
-                                           sizeof( ucRxData ),
-                                           xBlockTime );
-
-    if( xReceivedBytes > 0 )
-    {
-        // A ucRxData contains another xRecievedBytes bytes of data, which can
-        // be processed here....
-    }
-}
-</pre>
- * \defgroup xStreamBufferReceive xStreamBufferReceive
- * \ingroup StreamBufferManagement
- */
-size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
-							 void *pvRxData,
-							 size_t xBufferLengthBytes,
-							 TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
-                                    void *pvRxData,
-                                    size_t xBufferLengthBytes,
-                                    BaseType_t *pxHigherPriorityTaskWoken );
-</pre>
- *
- * An interrupt safe version of the API function that receives bytes from a
- * stream buffer.
- *
- * Use xStreamBufferReceive() to read bytes from a stream buffer from a task.
- * Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an
- * interrupt service routine (ISR).
- *
- * @param xStreamBuffer The handle of the stream buffer from which a stream
- * is being received.
- *
- * @param pvRxData A pointer to the buffer into which the received bytes are
- * copied.
- *
- * @param xBufferLengthBytes The length of the buffer pointed to by the
- * pvRxData parameter.  This sets the maximum number of bytes to receive in one
- * call.  xStreamBufferReceive will return as many bytes as possible up to a
- * maximum set by xBufferLengthBytes.
- *
- * @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
- * have a task blocked on it waiting for space to become available.  Calling
- * xStreamBufferReceiveFromISR() can make space available, and so cause a task
- * that is waiting for space to leave the Blocked state.  If calling
- * xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and
- * the unblocked task has a priority higher than the currently executing task
- * (the task that was interrupted), then, internally,
- * xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.
- * If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a
- * context switch should be performed before the interrupt is exited.  That will
- * ensure the interrupt returns directly to the highest priority Ready state
- * task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is
- * passed into the function.  See the code example below for an example.
- *
- * @return The number of bytes read from the stream buffer, if any.
- *
- * Example use:
-<pre>
-// A stream buffer that has already been created.
-StreamBuffer_t xStreamBuffer;
-
-void vAnInterruptServiceRoutine( void )
-{
-uint8_t ucRxData[ 20 ];
-size_t xReceivedBytes;
-BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.
-
-    // Receive the next stream from the stream buffer.
-    xReceivedBytes = xStreamBufferReceiveFromISR( xStreamBuffer,
-                                                  ( void * ) ucRxData,
-                                                  sizeof( ucRxData ),
-                                                  &xHigherPriorityTaskWoken );
-
-    if( xReceivedBytes > 0 )
-    {
-        // ucRxData contains xReceivedBytes read from the stream buffer.
-        // Process the stream here....
-    }
-
-    // If xHigherPriorityTaskWoken was set to pdTRUE inside
-    // xStreamBufferReceiveFromISR() then a task that has a priority above the
-    // priority of the currently executing task was unblocked and a context
-    // switch should be performed to ensure the ISR returns to the unblocked
-    // task.  In most FreeRTOS ports this is done by simply passing
-    // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the
-    // variables value, and perform the context switch if necessary.  Check the
-    // documentation for the port in use for port specific instructions.
-    taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );
-}
-</pre>
- * \defgroup xStreamBufferReceiveFromISR xStreamBufferReceiveFromISR
- * \ingroup StreamBufferManagement
- */
-size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
-									void *pvRxData,
-									size_t xBufferLengthBytes,
-									BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer );
-</pre>
- *
- * Deletes a stream buffer that was previously created using a call to
- * xStreamBufferCreate() or xStreamBufferCreateStatic().  If the stream
- * buffer was created using dynamic memory (that is, by xStreamBufferCreate()),
- * then the allocated memory is freed.
- *
- * A stream buffer handle must not be used after the stream buffer has been
- * deleted.
- *
- * @param xStreamBuffer The handle of the stream buffer to be deleted.
- *
- * \defgroup vStreamBufferDelete vStreamBufferDelete
- * \ingroup StreamBufferManagement
- */
-void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer );
-</pre>
- *
- * Queries a stream buffer to see if it is full.  A stream buffer is full if it
- * does not have any free space, and therefore cannot accept any more data.
- *
- * @param xStreamBuffer The handle of the stream buffer being queried.
- *
- * @return If the stream buffer is full then pdTRUE is returned.  Otherwise
- * pdFALSE is returned.
- *
- * \defgroup xStreamBufferIsFull xStreamBufferIsFull
- * \ingroup StreamBufferManagement
- */
-BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer );
-</pre>
- *
- * Queries a stream buffer to see if it is empty.  A stream buffer is empty if
- * it does not contain any data.
- *
- * @param xStreamBuffer The handle of the stream buffer being queried.
- *
- * @return If the stream buffer is empty then pdTRUE is returned.  Otherwise
- * pdFALSE is returned.
- *
- * \defgroup xStreamBufferIsEmpty xStreamBufferIsEmpty
- * \ingroup StreamBufferManagement
- */
-BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer );
-</pre>
- *
- * Resets a stream buffer to its initial, empty, state.  Any data that was in
- * the stream buffer is discarded.  A stream buffer can only be reset if there
- * are no tasks blocked waiting to either send to or receive from the stream
- * buffer.
- *
- * @param xStreamBuffer The handle of the stream buffer being reset.
- *
- * @return If the stream buffer is reset then pdPASS is returned.  If there was
- * a task blocked waiting to send to or read from the stream buffer then the
- * stream buffer is not reset and pdFAIL is returned.
- *
- * \defgroup xStreamBufferReset xStreamBufferReset
- * \ingroup StreamBufferManagement
- */
-BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer );
-</pre>
- *
- * Queries a stream buffer to see how much free space it contains, which is
- * equal to the amount of data that can be sent to the stream buffer before it
- * is full.
- *
- * @param xStreamBuffer The handle of the stream buffer being queried.
- *
- * @return The number of bytes that can be written to the stream buffer before
- * the stream buffer would be full.
- *
- * \defgroup xStreamBufferSpacesAvailable xStreamBufferSpacesAvailable
- * \ingroup StreamBufferManagement
- */
-size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer );
-</pre>
- *
- * Queries a stream buffer to see how much data it contains, which is equal to
- * the number of bytes that can be read from the stream buffer before the stream
- * buffer would be empty.
- *
- * @param xStreamBuffer The handle of the stream buffer being queried.
- *
- * @return The number of bytes that can be read from the stream buffer before
- * the stream buffer would be empty.
- *
- * \defgroup xStreamBufferBytesAvailable xStreamBufferBytesAvailable
- * \ingroup StreamBufferManagement
- */
-size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel );
-</pre>
- *
- * A stream buffer's trigger level is the number of bytes that must be in the
- * stream buffer before a task that is blocked on the stream buffer to
- * wait for data is moved out of the blocked state.  For example, if a task is
- * blocked on a read of an empty stream buffer that has a trigger level of 1
- * then the task will be unblocked when a single byte is written to the buffer
- * or the task's block time expires.  As another example, if a task is blocked
- * on a read of an empty stream buffer that has a trigger level of 10 then the
- * task will not be unblocked until the stream buffer contains at least 10 bytes
- * or the task's block time expires.  If a reading task's block time expires
- * before the trigger level is reached then the task will still receive however
- * many bytes are actually available.  Setting a trigger level of 0 will result
- * in a trigger level of 1 being used.  It is not valid to specify a trigger
- * level that is greater than the buffer size.
- *
- * A trigger level is set when the stream buffer is created, and can be modified
- * using xStreamBufferSetTriggerLevel().
- *
- * @param xStreamBuffer The handle of the stream buffer being updated.
- *
- * @param xTriggerLevel The new trigger level for the stream buffer.
- *
- * @return If xTriggerLevel was less than or equal to the stream buffer's length
- * then the trigger level will be updated and pdTRUE is returned.  Otherwise
- * pdFALSE is returned.
- *
- * \defgroup xStreamBufferSetTriggerLevel xStreamBufferSetTriggerLevel
- * \ingroup StreamBufferManagement
- */
-BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
-</pre>
- *
- * For advanced users only.
- *
- * The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when
- * data is sent to a message buffer or stream buffer.  If there was a task that
- * was blocked on the message or stream buffer waiting for data to arrive then
- * the sbSEND_COMPLETED() macro sends a notification to the task to remove it
- * from the Blocked state.  xStreamBufferSendCompletedFromISR() does the same
- * thing.  It is provided to enable application writers to implement their own
- * version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.
- *
- * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
- * additional information.
- *
- * @param xStreamBuffer The handle of the stream buffer to which data was
- * written.
- *
- * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
- * initialised to pdFALSE before it is passed into
- * xStreamBufferSendCompletedFromISR().  If calling
- * xStreamBufferSendCompletedFromISR() removes a task from the Blocked state,
- * and the task has a priority above the priority of the currently running task,
- * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
- * context switch should be performed before exiting the ISR.
- *
- * @return If a task was removed from the Blocked state then pdTRUE is returned.
- * Otherwise pdFALSE is returned.
- *
- * \defgroup xStreamBufferSendCompletedFromISR xStreamBufferSendCompletedFromISR
- * \ingroup StreamBufferManagement
- */
-BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/**
- * stream_buffer.h
- *
-<pre>
-BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
-</pre>
- *
- * For advanced users only.
- *
- * The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when
- * data is read out of a message buffer or stream buffer.  If there was a task
- * that was blocked on the message or stream buffer waiting for data to arrive
- * then the sbRECEIVE_COMPLETED() macro sends a notification to the task to
- * remove it from the Blocked state.  xStreamBufferReceiveCompletedFromISR()
- * does the same thing.  It is provided to enable application writers to
- * implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT
- * ANY OTHER TIME.
- *
- * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
- * additional information.
- *
- * @param xStreamBuffer The handle of the stream buffer from which data was
- * read.
- *
- * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
- * initialised to pdFALSE before it is passed into
- * xStreamBufferReceiveCompletedFromISR().  If calling
- * xStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state,
- * and the task has a priority above the priority of the currently running task,
- * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
- * context switch should be performed before exiting the ISR.
- *
- * @return If a task was removed from the Blocked state then pdTRUE is returned.
- * Otherwise pdFALSE is returned.
- *
- * \defgroup xStreamBufferReceiveCompletedFromISR xStreamBufferReceiveCompletedFromISR
- * \ingroup StreamBufferManagement
- */
-BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/* Functions below here are not part of the public API. */
-StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
-												 size_t xTriggerLevelBytes,
-												 BaseType_t xIsMessageBuffer ) PRIVILEGED_FUNCTION;
-
-StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
-													   size_t xTriggerLevelBytes,
-													   BaseType_t xIsMessageBuffer,
-													   uint8_t * const pucStreamBufferStorageArea,
-													   StaticStreamBuffer_t * const pxStaticStreamBuffer ) PRIVILEGED_FUNCTION;
-
-size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-
-#if( configUSE_TRACE_FACILITY == 1 )
-	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber ) PRIVILEGED_FUNCTION;
-	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;
-#endif
-
-#if defined( __cplusplus )
-}
-#endif
-
-#endif	/* !defined( STREAM_BUFFER_H ) */
diff --git a/osal/inc/freertos/task.h b/osal/inc/freertos/task.h
deleted file mode 100644
index b0cc60b..0000000
--- a/osal/inc/freertos/task.h
+++ /dev/null
@@ -1,2543 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef INC_TASK_H
-#define INC_TASK_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h must appear in source files before include task.h"
-#endif
-
-#include "list.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * MACROS AND DEFINITIONS
- *----------------------------------------------------------*/
-
-#define tskKERNEL_VERSION_NUMBER "V10.3.1"
-#define tskKERNEL_VERSION_MAJOR 10
-#define tskKERNEL_VERSION_MINOR 3
-#define tskKERNEL_VERSION_BUILD 1
-
-/* MPU region parameters passed in ulParameters
- * of MemoryRegion_t struct. */
-#define tskMPU_REGION_READ_ONLY			( 1UL << 0UL )
-#define tskMPU_REGION_READ_WRITE		( 1UL << 1UL )
-#define tskMPU_REGION_EXECUTE_NEVER		( 1UL << 2UL )
-#define tskMPU_REGION_NORMAL_MEMORY		( 1UL << 3UL )
-#define tskMPU_REGION_DEVICE_MEMORY		( 1UL << 4UL )
-
-/**
- * task. h
- *
- * Type by which tasks are referenced.  For example, a call to xTaskCreate
- * returns (via a pointer parameter) an TaskHandle_t variable that can then
- * be used as a parameter to vTaskDelete to delete the task.
- *
- * \defgroup TaskHandle_t TaskHandle_t
- * \ingroup Tasks
- */
-struct tskTaskControlBlock; /* The old naming convention is used to prevent breaking kernel aware debuggers. */
-typedef struct tskTaskControlBlock* TaskHandle_t;
-
-/*
- * Defines the prototype to which the application task hook function must
- * conform.
- */
-typedef BaseType_t (*TaskHookFunction_t)( void * );
-
-/* Task states returned by eTaskGetState. */
-typedef enum
-{
-	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
-	eReady,			/* The task being queried is in a read or pending ready list. */
-	eBlocked,		/* The task being queried is in the Blocked state. */
-	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
-	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
-	eInvalid		/* Used as an 'invalid state' value. */
-} eTaskState;
-
-/* Actions that can be performed when vTaskNotify() is called. */
-typedef enum
-{
-	eNoAction = 0,				/* Notify the task without updating its notify value. */
-	eSetBits,					/* Set bits in the task's notification value. */
-	eIncrement,					/* Increment the task's notification value. */
-	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
-	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
-} eNotifyAction;
-
-/*
- * Used internally only.
- */
-typedef struct xTIME_OUT
-{
-	BaseType_t xOverflowCount;
-	TickType_t xTimeOnEntering;
-} TimeOut_t;
-
-/*
- * Defines the memory ranges allocated to the task when an MPU is used.
- */
-typedef struct xMEMORY_REGION
-{
-	void *pvBaseAddress;
-	uint32_t ulLengthInBytes;
-	uint32_t ulParameters;
-} MemoryRegion_t;
-
-/*
- * Parameters required to create an MPU protected task.
- */
-typedef struct xTASK_PARAMETERS
-{
-	TaskFunction_t pvTaskCode;
-	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	configSTACK_DEPTH_TYPE usStackDepth;
-	void *pvParameters;
-	UBaseType_t uxPriority;
-	StackType_t *puxStackBuffer;
-	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
-	#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-		StaticTask_t * const pxTaskBuffer;
-	#endif
-} TaskParameters_t;
-
-/* Used with the uxTaskGetSystemState() function to return the state of each task
-in the system. */
-typedef struct xTASK_STATUS
-{
-	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
-	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	UBaseType_t xTaskNumber;		/* A number unique to the task. */
-	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
-	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
-	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
-	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
-	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
-	configSTACK_DEPTH_TYPE usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
-} TaskStatus_t;
-
-/* Possible return values for eTaskConfirmSleepModeStatus(). */
-typedef enum
-{
-	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
-	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
-	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
-} eSleepModeStatus;
-
-/**
- * Defines the priority used by the idle task.  This must not be modified.
- *
- * \ingroup TaskUtils
- */
-#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
-
-/**
- * task. h
- *
- * Macro for forcing a context switch.
- *
- * \defgroup taskYIELD taskYIELD
- * \ingroup SchedulerControl
- */
-#define taskYIELD()					portYIELD()
-
-/**
- * task. h
- *
- * Macro to mark the start of a critical code region.  Preemptive context
- * switches cannot occur when in a critical region.
- *
- * NOTE: This may alter the stack (depending on the portable implementation)
- * so must be used with care!
- *
- * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
- * \ingroup SchedulerControl
- */
-#define taskENTER_CRITICAL()		portENTER_CRITICAL()
-#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
-
-/**
- * task. h
- *
- * Macro to mark the end of a critical code region.  Preemptive context
- * switches cannot occur when in a critical region.
- *
- * NOTE: This may alter the stack (depending on the portable implementation)
- * so must be used with care!
- *
- * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
- * \ingroup SchedulerControl
- */
-#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
-#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
-/**
- * task. h
- *
- * Macro to disable all maskable interrupts.
- *
- * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
- * \ingroup SchedulerControl
- */
-#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
-
-/**
- * task. h
- *
- * Macro to enable microcontroller interrupts.
- *
- * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
- * \ingroup SchedulerControl
- */
-#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
-
-/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
-0 to generate more optimal code when configASSERT() is defined as the constant
-is used in assert() statements. */
-#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
-#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
-#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
-
-
-/*-----------------------------------------------------------
- * TASK CREATION API
- *----------------------------------------------------------*/
-
-/**
- * task. h
- *<pre>
- BaseType_t xTaskCreate(
-							  TaskFunction_t pvTaskCode,
-							  const char * const pcName,
-							  configSTACK_DEPTH_TYPE usStackDepth,
-							  void *pvParameters,
-							  UBaseType_t uxPriority,
-							  TaskHandle_t *pvCreatedTask
-						  );</pre>
- *
- * Create a new task and add it to the list of tasks that are ready to run.
- *
- * Internally, within the FreeRTOS implementation, tasks use two blocks of
- * memory.  The first block is used to hold the task's data structures.  The
- * second block is used by the task as its stack.  If a task is created using
- * xTaskCreate() then both blocks of memory are automatically dynamically
- * allocated inside the xTaskCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a task is created using
- * xTaskCreateStatic() then the application writer must provide the required
- * memory.  xTaskCreateStatic() therefore allows a task to be created without
- * using any dynamic memory allocation.
- *
- * See xTaskCreateStatic() for a version that does not use any dynamic memory
- * allocation.
- *
- * xTaskCreate() can only be used to create a task that has unrestricted
- * access to the entire microcontroller memory map.  Systems that include MPU
- * support can alternatively create an MPU constrained task using
- * xTaskCreateRestricted().
- *
- * @param pvTaskCode Pointer to the task entry function.  Tasks
- * must be implemented to never return (i.e. continuous loop).
- *
- * @param pcName A descriptive name for the task.  This is mainly used to
- * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
- * is 16.
- *
- * @param usStackDepth The size of the task stack specified as the number of
- * variables the stack can hold - not the number of bytes.  For example, if
- * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
- * will be allocated for stack storage.
- *
- * @param pvParameters Pointer that will be used as the parameter for the task
- * being created.
- *
- * @param uxPriority The priority at which the task should run.  Systems that
- * include MPU support can optionally create tasks in a privileged (system)
- * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
- * example, to create a privileged task at priority 2 the uxPriority parameter
- * should be set to ( 2 | portPRIVILEGE_BIT ).
- *
- * @param pvCreatedTask Used to pass back a handle by which the created task
- * can be referenced.
- *
- * @return pdPASS if the task was successfully created and added to a ready
- * list, otherwise an error code defined in the file projdefs.h
- *
- * Example usage:
-   <pre>
- // Task to be created.
- void vTaskCode( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-	 }
- }
-
- // Function that creates a task.
- void vOtherFunction( void )
- {
- static uint8_t ucParameterToPass;
- TaskHandle_t xHandle = NULL;
-
-	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
-	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
-	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
-	 // the new task attempts to access it.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
-	 configASSERT( xHandle );
-
-	 // Use the handle to delete the task.
-	 if( xHandle != NULL )
-	 {
-	 	vTaskDelete( xHandle );
-	 }
- }
-   </pre>
- * \defgroup xTaskCreate xTaskCreate
- * \ingroup Tasks
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
-							const char * const pcName,	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-							const configSTACK_DEPTH_TYPE usStackDepth,
-							void * const pvParameters,
-							UBaseType_t uxPriority,
-							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * task. h
- *<pre>
- TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
-								 const char * const pcName,
-								 uint32_t ulStackDepth,
-								 void *pvParameters,
-								 UBaseType_t uxPriority,
-								 StackType_t *pxStackBuffer,
-								 StaticTask_t *pxTaskBuffer );</pre>
- *
- * Create a new task and add it to the list of tasks that are ready to run.
- *
- * Internally, within the FreeRTOS implementation, tasks use two blocks of
- * memory.  The first block is used to hold the task's data structures.  The
- * second block is used by the task as its stack.  If a task is created using
- * xTaskCreate() then both blocks of memory are automatically dynamically
- * allocated inside the xTaskCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a task is created using
- * xTaskCreateStatic() then the application writer must provide the required
- * memory.  xTaskCreateStatic() therefore allows a task to be created without
- * using any dynamic memory allocation.
- *
- * @param pvTaskCode Pointer to the task entry function.  Tasks
- * must be implemented to never return (i.e. continuous loop).
- *
- * @param pcName A descriptive name for the task.  This is mainly used to
- * facilitate debugging.  The maximum length of the string is defined by
- * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
- *
- * @param ulStackDepth The size of the task stack specified as the number of
- * variables the stack can hold - not the number of bytes.  For example, if
- * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
- * will be allocated for stack storage.
- *
- * @param pvParameters Pointer that will be used as the parameter for the task
- * being created.
- *
- * @param uxPriority The priority at which the task will run.
- *
- * @param pxStackBuffer Must point to a StackType_t array that has at least
- * ulStackDepth indexes - the array will then be used as the task's stack,
- * removing the need for the stack to be allocated dynamically.
- *
- * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
- * then be used to hold the task's data structures, removing the need for the
- * memory to be allocated dynamically.
- *
- * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
- * be created and a handle to the created task is returned.  If either
- * pxStackBuffer or pxTaskBuffer are NULL then the task will not be created and
- * NULL is returned.
- *
- * Example usage:
-   <pre>
-
-    // Dimensions the buffer that the task being created will use as its stack.
-    // NOTE:  This is the number of words the stack will hold, not the number of
-    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
-    // then 400 bytes (100 * 32-bits) will be allocated.
-    #define STACK_SIZE 200
-
-    // Structure that will hold the TCB of the task being created.
-    StaticTask_t xTaskBuffer;
-
-    // Buffer that the task being created will use as its stack.  Note this is
-    // an array of StackType_t variables.  The size of StackType_t is dependent on
-    // the RTOS port.
-    StackType_t xStack[ STACK_SIZE ];
-
-    // Function that implements the task being created.
-    void vTaskCode( void * pvParameters )
-    {
-        // The parameter value is expected to be 1 as 1 is passed in the
-        // pvParameters value in the call to xTaskCreateStatic().
-        configASSERT( ( uint32_t ) pvParameters == 1UL );
-
-        for( ;; )
-        {
-            // Task code goes here.
-        }
-    }
-
-    // Function that creates a task.
-    void vOtherFunction( void )
-    {
-        TaskHandle_t xHandle = NULL;
-
-        // Create the task without using any dynamic memory allocation.
-        xHandle = xTaskCreateStatic(
-                      vTaskCode,       // Function that implements the task.
-                      "NAME",          // Text name for the task.
-                      STACK_SIZE,      // Stack size in words, not bytes.
-                      ( void * ) 1,    // Parameter passed into the task.
-                      tskIDLE_PRIORITY,// Priority at which the task is created.
-                      xStack,          // Array to use as the task's stack.
-                      &xTaskBuffer );  // Variable to hold the task's data structure.
-
-        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
-        // been created, and xHandle will be the task's handle.  Use the handle
-        // to suspend the task.
-        vTaskSuspend( xHandle );
-    }
-   </pre>
- * \defgroup xTaskCreateStatic xTaskCreateStatic
- * \ingroup Tasks
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
-									const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-									const uint32_t ulStackDepth,
-									void * const pvParameters,
-									UBaseType_t uxPriority,
-									StackType_t * const puxStackBuffer,
-									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-/**
- * task. h
- *<pre>
- BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
- *
- * Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.
- *
- * xTaskCreateRestricted() should only be used in systems that include an MPU
- * implementation.
- *
- * Create a new task and add it to the list of tasks that are ready to run.
- * The function parameters define the memory regions and associated access
- * permissions allocated to the task.
- *
- * See xTaskCreateRestrictedStatic() for a version that does not use any
- * dynamic memory allocation.
- *
- * @param pxTaskDefinition Pointer to a structure that contains a member
- * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
- * documentation) plus an optional stack buffer and the memory region
- * definitions.
- *
- * @param pxCreatedTask Used to pass back a handle by which the created task
- * can be referenced.
- *
- * @return pdPASS if the task was successfully created and added to a ready
- * list, otherwise an error code defined in the file projdefs.h
- *
- * Example usage:
-   <pre>
-// Create an TaskParameters_t structure that defines the task to be created.
-static const TaskParameters_t xCheckTaskParameters =
-{
-	vATask,		// pvTaskCode - the function that implements the task.
-	"ATask",	// pcName - just a text name for the task to assist debugging.
-	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
-	NULL,		// pvParameters - passed into the task function as the function parameters.
-	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
-	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
-
-	// xRegions - Allocate up to three separate memory regions for access by
-	// the task, with appropriate access permissions.  Different processors have
-	// different memory alignment requirements - refer to the FreeRTOS documentation
-	// for full information.
-	{
-		// Base address					Length	Parameters
-		{ cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
-		{ cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
-		{ cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
-	}
-};
-
-int main( void )
-{
-TaskHandle_t xHandle;
-
-	// Create a task from the const structure defined above.  The task handle
-	// is requested (the second parameter is not NULL) but in this case just for
-	// demonstration purposes as its not actually used.
-	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
-
-	// Start the scheduler.
-	vTaskStartScheduler();
-
-	// Will only get here if there was insufficient memory to create the idle
-	// and/or timer task.
-	for( ;; );
-}
-   </pre>
- * \defgroup xTaskCreateRestricted xTaskCreateRestricted
- * \ingroup Tasks
- */
-#if( portUSING_MPU_WRAPPERS == 1 )
-	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * task. h
- *<pre>
- BaseType_t xTaskCreateRestrictedStatic( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
- *
- * Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.
- *
- * xTaskCreateRestrictedStatic() should only be used in systems that include an
- * MPU implementation.
- *
- * Internally, within the FreeRTOS implementation, tasks use two blocks of
- * memory.  The first block is used to hold the task's data structures.  The
- * second block is used by the task as its stack.  If a task is created using
- * xTaskCreateRestricted() then the stack is provided by the application writer,
- * and the memory used to hold the task's data structure is automatically
- * dynamically allocated inside the xTaskCreateRestricted() function.  If a task
- * is created using xTaskCreateRestrictedStatic() then the application writer
- * must provide the memory used to hold the task's data structures too.
- * xTaskCreateRestrictedStatic() therefore allows a memory protected task to be
- * created without using any dynamic memory allocation.
- *
- * @param pxTaskDefinition Pointer to a structure that contains a member
- * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
- * documentation) plus an optional stack buffer and the memory region
- * definitions.  If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure
- * contains an additional member, which is used to point to a variable of type
- * StaticTask_t - which is then used to hold the task's data structure.
- *
- * @param pxCreatedTask Used to pass back a handle by which the created task
- * can be referenced.
- *
- * @return pdPASS if the task was successfully created and added to a ready
- * list, otherwise an error code defined in the file projdefs.h
- *
- * Example usage:
-   <pre>
-// Create an TaskParameters_t structure that defines the task to be created.
-// The StaticTask_t variable is only included in the structure when
-// configSUPPORT_STATIC_ALLOCATION is set to 1.  The PRIVILEGED_DATA macro can
-// be used to force the variable into the RTOS kernel's privileged data area.
-static PRIVILEGED_DATA StaticTask_t xTaskBuffer;
-static const TaskParameters_t xCheckTaskParameters =
-{
-	vATask,		// pvTaskCode - the function that implements the task.
-	"ATask",	// pcName - just a text name for the task to assist debugging.
-	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
-	NULL,		// pvParameters - passed into the task function as the function parameters.
-	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
-	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
-
-	// xRegions - Allocate up to three separate memory regions for access by
-	// the task, with appropriate access permissions.  Different processors have
-	// different memory alignment requirements - refer to the FreeRTOS documentation
-	// for full information.
-	{
-		// Base address					Length	Parameters
-		{ cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
-		{ cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
-		{ cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
-	}
-
-	&xTaskBuffer; // Holds the task's data structure.
-};
-
-int main( void )
-{
-TaskHandle_t xHandle;
-
-	// Create a task from the const structure defined above.  The task handle
-	// is requested (the second parameter is not NULL) but in this case just for
-	// demonstration purposes as its not actually used.
-	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
-
-	// Start the scheduler.
-	vTaskStartScheduler();
-
-	// Will only get here if there was insufficient memory to create the idle
-	// and/or timer task.
-	for( ;; );
-}
-   </pre>
- * \defgroup xTaskCreateRestrictedStatic xTaskCreateRestrictedStatic
- * \ingroup Tasks
- */
-#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * task. h
- *<pre>
- void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
- *
- * Memory regions are assigned to a restricted task when the task is created by
- * a call to xTaskCreateRestricted().  These regions can be redefined using
- * vTaskAllocateMPURegions().
- *
- * @param xTask The handle of the task being updated.
- *
- * @param xRegions A pointer to an MemoryRegion_t structure that contains the
- * new memory region definitions.
- *
- * Example usage:
-   <pre>
-// Define an array of MemoryRegion_t structures that configures an MPU region
-// allowing read/write access for 1024 bytes starting at the beginning of the
-// ucOneKByte array.  The other two of the maximum 3 definable regions are
-// unused so set to zero.
-static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
-{
-	// Base address		Length		Parameters
-	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
-	{ 0,				0,			0 },
-	{ 0,				0,			0 }
-};
-
-void vATask( void *pvParameters )
-{
-	// This task was created such that it has access to certain regions of
-	// memory as defined by the MPU configuration.  At some point it is
-	// desired that these MPU regions are replaced with that defined in the
-	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
-	// for this purpose.  NULL is used as the task handle to indicate that this
-	// function should modify the MPU regions of the calling task.
-	vTaskAllocateMPURegions( NULL, xAltRegions );
-
-	// Now the task can continue its function, but from this point on can only
-	// access its stack and the ucOneKByte array (unless any other statically
-	// defined or shared regions have been declared elsewhere).
-}
-   </pre>
- * \defgroup xTaskCreateRestricted xTaskCreateRestricted
- * \ingroup Tasks
- */
-void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
- *
- * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Remove a task from the RTOS real time kernel's management.  The task being
- * deleted will be removed from all ready, blocked, suspended and event lists.
- *
- * NOTE:  The idle task is responsible for freeing the kernel allocated
- * memory from tasks that have been deleted.  It is therefore important that
- * the idle task is not starved of microcontroller processing time if your
- * application makes any calls to vTaskDelete ().  Memory allocated by the
- * task code is not automatically freed, and should be freed before the task
- * is deleted.
- *
- * See the demo application file death.c for sample code that utilises
- * vTaskDelete ().
- *
- * @param xTask The handle of the task to be deleted.  Passing NULL will
- * cause the calling task to be deleted.
- *
- * Example usage:
-   <pre>
- void vOtherFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create the task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // Use the handle to delete the task.
-	 vTaskDelete( xHandle );
- }
-   </pre>
- * \defgroup vTaskDelete vTaskDelete
- * \ingroup Tasks
- */
-void vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------
- * TASK CONTROL API
- *----------------------------------------------------------*/
-
-/**
- * task. h
- * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
- *
- * Delay a task for a given number of ticks.  The actual time that the
- * task remains blocked depends on the tick rate.  The constant
- * portTICK_PERIOD_MS can be used to calculate real time from the tick
- * rate - with the resolution of one tick period.
- *
- * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- *
- * vTaskDelay() specifies a time at which the task wishes to unblock relative to
- * the time at which vTaskDelay() is called.  For example, specifying a block
- * period of 100 ticks will cause the task to unblock 100 ticks after
- * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
- * of controlling the frequency of a periodic task as the path taken through the
- * code, as well as other task and interrupt activity, will effect the frequency
- * at which vTaskDelay() gets called and therefore the time at which the task
- * next executes.  See vTaskDelayUntil() for an alternative API function designed
- * to facilitate fixed frequency execution.  It does this by specifying an
- * absolute time (rather than a relative time) at which the calling task should
- * unblock.
- *
- * @param xTicksToDelay The amount of time, in tick periods, that
- * the calling task should block.
- *
- * Example usage:
-
- void vTaskFunction( void * pvParameters )
- {
- // Block for 500ms.
- const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
-
-	 for( ;; )
-	 {
-		 // Simply toggle the LED every 500ms, blocking between each toggle.
-		 vToggleLED();
-		 vTaskDelay( xDelay );
-	 }
- }
-
- * \defgroup vTaskDelay vTaskDelay
- * \ingroup TaskCtrl
- */
-void vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
- *
- * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Delay a task until a specified time.  This function can be used by periodic
- * tasks to ensure a constant execution frequency.
- *
- * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
- * cause a task to block for the specified number of ticks from the time vTaskDelay () is
- * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
- * execution frequency as the time between a task starting to execute and that task
- * calling vTaskDelay () may not be fixed [the task may take a different path though the
- * code between calls, or may get interrupted or preempted a different number of times
- * each time it executes].
- *
- * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
- * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
- * unblock.
- *
- * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
- * rate - with the resolution of one tick period.
- *
- * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
- * task was last unblocked.  The variable must be initialised with the current time
- * prior to its first use (see the example below).  Following this the variable is
- * automatically updated within vTaskDelayUntil ().
- *
- * @param xTimeIncrement The cycle time period.  The task will be unblocked at
- * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
- * same xTimeIncrement parameter value will cause the task to execute with
- * a fixed interface period.
- *
- * Example usage:
-   <pre>
- // Perform an action every 10 ticks.
- void vTaskFunction( void * pvParameters )
- {
- TickType_t xLastWakeTime;
- const TickType_t xFrequency = 10;
-
-	 // Initialise the xLastWakeTime variable with the current time.
-	 xLastWakeTime = xTaskGetTickCount ();
-	 for( ;; )
-	 {
-		 // Wait for the next cycle.
-		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
-
-		 // Perform action here.
-	 }
- }
-   </pre>
- * \defgroup vTaskDelayUntil vTaskDelayUntil
- * \ingroup TaskCtrl
- */
-void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
- *
- * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
- * function to be available.
- *
- * A task will enter the Blocked state when it is waiting for an event.  The
- * event it is waiting for can be a temporal event (waiting for a time), such
- * as when vTaskDelay() is called, or an event on an object, such as when
- * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
- * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
- * task will leave the Blocked state, and return from whichever function call
- * placed the task into the Blocked state.
- *
- * There is no 'FromISR' version of this function as an interrupt would need to
- * know which object a task was blocked on in order to know which actions to
- * take.  For example, if the task was blocked on a queue the interrupt handler
- * would then need to know if the queue was locked.
- *
- * @param xTask The handle of the task to remove from the Blocked state.
- *
- * @return If the task referenced by xTask was not in the Blocked state then
- * pdFAIL is returned.  Otherwise pdPASS is returned.
- *
- * \defgroup xTaskAbortDelay xTaskAbortDelay
- * \ingroup TaskCtrl
- */
-BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );</pre>
- *
- * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Obtain the priority of any task.
- *
- * @param xTask Handle of the task to be queried.  Passing a NULL
- * handle results in the priority of the calling task being returned.
- *
- * @return The priority of xTask.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to obtain the priority of the created task.
-	 // It was created with tskIDLE_PRIORITY, but may have changed
-	 // it itself.
-	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
-	 {
-		 // The task has changed it's priority.
-	 }
-
-	 // ...
-
-	 // Is our priority higher than the created task?
-	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
-	 {
-		 // Our priority (obtained using NULL handle) is higher.
-	 }
- }
-   </pre>
- * \defgroup uxTaskPriorityGet uxTaskPriorityGet
- * \ingroup TaskCtrl
- */
-UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );</pre>
- *
- * A version of uxTaskPriorityGet() that can be used from an ISR.
- */
-UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
- *
- * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Obtain the state of any task.  States are encoded by the eTaskState
- * enumerated type.
- *
- * @param xTask Handle of the task to be queried.
- *
- * @return The state of xTask at the time the function was called.  Note the
- * state of the task might change between the function being called, and the
- * functions return value being tested by the calling task.
- */
-eTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
- *
- * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
- * available.  See the configuration section for more information.
- *
- * Populates a TaskStatus_t structure with information about a task.
- *
- * @param xTask Handle of the task being queried.  If xTask is NULL then
- * information will be returned about the calling task.
- *
- * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
- * filled with information about the task referenced by the handle passed using
- * the xTask parameter.
- *
- * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
- * the stack high water mark of the task being queried.  Calculating the stack
- * high water mark takes a relatively long time, and can make the system
- * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
- * allow the high water mark checking to be skipped.  The high watermark value
- * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
- * not set to pdFALSE;
- *
- * @param eState The TaskStatus_t structure contains a member to report the
- * state of the task being queried.  Obtaining the task state is not as fast as
- * a simple assignment - so the eState parameter is provided to allow the state
- * information to be omitted from the TaskStatus_t structure.  To obtain state
- * information then set eState to eInvalid - otherwise the value passed in
- * eState will be reported as the task state in the TaskStatus_t structure.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
- TaskStatus_t xTaskDetails;
-
-    // Obtain the handle of a task from its name.
-    xHandle = xTaskGetHandle( "Task_Name" );
-
-    // Check the handle is not NULL.
-    configASSERT( xHandle );
-
-    // Use the handle to obtain further information about the task.
-    vTaskGetInfo( xHandle,
-                  &xTaskDetails,
-                  pdTRUE, // Include the high water mark in xTaskDetails.
-                  eInvalid ); // Include the task state in xTaskDetails.
- }
-   </pre>
- * \defgroup vTaskGetInfo vTaskGetInfo
- * \ingroup TaskCtrl
- */
-void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
- *
- * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Set the priority of any task.
- *
- * A context switch will occur before the function returns if the priority
- * being set is higher than the currently executing task.
- *
- * @param xTask Handle to the task for which the priority is being set.
- * Passing a NULL handle results in the priority of the calling task being set.
- *
- * @param uxNewPriority The priority to which the task will be set.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to raise the priority of the created task.
-	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
-
-	 // ...
-
-	 // Use a NULL handle to raise our priority to the same value.
-	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
- }
-   </pre>
- * \defgroup vTaskPrioritySet vTaskPrioritySet
- * \ingroup TaskCtrl
- */
-void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
- *
- * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Suspend any task.  When suspended a task will never get any microcontroller
- * processing time, no matter what its priority.
- *
- * Calls to vTaskSuspend are not accumulative -
- * i.e. calling vTaskSuspend () twice on the same task still only requires one
- * call to vTaskResume () to ready the suspended task.
- *
- * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
- * handle will cause the calling task to be suspended.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to suspend the created task.
-	 vTaskSuspend( xHandle );
-
-	 // ...
-
-	 // The created task will not run during this period, unless
-	 // another task calls vTaskResume( xHandle ).
-
-	 //...
-
-
-	 // Suspend ourselves.
-	 vTaskSuspend( NULL );
-
-	 // We cannot get here unless another task calls vTaskResume
-	 // with our handle as the parameter.
- }
-   </pre>
- * \defgroup vTaskSuspend vTaskSuspend
- * \ingroup TaskCtrl
- */
-void vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
- *
- * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Resumes a suspended task.
- *
- * A task that has been suspended by one or more calls to vTaskSuspend ()
- * will be made available for running again by a single call to
- * vTaskResume ().
- *
- * @param xTaskToResume Handle to the task being readied.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to suspend the created task.
-	 vTaskSuspend( xHandle );
-
-	 // ...
-
-	 // The created task will not run during this period, unless
-	 // another task calls vTaskResume( xHandle ).
-
-	 //...
-
-
-	 // Resume the suspended task ourselves.
-	 vTaskResume( xHandle );
-
-	 // The created task will once again get microcontroller processing
-	 // time in accordance with its priority within the system.
- }
-   </pre>
- * \defgroup vTaskResume vTaskResume
- * \ingroup TaskCtrl
- */
-void vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
- *
- * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
- * available.  See the configuration section for more information.
- *
- * An implementation of vTaskResume() that can be called from within an ISR.
- *
- * A task that has been suspended by one or more calls to vTaskSuspend ()
- * will be made available for running again by a single call to
- * xTaskResumeFromISR ().
- *
- * xTaskResumeFromISR() should not be used to synchronise a task with an
- * interrupt if there is a chance that the interrupt could arrive prior to the
- * task being suspended - as this can lead to interrupts being missed. Use of a
- * semaphore as a synchronisation mechanism would avoid this eventuality.
- *
- * @param xTaskToResume Handle to the task being readied.
- *
- * @return pdTRUE if resuming the task should result in a context switch,
- * otherwise pdFALSE. This is used by the ISR to determine if a context switch
- * may be required following the ISR.
- *
- * \defgroup vTaskResumeFromISR vTaskResumeFromISR
- * \ingroup TaskCtrl
- */
-BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------
- * SCHEDULER CONTROL
- *----------------------------------------------------------*/
-
-/**
- * task. h
- * <pre>void vTaskStartScheduler( void );</pre>
- *
- * Starts the real time kernel tick processing.  After calling the kernel
- * has control over which tasks are executed and when.
- *
- * See the demo application file main.c for an example of creating
- * tasks and starting the kernel.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
-	 // Create at least one task before starting the kernel.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
-
-	 // Start the real time kernel with preemption.
-	 vTaskStartScheduler ();
-
-	 // Will not get here unless a task calls vTaskEndScheduler ()
- }
-   </pre>
- *
- * \defgroup vTaskStartScheduler vTaskStartScheduler
- * \ingroup SchedulerControl
- */
-void vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskEndScheduler( void );</pre>
- *
- * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
- * in place of DOS, implements this function.
- *
- * Stops the real time kernel tick.  All created tasks will be automatically
- * deleted and multitasking (either preemptive or cooperative) will
- * stop.  Execution then resumes from the point where vTaskStartScheduler ()
- * was called, as if vTaskStartScheduler () had just returned.
- *
- * See the demo application file main. c in the demo/PC directory for an
- * example that uses vTaskEndScheduler ().
- *
- * vTaskEndScheduler () requires an exit function to be defined within the
- * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
- * performs hardware specific operations such as stopping the kernel tick.
- *
- * vTaskEndScheduler () will cause all of the resources allocated by the
- * kernel to be freed - but will not free resources allocated by application
- * tasks.
- *
- * Example usage:
-   <pre>
- void vTaskCode( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-
-		 // At some point we want to end the real time kernel processing
-		 // so call ...
-		 vTaskEndScheduler ();
-	 }
- }
-
- void vAFunction( void )
- {
-	 // Create at least one task before starting the kernel.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
-
-	 // Start the real time kernel with preemption.
-	 vTaskStartScheduler ();
-
-	 // Will only get here when the vTaskCode () task has called
-	 // vTaskEndScheduler ().  When we get here we are back to single task
-	 // execution.
- }
-   </pre>
- *
- * \defgroup vTaskEndScheduler vTaskEndScheduler
- * \ingroup SchedulerControl
- */
-void vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskSuspendAll( void );</pre>
- *
- * Suspends the scheduler without disabling interrupts.  Context switches will
- * not occur while the scheduler is suspended.
- *
- * After calling vTaskSuspendAll () the calling task will continue to execute
- * without risk of being swapped out until a call to xTaskResumeAll () has been
- * made.
- *
- * API functions that have the potential to cause a context switch (for example,
- * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
- * is suspended.
- *
- * Example usage:
-   <pre>
- void vTask1( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-
-		 // ...
-
-		 // At some point the task wants to perform a long operation during
-		 // which it does not want to get swapped out.  It cannot use
-		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
-		 // operation may cause interrupts to be missed - including the
-		 // ticks.
-
-		 // Prevent the real time kernel swapping out the task.
-		 vTaskSuspendAll ();
-
-		 // Perform the operation here.  There is no need to use critical
-		 // sections as we have all the microcontroller processing time.
-		 // During this time interrupts will still operate and the kernel
-		 // tick count will be maintained.
-
-		 // ...
-
-		 // The operation is complete.  Restart the kernel.
-		 xTaskResumeAll ();
-	 }
- }
-   </pre>
- * \defgroup vTaskSuspendAll vTaskSuspendAll
- * \ingroup SchedulerControl
- */
-void vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>BaseType_t xTaskResumeAll( void );</pre>
- *
- * Resumes scheduler activity after it was suspended by a call to
- * vTaskSuspendAll().
- *
- * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
- * that were previously suspended by a call to vTaskSuspend().
- *
- * @return If resuming the scheduler caused a context switch then pdTRUE is
- *		  returned, otherwise pdFALSE is returned.
- *
- * Example usage:
-   <pre>
- void vTask1( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-
-		 // ...
-
-		 // At some point the task wants to perform a long operation during
-		 // which it does not want to get swapped out.  It cannot use
-		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
-		 // operation may cause interrupts to be missed - including the
-		 // ticks.
-
-		 // Prevent the real time kernel swapping out the task.
-		 vTaskSuspendAll ();
-
-		 // Perform the operation here.  There is no need to use critical
-		 // sections as we have all the microcontroller processing time.
-		 // During this time interrupts will still operate and the real
-		 // time kernel tick count will be maintained.
-
-		 // ...
-
-		 // The operation is complete.  Restart the kernel.  We want to force
-		 // a context switch - but there is no point if resuming the scheduler
-		 // caused a context switch already.
-		 if( !xTaskResumeAll () )
-		 {
-			  taskYIELD ();
-		 }
-	 }
- }
-   </pre>
- * \defgroup xTaskResumeAll xTaskResumeAll
- * \ingroup SchedulerControl
- */
-BaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------
- * TASK UTILITIES
- *----------------------------------------------------------*/
-
-/**
- * task. h
- * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
- *
- * @return The count of ticks since vTaskStartScheduler was called.
- *
- * \defgroup xTaskGetTickCount xTaskGetTickCount
- * \ingroup TaskUtils
- */
-TickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
- *
- * @return The count of ticks since vTaskStartScheduler was called.
- *
- * This is a version of xTaskGetTickCount() that is safe to be called from an
- * ISR - provided that TickType_t is the natural word size of the
- * microcontroller being used or interrupt nesting is either not supported or
- * not being used.
- *
- * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
- * \ingroup TaskUtils
- */
-TickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
- *
- * @return The number of tasks that the real time kernel is currently managing.
- * This includes all ready, blocked and suspended tasks.  A task that
- * has been deleted but not yet freed by the idle task will also be
- * included in the count.
- *
- * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
- * \ingroup TaskUtils
- */
-UBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
- *
- * @return The text (human readable) name of the task referenced by the handle
- * xTaskToQuery.  A task can query its own name by either passing in its own
- * handle, or by setting xTaskToQuery to NULL.
- *
- * \defgroup pcTaskGetName pcTaskGetName
- * \ingroup TaskUtils
- */
-char *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * task. h
- * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
- *
- * NOTE:  This function takes a relatively long time to complete and should be
- * used sparingly.
- *
- * @return The handle of the task that has the human readable name pcNameToQuery.
- * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
- * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
- *
- * \defgroup pcTaskGetHandle pcTaskGetHandle
- * \ingroup TaskUtils
- */
-TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * task.h
- * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
- *
- * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
- * this function to be available.
- *
- * Returns the high water mark of the stack associated with xTask.  That is,
- * the minimum free stack space there has been (in words, so on a 32 bit machine
- * a value of 1 means 4 bytes) since the task started.  The smaller the returned
- * number the closer the task has come to overflowing its stack.
- *
- * uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
- * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
- * user to determine the return type.  It gets around the problem of the value
- * overflowing on 8-bit types without breaking backward compatibility for
- * applications that expect an 8-bit return type.
- *
- * @param xTask Handle of the task associated with the stack to be checked.
- * Set xTask to NULL to check the stack of the calling task.
- *
- * @return The smallest amount of free stack space there has been (in words, so
- * actual spaces on the stack rather than bytes) since the task referenced by
- * xTask was created.
- */
-UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task.h
- * <PRE>configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );</PRE>
- *
- * INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for
- * this function to be available.
- *
- * Returns the high water mark of the stack associated with xTask.  That is,
- * the minimum free stack space there has been (in words, so on a 32 bit machine
- * a value of 1 means 4 bytes) since the task started.  The smaller the returned
- * number the closer the task has come to overflowing its stack.
- *
- * uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
- * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
- * user to determine the return type.  It gets around the problem of the value
- * overflowing on 8-bit types without breaking backward compatibility for
- * applications that expect an 8-bit return type.
- *
- * @param xTask Handle of the task associated with the stack to be checked.
- * Set xTask to NULL to check the stack of the calling task.
- *
- * @return The smallest amount of free stack space there has been (in words, so
- * actual spaces on the stack rather than bytes) since the task referenced by
- * xTask was created.
- */
-configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/* When using trace macros it is sometimes necessary to include task.h before
-FreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
-so the following two prototypes will cause a compilation error.  This can be
-fixed by simply guarding against the inclusion of these two prototypes unless
-they are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
-constant. */
-#ifdef configUSE_APPLICATION_TASK_TAG
-	#if configUSE_APPLICATION_TASK_TAG == 1
-		/**
-		 * task.h
-		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
-		 *
-		 * Sets pxHookFunction to be the task hook function used by the task xTask.
-		 * Passing xTask as NULL has the effect of setting the calling tasks hook
-		 * function.
-		 */
-		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
-
-		/**
-		 * task.h
-		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
-		 *
-		 * Returns the pxHookFunction value assigned to the task xTask.  Do not
-		 * call from an interrupt service routine - call
-		 * xTaskGetApplicationTaskTagFromISR() instead.
-		 */
-		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-		/**
-		 * task.h
-		 * <pre>void xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask );</pre>
-		 *
-		 * Returns the pxHookFunction value assigned to the task xTask.  Can
-		 * be called from an interrupt service routine.
-		 */
-		TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
-#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
-
-#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
-
-	/* Each task contains an array of pointers that is dimensioned by the
-	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
-	kernel does not use the pointers itself, so the application writer can use
-	the pointers for any purpose they wish.  The following two functions are
-	used to set and query a pointer respectively. */
-	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
-	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/**
- * task.h
- * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
- *
- * Calls the hook function associated with xTask.  Passing xTask as NULL has
- * the effect of calling the Running tasks (the calling task) hook function.
- *
- * pvParameter is passed to the hook function for the task to interpret as it
- * wants.  The return value is the value returned by the task hook function
- * registered by the user.
- */
-BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
-
-/**
- * xTaskGetIdleTaskHandle() is only available if
- * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
- *
- * Simply returns the handle of the idle task.  It is not valid to call
- * xTaskGetIdleTaskHandle() before the scheduler has been started.
- */
-TaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
-
-/**
- * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
- * uxTaskGetSystemState() to be available.
- *
- * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
- * the system.  TaskStatus_t structures contain, among other things, members
- * for the task handle, task name, task priority, task state, and total amount
- * of run time consumed by the task.  See the TaskStatus_t structure
- * definition in this file for the full member list.
- *
- * NOTE:  This function is intended for debugging use only as its use results in
- * the scheduler remaining suspended for an extended period.
- *
- * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
- * The array must contain at least one TaskStatus_t structure for each task
- * that is under the control of the RTOS.  The number of tasks under the control
- * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
- *
- * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
- * parameter.  The size is specified as the number of indexes in the array, or
- * the number of TaskStatus_t structures contained in the array, not by the
- * number of bytes in the array.
- *
- * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
- * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
- * total run time (as defined by the run time stats clock, see
- * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
- * pulTotalRunTime can be set to NULL to omit the total run time information.
- *
- * @return The number of TaskStatus_t structures that were populated by
- * uxTaskGetSystemState().  This should equal the number returned by the
- * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
- * in the uxArraySize parameter was too small.
- *
- * Example usage:
-   <pre>
-    // This example demonstrates how a human readable table of run time stats
-	// information is generated from raw data provided by uxTaskGetSystemState().
-	// The human readable table is written to pcWriteBuffer
-	void vTaskGetRunTimeStats( char *pcWriteBuffer )
-	{
-	TaskStatus_t *pxTaskStatusArray;
-	volatile UBaseType_t uxArraySize, x;
-	uint32_t ulTotalRunTime, ulStatsAsPercentage;
-
-		// Make sure the write buffer does not contain a string.
-		*pcWriteBuffer = 0x00;
-
-		// Take a snapshot of the number of tasks in case it changes while this
-		// function is executing.
-		uxArraySize = uxTaskGetNumberOfTasks();
-
-		// Allocate a TaskStatus_t structure for each task.  An array could be
-		// allocated statically at compile time.
-		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
-
-		if( pxTaskStatusArray != NULL )
-		{
-			// Generate raw status information about each task.
-			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
-
-			// For percentage calculations.
-			ulTotalRunTime /= 100UL;
-
-			// Avoid divide by zero errors.
-			if( ulTotalRunTime > 0 )
-			{
-				// For each populated position in the pxTaskStatusArray array,
-				// format the raw data as human readable ASCII data
-				for( x = 0; x < uxArraySize; x++ )
-				{
-					// What percentage of the total run time has the task used?
-					// This will always be rounded down to the nearest integer.
-					// ulTotalRunTimeDiv100 has already been divided by 100.
-					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
-
-					if( ulStatsAsPercentage > 0UL )
-					{
-						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
-					}
-					else
-					{
-						// If the percentage is zero here then the task has
-						// consumed less than 1% of the total run time.
-						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
-					}
-
-					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
-				}
-			}
-
-			// The array is no longer needed, free the memory it consumes.
-			vPortFree( pxTaskStatusArray );
-		}
-	}
-	</pre>
- */
-UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
- *
- * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
- * both be defined as 1 for this function to be available.  See the
- * configuration section of the FreeRTOS.org website for more information.
- *
- * NOTE 1: This function will disable interrupts for its duration.  It is
- * not intended for normal application runtime use but as a debug aid.
- *
- * Lists all the current tasks, along with their current state and stack
- * usage high water mark.
- *
- * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
- * suspended ('S').
- *
- * PLEASE NOTE:
- *
- * This function is provided for convenience only, and is used by many of the
- * demo applications.  Do not consider it to be part of the scheduler.
- *
- * vTaskList() calls uxTaskGetSystemState(), then formats part of the
- * uxTaskGetSystemState() output into a human readable table that displays task
- * names, states and stack usage.
- *
- * vTaskList() has a dependency on the sprintf() C library function that might
- * bloat the code size, use a lot of stack, and provide different results on
- * different platforms.  An alternative, tiny, third party, and limited
- * functionality implementation of sprintf() is provided in many of the
- * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
- * printf-stdarg.c does not provide a full snprintf() implementation!).
- *
- * It is recommended that production systems call uxTaskGetSystemState()
- * directly to get access to raw stats data, rather than indirectly through a
- * call to vTaskList().
- *
- * @param pcWriteBuffer A buffer into which the above mentioned details
- * will be written, in ASCII form.  This buffer is assumed to be large
- * enough to contain the generated report.  Approximately 40 bytes per
- * task should be sufficient.
- *
- * \defgroup vTaskList vTaskList
- * \ingroup TaskUtils
- */
-void vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * task. h
- * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
- *
- * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
- * must both be defined as 1 for this function to be available.  The application
- * must also then provide definitions for
- * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
- * to configure a peripheral timer/counter and return the timers current count
- * value respectively.  The counter should be at least 10 times the frequency of
- * the tick count.
- *
- * NOTE 1: This function will disable interrupts for its duration.  It is
- * not intended for normal application runtime use but as a debug aid.
- *
- * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
- * accumulated execution time being stored for each task.  The resolution
- * of the accumulated time value depends on the frequency of the timer
- * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
- * Calling vTaskGetRunTimeStats() writes the total execution time of each
- * task into a buffer, both as an absolute count value and as a percentage
- * of the total system execution time.
- *
- * NOTE 2:
- *
- * This function is provided for convenience only, and is used by many of the
- * demo applications.  Do not consider it to be part of the scheduler.
- *
- * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
- * uxTaskGetSystemState() output into a human readable table that displays the
- * amount of time each task has spent in the Running state in both absolute and
- * percentage terms.
- *
- * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
- * that might bloat the code size, use a lot of stack, and provide different
- * results on different platforms.  An alternative, tiny, third party, and
- * limited functionality implementation of sprintf() is provided in many of the
- * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
- * printf-stdarg.c does not provide a full snprintf() implementation!).
- *
- * It is recommended that production systems call uxTaskGetSystemState() directly
- * to get access to raw stats data, rather than indirectly through a call to
- * vTaskGetRunTimeStats().
- *
- * @param pcWriteBuffer A buffer into which the execution times will be
- * written, in ASCII form.  This buffer is assumed to be large enough to
- * contain the generated report.  Approximately 40 bytes per task should
- * be sufficient.
- *
- * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
- * \ingroup TaskUtils
- */
-void vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
-* task. h
-* <PRE>uint32_t ulTaskGetIdleRunTimeCounter( void );</PRE>
-*
-* configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
-* must both be defined as 1 for this function to be available.  The application
-* must also then provide definitions for
-* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
-* to configure a peripheral timer/counter and return the timers current count
-* value respectively.  The counter should be at least 10 times the frequency of
-* the tick count.
-*
-* Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
-* accumulated execution time being stored for each task.  The resolution
-* of the accumulated time value depends on the frequency of the timer
-* configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
-* While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total
-* execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter()
-* returns the total execution time of just the idle task.
-*
-* @return The total run time of the idle task.  This is the amount of time the
-* idle task has actually been executing.  The unit of time is dependent on the
-* frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and
-* portGET_RUN_TIME_COUNTER_VALUE() macros.
-*
-* \defgroup ulTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter
-* \ingroup TaskUtils
-*/
-uint32_t ulTaskGetIdleRunTimeCounter( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * A notification sent to a task will remain pending until it is cleared by the
- * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
- * already in the Blocked state to wait for a notification when the notification
- * arrives then the task will automatically be removed from the Blocked state
- * (unblocked) and the notification cleared.
- *
- * A task can use xTaskNotifyWait() to [optionally] block to wait for a
- * notification to be pending, or ulTaskNotifyTake() to [optionally] block
- * to wait for its notification value to have a non-zero value.  The task does
- * not consume any CPU time while it is in the Blocked state.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @param ulValue Data that can be sent with the notification.  How the data is
- * used depends on the value of the eAction parameter.
- *
- * @param eAction Specifies how the notification updates the task's notification
- * value, if at all.  Valid values for eAction are as follows:
- *
- * eSetBits -
- * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
- * always returns pdPASS in this case.
- *
- * eIncrement -
- * The task's notification value is incremented.  ulValue is not used and
- * xTaskNotify() always returns pdPASS in this case.
- *
- * eSetValueWithOverwrite -
- * The task's notification value is set to the value of ulValue, even if the
- * task being notified had not yet processed the previous notification (the
- * task already had a notification pending).  xTaskNotify() always returns
- * pdPASS in this case.
- *
- * eSetValueWithoutOverwrite -
- * If the task being notified did not already have a notification pending then
- * the task's notification value is set to ulValue and xTaskNotify() will
- * return pdPASS.  If the task being notified already had a notification
- * pending then no action is performed and pdFAIL is returned.
- *
- * eNoAction -
- * The task receives a notification without its notification value being
- * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
- * this case.
- *
- *  pulPreviousNotificationValue -
- *  Can be used to pass out the subject task's notification value before any
- *  bits are modified by the notify function.
- *
- * @return Dependent on the value of eAction.  See the description of the
- * eAction parameter.
- *
- * \defgroup xTaskNotify xTaskNotify
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
-#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
-#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * A version of xTaskNotify() that can be used from an interrupt service routine
- * (ISR).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * A notification sent to a task will remain pending until it is cleared by the
- * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
- * already in the Blocked state to wait for a notification when the notification
- * arrives then the task will automatically be removed from the Blocked state
- * (unblocked) and the notification cleared.
- *
- * A task can use xTaskNotifyWait() to [optionally] block to wait for a
- * notification to be pending, or ulTaskNotifyTake() to [optionally] block
- * to wait for its notification value to have a non-zero value.  The task does
- * not consume any CPU time while it is in the Blocked state.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @param ulValue Data that can be sent with the notification.  How the data is
- * used depends on the value of the eAction parameter.
- *
- * @param eAction Specifies how the notification updates the task's notification
- * value, if at all.  Valid values for eAction are as follows:
- *
- * eSetBits -
- * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
- * always returns pdPASS in this case.
- *
- * eIncrement -
- * The task's notification value is incremented.  ulValue is not used and
- * xTaskNotify() always returns pdPASS in this case.
- *
- * eSetValueWithOverwrite -
- * The task's notification value is set to the value of ulValue, even if the
- * task being notified had not yet processed the previous notification (the
- * task already had a notification pending).  xTaskNotify() always returns
- * pdPASS in this case.
- *
- * eSetValueWithoutOverwrite -
- * If the task being notified did not already have a notification pending then
- * the task's notification value is set to ulValue and xTaskNotify() will
- * return pdPASS.  If the task being notified already had a notification
- * pending then no action is performed and pdFAIL is returned.
- *
- * eNoAction -
- * The task receives a notification without its notification value being
- * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
- * this case.
- *
- * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
- * task to which the notification was sent to leave the Blocked state, and the
- * unblocked task has a priority higher than the currently running task.  If
- * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
- * be requested before the interrupt is exited.  How a context switch is
- * requested from an ISR is dependent on the port - see the documentation page
- * for the port in use.
- *
- * @return Dependent on the value of eAction.  See the description of the
- * eAction parameter.
- *
- * \defgroup xTaskNotify xTaskNotify
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
-#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * A notification sent to a task will remain pending until it is cleared by the
- * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
- * already in the Blocked state to wait for a notification when the notification
- * arrives then the task will automatically be removed from the Blocked state
- * (unblocked) and the notification cleared.
- *
- * A task can use xTaskNotifyWait() to [optionally] block to wait for a
- * notification to be pending, or ulTaskNotifyTake() to [optionally] block
- * to wait for its notification value to have a non-zero value.  The task does
- * not consume any CPU time while it is in the Blocked state.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
- * will be cleared in the calling task's notification value before the task
- * checks to see if any notifications are pending, and optionally blocks if no
- * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
- * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
- * the effect of resetting the task's notification value to 0.  Setting
- * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
- *
- * @param ulBitsToClearOnExit If a notification is pending or received before
- * the calling task exits the xTaskNotifyWait() function then the task's
- * notification value (see the xTaskNotify() API function) is passed out using
- * the pulNotificationValue parameter.  Then any bits that are set in
- * ulBitsToClearOnExit will be cleared in the task's notification value (note
- * *pulNotificationValue is set before any bits are cleared).  Setting
- * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
- * (if limits.h is not included) will have the effect of resetting the task's
- * notification value to 0 before the function exits.  Setting
- * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
- * when the function exits (in which case the value passed out in
- * pulNotificationValue will match the task's notification value).
- *
- * @param pulNotificationValue Used to pass the task's notification value out
- * of the function.  Note the value passed out will not be effected by the
- * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
- *
- * @param xTicksToWait The maximum amount of time that the task should wait in
- * the Blocked state for a notification to be received, should a notification
- * not already be pending when xTaskNotifyWait() was called.  The task
- * will not consume any processing time while it is in the Blocked state.  This
- * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
- * used to convert a time specified in milliseconds to a time specified in
- * ticks.
- *
- * @return If a notification was received (including notifications that were
- * already pending when xTaskNotifyWait was called) then pdPASS is
- * returned.  Otherwise pdFAIL is returned.
- *
- * \defgroup xTaskNotifyWait xTaskNotifyWait
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
- * to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * xTaskNotifyGive() is a helper macro intended for use when task notifications
- * are used as light weight and faster binary or counting semaphore equivalents.
- * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
- * the equivalent action that instead uses a task notification is
- * xTaskNotifyGive().
- *
- * When task notifications are being used as a binary or counting semaphore
- * equivalent then the task being notified should wait for the notification
- * using the ulTaskNotificationTake() API function rather than the
- * xTaskNotifyWait() API function.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
- * eAction parameter set to eIncrement - so pdPASS is always returned.
- *
- * \defgroup xTaskNotifyGive xTaskNotifyGive
- * \ingroup TaskNotifications
- */
-#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
-
-/**
- * task. h
- * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
- * to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * A version of xTaskNotifyGive() that can be called from an interrupt service
- * routine (ISR).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * vTaskNotifyGiveFromISR() is intended for use when task notifications are
- * used as light weight and faster binary or counting semaphore equivalents.
- * Actual FreeRTOS semaphores are given from an ISR using the
- * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
- * a task notification is vTaskNotifyGiveFromISR().
- *
- * When task notifications are being used as a binary or counting semaphore
- * equivalent then the task being notified should wait for the notification
- * using the ulTaskNotificationTake() API function rather than the
- * xTaskNotifyWait() API function.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
- * task to which the notification was sent to leave the Blocked state, and the
- * unblocked task has a priority higher than the currently running task.  If
- * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
- * should be requested before the interrupt is exited.  How a context switch is
- * requested from an ISR is dependent on the port - see the documentation page
- * for the port in use.
- *
- * \defgroup xTaskNotifyWait xTaskNotifyWait
- * \ingroup TaskNotifications
- */
-void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * ulTaskNotifyTake() is intended for use when a task notification is used as a
- * faster and lighter weight binary or counting semaphore alternative.  Actual
- * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
- * equivalent action that instead uses a task notification is
- * ulTaskNotifyTake().
- *
- * When a task is using its notification value as a binary or counting semaphore
- * other tasks should send notifications to it using the xTaskNotifyGive()
- * macro, or xTaskNotify() function with the eAction parameter set to
- * eIncrement.
- *
- * ulTaskNotifyTake() can either clear the task's notification value to
- * zero on exit, in which case the notification value acts like a binary
- * semaphore, or decrement the task's notification value on exit, in which case
- * the notification value acts like a counting semaphore.
- *
- * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
- * the task's notification value to be non-zero.  The task does not consume any
- * CPU time while it is in the Blocked state.
- *
- * Where as xTaskNotifyWait() will return when a notification is pending,
- * ulTaskNotifyTake() will return when the task's notification value is
- * not zero.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
- * notification value is decremented when the function exits.  In this way the
- * notification value acts like a counting semaphore.  If xClearCountOnExit is
- * not pdFALSE then the task's notification value is cleared to zero when the
- * function exits.  In this way the notification value acts like a binary
- * semaphore.
- *
- * @param xTicksToWait The maximum amount of time that the task should wait in
- * the Blocked state for the task's notification value to be greater than zero,
- * should the count not already be greater than zero when
- * ulTaskNotifyTake() was called.  The task will not consume any processing
- * time while it is in the Blocked state.  This is specified in kernel ticks,
- * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
- * specified in milliseconds to a time specified in ticks.
- *
- * @return The task's notification count before it is either cleared to zero or
- * decremented (see the xClearCountOnExit parameter).
- *
- * \defgroup ulTaskNotifyTake ulTaskNotifyTake
- * \ingroup TaskNotifications
- */
-uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
- *
- * If the notification state of the task referenced by the handle xTask is
- * eNotified, then set the task's notification state to eNotWaitingNotification.
- * The task's notification value is not altered.  Set xTask to NULL to clear the
- * notification state of the calling task.
- *
- * @return pdTRUE if the task's notification state was set to
- * eNotWaitingNotification, otherwise pdFALSE.
- * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
-
-/**
-* task. h
-* <PRE>uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );</pre>
-*
-* Clears the bits specified by the ulBitsToClear bit mask in the notification
-* value of the task referenced by xTask.
-*
-* Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear
-* the notification value to 0.  Set ulBitsToClear to 0 to query the task's
-* notification value without clearing any bits.
-*
-* @return The value of the target task's notification value before the bits
-* specified by ulBitsToClear were cleared.
-* \defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear
-* \ingroup TaskNotifications
-*/
-uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;
-
-/**
- * task.h
- * <pre>void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )</pre>
- *
- * Capture the current time for future use with xTaskCheckForTimeOut().
- *
- * @param pxTimeOut Pointer to a timeout object into which the current time
- * is to be captured.  The captured time includes the tick count and the number
- * of times the tick count has overflowed since the system first booted.
- * \defgroup vTaskSetTimeOutState vTaskSetTimeOutState
- * \ingroup TaskCtrl
- */
-void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
-
-/**
- * task.h
- * <pre>BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );</pre>
- *
- * Determines if pxTicksToWait ticks has passed since a time was captured
- * using a call to vTaskSetTimeOutState().  The captured time includes the tick
- * count and the number of times the tick count has overflowed.
- *
- * @param pxTimeOut The time status as captured previously using
- * vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated
- * to reflect the current time status.
- * @param pxTicksToWait The number of ticks to check for timeout i.e. if
- * pxTicksToWait ticks have passed since pxTimeOut was last updated (either by
- * vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.
- * If the timeout has not occurred, pxTIcksToWait is updated to reflect the
- * number of remaining ticks.
- *
- * @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is
- * returned and pxTicksToWait is updated to reflect the number of remaining
- * ticks.
- *
- * @see https://www.freertos.org/xTaskCheckForTimeOut.html
- *
- * Example Usage:
- * <pre>
-	// Driver library function used to receive uxWantedBytes from an Rx buffer
-	// that is filled by a UART interrupt. If there are not enough bytes in the
-	// Rx buffer then the task enters the Blocked state until it is notified that
-	// more data has been placed into the buffer. If there is still not enough
-	// data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()
-	// is used to re-calculate the Block time to ensure the total amount of time
-	// spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This
-	// continues until either the buffer contains at least uxWantedBytes bytes,
-	// or the total amount of time spent in the Blocked state reaches
-	// MAX_TIME_TO_WAIT  at which point the task reads however many bytes are
-	// available up to a maximum of uxWantedBytes.
-
-	size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )
-	{
-	size_t uxReceived = 0;
-	TickType_t xTicksToWait = MAX_TIME_TO_WAIT;
-	TimeOut_t xTimeOut;
-
-		// Initialize xTimeOut.  This records the time at which this function
-		// was entered.
-		vTaskSetTimeOutState( &xTimeOut );
-
-		// Loop until the buffer contains the wanted number of bytes, or a
-		// timeout occurs.
-		while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )
-		{
-			// The buffer didn't contain enough data so this task is going to
-			// enter the Blocked state. Adjusting xTicksToWait to account for
-			// any time that has been spent in the Blocked state within this
-			// function so far to ensure the total amount of time spent in the
-			// Blocked state does not exceed MAX_TIME_TO_WAIT.
-			if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )
-			{
-				//Timed out before the wanted number of bytes were available,
-				// exit the loop.
-				break;
-			}
-
-			// Wait for a maximum of xTicksToWait ticks to be notified that the
-			// receive interrupt has placed more data into the buffer.
-			ulTaskNotifyTake( pdTRUE, xTicksToWait );
-		}
-
-		// Attempt to read uxWantedBytes from the receive buffer into pucBuffer.
-		// The actual number of bytes read (which might be less than
-		// uxWantedBytes) is returned.
-		uxReceived = UART_read_from_receive_buffer( pxUARTInstance,
-													pucBuffer,
-													uxWantedBytes );
-
-		return uxReceived;
-	}
- </pre>
- * \defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut
- * \ingroup TaskCtrl
- */
-BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------
- * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
- *----------------------------------------------------------*/
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
- * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
- * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * Called from the real time kernel tick (either preemptive or cooperative),
- * this increments the tick count and checks if any tasks that are blocked
- * for a finite period required removing from a blocked list and placing on
- * a ready list.  If a non-zero value is returned then a context switch is
- * required because either:
- *   + A task was removed from a blocked list because its timeout had expired,
- *     or
- *   + Time slicing is in use and there is a task of equal priority to the
- *     currently running task.
- */
-BaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
- * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
- *
- * Removes the calling task from the ready list and places it both
- * on the list of tasks waiting for a particular event, and the
- * list of delayed tasks.  The task will be removed from both lists
- * and replaced on the ready list should either the event occur (and
- * there be no higher priority tasks waiting on the same event) or
- * the delay period expires.
- *
- * The 'unordered' version replaces the event list item value with the
- * xItemValue value, and inserts the list item at the end of the list.
- *
- * The 'ordered' version uses the existing event list item value (which is the
- * owning tasks priority) to insert the list item into the event list is task
- * priority order.
- *
- * @param pxEventList The list containing tasks that are blocked waiting
- * for the event to occur.
- *
- * @param xItemValue The item value to use for the event list item when the
- * event list is not ordered by task priority.
- *
- * @param xTicksToWait The maximum amount of time that the task should wait
- * for the event to occur.  This is specified in kernel ticks,the constant
- * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
- * period.
- */
-void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
- * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
- *
- * This function performs nearly the same function as vTaskPlaceOnEventList().
- * The difference being that this function does not permit tasks to block
- * indefinitely, whereas vTaskPlaceOnEventList() does.
- *
- */
-void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
- * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
- *
- * Removes a task from both the specified event list and the list of blocked
- * tasks, and places it on a ready queue.
- *
- * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called
- * if either an event occurs to unblock a task, or the block timeout period
- * expires.
- *
- * xTaskRemoveFromEventList() is used when the event list is in task priority
- * order.  It removes the list item from the head of the event list as that will
- * have the highest priority owning task of all the tasks on the event list.
- * vTaskRemoveFromUnorderedEventList() is used when the event list is not
- * ordered and the event list items hold something other than the owning tasks
- * priority.  In this case the event list item value is updated to the value
- * passed in the xItemValue parameter.
- *
- * @return pdTRUE if the task being removed has a higher priority than the task
- * making the call, otherwise pdFALSE.
- */
-BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
-void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
- * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
- * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * Sets the pointer to the current TCB to the TCB of the highest priority task
- * that is ready to run.
- */
-portDONT_DISCARD void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
-
-/*
- * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
- * THE EVENT BITS MODULE.
- */
-TickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the handle of the calling task.
- */
-TaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Shortcut used by the queue implementation to prevent unnecessary call to
- * taskYIELD();
- */
-void vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Returns the scheduler state as taskSCHEDULER_RUNNING,
- * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
- */
-BaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Raises the priority of the mutex holder to that of the calling task should
- * the mutex holder have a priority less than the calling task.
- */
-BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
-
-/*
- * Set the priority of a task back to its proper priority in the case that it
- * inherited a higher priority while it was holding a semaphore.
- */
-BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
-
-/*
- * If a higher priority task attempting to obtain a mutex caused a lower
- * priority task to inherit the higher priority task's priority - but the higher
- * priority task then timed out without obtaining the mutex, then the lower
- * priority task will disinherit the priority again - but only down as far as
- * the highest priority task that is still waiting for the mutex (if there were
- * more than one task waiting for the mutex).
- */
-void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;
-
-/*
- * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
- */
-UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/*
- * Set the uxTaskNumber of the task referenced by the xTask parameter to
- * uxHandle.
- */
-void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
-
-/*
- * Only available when configUSE_TICKLESS_IDLE is set to 1.
- * If tickless mode is being used, or a low power mode is implemented, then
- * the tick interrupt will not execute during idle periods.  When this is the
- * case, the tick count value maintained by the scheduler needs to be kept up
- * to date with the actual execution time by being skipped forward by a time
- * equal to the idle period.
- */
-void vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
-
-/* Correct the tick count value after the application code has held
-interrupts disabled for an extended period.  xTicksToCatchUp is the number
-of tick interrupts that have been missed due to interrupts being disabled.
-Its value is not computed automatically, so must be computed by the
-application writer.
-
-This function is similar to vTaskStepTick(), however, unlike
-vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a
-time at which a task should be removed from the blocked state.  That means
-tasks may have to be removed from the blocked state as the tick count is
-moved. */
-BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) PRIVILEGED_FUNCTION;
-
-/*
- * Only available when configUSE_TICKLESS_IDLE is set to 1.
- * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
- * specific sleep function to determine if it is ok to proceed with the sleep,
- * and if it is ok to proceed, if it is ok to sleep indefinitely.
- *
- * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
- * called with the scheduler suspended, not from within a critical section.  It
- * is therefore possible for an interrupt to request a context switch between
- * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
- * entered.  eTaskConfirmSleepModeStatus() should be called from a short
- * critical section between the timer being stopped and the sleep mode being
- * entered to ensure it is ok to proceed into the sleep mode.
- */
-eSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
-
-/*
- * For internal use only.  Increment the mutex held count when a mutex is
- * taken and return the handle of the task that has taken the mutex.
- */
-TaskHandle_t pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
-
-/*
- * For internal use only.  Same as vTaskSetTimeOutState(), but without a critial
- * section.
- */
-void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
-
-
-#ifdef __cplusplus
-}
-#endif
-#endif /* INC_TASK_H */
-
-
-
diff --git a/osal/inc/freertos/timers.h b/osal/inc/freertos/timers.h
deleted file mode 100644
index 307ea1f..0000000
--- a/osal/inc/freertos/timers.h
+++ /dev/null
@@ -1,1309 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef TIMERS_H
-#define TIMERS_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h must appear in source files before include timers.h"
-#endif
-
-/*lint -save -e537 This headers are only multiply included if the application code
-happens to also be including task.h. */
-#include "task.h"
-/*lint -restore */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * MACROS AND DEFINITIONS
- *----------------------------------------------------------*/
-
-/* IDs for commands that can be sent/received on the timer queue.  These are to
-be used solely through the macros that make up the public software timer API,
-as defined below.  The commands that are sent from interrupts must use the
-highest numbers as tmrFIRST_FROM_ISR_COMMAND is used to determine if the task
-or interrupt version of the queue send function should be used. */
-#define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR 	( ( BaseType_t ) -2 )
-#define tmrCOMMAND_EXECUTE_CALLBACK				( ( BaseType_t ) -1 )
-#define tmrCOMMAND_START_DONT_TRACE				( ( BaseType_t ) 0 )
-#define tmrCOMMAND_START					    ( ( BaseType_t ) 1 )
-#define tmrCOMMAND_RESET						( ( BaseType_t ) 2 )
-#define tmrCOMMAND_STOP							( ( BaseType_t ) 3 )
-#define tmrCOMMAND_CHANGE_PERIOD				( ( BaseType_t ) 4 )
-#define tmrCOMMAND_DELETE						( ( BaseType_t ) 5 )
-
-#define tmrFIRST_FROM_ISR_COMMAND				( ( BaseType_t ) 6 )
-#define tmrCOMMAND_START_FROM_ISR				( ( BaseType_t ) 6 )
-#define tmrCOMMAND_RESET_FROM_ISR				( ( BaseType_t ) 7 )
-#define tmrCOMMAND_STOP_FROM_ISR				( ( BaseType_t ) 8 )
-#define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR		( ( BaseType_t ) 9 )
-
-
-/**
- * Type by which software timers are referenced.  For example, a call to
- * xTimerCreate() returns an TimerHandle_t variable that can then be used to
- * reference the subject timer in calls to other software timer API functions
- * (for example, xTimerStart(), xTimerReset(), etc.).
- */
-struct tmrTimerControl; /* The old naming convention is used to prevent breaking kernel aware debuggers. */
-typedef struct tmrTimerControl * TimerHandle_t;
-
-/*
- * Defines the prototype to which timer callback functions must conform.
- */
-typedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );
-
-/*
- * Defines the prototype to which functions used with the
- * xTimerPendFunctionCallFromISR() function must conform.
- */
-typedef void (*PendedFunction_t)( void *, uint32_t );
-
-/**
- * TimerHandle_t xTimerCreate( 	const char * const pcTimerName,
- * 								TickType_t xTimerPeriodInTicks,
- * 								UBaseType_t uxAutoReload,
- * 								void * pvTimerID,
- * 								TimerCallbackFunction_t pxCallbackFunction );
- *
- * Creates a new software timer instance, and returns a handle by which the
- * created software timer can be referenced.
- *
- * Internally, within the FreeRTOS implementation, software timers use a block
- * of memory, in which the timer data structure is stored.  If a software timer
- * is created using xTimerCreate() then the required memory is automatically
- * dynamically allocated inside the xTimerCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a software timer is created using
- * xTimerCreateStatic() then the application writer must provide the memory that
- * will get used by the software timer.  xTimerCreateStatic() therefore allows a
- * software timer to be created without using any dynamic memory allocation.
- *
- * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
- * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
- * xTimerChangePeriodFromISR() API functions can all be used to transition a
- * timer into the active state.
- *
- * @param pcTimerName A text name that is assigned to the timer.  This is done
- * purely to assist debugging.  The kernel itself only ever references a timer
- * by its handle, and never by its name.
- *
- * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
- * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
- * has been specified in milliseconds.  For example, if the timer must expire
- * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
- * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
- * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
- * equal to 1000.  Time timer period must be greater than 0.
- *
- * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
- * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
- * If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
- * enter the dormant state after it expires.
- *
- * @param pvTimerID An identifier that is assigned to the timer being created.
- * Typically this would be used in the timer callback function to identify which
- * timer expired when the same callback function is assigned to more than one
- * timer.
- *
- * @param pxCallbackFunction The function to call when the timer expires.
- * Callback functions must have the prototype defined by TimerCallbackFunction_t,
- * which is	"void vCallbackFunction( TimerHandle_t xTimer );".
- *
- * @return If the timer is successfully created then a handle to the newly
- * created timer is returned.  If the timer cannot be created because there is
- * insufficient FreeRTOS heap remaining to allocate the timer
- * structures then NULL is returned.
- *
- * Example usage:
- * @verbatim
- * #define NUM_TIMERS 5
- *
- * // An array to hold handles to the created timers.
- * TimerHandle_t xTimers[ NUM_TIMERS ];
- *
- * // An array to hold a count of the number of times each timer expires.
- * int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };
- *
- * // Define a callback function that will be used by multiple timer instances.
- * // The callback function does nothing but count the number of times the
- * // associated timer expires, and stop the timer once the timer has expired
- * // 10 times.
- * void vTimerCallback( TimerHandle_t pxTimer )
- * {
- * int32_t lArrayIndex;
- * const int32_t xMaxExpiryCountBeforeStopping = 10;
- *
- * 	   // Optionally do something if the pxTimer parameter is NULL.
- * 	   configASSERT( pxTimer );
- *
- *     // Which timer expired?
- *     lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );
- *
- *     // Increment the number of times that pxTimer has expired.
- *     lExpireCounters[ lArrayIndex ] += 1;
- *
- *     // If the timer has expired 10 times then stop it from running.
- *     if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
- *     {
- *         // Do not use a block time if calling a timer API function from a
- *         // timer callback function, as doing so could cause a deadlock!
- *         xTimerStop( pxTimer, 0 );
- *     }
- * }
- *
- * void main( void )
- * {
- * int32_t x;
- *
- *     // Create then start some timers.  Starting the timers before the scheduler
- *     // has been started means the timers will start running immediately that
- *     // the scheduler starts.
- *     for( x = 0; x < NUM_TIMERS; x++ )
- *     {
- *         xTimers[ x ] = xTimerCreate(    "Timer",       // Just a text name, not used by the kernel.
- *                                         ( 100 * x ),   // The timer period in ticks.
- *                                         pdTRUE,        // The timers will auto-reload themselves when they expire.
- *                                         ( void * ) x,  // Assign each timer a unique id equal to its array index.
- *                                         vTimerCallback // Each timer calls the same callback when it expires.
- *                                     );
- *
- *         if( xTimers[ x ] == NULL )
- *         {
- *             // The timer was not created.
- *         }
- *         else
- *         {
- *             // Start the timer.  No block time is specified, and even if one was
- *             // it would be ignored because the scheduler has not yet been
- *             // started.
- *             if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
- *             {
- *                 // The timer could not be set into the Active state.
- *             }
- *         }
- *     }
- *
- *     // ...
- *     // Create tasks here.
- *     // ...
- *
- *     // Starting the scheduler will start the timers running as they have already
- *     // been set into the active state.
- *     vTaskStartScheduler();
- *
- *     // Should not reach here.
- *     for( ;; );
- * }
- * @endverbatim
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-								const TickType_t xTimerPeriodInTicks,
-								const UBaseType_t uxAutoReload,
-								void * const pvTimerID,
-								TimerCallbackFunction_t pxCallbackFunction ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * TimerHandle_t xTimerCreateStatic(const char * const pcTimerName,
- * 									TickType_t xTimerPeriodInTicks,
- * 									UBaseType_t uxAutoReload,
- * 									void * pvTimerID,
- * 									TimerCallbackFunction_t pxCallbackFunction,
- *									StaticTimer_t *pxTimerBuffer );
- *
- * Creates a new software timer instance, and returns a handle by which the
- * created software timer can be referenced.
- *
- * Internally, within the FreeRTOS implementation, software timers use a block
- * of memory, in which the timer data structure is stored.  If a software timer
- * is created using xTimerCreate() then the required memory is automatically
- * dynamically allocated inside the xTimerCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a software timer is created using
- * xTimerCreateStatic() then the application writer must provide the memory that
- * will get used by the software timer.  xTimerCreateStatic() therefore allows a
- * software timer to be created without using any dynamic memory allocation.
- *
- * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
- * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
- * xTimerChangePeriodFromISR() API functions can all be used to transition a
- * timer into the active state.
- *
- * @param pcTimerName A text name that is assigned to the timer.  This is done
- * purely to assist debugging.  The kernel itself only ever references a timer
- * by its handle, and never by its name.
- *
- * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
- * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
- * has been specified in milliseconds.  For example, if the timer must expire
- * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
- * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
- * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
- * equal to 1000.  The timer period must be greater than 0.
- *
- * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
- * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
- * If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
- * enter the dormant state after it expires.
- *
- * @param pvTimerID An identifier that is assigned to the timer being created.
- * Typically this would be used in the timer callback function to identify which
- * timer expired when the same callback function is assigned to more than one
- * timer.
- *
- * @param pxCallbackFunction The function to call when the timer expires.
- * Callback functions must have the prototype defined by TimerCallbackFunction_t,
- * which is "void vCallbackFunction( TimerHandle_t xTimer );".
- *
- * @param pxTimerBuffer Must point to a variable of type StaticTimer_t, which
- * will be then be used to hold the software timer's data structures, removing
- * the need for the memory to be allocated dynamically.
- *
- * @return If the timer is created then a handle to the created timer is
- * returned.  If pxTimerBuffer was NULL then NULL is returned.
- *
- * Example usage:
- * @verbatim
- *
- * // The buffer used to hold the software timer's data structure.
- * static StaticTimer_t xTimerBuffer;
- *
- * // A variable that will be incremented by the software timer's callback
- * // function.
- * UBaseType_t uxVariableToIncrement = 0;
- *
- * // A software timer callback function that increments a variable passed to
- * // it when the software timer was created.  After the 5th increment the
- * // callback function stops the software timer.
- * static void prvTimerCallback( TimerHandle_t xExpiredTimer )
- * {
- * UBaseType_t *puxVariableToIncrement;
- * BaseType_t xReturned;
- *
- *     // Obtain the address of the variable to increment from the timer ID.
- *     puxVariableToIncrement = ( UBaseType_t * ) pvTimerGetTimerID( xExpiredTimer );
- *
- *     // Increment the variable to show the timer callback has executed.
- *     ( *puxVariableToIncrement )++;
- *
- *     // If this callback has executed the required number of times, stop the
- *     // timer.
- *     if( *puxVariableToIncrement == 5 )
- *     {
- *         // This is called from a timer callback so must not block.
- *         xTimerStop( xExpiredTimer, staticDONT_BLOCK );
- *     }
- * }
- *
- *
- * void main( void )
- * {
- *     // Create the software time.  xTimerCreateStatic() has an extra parameter
- *     // than the normal xTimerCreate() API function.  The parameter is a pointer
- *     // to the StaticTimer_t structure that will hold the software timer
- *     // structure.  If the parameter is passed as NULL then the structure will be
- *     // allocated dynamically, just as if xTimerCreate() had been called.
- *     xTimer = xTimerCreateStatic( "T1",             // Text name for the task.  Helps debugging only.  Not used by FreeRTOS.
- *                                  xTimerPeriod,     // The period of the timer in ticks.
- *                                  pdTRUE,           // This is an auto-reload timer.
- *                                  ( void * ) &uxVariableToIncrement,    // A variable incremented by the software timer's callback function
- *                                  prvTimerCallback, // The function to execute when the timer expires.
- *                                  &xTimerBuffer );  // The buffer that will hold the software timer structure.
- *
- *     // The scheduler has not started yet so a block time is not used.
- *     xReturned = xTimerStart( xTimer, 0 );
- *
- *     // ...
- *     // Create tasks here.
- *     // ...
- *
- *     // Starting the scheduler will start the timers running as they have already
- *     // been set into the active state.
- *     vTaskStartScheduler();
- *
- *     // Should not reach here.
- *     for( ;; );
- * }
- * @endverbatim
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-										const TickType_t xTimerPeriodInTicks,
-										const UBaseType_t uxAutoReload,
-										void * const pvTimerID,
-										TimerCallbackFunction_t pxCallbackFunction,
-										StaticTimer_t *pxTimerBuffer ) PRIVILEGED_FUNCTION;
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-/**
- * void *pvTimerGetTimerID( TimerHandle_t xTimer );
- *
- * Returns the ID assigned to the timer.
- *
- * IDs are assigned to timers using the pvTimerID parameter of the call to
- * xTimerCreated() that was used to create the timer, and by calling the
- * vTimerSetTimerID() API function.
- *
- * If the same callback function is assigned to multiple timers then the timer
- * ID can be used as time specific (timer local) storage.
- *
- * @param xTimer The timer being queried.
- *
- * @return The ID assigned to the timer being queried.
- *
- * Example usage:
- *
- * See the xTimerCreate() API function example usage scenario.
- */
-void *pvTimerGetTimerID( const TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
-
-/**
- * void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );
- *
- * Sets the ID assigned to the timer.
- *
- * IDs are assigned to timers using the pvTimerID parameter of the call to
- * xTimerCreated() that was used to create the timer.
- *
- * If the same callback function is assigned to multiple timers then the timer
- * ID can be used as time specific (timer local) storage.
- *
- * @param xTimer The timer being updated.
- *
- * @param pvNewID The ID to assign to the timer.
- *
- * Example usage:
- *
- * See the xTimerCreate() API function example usage scenario.
- */
-void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) PRIVILEGED_FUNCTION;
-
-/**
- * BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );
- *
- * Queries a timer to see if it is active or dormant.
- *
- * A timer will be dormant if:
- *     1) It has been created but not started, or
- *     2) It is an expired one-shot timer that has not been restarted.
- *
- * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
- * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
- * xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the
- * active state.
- *
- * @param xTimer The timer being queried.
- *
- * @return pdFALSE will be returned if the timer is dormant.  A value other than
- * pdFALSE will be returned if the timer is active.
- *
- * Example usage:
- * @verbatim
- * // This function assumes xTimer has already been created.
- * void vAFunction( TimerHandle_t xTimer )
- * {
- *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
- *     {
- *         // xTimer is active, do something.
- *     }
- *     else
- *     {
- *         // xTimer is not active, do something else.
- *     }
- * }
- * @endverbatim
- */
-BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
-
-/**
- * TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );
- *
- * Simply returns the handle of the timer service/daemon task.  It it not valid
- * to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started.
- */
-TaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) PRIVILEGED_FUNCTION;
-
-/**
- * BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
- *
- * Timer functionality is provided by a timer service/daemon task.  Many of the
- * public FreeRTOS timer API functions send commands to the timer service task
- * through a queue called the timer command queue.  The timer command queue is
- * private to the kernel itself and is not directly accessible to application
- * code.  The length of the timer command queue is set by the
- * configTIMER_QUEUE_LENGTH configuration constant.
- *
- * xTimerStart() starts a timer that was previously created using the
- * xTimerCreate() API function.  If the timer had already been started and was
- * already in the active state, then xTimerStart() has equivalent functionality
- * to the xTimerReset() API function.
- *
- * Starting a timer ensures the timer is in the active state.  If the timer
- * is not stopped, deleted, or reset in the mean time, the callback function
- * associated with the timer will get called 'n' ticks after xTimerStart() was
- * called, where 'n' is the timers defined period.
- *
- * It is valid to call xTimerStart() before the scheduler has been started, but
- * when this is done the timer will not actually start until the scheduler is
- * started, and the timers expiry time will be relative to when the scheduler is
- * started, not relative to when xTimerStart() was called.
- *
- * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart()
- * to be available.
- *
- * @param xTimer The handle of the timer being started/restarted.
- *
- * @param xTicksToWait Specifies the time, in ticks, that the calling task should
- * be held in the Blocked state to wait for the start command to be successfully
- * sent to the timer command queue, should the queue already be full when
- * xTimerStart() was called.  xTicksToWait is ignored if xTimerStart() is called
- * before the scheduler is started.
- *
- * @return pdFAIL will be returned if the start command could not be sent to
- * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
- * be returned if the command was successfully sent to the timer command queue.
- * When the command is actually processed will depend on the priority of the
- * timer service/daemon task relative to other tasks in the system, although the
- * timers expiry time is relative to when xTimerStart() is actually called.  The
- * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
- * configuration constant.
- *
- * Example usage:
- *
- * See the xTimerCreate() API function example usage scenario.
- *
- */
-#define xTimerStart( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
-
-/**
- * BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );
- *
- * Timer functionality is provided by a timer service/daemon task.  Many of the
- * public FreeRTOS timer API functions send commands to the timer service task
- * through a queue called the timer command queue.  The timer command queue is
- * private to the kernel itself and is not directly accessible to application
- * code.  The length of the timer command queue is set by the
- * configTIMER_QUEUE_LENGTH configuration constant.
- *
- * xTimerStop() stops a timer that was previously started using either of the
- * The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(),
- * xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.
- *
- * Stopping a timer ensures the timer is not in the active state.
- *
- * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop()
- * to be available.
- *
- * @param xTimer The handle of the timer being stopped.
- *
- * @param xTicksToWait Specifies the time, in ticks, that the calling task should
- * be held in the Blocked state to wait for the stop command to be successfully
- * sent to the timer command queue, should the queue already be full when
- * xTimerStop() was called.  xTicksToWait is ignored if xTimerStop() is called
- * before the scheduler is started.
- *
- * @return pdFAIL will be returned if the stop command could not be sent to
- * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
- * be returned if the command was successfully sent to the timer command queue.
- * When the command is actually processed will depend on the priority of the
- * timer service/daemon task relative to other tasks in the system.  The timer
- * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
- * configuration constant.
- *
- * Example usage:
- *
- * See the xTimerCreate() API function example usage scenario.
- *
- */
-#define xTimerStop( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) )
-
-/**
- * BaseType_t xTimerChangePeriod( 	TimerHandle_t xTimer,
- *										TickType_t xNewPeriod,
- *										TickType_t xTicksToWait );
- *
- * Timer functionality is provided by a timer service/daemon task.  Many of the
- * public FreeRTOS timer API functions send commands to the timer service task
- * through a queue called the timer command queue.  The timer command queue is
- * private to the kernel itself and is not directly accessible to application
- * code.  The length of the timer command queue is set by the
- * configTIMER_QUEUE_LENGTH configuration constant.
- *
- * xTimerChangePeriod() changes the period of a timer that was previously
- * created using the xTimerCreate() API function.
- *
- * xTimerChangePeriod() can be called to change the period of an active or
- * dormant state timer.
- *
- * The configUSE_TIMERS configuration constant must be set to 1 for
- * xTimerChangePeriod() to be available.
- *
- * @param xTimer The handle of the timer that is having its period changed.
- *
- * @param xNewPeriod The new period for xTimer. Timer periods are specified in
- * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
- * that has been specified in milliseconds.  For example, if the timer must
- * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
- * if the timer must expire after 500ms, then xNewPeriod can be set to
- * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
- * or equal to 1000.
- *
- * @param xTicksToWait Specifies the time, in ticks, that the calling task should
- * be held in the Blocked state to wait for the change period command to be
- * successfully sent to the timer command queue, should the queue already be
- * full when xTimerChangePeriod() was called.  xTicksToWait is ignored if
- * xTimerChangePeriod() is called before the scheduler is started.
- *
- * @return pdFAIL will be returned if the change period command could not be
- * sent to the timer command queue even after xTicksToWait ticks had passed.
- * pdPASS will be returned if the command was successfully sent to the timer
- * command queue.  When the command is actually processed will depend on the
- * priority of the timer service/daemon task relative to other tasks in the
- * system.  The timer service/daemon task priority is set by the
- * configTIMER_TASK_PRIORITY configuration constant.
- *
- * Example usage:
- * @verbatim
- * // This function assumes xTimer has already been created.  If the timer
- * // referenced by xTimer is already active when it is called, then the timer
- * // is deleted.  If the timer referenced by xTimer is not active when it is
- * // called, then the period of the timer is set to 500ms and the timer is
- * // started.
- * void vAFunction( TimerHandle_t xTimer )
- * {
- *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
- *     {
- *         // xTimer is already active - delete it.
- *         xTimerDelete( xTimer );
- *     }
- *     else
- *     {
- *         // xTimer is not active, change its period to 500ms.  This will also
- *         // cause the timer to start.  Block for a maximum of 100 ticks if the
- *         // change period command cannot immediately be sent to the timer
- *         // command queue.
- *         if( xTimerChangePeriod( xTimer, 500 / portTICK_PERIOD_MS, 100 ) == pdPASS )
- *         {
- *             // The command was successfully sent.
- *         }
- *         else
- *         {
- *             // The command could not be sent, even after waiting for 100 ticks
- *             // to pass.  Take appropriate action here.
- *         }
- *     }
- * }
- * @endverbatim
- */
- #define xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) )
-
-/**
- * BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
- *
- * Timer functionality is provided by a timer service/daemon task.  Many of the
- * public FreeRTOS timer API functions send commands to the timer service task
- * through a queue called the timer command queue.  The timer command queue is
- * private to the kernel itself and is not directly accessible to application
- * code.  The length of the timer command queue is set by the
- * configTIMER_QUEUE_LENGTH configuration constant.
- *
- * xTimerDelete() deletes a timer that was previously created using the
- * xTimerCreate() API function.
- *
- * The configUSE_TIMERS configuration constant must be set to 1 for
- * xTimerDelete() to be available.
- *
- * @param xTimer The handle of the timer being deleted.
- *
- * @param xTicksToWait Specifies the time, in ticks, that the calling task should
- * be held in the Blocked state to wait for the delete command to be
- * successfully sent to the timer command queue, should the queue already be
- * full when xTimerDelete() was called.  xTicksToWait is ignored if xTimerDelete()
- * is called before the scheduler is started.
- *
- * @return pdFAIL will be returned if the delete command could not be sent to
- * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
- * be returned if the command was successfully sent to the timer command queue.
- * When the command is actually processed will depend on the priority of the
- * timer service/daemon task relative to other tasks in the system.  The timer
- * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
- * configuration constant.
- *
- * Example usage:
- *
- * See the xTimerChangePeriod() API function example usage scenario.
- */
-#define xTimerDelete( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) )
-
-/**
- * BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
- *
- * Timer functionality is provided by a timer service/daemon task.  Many of the
- * public FreeRTOS timer API functions send commands to the timer service task
- * through a queue called the timer command queue.  The timer command queue is
- * private to the kernel itself and is not directly accessible to application
- * code.  The length of the timer command queue is set by the
- * configTIMER_QUEUE_LENGTH configuration constant.
- *
- * xTimerReset() re-starts a timer that was previously created using the
- * xTimerCreate() API function.  If the timer had already been started and was
- * already in the active state, then xTimerReset() will cause the timer to
- * re-evaluate its expiry time so that it is relative to when xTimerReset() was
- * called.  If the timer was in the dormant state then xTimerReset() has
- * equivalent functionality to the xTimerStart() API function.
- *
- * Resetting a timer ensures the timer is in the active state.  If the timer
- * is not stopped, deleted, or reset in the mean time, the callback function
- * associated with the timer will get called 'n' ticks after xTimerReset() was
- * called, where 'n' is the timers defined period.
- *
- * It is valid to call xTimerReset() before the scheduler has been started, but
- * when this is done the timer will not actually start until the scheduler is
- * started, and the timers expiry time will be relative to when the scheduler is
- * started, not relative to when xTimerReset() was called.
- *
- * The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset()
- * to be available.
- *
- * @param xTimer The handle of the timer being reset/started/restarted.
- *
- * @param xTicksToWait Specifies the time, in ticks, that the calling task should
- * be held in the Blocked state to wait for the reset command to be successfully
- * sent to the timer command queue, should the queue already be full when
- * xTimerReset() was called.  xTicksToWait is ignored if xTimerReset() is called
- * before the scheduler is started.
- *
- * @return pdFAIL will be returned if the reset command could not be sent to
- * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
- * be returned if the command was successfully sent to the timer command queue.
- * When the command is actually processed will depend on the priority of the
- * timer service/daemon task relative to other tasks in the system, although the
- * timers expiry time is relative to when xTimerStart() is actually called.  The
- * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
- * configuration constant.
- *
- * Example usage:
- * @verbatim
- * // When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass
- * // without a key being pressed, then the LCD back-light is switched off.  In
- * // this case, the timer is a one-shot timer.
- *
- * TimerHandle_t xBacklightTimer = NULL;
- *
- * // The callback function assigned to the one-shot timer.  In this case the
- * // parameter is not used.
- * void vBacklightTimerCallback( TimerHandle_t pxTimer )
- * {
- *     // The timer expired, therefore 5 seconds must have passed since a key
- *     // was pressed.  Switch off the LCD back-light.
- *     vSetBacklightState( BACKLIGHT_OFF );
- * }
- *
- * // The key press event handler.
- * void vKeyPressEventHandler( char cKey )
- * {
- *     // Ensure the LCD back-light is on, then reset the timer that is
- *     // responsible for turning the back-light off after 5 seconds of
- *     // key inactivity.  Wait 10 ticks for the command to be successfully sent
- *     // if it cannot be sent immediately.
- *     vSetBacklightState( BACKLIGHT_ON );
- *     if( xTimerReset( xBacklightTimer, 100 ) != pdPASS )
- *     {
- *         // The reset command was not executed successfully.  Take appropriate
- *         // action here.
- *     }
- *
- *     // Perform the rest of the key processing here.
- * }
- *
- * void main( void )
- * {
- * int32_t x;
- *
- *     // Create then start the one-shot timer that is responsible for turning
- *     // the back-light off if no keys are pressed within a 5 second period.
- *     xBacklightTimer = xTimerCreate( "BacklightTimer",           // Just a text name, not used by the kernel.
- *                                     ( 5000 / portTICK_PERIOD_MS), // The timer period in ticks.
- *                                     pdFALSE,                    // The timer is a one-shot timer.
- *                                     0,                          // The id is not used by the callback so can take any value.
- *                                     vBacklightTimerCallback     // The callback function that switches the LCD back-light off.
- *                                   );
- *
- *     if( xBacklightTimer == NULL )
- *     {
- *         // The timer was not created.
- *     }
- *     else
- *     {
- *         // Start the timer.  No block time is specified, and even if one was
- *         // it would be ignored because the scheduler has not yet been
- *         // started.
- *         if( xTimerStart( xBacklightTimer, 0 ) != pdPASS )
- *         {
- *             // The timer could not be set into the Active state.
- *         }
- *     }
- *
- *     // ...
- *     // Create tasks here.
- *     // ...
- *
- *     // Starting the scheduler will start the timer running as it has already
- *     // been set into the active state.
- *     vTaskStartScheduler();
- *
- *     // Should not reach here.
- *     for( ;; );
- * }
- * @endverbatim
- */
-#define xTimerReset( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
-
-/**
- * BaseType_t xTimerStartFromISR( 	TimerHandle_t xTimer,
- *									BaseType_t *pxHigherPriorityTaskWoken );
- *
- * A version of xTimerStart() that can be called from an interrupt service
- * routine.
- *
- * @param xTimer The handle of the timer being started/restarted.
- *
- * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
- * of its time in the Blocked state, waiting for messages to arrive on the timer
- * command queue.  Calling xTimerStartFromISR() writes a message to the timer
- * command queue, so has the potential to transition the timer service/daemon
- * task out of the Blocked state.  If calling xTimerStartFromISR() causes the
- * timer service/daemon task to leave the Blocked state, and the timer service/
- * daemon task has a priority equal to or greater than the currently executing
- * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
- * get set to pdTRUE internally within the xTimerStartFromISR() function.  If
- * xTimerStartFromISR() sets this value to pdTRUE then a context switch should
- * be performed before the interrupt exits.
- *
- * @return pdFAIL will be returned if the start command could not be sent to
- * the timer command queue.  pdPASS will be returned if the command was
- * successfully sent to the timer command queue.  When the command is actually
- * processed will depend on the priority of the timer service/daemon task
- * relative to other tasks in the system, although the timers expiry time is
- * relative to when xTimerStartFromISR() is actually called.  The timer
- * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
- * configuration constant.
- *
- * Example usage:
- * @verbatim
- * // This scenario assumes xBacklightTimer has already been created.  When a
- * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
- * // without a key being pressed, then the LCD back-light is switched off.  In
- * // this case, the timer is a one-shot timer, and unlike the example given for
- * // the xTimerReset() function, the key press event handler is an interrupt
- * // service routine.
- *
- * // The callback function assigned to the one-shot timer.  In this case the
- * // parameter is not used.
- * void vBacklightTimerCallback( TimerHandle_t pxTimer )
- * {
- *     // The timer expired, therefore 5 seconds must have passed since a key
- *     // was pressed.  Switch off the LCD back-light.
- *     vSetBacklightState( BACKLIGHT_OFF );
- * }
- *
- * // The key press interrupt service routine.
- * void vKeyPressEventInterruptHandler( void )
- * {
- * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
- *
- *     // Ensure the LCD back-light is on, then restart the timer that is
- *     // responsible for turning the back-light off after 5 seconds of
- *     // key inactivity.  This is an interrupt service routine so can only
- *     // call FreeRTOS API functions that end in "FromISR".
- *     vSetBacklightState( BACKLIGHT_ON );
- *
- *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
- *     // as both cause the timer to re-calculate its expiry time.
- *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
- *     // declared (in this function).
- *     if( xTimerStartFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
- *     {
- *         // The start command was not executed successfully.  Take appropriate
- *         // action here.
- *     }
- *
- *     // Perform the rest of the key processing here.
- *
- *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
- *     // should be performed.  The syntax required to perform a context switch
- *     // from inside an ISR varies from port to port, and from compiler to
- *     // compiler.  Inspect the demos for the port you are using to find the
- *     // actual syntax required.
- *     if( xHigherPriorityTaskWoken != pdFALSE )
- *     {
- *         // Call the interrupt safe yield function here (actual function
- *         // depends on the FreeRTOS port being used).
- *     }
- * }
- * @endverbatim
- */
-#define xTimerStartFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
-
-/**
- * BaseType_t xTimerStopFromISR( 	TimerHandle_t xTimer,
- *									BaseType_t *pxHigherPriorityTaskWoken );
- *
- * A version of xTimerStop() that can be called from an interrupt service
- * routine.
- *
- * @param xTimer The handle of the timer being stopped.
- *
- * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
- * of its time in the Blocked state, waiting for messages to arrive on the timer
- * command queue.  Calling xTimerStopFromISR() writes a message to the timer
- * command queue, so has the potential to transition the timer service/daemon
- * task out of the Blocked state.  If calling xTimerStopFromISR() causes the
- * timer service/daemon task to leave the Blocked state, and the timer service/
- * daemon task has a priority equal to or greater than the currently executing
- * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
- * get set to pdTRUE internally within the xTimerStopFromISR() function.  If
- * xTimerStopFromISR() sets this value to pdTRUE then a context switch should
- * be performed before the interrupt exits.
- *
- * @return pdFAIL will be returned if the stop command could not be sent to
- * the timer command queue.  pdPASS will be returned if the command was
- * successfully sent to the timer command queue.  When the command is actually
- * processed will depend on the priority of the timer service/daemon task
- * relative to other tasks in the system.  The timer service/daemon task
- * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
- *
- * Example usage:
- * @verbatim
- * // This scenario assumes xTimer has already been created and started.  When
- * // an interrupt occurs, the timer should be simply stopped.
- *
- * // The interrupt service routine that stops the timer.
- * void vAnExampleInterruptServiceRoutine( void )
- * {
- * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
- *
- *     // The interrupt has occurred - simply stop the timer.
- *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
- *     // (within this function).  As this is an interrupt service routine, only
- *     // FreeRTOS API functions that end in "FromISR" can be used.
- *     if( xTimerStopFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
- *     {
- *         // The stop command was not executed successfully.  Take appropriate
- *         // action here.
- *     }
- *
- *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
- *     // should be performed.  The syntax required to perform a context switch
- *     // from inside an ISR varies from port to port, and from compiler to
- *     // compiler.  Inspect the demos for the port you are using to find the
- *     // actual syntax required.
- *     if( xHigherPriorityTaskWoken != pdFALSE )
- *     {
- *         // Call the interrupt safe yield function here (actual function
- *         // depends on the FreeRTOS port being used).
- *     }
- * }
- * @endverbatim
- */
-#define xTimerStopFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )
-
-/**
- * BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer,
- *										 TickType_t xNewPeriod,
- *										 BaseType_t *pxHigherPriorityTaskWoken );
- *
- * A version of xTimerChangePeriod() that can be called from an interrupt
- * service routine.
- *
- * @param xTimer The handle of the timer that is having its period changed.
- *
- * @param xNewPeriod The new period for xTimer. Timer periods are specified in
- * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
- * that has been specified in milliseconds.  For example, if the timer must
- * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
- * if the timer must expire after 500ms, then xNewPeriod can be set to
- * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
- * or equal to 1000.
- *
- * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
- * of its time in the Blocked state, waiting for messages to arrive on the timer
- * command queue.  Calling xTimerChangePeriodFromISR() writes a message to the
- * timer command queue, so has the potential to transition the timer service/
- * daemon task out of the Blocked state.  If calling xTimerChangePeriodFromISR()
- * causes the timer service/daemon task to leave the Blocked state, and the
- * timer service/daemon task has a priority equal to or greater than the
- * currently executing task (the task that was interrupted), then
- * *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the
- * xTimerChangePeriodFromISR() function.  If xTimerChangePeriodFromISR() sets
- * this value to pdTRUE then a context switch should be performed before the
- * interrupt exits.
- *
- * @return pdFAIL will be returned if the command to change the timers period
- * could not be sent to the timer command queue.  pdPASS will be returned if the
- * command was successfully sent to the timer command queue.  When the command
- * is actually processed will depend on the priority of the timer service/daemon
- * task relative to other tasks in the system.  The timer service/daemon task
- * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
- *
- * Example usage:
- * @verbatim
- * // This scenario assumes xTimer has already been created and started.  When
- * // an interrupt occurs, the period of xTimer should be changed to 500ms.
- *
- * // The interrupt service routine that changes the period of xTimer.
- * void vAnExampleInterruptServiceRoutine( void )
- * {
- * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
- *
- *     // The interrupt has occurred - change the period of xTimer to 500ms.
- *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
- *     // (within this function).  As this is an interrupt service routine, only
- *     // FreeRTOS API functions that end in "FromISR" can be used.
- *     if( xTimerChangePeriodFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
- *     {
- *         // The command to change the timers period was not executed
- *         // successfully.  Take appropriate action here.
- *     }
- *
- *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
- *     // should be performed.  The syntax required to perform a context switch
- *     // from inside an ISR varies from port to port, and from compiler to
- *     // compiler.  Inspect the demos for the port you are using to find the
- *     // actual syntax required.
- *     if( xHigherPriorityTaskWoken != pdFALSE )
- *     {
- *         // Call the interrupt safe yield function here (actual function
- *         // depends on the FreeRTOS port being used).
- *     }
- * }
- * @endverbatim
- */
-#define xTimerChangePeriodFromISR( xTimer, xNewPeriod, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )
-
-/**
- * BaseType_t xTimerResetFromISR( 	TimerHandle_t xTimer,
- *									BaseType_t *pxHigherPriorityTaskWoken );
- *
- * A version of xTimerReset() that can be called from an interrupt service
- * routine.
- *
- * @param xTimer The handle of the timer that is to be started, reset, or
- * restarted.
- *
- * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
- * of its time in the Blocked state, waiting for messages to arrive on the timer
- * command queue.  Calling xTimerResetFromISR() writes a message to the timer
- * command queue, so has the potential to transition the timer service/daemon
- * task out of the Blocked state.  If calling xTimerResetFromISR() causes the
- * timer service/daemon task to leave the Blocked state, and the timer service/
- * daemon task has a priority equal to or greater than the currently executing
- * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
- * get set to pdTRUE internally within the xTimerResetFromISR() function.  If
- * xTimerResetFromISR() sets this value to pdTRUE then a context switch should
- * be performed before the interrupt exits.
- *
- * @return pdFAIL will be returned if the reset command could not be sent to
- * the timer command queue.  pdPASS will be returned if the command was
- * successfully sent to the timer command queue.  When the command is actually
- * processed will depend on the priority of the timer service/daemon task
- * relative to other tasks in the system, although the timers expiry time is
- * relative to when xTimerResetFromISR() is actually called.  The timer service/daemon
- * task priority is set by the configTIMER_TASK_PRIORITY configuration constant.
- *
- * Example usage:
- * @verbatim
- * // This scenario assumes xBacklightTimer has already been created.  When a
- * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
- * // without a key being pressed, then the LCD back-light is switched off.  In
- * // this case, the timer is a one-shot timer, and unlike the example given for
- * // the xTimerReset() function, the key press event handler is an interrupt
- * // service routine.
- *
- * // The callback function assigned to the one-shot timer.  In this case the
- * // parameter is not used.
- * void vBacklightTimerCallback( TimerHandle_t pxTimer )
- * {
- *     // The timer expired, therefore 5 seconds must have passed since a key
- *     // was pressed.  Switch off the LCD back-light.
- *     vSetBacklightState( BACKLIGHT_OFF );
- * }
- *
- * // The key press interrupt service routine.
- * void vKeyPressEventInterruptHandler( void )
- * {
- * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
- *
- *     // Ensure the LCD back-light is on, then reset the timer that is
- *     // responsible for turning the back-light off after 5 seconds of
- *     // key inactivity.  This is an interrupt service routine so can only
- *     // call FreeRTOS API functions that end in "FromISR".
- *     vSetBacklightState( BACKLIGHT_ON );
- *
- *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
- *     // as both cause the timer to re-calculate its expiry time.
- *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
- *     // declared (in this function).
- *     if( xTimerResetFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
- *     {
- *         // The reset command was not executed successfully.  Take appropriate
- *         // action here.
- *     }
- *
- *     // Perform the rest of the key processing here.
- *
- *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
- *     // should be performed.  The syntax required to perform a context switch
- *     // from inside an ISR varies from port to port, and from compiler to
- *     // compiler.  Inspect the demos for the port you are using to find the
- *     // actual syntax required.
- *     if( xHigherPriorityTaskWoken != pdFALSE )
- *     {
- *         // Call the interrupt safe yield function here (actual function
- *         // depends on the FreeRTOS port being used).
- *     }
- * }
- * @endverbatim
- */
-#define xTimerResetFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
-
-
-/**
- * BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
- *                                          void *pvParameter1,
- *                                          uint32_t ulParameter2,
- *                                          BaseType_t *pxHigherPriorityTaskWoken );
- *
- *
- * Used from application interrupt service routines to defer the execution of a
- * function to the RTOS daemon task (the timer service task, hence this function
- * is implemented in timers.c and is prefixed with 'Timer').
- *
- * Ideally an interrupt service routine (ISR) is kept as short as possible, but
- * sometimes an ISR either has a lot of processing to do, or needs to perform
- * processing that is not deterministic.  In these cases
- * xTimerPendFunctionCallFromISR() can be used to defer processing of a function
- * to the RTOS daemon task.
- *
- * A mechanism is provided that allows the interrupt to return directly to the
- * task that will subsequently execute the pended callback function.  This
- * allows the callback function to execute contiguously in time with the
- * interrupt - just as if the callback had executed in the interrupt itself.
- *
- * @param xFunctionToPend The function to execute from the timer service/
- * daemon task.  The function must conform to the PendedFunction_t
- * prototype.
- *
- * @param pvParameter1 The value of the callback function's first parameter.
- * The parameter has a void * type to allow it to be used to pass any type.
- * For example, unsigned longs can be cast to a void *, or the void * can be
- * used to point to a structure.
- *
- * @param ulParameter2 The value of the callback function's second parameter.
- *
- * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
- * will result in a message being sent to the timer daemon task.  If the
- * priority of the timer daemon task (which is set using
- * configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of
- * the currently running task (the task the interrupt interrupted) then
- * *pxHigherPriorityTaskWoken will be set to pdTRUE within
- * xTimerPendFunctionCallFromISR(), indicating that a context switch should be
- * requested before the interrupt exits.  For that reason
- * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
- * example code below.
- *
- * @return pdPASS is returned if the message was successfully sent to the
- * timer daemon task, otherwise pdFALSE is returned.
- *
- * Example usage:
- * @verbatim
- *
- *	// The callback function that will execute in the context of the daemon task.
- *  // Note callback functions must all use this same prototype.
- *  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
- *	{
- *		BaseType_t xInterfaceToService;
- *
- *		// The interface that requires servicing is passed in the second
- *      // parameter.  The first parameter is not used in this case.
- *		xInterfaceToService = ( BaseType_t ) ulParameter2;
- *
- *		// ...Perform the processing here...
- *	}
- *
- *	// An ISR that receives data packets from multiple interfaces
- *  void vAnISR( void )
- *	{
- *		BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;
- *
- *		// Query the hardware to determine which interface needs processing.
- *		xInterfaceToService = prvCheckInterfaces();
- *
- *      // The actual processing is to be deferred to a task.  Request the
- *      // vProcessInterface() callback function is executed, passing in the
- *		// number of the interface that needs processing.  The interface to
- *		// service is passed in the second parameter.  The first parameter is
- *		// not used in this case.
- *		xHigherPriorityTaskWoken = pdFALSE;
- *		xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );
- *
- *		// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
- *		// switch should be requested.  The macro used is port specific and will
- *		// be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
- *		// the documentation page for the port being used.
- *		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
- *
- *	}
- * @endverbatim
- */
-BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
- /**
-  * BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
-  *                                    void *pvParameter1,
-  *                                    uint32_t ulParameter2,
-  *                                    TickType_t xTicksToWait );
-  *
-  *
-  * Used to defer the execution of a function to the RTOS daemon task (the timer
-  * service task, hence this function is implemented in timers.c and is prefixed
-  * with 'Timer').
-  *
-  * @param xFunctionToPend The function to execute from the timer service/
-  * daemon task.  The function must conform to the PendedFunction_t
-  * prototype.
-  *
-  * @param pvParameter1 The value of the callback function's first parameter.
-  * The parameter has a void * type to allow it to be used to pass any type.
-  * For example, unsigned longs can be cast to a void *, or the void * can be
-  * used to point to a structure.
-  *
-  * @param ulParameter2 The value of the callback function's second parameter.
-  *
-  * @param xTicksToWait Calling this function will result in a message being
-  * sent to the timer daemon task on a queue.  xTicksToWait is the amount of
-  * time the calling task should remain in the Blocked state (so not using any
-  * processing time) for space to become available on the timer queue if the
-  * queue is found to be full.
-  *
-  * @return pdPASS is returned if the message was successfully sent to the
-  * timer daemon task, otherwise pdFALSE is returned.
-  *
-  */
-BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * const char * const pcTimerGetName( TimerHandle_t xTimer );
- *
- * Returns the name that was assigned to a timer when the timer was created.
- *
- * @param xTimer The handle of the timer being queried.
- *
- * @return The name assigned to the timer specified by the xTimer parameter.
- */
-const char * pcTimerGetName( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload );
- *
- * Updates a timer to be either an auto-reload timer, in which case the timer
- * automatically resets itself each time it expires, or a one-shot timer, in
- * which case the timer will only expire once unless it is manually restarted.
- *
- * @param xTimer The handle of the timer being updated.
- *
- * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
- * expire repeatedly with a frequency set by the timer's period (see the
- * xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If
- * uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
- * enter the dormant state after it expires.
- */
-void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload ) PRIVILEGED_FUNCTION;
-
-/**
-* UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );
-*
-* Queries a timer to determine if it is an auto-reload timer, in which case the timer
-* automatically resets itself each time it expires, or a one-shot timer, in
-* which case the timer will only expire once unless it is manually restarted.
-*
-* @param xTimer The handle of the timer being queried.
-*
-* @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise
-* pdFALSE is returned.
-*/
-UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
-
-/**
- * TickType_t xTimerGetPeriod( TimerHandle_t xTimer );
- *
- * Returns the period of a timer.
- *
- * @param xTimer The handle of the timer being queried.
- *
- * @return The period of the timer in ticks.
- */
-TickType_t xTimerGetPeriod( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
-
-/**
-* TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );
-*
-* Returns the time in ticks at which the timer will expire.  If this is less
-* than the current tick count then the expiry time has overflowed from the
-* current time.
-*
-* @param xTimer The handle of the timer being queried.
-*
-* @return If the timer is running then the time in ticks at which the timer
-* will next expire is returned.  If the timer is not running then the return
-* value is undefined.
-*/
-TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
-
-/*
- * Functions beyond this part are not part of the public API and are intended
- * for use by the kernel only.
- */
-BaseType_t xTimerCreateTimerTask( void ) PRIVILEGED_FUNCTION;
-BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-#if( configUSE_TRACE_FACILITY == 1 )
-	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber ) PRIVILEGED_FUNCTION;
-	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-#endif /* TIMERS_H */
-
-
-
diff --git a/osal/inc/sugar/s_list.h b/osal/inc/sugar/s_list.h
new file mode 100644
index 0000000..0e9cc28
--- /dev/null
+++ b/osal/inc/sugar/s_list.h
@@ -0,0 +1,43 @@
+#ifndef INC_S_LIST_H_
+#define INC_S_LIST_H_
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef GET_PARENT_ADDR
+#define GET_PARENT_ADDR(pMe,tParent,eMyName) \
+    ((tParent *)((char *)(pMe) - (ptrdiff_t)&((tParent *)0)->eMyName))
+#endif
+
+struct tag_list;
+typedef struct tag_s_list {
+    struct tag_s_list *next;
+    struct tag_s_list *prev;
+} s_list_t;
+
+s_list_t *s_list_get_prev (s_list_t *list);
+s_list_t *s_list_get_next (s_list_t *list);
+void s_list_set_prev (s_list_t *list, s_list_t *other);
+void s_list_set_next (s_list_t *list, s_list_t *other);
+/* Initilization a list */
+void s_list_init(s_list_t *list);
+/* Connect two lists. */
+void s_list_connect (s_list_t *list1, s_list_t *list2);
+/* Disconnect tow lists. */
+void s_list_disconnect (s_list_t *list1, s_list_t *list2);
+/* Same as s_list_connect */
+void s_list_attach (s_list_t *node1, s_list_t *node2);
+/* Make node in detach mode */
+void s_list_detach (s_list_t *node);
+/* Check if list is empty */
+int s_list_is_empty (s_list_t *list);
+int s_list_size(s_list_t *list);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/osal/inc/sugar/s_port_armv6m.h b/osal/inc/sugar/s_port_armv6m.h
new file mode 100644
index 0000000..98b6bb1
--- /dev/null
+++ b/osal/inc/sugar/s_port_armv6m.h
@@ -0,0 +1,69 @@
+#ifndef INC_S_PORT_ARMV6M_H_
+#define INC_S_PORT_ARMV6M_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* 1. define a type for clock */
+typedef uint32_t my_clock_t;
+typedef int32_t my_clock_diff_t;
+
+typedef struct {
+    int sp; //stack register
+} ucontext_t;
+
+/* 2. define the clock ticks count for one second */
+#ifndef MY_CLOCKS_PER_SEC
+#   define MY_CLOCKS_PER_SEC 1000
+#endif
+
+/* 3. Implement the initilization function for clock. Leave it blank if not required. */
+void my_clock_init(void);
+
+/* 4. Implement the function of getting current clock ticks. */
+my_clock_t my_clock(void);
+
+/* 5. Implement the idle delay function. */
+void my_on_idle(uint64_t max_idle_ms);
+
+/* 6. Define irq enable/disable functions */
+#ifdef __GNUC__
+__attribute__((always_inline))
+#if __STDC_VERSION__ >= 199901L
+inline
+#endif
+static void __set_PRIMASK_gcc(uint32_t primask) {
+  __asm volatile ("MSR primask, %0" : : "r" (primask) : "memory");
+}
+#endif
+
+__attribute__((always_inline))
+#if __STDC_VERSION__ >= 199901L
+inline
+#endif
+static void S_IRQ_DISABLE(){
+#ifdef __GNUC__
+    __set_PRIMASK_gcc(1);
+#else
+    __set_PRIMASK(1);
+#endif
+}
+
+__attribute__((always_inline))
+#if __STDC_VERSION__ >= 199901L
+inline
+#endif
+static void S_IRQ_ENABLE(){
+#ifdef __GNUC__
+    __set_PRIMASK_gcc(0);
+#else
+    __set_PRIMASK(0);
+#endif
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/osal/inc/sugar/s_port_armv7m.h b/osal/inc/sugar/s_port_armv7m.h
new file mode 100644
index 0000000..abb721a
--- /dev/null
+++ b/osal/inc/sugar/s_port_armv7m.h
@@ -0,0 +1,69 @@
+#ifndef INC_S_PORT_ARMV7M_H_
+#define INC_S_PORT_ARMV7M_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* 1. define a type for clock */
+typedef uint32_t my_clock_t;
+typedef int32_t my_clock_diff_t;
+
+typedef struct {
+    int sp; //stack register
+} ucontext_t;
+
+/* 2. define the clock ticks count for one second */
+#ifndef MY_CLOCKS_PER_SEC
+#   define MY_CLOCKS_PER_SEC 1000
+#endif
+
+/* 3. Implement the initilization function for clock. Leave it blank if not required. */
+void my_clock_init(void);
+
+/* 4. Implement the function of getting current clock ticks. */
+my_clock_t my_clock(void);
+
+/* 5. Implement the idle delay function. */
+void my_on_idle(uint64_t max_idle_ms);
+
+/* 6. Define irq enable/disable functions */
+#ifdef __GNUC__
+__attribute__((always_inline))
+#if __STDC_VERSION__ >= 199901L
+inline
+#endif
+static void __set_PRIMASK_gcc(uint32_t primask) {
+  __asm volatile ("MSR primask, %0" : : "r" (primask) : "memory");
+}
+#endif
+
+__attribute__((always_inline))
+#if __STDC_VERSION__ >= 199901L
+inline
+#endif
+static void S_IRQ_DISABLE(){
+#ifdef __GNUC__
+    __set_PRIMASK_gcc(1);
+#else
+    __set_PRIMASK(1);
+#endif
+}
+
+__attribute__((always_inline))
+#if __STDC_VERSION__ >= 199901L
+inline
+#endif
+static void S_IRQ_ENABLE(){
+#ifdef __GNUC__
+    __set_PRIMASK_gcc(0);
+#else
+    __set_PRIMASK(0);
+#endif
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/osal/inc/sugar/s_port_posix.h b/osal/inc/sugar/s_port_posix.h
new file mode 100644
index 0000000..21eff9c
--- /dev/null
+++ b/osal/inc/sugar/s_port_posix.h
@@ -0,0 +1,44 @@
+#ifndef INC_S_PORT_H_
+#define INC_S_PORT_H_
+
+#include <time.h>
+#include <unistd.h>
+#ifdef USE_SWAP_CONTEXT
+#   ifndef _XOPEN_SOURCE
+#       define _XOPEN_SOURCE
+#   endif
+#   include <ucontext.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Copyright xhawk, MIT license */
+
+/* Timer functions need to be implemented on a new porting. */
+
+/* === Timer functions on posix/linux === */
+
+/* 1. define a type for clock */
+typedef uint32_t my_clock_t;
+typedef int32_t my_clock_diff_t;
+
+/* 2. define the clock ticks count for one second */
+#define MY_CLOCKS_PER_SEC 1000
+
+/* 3. Implement the initilization function for clock. Leave it blank if not required. */
+void my_clock_init(void);
+
+/* 4. Implement the function of getting current clock ticks. */
+my_clock_t my_clock(void);
+
+/* 5. Implement the idle delay function. */
+void my_on_idle(uint64_t max_idle_ms);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/osal/inc/sugar/s_port_riscv.h b/osal/inc/sugar/s_port_riscv.h
new file mode 100644
index 0000000..5d0b10b
--- /dev/null
+++ b/osal/inc/sugar/s_port_riscv.h
@@ -0,0 +1,51 @@
+#ifndef INC_S_PORT_RISCV_H_
+#define INC_S_PORT_RISCV_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    int sp;
+} ucontext_t;
+
+/* Copyright xhawk, MIT license */
+
+/* Timer functions need to be implemented on a new porting. */
+
+/* === Timer functions on posix/linux === */
+
+/* 1. define a type for clock */
+typedef uint64_t my_clock_t;
+typedef int64_t my_clock_diff_t;
+
+/* 2. define the clock ticks count for one second */
+#define MY_CLOCKS_PER_SEC (SystemCoreClock/4)
+
+/* 3. Implement the initilization function for clock. Leave it blank if not required. */
+void my_clock_init(void);
+
+/* 4. Implement the function of getting current clock ticks. */
+my_clock_t my_clock(void);
+
+/* 5. Implement the idle delay function. */
+void my_on_idle(uint64_t max_idle_ms);
+
+/* 6. Define irq enable/disable functions */
+
+//    #define CSR_MSTATUS 0x300
+//    #define MSTATUS_MIE 0x00000008
+
+static inline void S_IRQ_DISABLE(){
+    asm volatile ("csrc 0x300, 0x8");
+}
+
+static inline void S_IRQ_ENABLE(){
+    asm volatile ("csrs 0x300, 0x8");
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/osal/inc/sugar/s_port_windows.h b/osal/inc/sugar/s_port_windows.h
new file mode 100644
index 0000000..c8d036f
--- /dev/null
+++ b/osal/inc/sugar/s_port_windows.h
@@ -0,0 +1,39 @@
+#ifndef INC_S_PORT_H_
+#define INC_S_PORT_H_
+
+#include <Windows.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Copyright xhawk, MIT license */
+
+/* Timer functions need to be implemented on a new porting. */
+
+/* === Timer functions on windows === */
+
+/* 1. define a type for clock */
+typedef DWORD my_clock_t;
+typedef LONG  my_clock_diff_t;
+
+/* 2. define the clock ticks count for one second */
+#define MY_CLOCKS_PER_SEC 1000
+
+/* 3. Implement the initilization function for clock. Leave it blank if not required. */
+void my_clock_init(void);
+
+/* 4. Implement the function of getting current clock ticks. */
+my_clock_t my_clock(void);
+
+/* 5. Implement the idle delay function. */
+void my_on_idle(uint64_t max_idle_ms);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/osal/inc/sugar/s_rbtree.h b/osal/inc/sugar/s_rbtree.h
new file mode 100644
index 0000000..1500f05
--- /dev/null
+++ b/osal/inc/sugar/s_rbtree.h
@@ -0,0 +1,112 @@
+/*-------------------------------------------------------------------------
+ *
+ * rbtree.h
+ *      interface for PostgreSQL generic Red-Black binary tree package
+ *
+ * Copyright (c) 2009-2020, PostgreSQL Global Development Group
+ *
+ * IDENTIFICATION
+ *      src/include/lib/rbtree.h
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef INC_S_RBTREE_H_
+#define INC_S_RBTREE_H_
+
+#include <stdbool.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifndef GET_PARENT_ADDR
+#define GET_PARENT_ADDR(pMe,tParent,eMyName) \
+    ((tParent *)((char *)(pMe) - (ptrdiff_t)&((tParent *)0)->eMyName))
+#endif
+
+
+/*
+ * RBTNode is intended to be used as the first field of a larger struct,
+ * whose additional fields carry whatever payload data the caller needs
+ * for a tree entry.  (The total size of that larger struct is passed to
+ * rbt_create.) RBTNode is declared here to support this usage, but
+ * callers must treat it as an opaque struct.
+ */
+typedef struct RBTNode
+{
+    char color;                 /* node's current color, red or black */
+    struct RBTNode *left;       /* left child, or RBTNIL if none */
+    struct RBTNode *right;      /* right child, or RBTNIL if none */
+    struct RBTNode *parent;     /* parent, or NULL (not RBTNIL!) if none */
+} RBTNode;
+
+
+#define RBTNIL (&g_sentinel)
+extern RBTNode g_sentinel;
+
+/* Support functions to be provided by caller */
+typedef int (*rbt_comparator) (const RBTNode *a, const RBTNode *b, void *arg);
+typedef int (*rbt_find_comparator) (const void *a, const RBTNode *b);
+/*
+typedef void (*rbt_combiner) (RBTNode *existing, const RBTNode *newdata, void *arg);
+typedef RBTNode *(*rbt_allocfunc) (void *arg);
+typedef void (*rbt_freefunc) (RBTNode *x, void *arg);
+*/
+
+/*
+ * RBTree control structure
+ */
+typedef struct
+{
+    RBTNode *root;          /* root node, or RBTNIL if tree is empty */
+
+    /* Remaining fields are constant after rbt_create */
+    rbt_comparator comparator;
+    void* comparator_arg;
+} RBTree;
+
+/* Available tree iteration orderings */
+typedef enum RBTOrderControl
+{
+    LeftRightWalk,              /* inorder: left child, node, right child */
+    RightLeftWalk               /* reverse inorder: right, node, left */
+} RBTOrderControl;
+
+/*
+ * RBTreeIterator holds state while traversing a tree.  This is declared
+ * here so that callers can stack-allocate this, but must otherwise be
+ * treated as an opaque struct.
+ */
+typedef struct RBTreeIterator RBTreeIterator;
+
+struct RBTreeIterator
+{
+    RBTree     *rbt;
+    RBTNode    *(*iterate) (RBTreeIterator *iter);
+    RBTNode    *last_visited;
+    bool        is_over;
+};
+
+
+extern RBTree *rbt_create(RBTree* tree,
+                          rbt_comparator comparator,
+                          void *comparator_arg);
+
+extern RBTNode *rbt_find(RBTree *rbt, const RBTNode *data);
+extern RBTNode* rbt_find2(RBTree* rbt, rbt_find_comparator comparator, const void* data);
+extern RBTNode *rbt_leftmost(RBTree *rbt);
+
+extern bool rbt_insert(RBTree *rbt, RBTNode *data);
+extern void rbt_delete(RBTree *rbt, RBTNode *node);
+
+extern void rbt_begin_iterate(RBTree *rbt, RBTOrderControl ctrl,
+                              RBTreeIterator *iter);
+extern RBTNode *rbt_iterate(RBTreeIterator *iter);
+extern bool rbt_is_empty(const RBTree* rbt);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* INC_S_RBTREE_H_ */
diff --git a/osal/inc/sugar/s_task.h b/osal/inc/sugar/s_task.h
new file mode 100644
index 0000000..21f53a8
--- /dev/null
+++ b/osal/inc/sugar/s_task.h
@@ -0,0 +1,286 @@
+#ifndef INC_S_TASK_H_
+#define INC_S_TASK_H_
+
+/* Copyright xhawk, MIT license */
+#include <stdio.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include "s_list.h"
+#include "s_rbtree.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct{
+    int dummy;
+} s_awaiter_t;
+
+#   define __await__      __awaiter_dummy__
+#   define __async__      s_awaiter_t *__awaiter_dummy__
+
+/* Function type for task entrance */
+typedef void(*s_task_fn_t)(__async__, void *arg);
+
+
+/* #define USE_SWAP_CONTEXT                                            */
+/* #define USE_JUMP_FCONTEXT                                           */
+/* #define USE_LIST_TIMER_CONTAINER //for very small memory footprint  */
+/* #define USE_IN_EMBEDDED                                             */
+/* #define USE_STACK_DEBUG                                             */
+/* #define USE_DEAD_TASK_CHECKING                                      */
+
+
+#if defined __ARMCC_VERSION || (defined __GNUC__ && __USES_INITFINI__ && defined __ARM_ARCH)
+#   define USE_IN_EMBEDDED
+#   define USE_SWAP_CONTEXT
+#   define USE_LIST_TIMER_CONTAINER
+#   include "s_port_armv7m.h"
+#elif defined _WIN32
+#   define USE_JUMP_FCONTEXT
+#   define USE_DEAD_TASK_CHECKING
+#   include "s_port_windows.h"
+#elif defined __unix__ || defined __linux__ || defined __APPLE__
+#   ifdef __CYGWIN__
+#       define USE_SWAP_CONTEXT
+#   else
+#       define USE_JUMP_FCONTEXT
+#   endif
+#   define USE_DEAD_TASK_CHECKING
+#   include "s_port_posix.h"
+#elif defined __riscv
+#   define USE_IN_EMBEDDED
+#   define USE_JUMP_FCONTEXT
+#   define USE_LIST_TIMER_CONTAINER
+#   include "s_port_gd32vf103.h"
+#else
+#   error "no arch detected"
+#endif
+
+typedef struct {
+    s_list_t wait_list;
+#ifdef USE_DEAD_TASK_CHECKING
+    s_list_t self;
+#endif
+    bool locked;
+} s_mutex_t;
+
+typedef struct {
+    s_list_t wait_list;
+#ifdef USE_DEAD_TASK_CHECKING
+    s_list_t self;
+#endif
+} s_event_t;
+
+typedef struct {
+    uint16_t max_count;
+    uint16_t begin;
+    uint16_t available_count;
+    uint16_t element_size;
+    s_event_t event;
+} s_chan_t;
+
+
+#include "s_task_internal.h"
+
+
+
+/* Initialize the task system. */
+void s_task_init_system_(void);
+#define s_task_init_system() __async__ = 0; (void)__awaiter_dummy__; s_task_init_system_()
+
+
+
+/* Create a new task */
+void s_task_create(void *stack, size_t stack_size, s_task_fn_t entry, void *arg);
+
+/* Wait a task to exit */
+int s_task_join(__async__, void *stack);
+
+/* Kill a task */
+void s_task_kill(void *stack);
+
+/* Sleep in ticks */
+int s_task_sleep_ticks(__async__, my_clock_t ticks);
+
+/* Sleep in milliseconds */
+int s_task_msleep(__async__, uint32_t msec);
+
+/* Sleep in seconds */
+int s_task_sleep(__async__, uint32_t sec);
+
+/* Yield current task */
+void s_task_yield(__async__);
+
+/* Cancel task waiting and make it running */
+void s_task_cancel_wait(void* stack);
+
+/* Get free stack size (for debug) */
+size_t s_task_get_stack_free_size(void);
+
+/* Dump task information */
+/* void dump_tasks(__async__); */
+
+/* Initialize a mutex */
+void s_mutex_init(s_mutex_t *mutex);
+
+/* Lock the mutex */
+int s_mutex_lock(__async__, s_mutex_t *mutex);
+
+/* Unlock the mutex */
+void s_mutex_unlock(s_mutex_t *mutex);
+
+/* Initialize a wait event */
+void s_event_init(s_event_t *event);
+
+/* Set event */
+void s_event_set(s_event_t *event);
+
+/* Wait event
+ *  return 0 on event set
+ *  return -1 on event waiting cancelled
+ */
+int s_event_wait(__async__, s_event_t *event);
+
+/* Wait event with timeout */
+int s_event_wait_msec(__async__, s_event_t *event, uint32_t msec);
+
+/* Wait event with timeout */
+int s_event_wait_sec(__async__, s_event_t *event, uint32_t msec);
+
+
+/* macro: Declare the chan variable
+ *    name: name of the chan
+ *    TYPE: type of element in the chan
+ *    count: max count of element buffer in the chan
+ */
+#define s_chan_declare(name,TYPE,count)                                                         \
+    s_chan_t name[1 + ((count)*sizeof(TYPE) + sizeof(s_chan_t) - 1) / sizeof(s_chan_t)]
+
+/* macro: Initialize the chan (parameters same as what's in s_declare_chan).
+ * To make a chan, we need to use "s_chan_declare" and then call "s_chan_init".
+ */
+#define s_chan_init(name,TYPE,count)    do {                                                    \
+    (&name[0])->max_count       = (count);                                                      \
+    (&name[0])->begin           = 0;                                                            \
+    (&name[0])->available_count = 0;                                                            \
+    (&name[0])->element_size    = sizeof(TYPE);                                                 \
+    s_event_init(&(&name[0])->event);                                                           \
+} while(0)
+
+/* Put element into chan
+ *  return 0 on chan put successfully
+ *  return -1 on chan cancelled
+ */
+int s_chan_put(__async__, s_chan_t *chan, const void *in_object);
+
+/* Put number of elements into chan
+ *  return 0 on chan put successfully
+ *  return -1 on chan cancelled
+ */
+int s_chan_put_n(__async__, s_chan_t *chan, const void *in_object, uint16_t number);
+
+/* Get element from chan
+ *  return 0 on chan get successfully
+ *  return -1 on chan cancelled
+ */
+int s_chan_get(__async__, s_chan_t *chan, void *out_object);
+
+/* Get number of elements from chan
+ *  return 0 on chan get successfully
+ *  return -1 on chan cancelled
+ */
+int s_chan_get_n(__async__, s_chan_t *chan, void *out_object, uint16_t number);
+
+/* milliseconds to ticks */
+my_clock_t msec_to_ticks(uint32_t msec);
+/* seconds to ticks */
+my_clock_t sec_to_ticks(uint32_t sec);
+/* ticks to milliseconds */
+uint32_t ticks_to_msec(my_clock_t ticks);
+/* ticks to seconds */
+uint32_t ticks_to_sec(my_clock_t ticks);
+
+
+#ifdef USE_IN_EMBEDDED
+
+/* Set event in interrupt */
+void s_event_set__in_irq(s_event_t * event);
+
+/*
+ * Task waits event from irq. Disable irq before call this function!
+ *   S_IRQ_DISABLE()
+ *   ...
+ *   s_event_wait__from_irq(...)
+ *   ...
+ *   S_IRQ_ENABLE()
+ */
+int s_event_wait__from_irq(__async__, s_event_t * event);
+
+/*
+ * Task waits event from irq. Disable irq before call this function!
+ *   S_IRQ_DISABLE()
+ *   ...
+ *   s_event_wait_msec__from_irq(...)
+ *   ...
+ *   S_IRQ_ENABLE()
+ */
+int s_event_wait_msec__from_irq(__async__, s_event_t * event, uint32_t msec);
+
+/*
+ * Task waits event from irq. Disable irq before call this function!
+ *   S_IRQ_DISABLE()
+ *   ...
+ *   s_event_wait_sec__from_irq(...)
+ *   ...
+ *   S_IRQ_ENABLE()
+ */
+int s_event_wait_sec__from_irq(__async__, s_event_t * event, uint32_t sec);
+
+
+/* Task puts element into chan and waits interrupt to read the chan */
+void s_chan_put__to_irq(__async__, s_chan_t *chan, const void *in_object);
+
+/* Task puts number of elements into chan and waits interrupt to read the chan */
+void s_chan_put_n__to_irq(__async__, s_chan_t *chan, const void *in_object, uint16_t number);
+
+/* Task waits interrupt to write the chan and then gets element from chan */
+void s_chan_get__from_irq(__async__, s_chan_t *chan, void *out_object);
+
+/* Task waits interrupt to write the chan and then gets number of elements from chan */
+void s_chan_get_n__from_irq(__async__, s_chan_t *chan, void *out_object, uint16_t number);
+
+
+/*
+ * Interrupt writes element into the chan,
+ * return number of element was written into chan
+ */
+uint16_t s_chan_put__in_irq(s_chan_t *chan, const void *in_object);
+
+/*
+ * Interrupt writes number of elements into the chan,
+ * return number of element was written into chan
+ */
+uint16_t s_chan_put_n__in_irq(s_chan_t *chan, const void *in_object, uint16_t number);
+
+/*
+ * Interrupt reads element from chan,
+ * return number of element was read from chan
+ */
+uint16_t s_chan_get__in_irq(s_chan_t *chan, void *out_object);
+
+/*
+ * Interrupt reads number of elements from chan,
+ * return number of element was read from chan
+ */
+uint16_t s_chan_get_n__in_irq(s_chan_t *chan, void *out_object, uint16_t number);
+
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/osal/inc/sugar/s_task_internal.h b/osal/inc/sugar/s_task_internal.h
new file mode 100644
index 0000000..81bf0b7
--- /dev/null
+++ b/osal/inc/sugar/s_task_internal.h
@@ -0,0 +1,131 @@
+#ifndef INC_S_TASK_INTERNAL_H_
+#define INC_S_TASK_INTERNAL_H_
+
+/* Copyright xhawk, MIT license */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************/
+/* s_task type definitions                                         */
+/*******************************************************************/
+
+#ifdef USE_JUMP_FCONTEXT
+typedef void* fcontext_t;
+typedef struct {
+    fcontext_t  fctx;
+    void* data;
+} transfer_t;
+#endif
+
+typedef struct tag_s_task_t {
+    s_list_t     node;
+    s_event_t    join_event;
+    s_task_fn_t  task_entry;
+    void        *task_arg;
+#if defined   USE_SWAP_CONTEXT
+    ucontext_t   uc;
+#   ifdef __APPLE__
+    char dummy[512]; /* it seems darwin ucontext has no enough memory ? */
+#   endif
+#elif defined USE_JUMP_FCONTEXT
+    fcontext_t   fc;
+#endif
+    size_t       stack_size;
+    bool         waiting_cancelled;
+    bool         closed;
+} s_task_t;
+
+typedef struct {
+#ifndef USE_LIST_TIMER_CONTAINER
+    RBTNode    rbt_node;
+#else
+    s_list_t   node;
+#endif
+    s_task_t  *task;
+    my_clock_t wakeup_ticks;
+} s_timer_t;
+
+#if defined USE_JUMP_FCONTEXT
+typedef struct {
+    fcontext_t *from;
+    fcontext_t *to;
+} s_jump_t;
+#endif
+
+typedef struct {
+    s_task_t    main_task;
+    s_list_t    active_tasks;
+    s_task_t   *current_task;
+
+#ifndef USE_LIST_TIMER_CONTAINER
+    RBTree      timers;
+#else
+    s_list_t    timers;
+#endif
+
+#ifdef USE_DEAD_TASK_CHECKING
+    s_list_t    waiting_mutexes;
+    s_list_t    waiting_events;
+#endif
+
+#if defined USE_IN_EMBEDDED
+    s_list_t         irq_active_tasks;
+    volatile uint8_t irq_actived;
+#endif
+} s_task_globals_t;
+
+#if defined USE_IN_EMBEDDED
+#   define THREAD_LOCAL
+#elif defined _MSC_VER
+#   define THREAD_LOCAL __declspec(thread)
+#elif defined __clang__
+#   if __clang_major__ >= 2
+#       define THREAD_LOCAL __thread
+#   else
+#       define THREAD_LOCAL
+#   endif
+#elif defined __GNUC__
+#   define GNUC_VERSION_ (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#   if GNUC_VERSION_ >= 30301
+#       define THREAD_LOCAL __thread
+#   else
+#       define THREAD_LOCAL
+#   endif
+#elif defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L
+#   define THREAD_LOCAL _Thread_local
+#else
+#   define THREAD_LOCAL
+#endif
+extern THREAD_LOCAL s_task_globals_t g_globals;
+
+
+struct tag_s_task_t;
+/* */
+void s_task_context_entry(void);
+#ifdef USE_JUMP_FCONTEXT
+void s_task_fcontext_entry(transfer_t arg);
+#endif
+
+/* Run next task, but not set myself for ready to run */
+void s_task_next(__async__);
+
+void s_timer_run(void);
+uint64_t s_timer_wait_recent(void);
+int s_timer_comparator(const RBTNode* a, const RBTNode* b, void* arg);
+
+uint16_t s_chan_put_(s_chan_t *chan, const void **in_object, uint16_t *number);
+uint16_t s_chan_get_(s_chan_t *chan, void **out_object, uint16_t *number);
+
+/* Return: number of cancelled tasks */
+unsigned int s_task_cancel_dead(void);
+#ifdef USE_DEAD_TASK_CHECKING
+unsigned int s_event_cancel_dead_waiting_tasks_(void);
+unsigned int s_mutex_cancel_dead_waiting_tasks_(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/osal/src/freertos/LICENSE b/osal/src/freertos/LICENSE
deleted file mode 100644
index 2ce4711..0000000
--- a/osal/src/freertos/LICENSE
+++ /dev/null
@@ -1,18 +0,0 @@
-Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-the Software, and to permit persons to whom the Software is furnished to do so,
-subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
diff --git a/osal/src/freertos/MemMang/ReadMe.url b/osal/src/freertos/MemMang/ReadMe.url
deleted file mode 100644
index 6c23737..0000000
--- a/osal/src/freertos/MemMang/ReadMe.url
+++ /dev/null
@@ -1,5 +0,0 @@
-[{000214A0-0000-0000-C000-000000000046}]
-Prop3=19,2
-[InternetShortcut]
-URL=http://www.freertos.org/a00111.html
-IDList=
diff --git a/osal/src/freertos/MemMang/heap_1.c b/osal/src/freertos/MemMang/heap_1.c
deleted file mode 100644
index 0bd40cd..0000000
--- a/osal/src/freertos/MemMang/heap_1.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-/*
- * The simplest possible implementation of pvPortMalloc().  Note that this
- * implementation does NOT allow allocated memory to be freed again.
- *
- * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
- * memory management pages of http://www.FreeRTOS.org for more information.
- */
-#include <stdlib.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
-	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
-#endif
-
-/* A few bytes might be lost to byte aligning the heap start address. */
-#define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
-
-/* Allocate the memory for the heap. */
-#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
-	/* The application writer has already defined the array used for the RTOS
-	heap - probably so it can be placed in a special segment or address. */
-	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
-#else
-	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
-#endif /* configAPPLICATION_ALLOCATED_HEAP */
-
-/* Index into the ucHeap array. */
-static size_t xNextFreeByte = ( size_t ) 0;
-
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-void *pvReturn = NULL;
-static uint8_t *pucAlignedHeap = NULL;
-
-	/* Ensure that blocks are always aligned to the required number of bytes. */
-	#if( portBYTE_ALIGNMENT != 1 )
-	{
-		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
-		{
-			/* Byte alignment required. */
-			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
-		}
-	}
-	#endif
-
-	vTaskSuspendAll();
-	{
-		if( pucAlignedHeap == NULL )
-		{
-			/* Ensure the heap starts on a correctly aligned boundary. */
-			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
-		}
-
-		/* Check there is enough room left for the allocation. */
-		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
-			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
-		{
-			/* Return the next free byte then increment the index past this
-			block. */
-			pvReturn = pucAlignedHeap + xNextFreeByte;
-			xNextFreeByte += xWantedSize;
-		}
-
-		traceMALLOC( pvReturn, xWantedSize );
-	}
-	( void ) xTaskResumeAll();
-
-	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-	}
-	#endif
-
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
-	heap_4.c for alternative implementations, and the memory management pages of
-	http://www.FreeRTOS.org for more information. */
-	( void ) pv;
-
-	/* Force an assert as it is invalid to call this function. */
-	configASSERT( pv == NULL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortInitialiseBlocks( void )
-{
-	/* Only required when static memory is not cleared. */
-	xNextFreeByte = ( size_t ) 0;
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
-}
-
-
-
diff --git a/osal/src/freertos/MemMang/heap_2.c b/osal/src/freertos/MemMang/heap_2.c
deleted file mode 100644
index 33b849d..0000000
--- a/osal/src/freertos/MemMang/heap_2.c
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * A sample implementation of pvPortMalloc() and vPortFree() that permits
- * allocated blocks to be freed, but does not combine adjacent free blocks
- * into a single larger block (and so will fragment memory).  See heap_4.c for
- * an equivalent that does combine adjacent blocks into single larger blocks.
- *
- * See heap_1.c, heap_3.c and heap_4.c for alternative implementations, and the
- * memory management pages of http://www.FreeRTOS.org for more information.
- */
-#include <stdlib.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
-	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
-#endif
-
-/* A few bytes might be lost to byte aligning the heap start address. */
-#define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
-
-/*
- * Initialises the heap structures before their first use.
- */
-static void prvHeapInit( void );
-
-/* Allocate the memory for the heap. */
-#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
-	/* The application writer has already defined the array used for the RTOS
-	heap - probably so it can be placed in a special segment or address. */
-	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
-#else
-	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
-#endif /* configAPPLICATION_ALLOCATED_HEAP */
-
-
-/* Define the linked list structure.  This is used to link free blocks in order
-of their size. */
-typedef struct A_BLOCK_LINK
-{
-	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
-	size_t xBlockSize;						/*<< The size of the free block. */
-} BlockLink_t;
-
-
-static const uint16_t heapSTRUCT_SIZE	= ( ( sizeof ( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );
-#define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
-
-/* Create a couple of list links to mark the start and end of the list. */
-static BlockLink_t xStart, xEnd;
-
-/* Keeps track of the number of free bytes remaining, but says nothing about
-fragmentation. */
-static size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;
-
-/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */
-
-/*
- * Insert a block into the list of free blocks - which is ordered by size of
- * the block.  Small blocks at the start of the list and large blocks at the end
- * of the list.
- */
-#define prvInsertBlockIntoFreeList( pxBlockToInsert )								\
-{																					\
-BlockLink_t *pxIterator;															\
-size_t xBlockSize;																	\
-																					\
-	xBlockSize = pxBlockToInsert->xBlockSize;										\
-																					\
-	/* Iterate through the list until a block is found that has a larger size */	\
-	/* than the block we are inserting. */											\
-	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock )	\
-	{																				\
-		/* There is nothing to do here - just iterate to the correct position. */	\
-	}																				\
-																					\
-	/* Update the list to include the block being inserted in the correct */		\
-	/* position. */																	\
-	pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;					\
-	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
-}
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
-static BaseType_t xHeapHasBeenInitialised = pdFALSE;
-void *pvReturn = NULL;
-
-	vTaskSuspendAll();
-	{
-		/* If this is the first call to malloc then the heap will require
-		initialisation to setup the list of free blocks. */
-		if( xHeapHasBeenInitialised == pdFALSE )
-		{
-			prvHeapInit();
-			xHeapHasBeenInitialised = pdTRUE;
-		}
-
-		/* The wanted size is increased so it can contain a BlockLink_t
-		structure in addition to the requested amount of bytes. */
-		if( xWantedSize > 0 )
-		{
-			xWantedSize += heapSTRUCT_SIZE;
-
-			/* Ensure that blocks are always aligned to the required number of bytes. */
-			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
-			{
-				/* Byte alignment required. */
-				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
-			}
-		}
-
-		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
-		{
-			/* Blocks are stored in byte order - traverse the list from the start
-			(smallest) block until one of adequate size is found. */
-			pxPreviousBlock = &xStart;
-			pxBlock = xStart.pxNextFreeBlock;
-			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
-			{
-				pxPreviousBlock = pxBlock;
-				pxBlock = pxBlock->pxNextFreeBlock;
-			}
-
-			/* If we found the end marker then a block of adequate size was not found. */
-			if( pxBlock != &xEnd )
-			{
-				/* Return the memory space - jumping over the BlockLink_t structure
-				at its start. */
-				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
-
-				/* This block is being returned for use so must be taken out of the
-				list of free blocks. */
-				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
-
-				/* If the block is larger than required it can be split into two. */
-				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
-				{
-					/* This block is to be split into two.  Create a new block
-					following the number of bytes requested. The void cast is
-					used to prevent byte alignment warnings from the compiler. */
-					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
-
-					/* Calculate the sizes of two blocks split from the single
-					block. */
-					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
-					pxBlock->xBlockSize = xWantedSize;
-
-					/* Insert the new block into the list of free blocks. */
-					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
-				}
-
-				xFreeBytesRemaining -= pxBlock->xBlockSize;
-			}
-		}
-
-		traceMALLOC( pvReturn, xWantedSize );
-	}
-	( void ) xTaskResumeAll();
-
-	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-	}
-	#endif
-
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-uint8_t *puc = ( uint8_t * ) pv;
-BlockLink_t *pxLink;
-
-	if( pv != NULL )
-	{
-		/* The memory being freed will have an BlockLink_t structure immediately
-		before it. */
-		puc -= heapSTRUCT_SIZE;
-
-		/* This unexpected casting is to keep some compilers from issuing
-		byte alignment warnings. */
-		pxLink = ( void * ) puc;
-
-		vTaskSuspendAll();
-		{
-			/* Add this block to the list of free blocks. */
-			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
-			xFreeBytesRemaining += pxLink->xBlockSize;
-			traceFREE( pv, pxLink->xBlockSize );
-		}
-		( void ) xTaskResumeAll();
-	}
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return xFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-void vPortInitialiseBlocks( void )
-{
-	/* This just exists to keep the linker quiet. */
-}
-/*-----------------------------------------------------------*/
-
-static void prvHeapInit( void )
-{
-BlockLink_t *pxFirstFreeBlock;
-uint8_t *pucAlignedHeap;
-
-	/* Ensure the heap starts on a correctly aligned boundary. */
-	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
-
-	/* xStart is used to hold a pointer to the first item in the list of free
-	blocks.  The void cast is used to prevent compiler warnings. */
-	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
-	xStart.xBlockSize = ( size_t ) 0;
-
-	/* xEnd is used to mark the end of the list of free blocks. */
-	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
-	xEnd.pxNextFreeBlock = NULL;
-
-	/* To start with there is a single free block that is sized to take up the
-	entire heap space. */
-	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
-	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
-	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/MemMang/heap_3.c b/osal/src/freertos/MemMang/heap_3.c
deleted file mode 100644
index 613611b..0000000
--- a/osal/src/freertos/MemMang/heap_3.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-/*
- * Implementation of pvPortMalloc() and vPortFree() that relies on the
- * compilers own malloc() and free() implementations.
- *
- * This file can only be used if the linker is configured to to generate
- * a heap memory area.
- *
- * See heap_1.c, heap_2.c and heap_4.c for alternative implementations, and the
- * memory management pages of http://www.FreeRTOS.org for more information.
- */
-
-#include <stdlib.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
-	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
-#endif
-
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-void *pvReturn;
-
-	vTaskSuspendAll();
-	{
-		pvReturn = malloc( xWantedSize );
-		traceMALLOC( pvReturn, xWantedSize );
-	}
-	( void ) xTaskResumeAll();
-
-	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-	}
-	#endif
-
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-	if( pv )
-	{
-		vTaskSuspendAll();
-		{
-			free( pv );
-			traceFREE( pv, 0 );
-		}
-		( void ) xTaskResumeAll();
-	}
-}
-
-
-
diff --git a/osal/src/freertos/MemMang/heap_4.c b/osal/src/freertos/MemMang/heap_4.c
deleted file mode 100644
index eaf443f..0000000
--- a/osal/src/freertos/MemMang/heap_4.c
+++ /dev/null
@@ -1,492 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * A sample implementation of pvPortMalloc() and vPortFree() that combines
- * (coalescences) adjacent memory blocks as they are freed, and in so doing
- * limits memory fragmentation.
- *
- * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
- * memory management pages of http://www.FreeRTOS.org for more information.
- */
-#include <stdlib.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
-	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
-#endif
-
-/* Block sizes must not get too small. */
-#define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
-
-/* Assumes 8bit bytes! */
-#define heapBITS_PER_BYTE		( ( size_t ) 8 )
-
-/* Allocate the memory for the heap. */
-#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
-	/* The application writer has already defined the array used for the RTOS
-	heap - probably so it can be placed in a special segment or address. */
-	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
-#else
-	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
-#endif /* configAPPLICATION_ALLOCATED_HEAP */
-
-/* Define the linked list structure.  This is used to link free blocks in order
-of their memory address. */
-typedef struct A_BLOCK_LINK
-{
-	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
-	size_t xBlockSize;						/*<< The size of the free block. */
-} BlockLink_t;
-
-/*-----------------------------------------------------------*/
-
-/*
- * Inserts a block of memory that is being freed into the correct position in
- * the list of free memory blocks.  The block being freed will be merged with
- * the block in front it and/or the block behind it if the memory blocks are
- * adjacent to each other.
- */
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
-
-/*
- * Called automatically to setup the required heap structures the first time
- * pvPortMalloc() is called.
- */
-static void prvHeapInit( void );
-
-/*-----------------------------------------------------------*/
-
-/* The size of the structure placed at the beginning of each allocated memory
-block must by correctly byte aligned. */
-static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
-
-/* Create a couple of list links to mark the start and end of the list. */
-static BlockLink_t xStart, *pxEnd = NULL;
-
-/* Keeps track of the number of calls to allocate and free memory as well as the
-number of free bytes remaining, but says nothing about fragmentation. */
-static size_t xFreeBytesRemaining = 0U;
-static size_t xMinimumEverFreeBytesRemaining = 0U;
-static size_t xNumberOfSuccessfulAllocations = 0;
-static size_t xNumberOfSuccessfulFrees = 0;
-
-/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
-member of an BlockLink_t structure is set then the block belongs to the
-application.  When the bit is free the block is still part of the free heap
-space. */
-static size_t xBlockAllocatedBit = 0;
-
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
-void *pvReturn = NULL;
-
-	vTaskSuspendAll();
-	{
-		/* If this is the first call to malloc then the heap will require
-		initialisation to setup the list of free blocks. */
-		if( pxEnd == NULL )
-		{
-			prvHeapInit();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		/* Check the requested block size is not so large that the top bit is
-		set.  The top bit of the block size member of the BlockLink_t structure
-		is used to determine who owns the block - the application or the
-		kernel, so it must be free. */
-		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
-		{
-			/* The wanted size is increased so it can contain a BlockLink_t
-			structure in addition to the requested amount of bytes. */
-			if( xWantedSize > 0 )
-			{
-				xWantedSize += xHeapStructSize;
-
-				/* Ensure that blocks are always aligned to the required number
-				of bytes. */
-				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
-				{
-					/* Byte alignment required. */
-					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
-					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
-			{
-				/* Traverse the list from the start	(lowest address) block until
-				one	of adequate size is found. */
-				pxPreviousBlock = &xStart;
-				pxBlock = xStart.pxNextFreeBlock;
-				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
-				{
-					pxPreviousBlock = pxBlock;
-					pxBlock = pxBlock->pxNextFreeBlock;
-				}
-
-				/* If the end marker was reached then a block of adequate size
-				was	not found. */
-				if( pxBlock != pxEnd )
-				{
-					/* Return the memory space pointed to - jumping over the
-					BlockLink_t structure at its start. */
-					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
-
-					/* This block is being returned for use so must be taken out
-					of the list of free blocks. */
-					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
-
-					/* If the block is larger than required it can be split into
-					two. */
-					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
-					{
-						/* This block is to be split into two.  Create a new
-						block following the number of bytes requested. The void
-						cast is used to prevent byte alignment warnings from the
-						compiler. */
-						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
-						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
-
-						/* Calculate the sizes of two blocks split from the
-						single block. */
-						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
-						pxBlock->xBlockSize = xWantedSize;
-
-						/* Insert the new block into the list of free blocks. */
-						prvInsertBlockIntoFreeList( pxNewBlockLink );
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					xFreeBytesRemaining -= pxBlock->xBlockSize;
-
-					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
-					{
-						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* The block is being returned - it is allocated and owned
-					by the application and has no "next" block. */
-					pxBlock->xBlockSize |= xBlockAllocatedBit;
-					pxBlock->pxNextFreeBlock = NULL;
-					xNumberOfSuccessfulAllocations++;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		traceMALLOC( pvReturn, xWantedSize );
-	}
-	( void ) xTaskResumeAll();
-
-	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#endif
-
-	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-uint8_t *puc = ( uint8_t * ) pv;
-BlockLink_t *pxLink;
-
-	if( pv != NULL )
-	{
-		/* The memory being freed will have an BlockLink_t structure immediately
-		before it. */
-		puc -= xHeapStructSize;
-
-		/* This casting is to keep the compiler from issuing warnings. */
-		pxLink = ( void * ) puc;
-
-		/* Check the block is actually allocated. */
-		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
-		configASSERT( pxLink->pxNextFreeBlock == NULL );
-
-		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
-		{
-			if( pxLink->pxNextFreeBlock == NULL )
-			{
-				/* The block is being returned to the heap - it is no longer
-				allocated. */
-				pxLink->xBlockSize &= ~xBlockAllocatedBit;
-
-				vTaskSuspendAll();
-				{
-					/* Add this block to the list of free blocks. */
-					xFreeBytesRemaining += pxLink->xBlockSize;
-					traceFREE( pv, pxLink->xBlockSize );
-					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
-					xNumberOfSuccessfulFrees++;
-				}
-				( void ) xTaskResumeAll();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return xFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetMinimumEverFreeHeapSize( void )
-{
-	return xMinimumEverFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-void vPortInitialiseBlocks( void )
-{
-	/* This just exists to keep the linker quiet. */
-}
-/*-----------------------------------------------------------*/
-
-static void prvHeapInit( void )
-{
-BlockLink_t *pxFirstFreeBlock;
-uint8_t *pucAlignedHeap;
-size_t uxAddress;
-size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
-
-	/* Ensure the heap starts on a correctly aligned boundary. */
-	uxAddress = ( size_t ) ucHeap;
-
-	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
-	{
-		uxAddress += ( portBYTE_ALIGNMENT - 1 );
-		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
-		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
-	}
-
-	pucAlignedHeap = ( uint8_t * ) uxAddress;
-
-	/* xStart is used to hold a pointer to the first item in the list of free
-	blocks.  The void cast is used to prevent compiler warnings. */
-	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
-	xStart.xBlockSize = ( size_t ) 0;
-
-	/* pxEnd is used to mark the end of the list of free blocks and is inserted
-	at the end of the heap space. */
-	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
-	uxAddress -= xHeapStructSize;
-	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
-	pxEnd = ( void * ) uxAddress;
-	pxEnd->xBlockSize = 0;
-	pxEnd->pxNextFreeBlock = NULL;
-
-	/* To start with there is a single free block that is sized to take up the
-	entire heap space, minus the space taken by pxEnd. */
-	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
-	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
-	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
-
-	/* Only one block exists - and it covers the entire usable heap space. */
-	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-
-	/* Work out the position of the top bit in a size_t variable. */
-	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
-}
-/*-----------------------------------------------------------*/
-
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
-{
-BlockLink_t *pxIterator;
-uint8_t *puc;
-
-	/* Iterate through the list until a block is found that has a higher address
-	than the block being inserted. */
-	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
-	{
-		/* Nothing to do here, just iterate to the right position. */
-	}
-
-	/* Do the block being inserted, and the block it is being inserted after
-	make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxIterator;
-	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
-	{
-		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
-		pxBlockToInsert = pxIterator;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Do the block being inserted, and the block it is being inserted before
-	make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxBlockToInsert;
-	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
-	{
-		if( pxIterator->pxNextFreeBlock != pxEnd )
-		{
-			/* Form one big block from the two blocks. */
-			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
-			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
-		}
-		else
-		{
-			pxBlockToInsert->pxNextFreeBlock = pxEnd;
-		}
-	}
-	else
-	{
-		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
-	}
-
-	/* If the block being inserted plugged a gab, so was merged with the block
-	before and the block after, then it's pxNextFreeBlock pointer will have
-	already been set, and should not be set here as that would make it point
-	to itself. */
-	if( pxIterator != pxBlockToInsert )
-	{
-		pxIterator->pxNextFreeBlock = pxBlockToInsert;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortGetHeapStats( HeapStats_t *pxHeapStats )
-{
-BlockLink_t *pxBlock;
-size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
-
-	vTaskSuspendAll();
-	{
-		pxBlock = xStart.pxNextFreeBlock;
-
-		/* pxBlock will be NULL if the heap has not been initialised.  The heap
-		is initialised automatically when the first allocation is made. */
-		if( pxBlock != NULL )
-		{
-			do
-			{
-				/* Increment the number of blocks and record the largest block seen
-				so far. */
-				xBlocks++;
-
-				if( pxBlock->xBlockSize > xMaxSize )
-				{
-					xMaxSize = pxBlock->xBlockSize;
-				}
-
-				if( pxBlock->xBlockSize < xMinSize )
-				{
-					xMinSize = pxBlock->xBlockSize;
-				}
-
-				/* Move to the next block in the chain until the last block is
-				reached. */
-				pxBlock = pxBlock->pxNextFreeBlock;
-			} while( pxBlock != pxEnd );
-		}
-	}
-	xTaskResumeAll();
-
-	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
-	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
-	pxHeapStats->xNumberOfFreeBlocks = xBlocks;
-
-	taskENTER_CRITICAL();
-	{
-		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
-		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
-		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
-		pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
-	}
-	taskEXIT_CRITICAL();
-}
-
diff --git a/osal/src/freertos/MemMang/heap_5.c b/osal/src/freertos/MemMang/heap_5.c
deleted file mode 100644
index 56abb78..0000000
--- a/osal/src/freertos/MemMang/heap_5.c
+++ /dev/null
@@ -1,547 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * A sample implementation of pvPortMalloc() that allows the heap to be defined
- * across multiple non-contigous blocks and combines (coalescences) adjacent
- * memory blocks as they are freed.
- *
- * See heap_1.c, heap_2.c, heap_3.c and heap_4.c for alternative
- * implementations, and the memory management pages of http://www.FreeRTOS.org
- * for more information.
- *
- * Usage notes:
- *
- * vPortDefineHeapRegions() ***must*** be called before pvPortMalloc().
- * pvPortMalloc() will be called if any task objects (tasks, queues, event
- * groups, etc.) are created, therefore vPortDefineHeapRegions() ***must*** be
- * called before any other objects are defined.
- *
- * vPortDefineHeapRegions() takes a single parameter.  The parameter is an array
- * of HeapRegion_t structures.  HeapRegion_t is defined in portable.h as
- *
- * typedef struct HeapRegion
- * {
- *	uint8_t *pucStartAddress; << Start address of a block of memory that will be part of the heap.
- *	size_t xSizeInBytes;	  << Size of the block of memory.
- * } HeapRegion_t;
- *
- * The array is terminated using a NULL zero sized region definition, and the
- * memory regions defined in the array ***must*** appear in address order from
- * low address to high address.  So the following is a valid example of how
- * to use the function.
- *
- * HeapRegion_t xHeapRegions[] =
- * {
- * 	{ ( uint8_t * ) 0x80000000UL, 0x10000 }, << Defines a block of 0x10000 bytes starting at address 0x80000000
- * 	{ ( uint8_t * ) 0x90000000UL, 0xa0000 }, << Defines a block of 0xa0000 bytes starting at address of 0x90000000
- * 	{ NULL, 0 }                << Terminates the array.
- * };
- *
- * vPortDefineHeapRegions( xHeapRegions ); << Pass the array into vPortDefineHeapRegions().
- *
- * Note 0x80000000 is the lower address so appears in the array first.
- *
- */
-#include <stdlib.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
-	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
-#endif
-
-/* Block sizes must not get too small. */
-#define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
-
-/* Assumes 8bit bytes! */
-#define heapBITS_PER_BYTE		( ( size_t ) 8 )
-
-/* Define the linked list structure.  This is used to link free blocks in order
-of their memory address. */
-typedef struct A_BLOCK_LINK
-{
-	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
-	size_t xBlockSize;						/*<< The size of the free block. */
-} BlockLink_t;
-
-/*-----------------------------------------------------------*/
-
-/*
- * Inserts a block of memory that is being freed into the correct position in
- * the list of free memory blocks.  The block being freed will be merged with
- * the block in front it and/or the block behind it if the memory blocks are
- * adjacent to each other.
- */
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
-
-/*-----------------------------------------------------------*/
-
-/* The size of the structure placed at the beginning of each allocated memory
-block must by correctly byte aligned. */
-static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
-
-/* Create a couple of list links to mark the start and end of the list. */
-static BlockLink_t xStart, *pxEnd = NULL;
-
-/* Keeps track of the number of calls to allocate and free memory as well as the
-number of free bytes remaining, but says nothing about fragmentation. */
-static size_t xFreeBytesRemaining = 0U;
-static size_t xMinimumEverFreeBytesRemaining = 0U;
-static size_t xNumberOfSuccessfulAllocations = 0;
-static size_t xNumberOfSuccessfulFrees = 0;
-
-/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
-member of an BlockLink_t structure is set then the block belongs to the
-application.  When the bit is free the block is still part of the free heap
-space. */
-static size_t xBlockAllocatedBit = 0;
-
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
-void *pvReturn = NULL;
-
-	/* The heap must be initialised before the first call to
-	prvPortMalloc(). */
-	configASSERT( pxEnd );
-
-	vTaskSuspendAll();
-	{
-		/* Check the requested block size is not so large that the top bit is
-		set.  The top bit of the block size member of the BlockLink_t structure
-		is used to determine who owns the block - the application or the
-		kernel, so it must be free. */
-		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
-		{
-			/* The wanted size is increased so it can contain a BlockLink_t
-			structure in addition to the requested amount of bytes. */
-			if( xWantedSize > 0 )
-			{
-				xWantedSize += xHeapStructSize;
-
-				/* Ensure that blocks are always aligned to the required number
-				of bytes. */
-				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
-				{
-					/* Byte alignment required. */
-					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
-			{
-				/* Traverse the list from the start	(lowest address) block until
-				one	of adequate size is found. */
-				pxPreviousBlock = &xStart;
-				pxBlock = xStart.pxNextFreeBlock;
-				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
-				{
-					pxPreviousBlock = pxBlock;
-					pxBlock = pxBlock->pxNextFreeBlock;
-				}
-
-				/* If the end marker was reached then a block of adequate size
-				was	not found. */
-				if( pxBlock != pxEnd )
-				{
-					/* Return the memory space pointed to - jumping over the
-					BlockLink_t structure at its start. */
-					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
-
-					/* This block is being returned for use so must be taken out
-					of the list of free blocks. */
-					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
-
-					/* If the block is larger than required it can be split into
-					two. */
-					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
-					{
-						/* This block is to be split into two.  Create a new
-						block following the number of bytes requested. The void
-						cast is used to prevent byte alignment warnings from the
-						compiler. */
-						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
-
-						/* Calculate the sizes of two blocks split from the
-						single block. */
-						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
-						pxBlock->xBlockSize = xWantedSize;
-
-						/* Insert the new block into the list of free blocks. */
-						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					xFreeBytesRemaining -= pxBlock->xBlockSize;
-
-					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
-					{
-						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* The block is being returned - it is allocated and owned
-					by the application and has no "next" block. */
-					pxBlock->xBlockSize |= xBlockAllocatedBit;
-					pxBlock->pxNextFreeBlock = NULL;
-					xNumberOfSuccessfulAllocations++;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		traceMALLOC( pvReturn, xWantedSize );
-	}
-	( void ) xTaskResumeAll();
-
-	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#endif
-
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-uint8_t *puc = ( uint8_t * ) pv;
-BlockLink_t *pxLink;
-
-	if( pv != NULL )
-	{
-		/* The memory being freed will have an BlockLink_t structure immediately
-		before it. */
-		puc -= xHeapStructSize;
-
-		/* This casting is to keep the compiler from issuing warnings. */
-		pxLink = ( void * ) puc;
-
-		/* Check the block is actually allocated. */
-		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
-		configASSERT( pxLink->pxNextFreeBlock == NULL );
-
-		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
-		{
-			if( pxLink->pxNextFreeBlock == NULL )
-			{
-				/* The block is being returned to the heap - it is no longer
-				allocated. */
-				pxLink->xBlockSize &= ~xBlockAllocatedBit;
-
-				vTaskSuspendAll();
-				{
-					/* Add this block to the list of free blocks. */
-					xFreeBytesRemaining += pxLink->xBlockSize;
-					traceFREE( pv, pxLink->xBlockSize );
-					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
-					xNumberOfSuccessfulFrees++;
-				}
-				( void ) xTaskResumeAll();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return xFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetMinimumEverFreeHeapSize( void )
-{
-	return xMinimumEverFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
-{
-BlockLink_t *pxIterator;
-uint8_t *puc;
-
-	/* Iterate through the list until a block is found that has a higher address
-	than the block being inserted. */
-	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
-	{
-		/* Nothing to do here, just iterate to the right position. */
-	}
-
-	/* Do the block being inserted, and the block it is being inserted after
-	make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxIterator;
-	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
-	{
-		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
-		pxBlockToInsert = pxIterator;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Do the block being inserted, and the block it is being inserted before
-	make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxBlockToInsert;
-	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
-	{
-		if( pxIterator->pxNextFreeBlock != pxEnd )
-		{
-			/* Form one big block from the two blocks. */
-			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
-			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
-		}
-		else
-		{
-			pxBlockToInsert->pxNextFreeBlock = pxEnd;
-		}
-	}
-	else
-	{
-		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
-	}
-
-	/* If the block being inserted plugged a gab, so was merged with the block
-	before and the block after, then it's pxNextFreeBlock pointer will have
-	already been set, and should not be set here as that would make it point
-	to itself. */
-	if( pxIterator != pxBlockToInsert )
-	{
-		pxIterator->pxNextFreeBlock = pxBlockToInsert;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )
-{
-BlockLink_t *pxFirstFreeBlockInRegion = NULL, *pxPreviousFreeBlock;
-size_t xAlignedHeap;
-size_t xTotalRegionSize, xTotalHeapSize = 0;
-BaseType_t xDefinedRegions = 0;
-size_t xAddress;
-const HeapRegion_t *pxHeapRegion;
-
-	/* Can only call once! */
-	configASSERT( pxEnd == NULL );
-
-	pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
-
-	while( pxHeapRegion->xSizeInBytes > 0 )
-	{
-		xTotalRegionSize = pxHeapRegion->xSizeInBytes;
-
-		/* Ensure the heap region starts on a correctly aligned boundary. */
-		xAddress = ( size_t ) pxHeapRegion->pucStartAddress;
-		if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
-		{
-			xAddress += ( portBYTE_ALIGNMENT - 1 );
-			xAddress &= ~portBYTE_ALIGNMENT_MASK;
-
-			/* Adjust the size for the bytes lost to alignment. */
-			xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;
-		}
-
-		xAlignedHeap = xAddress;
-
-		/* Set xStart if it has not already been set. */
-		if( xDefinedRegions == 0 )
-		{
-			/* xStart is used to hold a pointer to the first item in the list of
-			free blocks.  The void cast is used to prevent compiler warnings. */
-			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
-			xStart.xBlockSize = ( size_t ) 0;
-		}
-		else
-		{
-			/* Should only get here if one region has already been added to the
-			heap. */
-			configASSERT( pxEnd != NULL );
-
-			/* Check blocks are passed in with increasing start addresses. */
-			configASSERT( xAddress > ( size_t ) pxEnd );
-		}
-
-		/* Remember the location of the end marker in the previous region, if
-		any. */
-		pxPreviousFreeBlock = pxEnd;
-
-		/* pxEnd is used to mark the end of the list of free blocks and is
-		inserted at the end of the region space. */
-		xAddress = xAlignedHeap + xTotalRegionSize;
-		xAddress -= xHeapStructSize;
-		xAddress &= ~portBYTE_ALIGNMENT_MASK;
-		pxEnd = ( BlockLink_t * ) xAddress;
-		pxEnd->xBlockSize = 0;
-		pxEnd->pxNextFreeBlock = NULL;
-
-		/* To start with there is a single free block in this region that is
-		sized to take up the entire heap region minus the space taken by the
-		free block structure. */
-		pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;
-		pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;
-		pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;
-
-		/* If this is not the first region that makes up the entire heap space
-		then link the previous region to this region. */
-		if( pxPreviousFreeBlock != NULL )
-		{
-			pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;
-		}
-
-		xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;
-
-		/* Move onto the next HeapRegion_t structure. */
-		xDefinedRegions++;
-		pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
-	}
-
-	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
-	xFreeBytesRemaining = xTotalHeapSize;
-
-	/* Check something was actually defined before it is accessed. */
-	configASSERT( xTotalHeapSize );
-
-	/* Work out the position of the top bit in a size_t variable. */
-	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
-}
-/*-----------------------------------------------------------*/
-
-void vPortGetHeapStats( HeapStats_t *pxHeapStats )
-{
-BlockLink_t *pxBlock;
-size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
-
-	vTaskSuspendAll();
-	{
-		pxBlock = xStart.pxNextFreeBlock;
-
-		/* pxBlock will be NULL if the heap has not been initialised.  The heap
-		is initialised automatically when the first allocation is made. */
-		if( pxBlock != NULL )
-		{
-			do
-			{
-				/* Increment the number of blocks and record the largest block seen
-				so far. */
-				xBlocks++;
-
-				if( pxBlock->xBlockSize > xMaxSize )
-				{
-					xMaxSize = pxBlock->xBlockSize;
-				}
-
-				/* Heap five will have a zero sized block at the end of each
-				each region - the block is only used to link to the next
-				heap region so it not a real block. */
-				if( pxBlock->xBlockSize != 0 )
-				{
-					if( pxBlock->xBlockSize < xMinSize )
-					{
-						xMinSize = pxBlock->xBlockSize;
-					}
-				}
-
-				/* Move to the next block in the chain until the last block is
-				reached. */
-				pxBlock = pxBlock->pxNextFreeBlock;
-			} while( pxBlock != pxEnd );
-		}
-	}
-	xTaskResumeAll();
-
-	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
-	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
-	pxHeapStats->xNumberOfFreeBlocks = xBlocks;
-
-	taskENTER_CRITICAL();
-	{
-		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
-		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
-		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
-		pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
-	}
-	taskEXIT_CRITICAL();
-}
-
diff --git a/osal/src/freertos/croutine.c b/osal/src/freertos/croutine.c
deleted file mode 100644
index 9ce5003..0000000
--- a/osal/src/freertos/croutine.c
+++ /dev/null
@@ -1,353 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#include "FreeRTOS.h"
-#include "task.h"
-#include "croutine.h"
-
-/* Remove the whole file is co-routines are not being used. */
-#if( configUSE_CO_ROUTINES != 0 )
-
-/*
- * Some kernel aware debuggers require data to be viewed to be global, rather
- * than file scope.
- */
-#ifdef portREMOVE_STATIC_QUALIFIER
-	#define static
-#endif
-
-
-/* Lists for ready and blocked co-routines. --------------------*/
-static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
-static List_t xDelayedCoRoutineList1;									/*< Delayed co-routines. */
-static List_t xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
-static List_t * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
-static List_t * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
-static List_t xPendingReadyCoRoutineList;								/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
-
-/* Other file private variables. --------------------------------*/
-CRCB_t * pxCurrentCoRoutine = NULL;
-static UBaseType_t uxTopCoRoutineReadyPriority = 0;
-static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
-
-/* The initial state of the co-routine when it is created. */
-#define corINITIAL_STATE	( 0 )
-
-/*
- * Place the co-routine represented by pxCRCB into the appropriate ready queue
- * for the priority.  It is inserted at the end of the list.
- *
- * This macro accesses the co-routine ready lists and therefore must not be
- * used from within an ISR.
- */
-#define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
-{																													\
-	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
-	{																												\
-		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
-	}																												\
-	vListInsertEnd( ( List_t * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
-}
-
-/*
- * Utility to ready all the lists used by the scheduler.  This is called
- * automatically upon the creation of the first co-routine.
- */
-static void prvInitialiseCoRoutineLists( void );
-
-/*
- * Co-routines that are readied by an interrupt cannot be placed directly into
- * the ready lists (there is no mutual exclusion).  Instead they are placed in
- * in the pending ready list in order that they can later be moved to the ready
- * list by the co-routine scheduler.
- */
-static void prvCheckPendingReadyList( void );
-
-/*
- * Macro that looks at the list of co-routines that are currently delayed to
- * see if any require waking.
- *
- * Co-routines are stored in the queue in the order of their wake time -
- * meaning once one co-routine has been found whose timer has not expired
- * we need not look any further down the list.
- */
-static void prvCheckDelayedList( void );
-
-/*-----------------------------------------------------------*/
-
-BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
-{
-BaseType_t xReturn;
-CRCB_t *pxCoRoutine;
-
-	/* Allocate the memory that will store the co-routine control block. */
-	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
-	if( pxCoRoutine )
-	{
-		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
-		be created and the co-routine data structures need initialising. */
-		if( pxCurrentCoRoutine == NULL )
-		{
-			pxCurrentCoRoutine = pxCoRoutine;
-			prvInitialiseCoRoutineLists();
-		}
-
-		/* Check the priority is within limits. */
-		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
-		{
-			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
-		}
-
-		/* Fill out the co-routine control block from the function parameters. */
-		pxCoRoutine->uxState = corINITIAL_STATE;
-		pxCoRoutine->uxPriority = uxPriority;
-		pxCoRoutine->uxIndex = uxIndex;
-		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
-
-		/* Initialise all the other co-routine control block parameters. */
-		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
-		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
-
-		/* Set the co-routine control block as a link back from the ListItem_t.
-		This is so we can get back to the containing CRCB from a generic item
-		in a list. */
-		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
-		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
-
-		/* Event lists are always in priority order. */
-		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
-
-		/* Now the co-routine has been initialised it can be added to the ready
-		list at the correct priority. */
-		prvAddCoRoutineToReadyQueue( pxCoRoutine );
-
-		xReturn = pdPASS;
-	}
-	else
-	{
-		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
-{
-TickType_t xTimeToWake;
-
-	/* Calculate the time to wake - this may overflow but this is
-	not a problem. */
-	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
-
-	/* We must remove ourselves from the ready list before adding
-	ourselves to the blocked list as the same list item is used for
-	both lists. */
-	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
-
-	/* The list item will be inserted in wake time order. */
-	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
-
-	if( xTimeToWake < xCoRoutineTickCount )
-	{
-		/* Wake time has overflowed.  Place this item in the
-		overflow list. */
-		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
-	}
-	else
-	{
-		/* The wake time has not overflowed, so we can use the
-		current block list. */
-		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
-	}
-
-	if( pxEventList )
-	{
-		/* Also add the co-routine to an event list.  If this is done then the
-		function must be called with interrupts disabled. */
-		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvCheckPendingReadyList( void )
-{
-	/* Are there any co-routines waiting to get moved to the ready list?  These
-	are co-routines that have been readied by an ISR.  The ISR cannot access
-	the	ready lists itself. */
-	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
-	{
-		CRCB_t *pxUnblockedCRCB;
-
-		/* The pending ready list can be accessed by an ISR. */
-		portDISABLE_INTERRUPTS();
-		{
-			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
-			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
-		}
-		portENABLE_INTERRUPTS();
-
-		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
-		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvCheckDelayedList( void )
-{
-CRCB_t *pxCRCB;
-
-	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
-	while( xPassedTicks )
-	{
-		xCoRoutineTickCount++;
-		xPassedTicks--;
-
-		/* If the tick count has overflowed we need to swap the ready lists. */
-		if( xCoRoutineTickCount == 0 )
-		{
-			List_t * pxTemp;
-
-			/* Tick count has overflowed so we need to swap the delay lists.  If there are
-			any items in pxDelayedCoRoutineList here then there is an error! */
-			pxTemp = pxDelayedCoRoutineList;
-			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
-			pxOverflowDelayedCoRoutineList = pxTemp;
-		}
-
-		/* See if this tick has made a timeout expire. */
-		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
-		{
-			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
-
-			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
-			{
-				/* Timeout not yet expired. */
-				break;
-			}
-
-			portDISABLE_INTERRUPTS();
-			{
-				/* The event could have occurred just before this critical
-				section.  If this is the case then the generic list item will
-				have been moved to the pending ready list and the following
-				line is still valid.  Also the pvContainer parameter will have
-				been set to NULL so the following lines are also valid. */
-				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
-
-				/* Is the co-routine waiting on an event also? */
-				if( pxCRCB->xEventListItem.pxContainer )
-				{
-					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
-				}
-			}
-			portENABLE_INTERRUPTS();
-
-			prvAddCoRoutineToReadyQueue( pxCRCB );
-		}
-	}
-
-	xLastTickCount = xCoRoutineTickCount;
-}
-/*-----------------------------------------------------------*/
-
-void vCoRoutineSchedule( void )
-{
-	/* See if any co-routines readied by events need moving to the ready lists. */
-	prvCheckPendingReadyList();
-
-	/* See if any delayed co-routines have timed out. */
-	prvCheckDelayedList();
-
-	/* Find the highest priority queue that contains ready co-routines. */
-	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
-	{
-		if( uxTopCoRoutineReadyPriority == 0 )
-		{
-			/* No more co-routines to check. */
-			return;
-		}
-		--uxTopCoRoutineReadyPriority;
-	}
-
-	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
-	 of the	same priority get an equal share of the processor time. */
-	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
-
-	/* Call the co-routine. */
-	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
-
-	return;
-}
-/*-----------------------------------------------------------*/
-
-static void prvInitialiseCoRoutineLists( void )
-{
-UBaseType_t uxPriority;
-
-	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
-	{
-		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
-	}
-
-	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
-	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
-	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
-
-	/* Start with pxDelayedCoRoutineList using list1 and the
-	pxOverflowDelayedCoRoutineList using list2. */
-	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
-	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
-{
-CRCB_t *pxUnblockedCRCB;
-BaseType_t xReturn;
-
-	/* This function is called from within an interrupt.  It can only access
-	event lists and the pending ready list.  This function assumes that a
-	check has already been made to ensure pxEventList is not empty. */
-	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
-	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
-	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
-
-	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
-	{
-		xReturn = pdTRUE;
-	}
-	else
-	{
-		xReturn = pdFALSE;
-	}
-
-	return xReturn;
-}
-
-#endif /* configUSE_CO_ROUTINES == 0 */
-
diff --git a/osal/src/freertos/event_groups.c b/osal/src/freertos/event_groups.c
deleted file mode 100644
index bf4ec24..0000000
--- a/osal/src/freertos/event_groups.c
+++ /dev/null
@@ -1,753 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdlib.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* FreeRTOS includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-#include "timers.h"
-#include "event_groups.h"
-
-/* Lint e961, e750 and e9021 are suppressed as a MISRA exception justified
-because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
-for the header files above, but not in this file, in order to generate the
-correct privileged Vs unprivileged linkage and placement. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021 See comment above. */
-
-/* The following bit fields convey control information in a task's event list
-item value.  It is important they don't clash with the
-taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
-#if configUSE_16_BIT_TICKS == 1
-	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
-	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
-	#define eventWAIT_FOR_ALL_BITS			0x0400U
-	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
-#else
-	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
-	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
-	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
-	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
-#endif
-
-typedef struct EventGroupDef_t
-{
-	EventBits_t uxEventBits;
-	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
-
-	#if( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxEventGroupNumber;
-	#endif
-
-	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
-	#endif
-} EventGroup_t;
-
-/*-----------------------------------------------------------*/
-
-/*
- * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
- * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
- * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
- * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
- * wait condition is met if any of the bits set in uxBitsToWait for are also set
- * in uxCurrentEventBits.
- */
-static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
-	{
-	EventGroup_t *pxEventBits;
-
-		/* A StaticEventGroup_t object must be provided. */
-		configASSERT( pxEventGroupBuffer );
-
-		#if( configASSERT_DEFINED == 1 )
-		{
-			/* Sanity check that the size of the structure used to declare a
-			variable of type StaticEventGroup_t equals the size of the real
-			event group structure. */
-			volatile size_t xSize = sizeof( StaticEventGroup_t );
-			configASSERT( xSize == sizeof( EventGroup_t ) );
-		} /*lint !e529 xSize is referenced if configASSERT() is defined. */
-		#endif /* configASSERT_DEFINED */
-
-		/* The user has provided a statically allocated event group - use it. */
-		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 !e9087 EventGroup_t and StaticEventGroup_t are deliberately aliased for data hiding purposes and guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
-
-		if( pxEventBits != NULL )
-		{
-			pxEventBits->uxEventBits = 0;
-			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
-
-			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-			{
-				/* Both static and dynamic allocation can be used, so note that
-				this event group was created statically in case the event group
-				is later deleted. */
-				pxEventBits->ucStaticallyAllocated = pdTRUE;
-			}
-			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-
-			traceEVENT_GROUP_CREATE( pxEventBits );
-		}
-		else
-		{
-			/* xEventGroupCreateStatic should only ever be called with
-			pxEventGroupBuffer pointing to a pre-allocated (compile time
-			allocated) StaticEventGroup_t variable. */
-			traceEVENT_GROUP_CREATE_FAILED();
-		}
-
-		return pxEventBits;
-	}
-
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-
-	EventGroupHandle_t xEventGroupCreate( void )
-	{
-	EventGroup_t *pxEventBits;
-
-		/* Allocate the event group.  Justification for MISRA deviation as
-		follows:  pvPortMalloc() always ensures returned memory blocks are
-		aligned per the requirements of the MCU stack.  In this case
-		pvPortMalloc() must return a pointer that is guaranteed to meet the
-		alignment requirements of the EventGroup_t structure - which (if you
-		follow it through) is the alignment requirements of the TickType_t type
-		(EventBits_t being of TickType_t itself).  Therefore, whenever the
-		stack alignment requirements are greater than or equal to the
-		TickType_t alignment requirements the cast is safe.  In other cases,
-		where the natural word size of the architecture is less than
-		sizeof( TickType_t ), the TickType_t variables will be accessed in two
-		or more reads operations, and the alignment requirements is only that
-		of each individual read. */
-		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
-
-		if( pxEventBits != NULL )
-		{
-			pxEventBits->uxEventBits = 0;
-			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
-
-			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-			{
-				/* Both static and dynamic allocation can be used, so note this
-				event group was allocated statically in case the event group is
-				later deleted. */
-				pxEventBits->ucStaticallyAllocated = pdFALSE;
-			}
-			#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-			traceEVENT_GROUP_CREATE( pxEventBits );
-		}
-		else
-		{
-			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
-		}
-
-		return pxEventBits;
-	}
-
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
-{
-EventBits_t uxOriginalBitValue, uxReturn;
-EventGroup_t *pxEventBits = xEventGroup;
-BaseType_t xAlreadyYielded;
-BaseType_t xTimeoutOccurred = pdFALSE;
-
-	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
-	configASSERT( uxBitsToWaitFor != 0 );
-	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
-	{
-		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
-	}
-	#endif
-
-	vTaskSuspendAll();
-	{
-		uxOriginalBitValue = pxEventBits->uxEventBits;
-
-		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
-
-		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
-		{
-			/* All the rendezvous bits are now set - no need to block. */
-			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
-
-			/* Rendezvous always clear the bits.  They will have been cleared
-			already unless this is the only task in the rendezvous. */
-			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
-
-			xTicksToWait = 0;
-		}
-		else
-		{
-			if( xTicksToWait != ( TickType_t ) 0 )
-			{
-				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
-
-				/* Store the bits that the calling task is waiting for in the
-				task's event list item so the kernel knows when a match is
-				found.  Then enter the blocked state. */
-				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
-
-				/* This assignment is obsolete as uxReturn will get set after
-				the task unblocks, but some compilers mistakenly generate a
-				warning about uxReturn being returned without being set if the
-				assignment is omitted. */
-				uxReturn = 0;
-			}
-			else
-			{
-				/* The rendezvous bits were not set, but no block time was
-				specified - just return the current event bit value. */
-				uxReturn = pxEventBits->uxEventBits;
-				xTimeoutOccurred = pdTRUE;
-			}
-		}
-	}
-	xAlreadyYielded = xTaskResumeAll();
-
-	if( xTicksToWait != ( TickType_t ) 0 )
-	{
-		if( xAlreadyYielded == pdFALSE )
-		{
-			portYIELD_WITHIN_API();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		/* The task blocked to wait for its required bits to be set - at this
-		point either the required bits were set or the block time expired.  If
-		the required bits were set they will have been stored in the task's
-		event list item, and they should now be retrieved then cleared. */
-		uxReturn = uxTaskResetEventItemValue();
-
-		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
-		{
-			/* The task timed out, just return the current event bit value. */
-			taskENTER_CRITICAL();
-			{
-				uxReturn = pxEventBits->uxEventBits;
-
-				/* Although the task got here because it timed out before the
-				bits it was waiting for were set, it is possible that since it
-				unblocked another task has set the bits.  If this is the case
-				then it needs to clear the bits before exiting. */
-				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
-				{
-					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			taskEXIT_CRITICAL();
-
-			xTimeoutOccurred = pdTRUE;
-		}
-		else
-		{
-			/* The task unblocked because the bits were set. */
-		}
-
-		/* Control bits might be set as the task had blocked should not be
-		returned. */
-		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
-	}
-
-	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
-
-	/* Prevent compiler warnings when trace macros are not used. */
-	( void ) xTimeoutOccurred;
-
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
-{
-EventGroup_t *pxEventBits = xEventGroup;
-EventBits_t uxReturn, uxControlBits = 0;
-BaseType_t xWaitConditionMet, xAlreadyYielded;
-BaseType_t xTimeoutOccurred = pdFALSE;
-
-	/* Check the user is not attempting to wait on the bits used by the kernel
-	itself, and that at least one bit is being requested. */
-	configASSERT( xEventGroup );
-	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
-	configASSERT( uxBitsToWaitFor != 0 );
-	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
-	{
-		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
-	}
-	#endif
-
-	vTaskSuspendAll();
-	{
-		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
-
-		/* Check to see if the wait condition is already met or not. */
-		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
-
-		if( xWaitConditionMet != pdFALSE )
-		{
-			/* The wait condition has already been met so there is no need to
-			block. */
-			uxReturn = uxCurrentEventBits;
-			xTicksToWait = ( TickType_t ) 0;
-
-			/* Clear the wait bits if requested to do so. */
-			if( xClearOnExit != pdFALSE )
-			{
-				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else if( xTicksToWait == ( TickType_t ) 0 )
-		{
-			/* The wait condition has not been met, but no block time was
-			specified, so just return the current value. */
-			uxReturn = uxCurrentEventBits;
-			xTimeoutOccurred = pdTRUE;
-		}
-		else
-		{
-			/* The task is going to block to wait for its required bits to be
-			set.  uxControlBits are used to remember the specified behaviour of
-			this call to xEventGroupWaitBits() - for use when the event bits
-			unblock the task. */
-			if( xClearOnExit != pdFALSE )
-			{
-				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			if( xWaitForAllBits != pdFALSE )
-			{
-				uxControlBits |= eventWAIT_FOR_ALL_BITS;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			/* Store the bits that the calling task is waiting for in the
-			task's event list item so the kernel knows when a match is
-			found.  Then enter the blocked state. */
-			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
-
-			/* This is obsolete as it will get set after the task unblocks, but
-			some compilers mistakenly generate a warning about the variable
-			being returned without being set if it is not done. */
-			uxReturn = 0;
-
-			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
-		}
-	}
-	xAlreadyYielded = xTaskResumeAll();
-
-	if( xTicksToWait != ( TickType_t ) 0 )
-	{
-		if( xAlreadyYielded == pdFALSE )
-		{
-			portYIELD_WITHIN_API();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		/* The task blocked to wait for its required bits to be set - at this
-		point either the required bits were set or the block time expired.  If
-		the required bits were set they will have been stored in the task's
-		event list item, and they should now be retrieved then cleared. */
-		uxReturn = uxTaskResetEventItemValue();
-
-		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
-		{
-			taskENTER_CRITICAL();
-			{
-				/* The task timed out, just return the current event bit value. */
-				uxReturn = pxEventBits->uxEventBits;
-
-				/* It is possible that the event bits were updated between this
-				task leaving the Blocked state and running again. */
-				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
-				{
-					if( xClearOnExit != pdFALSE )
-					{
-						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-				xTimeoutOccurred = pdTRUE;
-			}
-			taskEXIT_CRITICAL();
-		}
-		else
-		{
-			/* The task unblocked because the bits were set. */
-		}
-
-		/* The task blocked so control bits may have been set. */
-		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
-	}
-	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
-
-	/* Prevent compiler warnings when trace macros are not used. */
-	( void ) xTimeoutOccurred;
-
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
-{
-EventGroup_t *pxEventBits = xEventGroup;
-EventBits_t uxReturn;
-
-	/* Check the user is not attempting to clear the bits used by the kernel
-	itself. */
-	configASSERT( xEventGroup );
-	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
-
-	taskENTER_CRITICAL();
-	{
-		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
-
-		/* The value returned is the event group value prior to the bits being
-		cleared. */
-		uxReturn = pxEventBits->uxEventBits;
-
-		/* Clear the bits. */
-		pxEventBits->uxEventBits &= ~uxBitsToClear;
-	}
-	taskEXIT_CRITICAL();
-
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
-
-	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
-	{
-		BaseType_t xReturn;
-
-		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
-		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
-
-		return xReturn;
-	}
-
-#endif
-/*-----------------------------------------------------------*/
-
-EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
-{
-UBaseType_t uxSavedInterruptStatus;
-EventGroup_t const * const pxEventBits = xEventGroup;
-EventBits_t uxReturn;
-
-	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		uxReturn = pxEventBits->uxEventBits;
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return uxReturn;
-} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
-/*-----------------------------------------------------------*/
-
-EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
-{
-ListItem_t *pxListItem, *pxNext;
-ListItem_t const *pxListEnd;
-List_t const * pxList;
-EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
-EventGroup_t *pxEventBits = xEventGroup;
-BaseType_t xMatchFound = pdFALSE;
-
-	/* Check the user is not attempting to set the bits used by the kernel
-	itself. */
-	configASSERT( xEventGroup );
-	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
-
-	pxList = &( pxEventBits->xTasksWaitingForBits );
-	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
-	vTaskSuspendAll();
-	{
-		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
-
-		pxListItem = listGET_HEAD_ENTRY( pxList );
-
-		/* Set the bits. */
-		pxEventBits->uxEventBits |= uxBitsToSet;
-
-		/* See if the new bit value should unblock any tasks. */
-		while( pxListItem != pxListEnd )
-		{
-			pxNext = listGET_NEXT( pxListItem );
-			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
-			xMatchFound = pdFALSE;
-
-			/* Split the bits waited for from the control bits. */
-			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
-			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
-
-			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
-			{
-				/* Just looking for single bit being set. */
-				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
-				{
-					xMatchFound = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
-			{
-				/* All bits are set. */
-				xMatchFound = pdTRUE;
-			}
-			else
-			{
-				/* Need all bits to be set, but not all the bits were set. */
-			}
-
-			if( xMatchFound != pdFALSE )
-			{
-				/* The bits match.  Should the bits be cleared on exit? */
-				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
-				{
-					uxBitsToClear |= uxBitsWaitedFor;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* Store the actual event flag value in the task's event list
-				item before removing the task from the event list.  The
-				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
-				that is was unblocked due to its required bits matching, rather
-				than because it timed out. */
-				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
-			}
-
-			/* Move onto the next list item.  Note pxListItem->pxNext is not
-			used here as the list item may have been removed from the event list
-			and inserted into the ready/pending reading list. */
-			pxListItem = pxNext;
-		}
-
-		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
-		bit was set in the control word. */
-		pxEventBits->uxEventBits &= ~uxBitsToClear;
-	}
-	( void ) xTaskResumeAll();
-
-	return pxEventBits->uxEventBits;
-}
-/*-----------------------------------------------------------*/
-
-void vEventGroupDelete( EventGroupHandle_t xEventGroup )
-{
-EventGroup_t *pxEventBits = xEventGroup;
-const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
-
-	vTaskSuspendAll();
-	{
-		traceEVENT_GROUP_DELETE( xEventGroup );
-
-		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
-		{
-			/* Unblock the task, returning 0 as the event list is being deleted
-			and cannot therefore have any bits set. */
-			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
-			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
-		}
-
-		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
-		{
-			/* The event group can only have been allocated dynamically - free
-			it again. */
-			vPortFree( pxEventBits );
-		}
-		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-		{
-			/* The event group could have been allocated statically or
-			dynamically, so check before attempting to free the memory. */
-			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
-			{
-				vPortFree( pxEventBits );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-	}
-	( void ) xTaskResumeAll();
-}
-/*-----------------------------------------------------------*/
-
-/* For internal use only - execute a 'set bits' command that was pended from
-an interrupt. */
-void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
-{
-	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
-}
-/*-----------------------------------------------------------*/
-
-/* For internal use only - execute a 'clear bits' command that was pended from
-an interrupt. */
-void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
-{
-	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
-}
-/*-----------------------------------------------------------*/
-
-static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
-{
-BaseType_t xWaitConditionMet = pdFALSE;
-
-	if( xWaitForAllBits == pdFALSE )
-	{
-		/* Task only has to wait for one bit within uxBitsToWaitFor to be
-		set.  Is one already set? */
-		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
-		{
-			xWaitConditionMet = pdTRUE;
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
-		Are they set already? */
-		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
-		{
-			xWaitConditionMet = pdTRUE;
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-	return xWaitConditionMet;
-}
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
-
-	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
-	{
-	BaseType_t xReturn;
-
-		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
-		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
-
-		return xReturn;
-	}
-
-#endif
-/*-----------------------------------------------------------*/
-
-#if (configUSE_TRACE_FACILITY == 1)
-
-	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
-	{
-	UBaseType_t xReturn;
-	EventGroup_t const *pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
-
-		if( xEventGroup == NULL )
-		{
-			xReturn = 0;
-		}
-		else
-		{
-			xReturn = pxEventBits->uxEventGroupNumber;
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	void vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )
-	{
-		( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-
diff --git a/osal/src/freertos/list.c b/osal/src/freertos/list.c
deleted file mode 100644
index 7618ee8..0000000
--- a/osal/src/freertos/list.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#include <stdlib.h>
-#include "FreeRTOS.h"
-#include "list.h"
-
-/*-----------------------------------------------------------
- * PUBLIC LIST API documented in list.h
- *----------------------------------------------------------*/
-
-void vListInitialise( List_t * const pxList )
-{
-	/* The list structure contains a list item which is used to mark the
-	end of the list.  To initialise the list the list end is inserted
-	as the only list entry. */
-	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
-
-	/* The list end value is the highest possible value in the list to
-	ensure it remains at the end of the list. */
-	pxList->xListEnd.xItemValue = portMAX_DELAY;
-
-	/* The list end next and previous pointers point to itself so we know
-	when the list is empty. */
-	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
-	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
-
-	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
-
-	/* Write known values into the list if
-	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
-	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
-}
-/*-----------------------------------------------------------*/
-
-void vListInitialiseItem( ListItem_t * const pxItem )
-{
-	/* Make sure the list item is not recorded as being on a list. */
-	pxItem->pxContainer = NULL;
-
-	/* Write known values into the list item if
-	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
-	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
-}
-/*-----------------------------------------------------------*/
-
-void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
-{
-ListItem_t * const pxIndex = pxList->pxIndex;
-
-	/* Only effective when configASSERT() is also defined, these tests may catch
-	the list data structures being overwritten in memory.  They will not catch
-	data errors caused by incorrect configuration or use of FreeRTOS. */
-	listTEST_LIST_INTEGRITY( pxList );
-	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
-
-	/* Insert a new list item into pxList, but rather than sort the list,
-	makes the new list item the last item to be removed by a call to
-	listGET_OWNER_OF_NEXT_ENTRY(). */
-	pxNewListItem->pxNext = pxIndex;
-	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
-
-	/* Only used during decision coverage testing. */
-	mtCOVERAGE_TEST_DELAY();
-
-	pxIndex->pxPrevious->pxNext = pxNewListItem;
-	pxIndex->pxPrevious = pxNewListItem;
-
-	/* Remember which list the item is in. */
-	pxNewListItem->pxContainer = pxList;
-
-	( pxList->uxNumberOfItems )++;
-}
-/*-----------------------------------------------------------*/
-
-void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
-{
-ListItem_t *pxIterator;
-const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
-
-	/* Only effective when configASSERT() is also defined, these tests may catch
-	the list data structures being overwritten in memory.  They will not catch
-	data errors caused by incorrect configuration or use of FreeRTOS. */
-	listTEST_LIST_INTEGRITY( pxList );
-	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
-
-	/* Insert the new list item into the list, sorted in xItemValue order.
-
-	If the list already contains a list item with the same item value then the
-	new list item should be placed after it.  This ensures that TCBs which are
-	stored in ready lists (all of which have the same xItemValue value) get a
-	share of the CPU.  However, if the xItemValue is the same as the back marker
-	the iteration loop below will not end.  Therefore the value is checked
-	first, and the algorithm slightly modified if necessary. */
-	if( xValueOfInsertion == portMAX_DELAY )
-	{
-		pxIterator = pxList->xListEnd.pxPrevious;
-	}
-	else
-	{
-		/* *** NOTE ***********************************************************
-		If you find your application is crashing here then likely causes are
-		listed below.  In addition see https://www.freertos.org/FAQHelp.html for
-		more tips, and ensure configASSERT() is defined!
-		https://www.freertos.org/a00110.html#configASSERT
-
-			1) Stack overflow -
-			   see https://www.freertos.org/Stacks-and-stack-overflow-checking.html
-			2) Incorrect interrupt priority assignment, especially on Cortex-M
-			   parts where numerically high priority values denote low actual
-			   interrupt priorities, which can seem counter intuitive.  See
-			   https://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
-			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
-			   https://www.freertos.org/a00110.html
-			3) Calling an API function from within a critical section or when
-			   the scheduler is suspended, or calling an API function that does
-			   not end in "FromISR" from an interrupt.
-			4) Using a queue or semaphore before it has been initialised or
-			   before the scheduler has been started (are interrupts firing
-			   before vTaskStartScheduler() has been called?).
-		**********************************************************************/
-
-		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
-		{
-			/* There is nothing to do here, just iterating to the wanted
-			insertion position. */
-		}
-	}
-
-	pxNewListItem->pxNext = pxIterator->pxNext;
-	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
-	pxNewListItem->pxPrevious = pxIterator;
-	pxIterator->pxNext = pxNewListItem;
-
-	/* Remember which list the item is in.  This allows fast removal of the
-	item later. */
-	pxNewListItem->pxContainer = pxList;
-
-	( pxList->uxNumberOfItems )++;
-}
-/*-----------------------------------------------------------*/
-
-UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
-{
-/* The list item knows which list it is in.  Obtain the list from the list
-item. */
-List_t * const pxList = pxItemToRemove->pxContainer;
-
-	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
-	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
-
-	/* Only used during decision coverage testing. */
-	mtCOVERAGE_TEST_DELAY();
-
-	/* Make sure the index is left pointing to a valid item. */
-	if( pxList->pxIndex == pxItemToRemove )
-	{
-		pxList->pxIndex = pxItemToRemove->pxPrevious;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	pxItemToRemove->pxContainer = NULL;
-	( pxList->uxNumberOfItems )--;
-
-	return pxList->uxNumberOfItems;
-}
-/*-----------------------------------------------------------*/
-
diff --git a/osal/src/freertos/portable/Common/mpu_wrappers.c b/osal/src/freertos/portable/Common/mpu_wrappers.c
deleted file mode 100644
index a738470..0000000
--- a/osal/src/freertos/portable/Common/mpu_wrappers.c
+++ /dev/null
@@ -1,1374 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * Implementation of the wrapper functions used to raise the processor privilege
- * before calling a standard FreeRTOS API function.
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-#include "queue.h"
-#include "timers.h"
-#include "event_groups.h"
-#include "stream_buffer.h"
-#include "mpu_prototypes.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-BaseType_t xPortRaisePrivilege( void ) FREERTOS_SYSTEM_CALL;
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortRaisePrivilege( void ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged;
-
-	/* Check whether the processor is already privileged. */
-	xRunningPrivileged = portIS_PRIVILEGED();
-
-	/* If the processor is not already privileged, raise privilege. */
-	if( xRunningPrivileged != pdTRUE )
-	{
-		portRAISE_PRIVILEGE();
-	}
-
-	return xRunningPrivileged;
-}
-/*-----------------------------------------------------------*/
-
-void vPortResetPrivilege( BaseType_t xRunningPrivileged )
-{
-	if( xRunningPrivileged != pdTRUE )
-	{
-		portRESET_PRIVILEGE();
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	BaseType_t MPU_xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskCreateRestricted( pxTaskDefinition, pxCreatedTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif /* conifgSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	BaseType_t MPU_xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskCreateRestrictedStatic( pxTaskDefinition, pxCreatedTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif /* conifgSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	BaseType_t MPU_xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	TaskHandle_t MPU_xTaskCreateStatic( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TaskHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskCreateStatic( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-void MPU_vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const xRegions ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	vTaskAllocateMPURegions( xTask, xRegions );
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskDelete == 1 )
-	void MPU_vTaskDelete( TaskHandle_t pxTaskToDelete ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskDelete( pxTaskToDelete );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskDelayUntil == 1 )
-	void MPU_vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, TickType_t xTimeIncrement ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskAbortDelay == 1 )
-	BaseType_t MPU_xTaskAbortDelay( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskAbortDelay( xTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskDelay == 1 )
-	void MPU_vTaskDelay( TickType_t xTicksToDelay ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskDelay( xTicksToDelay );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_uxTaskPriorityGet == 1 )
-	UBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t pxTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	UBaseType_t uxReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		uxReturn = uxTaskPriorityGet( pxTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return uxReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskPrioritySet == 1 )
-	void MPU_vTaskPrioritySet( TaskHandle_t pxTask, UBaseType_t uxNewPriority ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskPrioritySet( pxTask, uxNewPriority );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_eTaskGetState == 1 )
-	eTaskState MPU_eTaskGetState( TaskHandle_t pxTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-	eTaskState eReturn;
-
-		eReturn = eTaskGetState( pxTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return eReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TRACE_FACILITY == 1 )
-	void MPU_vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
-	TaskHandle_t MPU_xTaskGetIdleTaskHandle( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TaskHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskGetIdleTaskHandle();
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskSuspend == 1 )
-	void MPU_vTaskSuspend( TaskHandle_t pxTaskToSuspend ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskSuspend( pxTaskToSuspend );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskSuspend == 1 )
-	void MPU_vTaskResume( TaskHandle_t pxTaskToResume ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskResume( pxTaskToResume );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-void MPU_vTaskSuspendAll( void ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	vTaskSuspendAll();
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xTaskResumeAll( void ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xTaskResumeAll();
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-TickType_t MPU_xTaskGetTickCount( void ) /* FREERTOS_SYSTEM_CALL */
-{
-TickType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xTaskGetTickCount();
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-UBaseType_t MPU_uxTaskGetNumberOfTasks( void ) /* FREERTOS_SYSTEM_CALL */
-{
-UBaseType_t uxReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	uxReturn = uxTaskGetNumberOfTasks();
-	vPortResetPrivilege( xRunningPrivileged );
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-char * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery ) /* FREERTOS_SYSTEM_CALL */
-{
-char *pcReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	pcReturn = pcTaskGetName( xTaskToQuery );
-	vPortResetPrivilege( xRunningPrivileged );
-	return pcReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskGetHandle == 1 )
-	TaskHandle_t MPU_xTaskGetHandle( const char *pcNameToQuery ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TaskHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskGetHandle( pcNameToQuery );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-	void MPU_vTaskList( char *pcWriteBuffer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskList( pcWriteBuffer );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-	void MPU_vTaskGetRunTimeStats( char *pcWriteBuffer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskGetRunTimeStats( pcWriteBuffer );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
-	uint32_t MPU_ulTaskGetIdleRunTimeCounter( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	uint32_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = ulTaskGetIdleRunTimeCounter();
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-	void MPU_vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxTagValue ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskSetApplicationTaskTag( xTask, pxTagValue );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-	TaskHookFunction_t MPU_xTaskGetApplicationTaskTag( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TaskHookFunction_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskGetApplicationTaskTag( xTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
-	void MPU_vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTaskSetThreadLocalStoragePointer( xTaskToSet, xIndex, pvValue );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
-	void *MPU_pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) /* FREERTOS_SYSTEM_CALL */
-	{
-	void *pvReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		pvReturn = pvTaskGetThreadLocalStoragePointer( xTaskToQuery, xIndex );
-		vPortResetPrivilege( xRunningPrivileged );
-		return pvReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-	BaseType_t MPU_xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskCallApplicationTaskHook( xTask, pvParameter );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-	UBaseType_t MPU_uxTaskGetSystemState( TaskStatus_t *pxTaskStatusArray, UBaseType_t uxArraySize, uint32_t *pulTotalRunTime ) /* FREERTOS_SYSTEM_CALL */
-	{
-	UBaseType_t uxReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		uxReturn = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );
-		vPortResetPrivilege( xRunningPrivileged );
-		return uxReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xTaskCatchUpTicks( xTicksToCatchUp );
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
-	UBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	UBaseType_t uxReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		uxReturn = uxTaskGetStackHighWaterMark( xTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return uxReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
-	configSTACK_DEPTH_TYPE MPU_uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	configSTACK_DEPTH_TYPE uxReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		uxReturn = uxTaskGetStackHighWaterMark2( xTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return uxReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )
-	TaskHandle_t MPU_xTaskGetCurrentTaskHandle( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TaskHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskGetCurrentTaskHandle();
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskGetSchedulerState == 1 )
-	BaseType_t MPU_xTaskGetSchedulerState( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskGetSchedulerState();
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-void MPU_vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	vTaskSetTimeOutState( pxTimeOut );
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-	BaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskGenericNotify( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-	BaseType_t MPU_xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskNotifyWait( ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-	uint32_t MPU_ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-	{
-	uint32_t ulReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		ulReturn = ulTaskNotifyTake( xClearCountOnExit, xTicksToWait );
-		vPortResetPrivilege( xRunningPrivileged );
-		return ulReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-	BaseType_t MPU_xTaskNotifyStateClear( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTaskNotifyStateClear( xTask );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-	uint32_t MPU_ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear ) /* FREERTOS_SYSTEM_CALL */
-	{
-	uint32_t ulReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		ulReturn = ulTaskNotifyValueClear( xTask, ulBitsToClear );
-		vPortResetPrivilege( xRunningPrivileged );
-		return ulReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	QueueHandle_t MPU_xQueueGenericCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t ucQueueType ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	QueueHandle_t MPU_xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xQueueGenericReset( QueueHandle_t pxQueue, BaseType_t xNewQueue ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xQueueGenericReset( pxQueue, xNewQueue );
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-UBaseType_t MPU_uxQueueMessagesWaiting( const QueueHandle_t pxQueue ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-UBaseType_t uxReturn;
-
-	uxReturn = uxQueueMessagesWaiting( pxQueue );
-	vPortResetPrivilege( xRunningPrivileged );
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-UBaseType_t MPU_uxQueueSpacesAvailable( const QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-UBaseType_t uxReturn;
-
-	uxReturn = uxQueueSpacesAvailable( xQueue );
-	vPortResetPrivilege( xRunningPrivileged );
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xQueueReceive( QueueHandle_t pxQueue, void * const pvBuffer, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-BaseType_t xReturn;
-
-	xReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-BaseType_t xReturn;
-
-	xReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-BaseType_t xReturn;
-
-	xReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
-	TaskHandle_t MPU_xQueueGetMutexHolder( QueueHandle_t xSemaphore ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-	void * xReturn;
-
-		xReturn = xQueueGetMutexHolder( xSemaphore );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-	QueueHandle_t MPU_xQueueCreateMutex( const uint8_t ucQueueType ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueCreateMutex( ucQueueType );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-	QueueHandle_t MPU_xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueCreateMutexStatic( ucQueueType, pxStaticQueue );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-	QueueHandle_t MPU_xQueueCreateCountingSemaphore( UBaseType_t uxCountValue, UBaseType_t uxInitialCount ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueCreateCountingSemaphore( uxCountValue, uxInitialCount );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-
-	QueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueCreateCountingSemaphoreStatic( uxMaxCount, uxInitialCount, pxStaticQueue );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_RECURSIVE_MUTEXES == 1 )
-	BaseType_t MPU_xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xBlockTime ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueTakeMutexRecursive( xMutex, xBlockTime );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_RECURSIVE_MUTEXES == 1 )
-	BaseType_t MPU_xQueueGiveMutexRecursive( QueueHandle_t xMutex ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueGiveMutexRecursive( xMutex );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-	QueueSetHandle_t MPU_xQueueCreateSet( UBaseType_t uxEventQueueLength ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueSetHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueCreateSet( uxEventQueueLength );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-	QueueSetMemberHandle_t MPU_xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t xBlockTimeTicks ) /* FREERTOS_SYSTEM_CALL */
-	{
-	QueueSetMemberHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueSelectFromSet( xQueueSet, xBlockTimeTicks );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-	BaseType_t MPU_xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueAddToSet( xQueueOrSemaphore, xQueueSet );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-	BaseType_t MPU_xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xQueueRemoveFromSet( xQueueOrSemaphore, xQueueSet );
-		vPortResetPrivilege( xRunningPrivileged );
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if configQUEUE_REGISTRY_SIZE > 0
-	void MPU_vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vQueueAddToRegistry( xQueue, pcName );
-
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if configQUEUE_REGISTRY_SIZE > 0
-	void MPU_vQueueUnregisterQueue( QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vQueueUnregisterQueue( xQueue );
-
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if configQUEUE_REGISTRY_SIZE > 0
-	const char *MPU_pcQueueGetName( QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-	const char *pcReturn;
-
-		pcReturn = pcQueueGetName( xQueue );
-
-		vPortResetPrivilege( xRunningPrivileged );
-		return pcReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-void MPU_vQueueDelete( QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	vQueueDelete( xQueue );
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	void *MPU_pvPortMalloc( size_t xSize ) /* FREERTOS_SYSTEM_CALL */
-	{
-	void *pvReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		pvReturn = pvPortMalloc( xSize );
-
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return pvReturn;
-	}
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	void MPU_vPortFree( void *pv ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vPortFree( pv );
-
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	void MPU_vPortInitialiseBlocks( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vPortInitialiseBlocks();
-
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	size_t MPU_xPortGetFreeHeapSize( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	size_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xPortGetFreeHeapSize();
-
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configUSE_TIMERS == 1 ) )
-	TimerHandle_t MPU_xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TimerHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerCreate( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_TIMERS == 1 ) )
-	TimerHandle_t MPU_xTimerCreateStatic( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TimerHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerCreateStatic( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	void *MPU_pvTimerGetTimerID( const TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	void * pvReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		pvReturn = pvTimerGetTimerID( xTimer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return pvReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	void MPU_vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTimerSetTimerID( xTimer, pvNewID );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	BaseType_t MPU_xTimerIsTimerActive( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerIsTimerActive( xTimer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TaskHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerGetTimerDaemonTaskHandle();
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
-	BaseType_t MPU_xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerPendFunctionCall( xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	void MPU_vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		vTimerSetReloadMode( xTimer, uxAutoReload );
-		vPortResetPrivilege( xRunningPrivileged );
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	UBaseType_t MPU_uxTimerGetReloadMode( TimerHandle_t xTimer )
-	{
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-	UBaseType_t uxReturn;
-
-		uxReturn = uxTimerGetReloadMode( xTimer );
-		vPortResetPrivilege( xRunningPrivileged );
-		return uxReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	const char * MPU_pcTimerGetName( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	const char * pcReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		pcReturn = pcTimerGetName( xTimer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return pcReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	TickType_t MPU_xTimerGetPeriod( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TickType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerGetPeriod( xTimer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	TickType_t MPU_xTimerGetExpiryTime( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	TickType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerGetExpiryTime( xTimer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-	BaseType_t MPU_xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-	{
-	BaseType_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xTimerGenericCommand( xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	EventGroupHandle_t MPU_xEventGroupCreate( void ) /* FREERTOS_SYSTEM_CALL */
-	{
-	EventGroupHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xEventGroupCreate();
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	EventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	EventGroupHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xEventGroupCreateStatic( pxEventGroupBuffer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif
-/*-----------------------------------------------------------*/
-
-EventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-EventBits_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-EventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) /* FREERTOS_SYSTEM_CALL */
-{
-EventBits_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-EventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) /* FREERTOS_SYSTEM_CALL */
-{
-EventBits_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-EventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-EventBits_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-void MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	vEventGroupDelete( xEventGroup );
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-size_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-size_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t MPU_xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-{
-size_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
-{
-size_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-void MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	vStreamBufferDelete( xStreamBuffer );
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferIsFull( xStreamBuffer );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferIsEmpty( xStreamBuffer );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferReset( xStreamBuffer );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-{
-size_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferSpacesAvailable( xStreamBuffer );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-{
-size_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferBytesAvailable( xStreamBuffer );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel ) /* FREERTOS_SYSTEM_CALL */
-{
-BaseType_t xReturn;
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	xReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );
-	vPortResetPrivilege( xRunningPrivileged );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	StreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	StreamBufferHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
-	{
-	StreamBufferHandle_t xReturn;
-	BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-		xReturn = xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer );
-		vPortResetPrivilege( xRunningPrivileged );
-
-		return xReturn;
-	}
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-
-/* Functions that the application writer wants to execute in privileged mode
-can be defined in application_defined_privileged_functions.h.  The functions
-must take the same format as those above whereby the privilege state on exit
-equals the privilege state on entry.  For example:
-
-void MPU_FunctionName( [parameters ] )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	FunctionName( [parameters ] );
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-*/
-
-#if configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS == 1
-	#include "application_defined_privileged_functions.h"
-#endif
diff --git a/osal/src/freertos/portable/GCC/ARM_CM0/port.c b/osal/src/freertos/portable/GCC/ARM_CM0/port.c
deleted file mode 100644
index fea473e..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM0/port.c
+++ /dev/null
@@ -1,560 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM0 port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* Constants required to manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_INT_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_CLK_BIT			( 1UL << 2UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVSET_BIT				( 1UL << 28UL )
-#define portMIN_INTERRUPT_PRIORITY		( 255UL )
-#define portNVIC_PENDSV_PRI				( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI			( portMIN_INTERRUPT_PRIORITY << 24UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR			( 0x01000000 )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#ifndef portMISSED_COUNTS_FACTOR
-	#define portMISSED_COUNTS_FACTOR			( 45UL )
-#endif
-
-/* Let the user override the pre-loading of the initial LR with the address of
-prvTaskExitError() in case it messes up unwinding of the stack in the
-debugger. */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS	prvTaskExitError
-#endif
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void ) __attribute__ (( naked ));
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void vPortStartFirstTask( void ) __attribute__ (( naked ));
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*-----------------------------------------------------------*/
-
-/*
-* The number of SysTick increments that make up one tick period.
-*/
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-	pxTopOfStack -= 8; /* R11..R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		started to remove a compiler warning about the function being defined
-		but never called.  ulDummy is used purely to quieten other warnings
-		about code appearing after this function is called - making ulDummy
-		volatile makes the compiler think the function could return and
-		therefore not output an 'unreachable code' warning for code that appears
-		after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	/* This function is no longer used, but retained for backward
-	compatibility. */
-}
-/*-----------------------------------------------------------*/
-
-void vPortStartFirstTask( void )
-{
-	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
-	table offset register that can be used to locate the initial stack value.
-	Not all M0 parts have the application vector table at address 0. */
-	__asm volatile(
-	"	.syntax unified				\n"
-	"	ldr  r2, pxCurrentTCBConst2	\n" /* Obtain location of pxCurrentTCB. */
-	"	ldr  r3, [r2]				\n"
-	"	ldr  r0, [r3]				\n" /* The first item in pxCurrentTCB is the task top of stack. */
-	"	adds r0, #32					\n" /* Discard everything up to r0. */
-	"	msr  psp, r0					\n" /* This is now the new top of stack to use in the task. */
-	"	movs r0, #2					\n" /* Switch to the psp stack. */
-	"	msr  CONTROL, r0				\n"
-	"	isb							\n"
-	"	pop  {r0-r5}					\n" /* Pop the registers that are saved automatically. */
-	"	mov  lr, r5					\n" /* lr is now in r5. */
-	"	pop  {r3}					\n" /* Return address is now in r3. */
-	"	pop  {r2}					\n" /* Pop and discard XPSR. */
-	"	cpsie i						\n" /* The first task has its context and interrupts can be enabled. */
-	"	bx   r3						\n" /* Finally, jump to the user defined task code. */
-	"								\n"
-	"	.align 4					\n"
-	"pxCurrentTCBConst2: .word pxCurrentTCB	  "
-				  );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing!  Call the task
-	exit error function to prevent compiler warnings about a static function
-	not being called in the case that the application writer overrides this
-	functionality by defining configTASK_RETURN_ADDRESS.  Call
-	vTaskSwitchContext() so link time optimisation does not remove the
-	symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortYield( void )
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is completely
-	within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-uint32_t ulSetInterruptMaskFromISR( void )
-{
-	__asm volatile(
-					" mrs r0, PRIMASK	\n"
-					" cpsid i			\n"
-					" bx lr				  "
-					::: "memory"
-				  );
-}
-/*-----------------------------------------------------------*/
-
-void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
-{
-	__asm volatile(
-					" msr PRIMASK, r0	\n"
-					" bx lr				  "
-					::: "memory"
-				  );
-}
-/*-----------------------------------------------------------*/
-
-void xPortPendSVHandler( void )
-{
-	/* This is a naked function. */
-
-	__asm volatile
-	(
-	"	.syntax unified						\n"
-	"	mrs r0, psp							\n"
-	"										\n"
-	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
-	"	ldr	r2, [r3]						\n"
-	"										\n"
-	"	subs r0, r0, #32					\n" /* Make space for the remaining low registers. */
-	"	str r0, [r2]						\n" /* Save the new top of stack. */
-	"	stmia r0!, {r4-r7}					\n" /* Store the low registers that are not saved automatically. */
-	" 	mov r4, r8							\n" /* Store the high registers. */
-	" 	mov r5, r9							\n"
-	" 	mov r6, r10							\n"
-	" 	mov r7, r11							\n"
-	" 	stmia r0!, {r4-r7}					\n"
-	"										\n"
-	"	push {r3, r14}						\n"
-	"	cpsid i								\n"
-	"	bl vTaskSwitchContext				\n"
-	"	cpsie i								\n"
-	"	pop {r2, r3}						\n" /* lr goes in r3. r2 now holds tcb pointer. */
-	"										\n"
-	"	ldr r1, [r2]						\n"
-	"	ldr r0, [r1]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
-	"	adds r0, r0, #16					\n" /* Move to the high registers. */
-	"	ldmia r0!, {r4-r7}					\n" /* Pop the high registers. */
-	" 	mov r8, r4							\n"
-	" 	mov r9, r5							\n"
-	" 	mov r10, r6							\n"
-	" 	mov r11, r7							\n"
-	"										\n"
-	"	msr psp, r0							\n" /* Remember the new top of stack for the task. */
-	"										\n"
-	"	subs r0, r0, #32					\n" /* Go back for the low registers that are not automatically restored. */
-	" 	ldmia r0!, {r4-r7}					\n" /* Pop low registers.  */
-	"										\n"
-	"	bx r3								\n"
-	"										\n"
-	"	.align 4							\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB	  "
-	);
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrpts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM0/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM0/portmacro.h
deleted file mode 100644
index 54397af..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM0/portmacro.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-
-/* Scheduler utilities. */
-extern void vPortYield( void );
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portYIELD()					vPortYield()
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-extern uint32_t ulSetInterruptMaskFromISR( void ) __attribute__((naked));
-extern void vClearInterruptMaskFromISR( uint32_t ulMask )  __attribute__((naked));
-
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulSetInterruptMaskFromISR()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vClearInterruptMaskFromISR( x )
-#define portDISABLE_INTERRUPTS()				__asm volatile 	( " cpsid i " ::: "memory" )
-#define portENABLE_INTERRUPTS()					__asm volatile 	( " cpsie i " ::: "memory" )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-
-#define portNOP()
-
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/port.c b/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.c b/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.c
deleted file mode 100644
index dbe84b1..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.c
+++ /dev/null
@@ -1,453 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE ensures that PRIVILEGED_FUNCTION
- * is defined correctly and privileged functions are placed in correct sections. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Portasm includes. */
-#include "portasm.h"
-
-/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE is needed to be defined only for the
- * header files. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#if( configENABLE_FPU == 1 )
-	#error Cortex-M23 does not have a Floating Point Unit (FPU) and therefore configENABLE_FPU must be set to 0.
-#endif
-
-void vRestoreContextOfFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"													\n"
-	"	ldr  r2, pxCurrentTCBConst2						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr  r3, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr  r0, [r3]									\n" /* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r5, #1										\n" /* r5 = 1. */
-	"	bics r4, r5										\n" /* r4 = r4 & ~r5 i.e. Clear the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-	"	ldr  r4, [r3]									\n" /* r4 = *r3 i.e. r4 = MAIR0. */
-	"	ldr  r2, xMAIR0Const2							\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str  r4, [r2]									\n" /* Program MAIR0. */
-	"	ldr  r2, xRNRConst2								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-	"	movs r5, #4										\n" /* r5 = 4. */
-	"	str  r5, [r2]									\n" /* Program RNR = 4. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read first set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst2							\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write first set of RBAR/RLAR registers. */
-	"	movs r5, #5										\n" /* r5 = 5. */
-	"	str  r5, [r2]									\n" /* Program RNR = 5. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read second set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst2							\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write second set of RBAR/RLAR registers. */
-	"	movs r5, #6										\n" /* r5 = 6. */
-	"	str  r5, [r2]									\n" /* Program RNR = 6. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read third set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst2							\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write third set of RBAR/RLAR registers. */
-	"	movs r5, #7										\n" /* r5 = 7. */
-	"	str  r5, [r2]									\n" /* Program RNR = 7. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read fourth set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst2							\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write fourth set of RBAR/RLAR registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r5, #1										\n" /* r5 = 1. */
-	"	orrs r4, r5										\n" /* r4 = r4 | r5 i.e. Set the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	ldm  r0!, {r1-r4}								\n" /* Read from stack - r1 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = EXC_RETURN. */
-	"	ldr  r5, xSecureContextConst2					\n"
-	"	str  r1, [r5]									\n" /* Set xSecureContext to this task's value for the same. */
-	"	msr  psplim, r2									\n" /* Set this task's PSPLIM value. */
-	"	msr  control, r3								\n" /* Set this task's CONTROL value. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r4											\n" /* Finally, branch to EXC_RETURN. */
-	#else /* configENABLE_MPU */
-	"	ldm  r0!, {r1-r3}								\n" /* Read from stack - r1 = xSecureContext, r2 = PSPLIM and r3 = EXC_RETURN. */
-	"	ldr  r4, xSecureContextConst2					\n"
-	"	str  r1, [r4]									\n" /* Set xSecureContext to this task's value for the same. */
-	"	msr  psplim, r2									\n" /* Set this task's PSPLIM value. */
-	"	movs r1, #2										\n" /* r1 = 2. */
-	"	msr  CONTROL, r1								\n" /* Switch to use PSP in the thread mode. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r3											\n" /* Finally, branch to EXC_RETURN. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
-	"xSecureContextConst2: .word xSecureContext			\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst2: .word 0xe000ed94					\n"
-	"xMAIR0Const2: .word 0xe000edc0						\n"
-	"xRNRConst2: .word 0xe000ed98						\n"
-	"xRBARConst2: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	);
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	movs r1, #1										\n" /* r1 = 1. */
-	"	tst r0, r1										\n" /* Perform r0 & r1 (bitwise AND) and update the conditions flag. */
-	"	beq running_privileged							\n" /* If the result of previous AND operation was 0, branch. */
-	"	movs r0, #0										\n" /* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	"	bx lr											\n" /* Return. */
-	" running_privileged:								\n"
-	"	movs r0, #1										\n" /* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	"	bx lr											\n" /* Return. */
-	"													\n"
-	"	.align 4										\n"
-	::: "r0", "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vRaisePrivilege( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	 __asm volatile
-	(
-	"	mrs r0, control									\n" /* Read the CONTROL register. */
-	"	movs r1, #1										\n" /* r1 = 1. */
-	"	bics r0, r1										\n" /* Clear the bit 0. */
-	"	msr control, r0									\n" /* Write back the new CONTROL value. */
-	"	bx lr											\n" /* Return to the caller. */
-	::: "r0", "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vResetPrivilege( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	movs r1, #1										\n" /* r1 = 1. */
-	"	orrs r0, r1										\n" /* r0 = r0 | r1. */
-	"	msr control, r0									\n" /* CONTROL = r0. */
-	"	bx lr											\n" /* Return to the caller. */
-	:::"r0", "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vStartFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	ldr r0, xVTORConst								\n" /* Use the NVIC offset register to locate the stack. */
-	"	ldr r0, [r0]									\n" /* Read the VTOR register which gives the address of vector table. */
-	"	ldr r0, [r0]									\n" /* The first entry in vector table is stack pointer. */
-	"	msr msp, r0										\n" /* Set the MSP back to the start of the stack. */
-	"	cpsie i											\n" /* Globally enable interrupts. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	svc %0											\n" /* System call to start the first task. */
-	"	nop												\n"
-	"													\n"
-	"   .align 4										\n"
-	"xVTORConst: .word 0xe000ed08						\n"
-	:: "i" ( portSVC_START_SCHEDULER ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	mrs r0, PRIMASK									\n"
-	"	cpsid i											\n"
-	"	bx lr											\n"
-	::: "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vClearInterruptMask( __attribute__( ( unused ) ) uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	msr PRIMASK, r0									\n"
-	"	bx lr											\n"
-	::: "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void PendSV_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"	.extern SecureContext_SaveContext				\n"
-	"	.extern SecureContext_LoadContext				\n"
-	"													\n"
-	"	mrs r1, psp										\n" /* Read PSP in r1. */
-	"	ldr r2, xSecureContextConst						\n" /* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	"	ldr r0, [r2]									\n" /* Read xSecureContext - Value of xSecureContext must be in r0 as it is used as a parameter later. */
-	"													\n"
-	"	cbz r0, save_ns_context							\n" /* No secure context to save. */
-	"	push {r0-r2, r14}								\n"
-	"	bl SecureContext_SaveContext					\n"
-	"	pop {r0-r3}										\n" /* LR is now in r3. */
-	"	mov lr, r3										\n" /* LR = r3. */
-	"	lsls r2, r3, #25								\n" /* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	"	bpl save_ns_context								\n" /* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	"	ldr r3, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r2, [r3]									\n" /* Read pxCurrentTCB. */
-	#if( configENABLE_MPU == 1 )
-	"	subs r1, r1, #16								\n" /* Make space for xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mrs r3, control									\n" /* r3 = CONTROL. */
-	"	mov r4, lr										\n" /* r4 = LR/EXC_RETURN. */
-	"	stmia r1!, {r0, r2-r4}							\n" /* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	#else /* configENABLE_MPU */
-	"	subs r1, r1, #12								\n" /* Make space for xSecureContext, PSPLIM and LR on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	stmia r1!, {r0, r2-r3}							\n" /* Store xSecureContext, PSPLIM and LR on the stack. */
-	#endif /* configENABLE_MPU */
-	"	b select_next_task								\n"
-	"													\n"
-	" save_ns_context:									\n"
-	"	ldr r3, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r2, [r3]									\n" /* Read pxCurrentTCB. */
-	#if( configENABLE_MPU == 1 )
-	"	subs r1, r1, #48								\n" /* Make space for xSecureContext, PSPLIM, CONTROL, LR and the remaining registers on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	adds r1, r1, #16								\n" /* r1 = r1 + 16. */
-	"	stmia r1!, {r4-r7}								\n" /* Store the low registers that are not saved automatically. */
-	"	mov r4, r8										\n" /* r4 = r8. */
-	"	mov r5, r9										\n" /* r5 = r9. */
-	"	mov r6, r10										\n" /* r6 = r10. */
-	"	mov r7, r11										\n" /* r7 = r11. */
-	"	stmia r1!, {r4-r7}								\n" /* Store the high registers that are not saved automatically. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mrs r3, control									\n" /* r3 = CONTROL. */
-	"	mov r4, lr										\n" /* r4 = LR/EXC_RETURN. */
-	"	subs r1, r1, #48								\n" /* r1 = r1 - 48. */
-	"	stmia r1!, {r0, r2-r4}							\n" /* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	#else /* configENABLE_MPU */
-	"	subs r1, r1, #44								\n" /* Make space for xSecureContext, PSPLIM, LR and the remaining registers on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	stmia r1!, {r0, r2-r7}							\n" /* Store xSecureContext, PSPLIM, LR and the low registers that are not saved automatically. */
-	"	mov r4, r8										\n" /* r4 = r8. */
-	"	mov r5, r9										\n" /* r5 = r9. */
-	"	mov r6, r10										\n" /* r6 = r10. */
-	"	mov r7, r11										\n" /* r7 = r11. */
-	"	stmia r1!, {r4-r7}								\n" /* Store the high registers that are not saved automatically. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	" select_next_task:									\n"
-	"	cpsid i											\n"
-	"	bl vTaskSwitchContext							\n"
-	"	cpsie i											\n"
-	"													\n"
-	"	ldr r2, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r3, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr r1, [r3]									\n" /* The first item in pxCurrentTCB is the task top of stack. r1 now points to the top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r5, #1										\n" /* r5 = 1. */
-	"	bics r4, r5										\n" /* r4 = r4 & ~r5 i.e. Clear the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-	"	ldr r4, [r3]									\n" /* r4 = *r3 i.e. r4 = MAIR0. */
-	"	ldr r2, xMAIR0Const								\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str r4, [r2]									\n" /* Program MAIR0. */
-	"	ldr r2, xRNRConst								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-	"	movs r5, #4										\n" /* r5 = 4. */
-	"	str  r5, [r2]									\n" /* Program RNR = 4. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read first set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst								\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write first set of RBAR/RLAR registers. */
-	"	movs r5, #5										\n" /* r5 = 5. */
-	"	str  r5, [r2]									\n" /* Program RNR = 5. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read second set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst								\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write second set of RBAR/RLAR registers. */
-	"	movs r5, #6										\n" /* r5 = 6. */
-	"	str  r5, [r2]									\n" /* Program RNR = 6. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read third set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst								\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write third set of RBAR/RLAR registers. */
-	"	movs r5, #7										\n" /* r5 = 7. */
-	"	str  r5, [r2]									\n" /* Program RNR = 7. */
-	"	ldmia r3!, {r6,r7}								\n" /* Read fourth set of RBAR/RLAR from TCB. */
-	"	ldr  r4, xRBARConst								\n" /* r4 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r4!, {r6,r7}								\n" /* Write fourth set of RBAR/RLAR registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r5, #1										\n" /* r5 = 1. */
-	"	orrs r4, r5										\n" /* r4 = r4 | r5 i.e. Set the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	ldmia r1!, {r0, r2-r4}							\n" /* Read from stack - r0 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = LR. */
-	"	msr psplim, r2									\n" /* Restore the PSPLIM register value for the task. */
-	"	msr control, r3									\n" /* Restore the CONTROL register value for the task. */
-	"	mov lr, r4										\n" /* LR = r4. */
-	"	ldr r2, xSecureContextConst						\n" /* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	"	str r0, [r2]									\n" /* Restore the task's xSecureContext. */
-	"	cbz r0, restore_ns_context						\n" /* If there is no secure context for the task, restore the non-secure context. */
-	"	push {r1,r4}									\n"
-	"	bl SecureContext_LoadContext					\n" /* Restore the secure context. */
-	"	pop {r1,r4}										\n"
-	"	mov lr, r4										\n" /* LR = r4. */
-	"	lsls r2, r4, #25								\n" /* r2 = r4 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	"	bpl restore_ns_context							\n" /* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	"	msr psp, r1										\n" /* Remember the new top of stack for the task. */
-	"	bx lr											\n"
-	#else /* configENABLE_MPU */
-	"	ldmia r1!, {r0, r2-r3}							\n" /* Read from stack - r0 = xSecureContext, r2 = PSPLIM and r3 = LR. */
-	"	msr psplim, r2									\n" /* Restore the PSPLIM register value for the task. */
-	"	mov lr, r3										\n" /* LR = r3. */
-	"	ldr r2, xSecureContextConst						\n" /* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	"	str r0, [r2]									\n" /* Restore the task's xSecureContext. */
-	"	cbz r0, restore_ns_context						\n" /* If there is no secure context for the task, restore the non-secure context. */
-	"	push {r1,r3}									\n"
-	"	bl SecureContext_LoadContext					\n" /* Restore the secure context. */
-	"	pop {r1,r3}										\n"
-	"	mov lr, r3										\n" /* LR = r3. */
-	"	lsls r2, r3, #25								\n" /* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	"	bpl restore_ns_context							\n" /* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	"	msr psp, r1										\n" /* Remember the new top of stack for the task. */
-	"	bx lr											\n"
-	#endif /* configENABLE_MPU */
-	"													\n"
-	" restore_ns_context:								\n"
-	"	adds r1, r1, #16								\n" /* Move to the high registers. */
-	"	ldmia r1!, {r4-r7}								\n" /* Restore the high registers that are not automatically restored. */
-	"	mov r8, r4										\n" /* r8 = r4. */
-	"	mov r9, r5										\n" /* r9 = r5. */
-	"	mov r10, r6										\n" /* r10 = r6. */
-	"	mov r11, r7										\n" /* r11 = r7. */
-	"	msr psp, r1										\n" /* Remember the new top of stack for the task. */
-	"	subs r1, r1, #32								\n" /* Go back to the low registers. */
-	"	ldmia r1!, {r4-r7}								\n" /* Restore the low registers that are not automatically restored. */
-	"	bx lr											\n"
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB				\n"
-	"xSecureContextConst: .word xSecureContext			\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst: .word 0xe000ed94					\n"
-	"xMAIR0Const: .word 0xe000edc0						\n"
-	"xRNRConst: .word 0xe000ed98						\n"
-	"xRBARConst: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	);
-}
-/*-----------------------------------------------------------*/
-
-void SVC_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	movs r0, #4										\n"
-	"	mov r1, lr										\n"
-	"	tst r0, r1										\n"
-	"	beq stacking_used_msp							\n"
-	"	mrs r0, psp										\n"
-	"	ldr r2, svchandler_address_const				\n"
-	"	bx r2											\n"
-	" stacking_used_msp:								\n"
-	"	mrs r0, msp										\n"
-	"	ldr r2, svchandler_address_const				\n"
-	"	bx r2											\n"
-	"													\n"
-	"	.align 4										\n"
-	"svchandler_address_const: .word vPortSVCHandler_C	\n"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	svc %0											\n" /* Secure context is allocated in the supervisor call. */
-	"	bx lr											\n" /* Return. */
-	:: "i" ( portSVC_ALLOCATE_SECURE_CONTEXT ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	ldr r1, [r0]									\n" /* The first item in the TCB is the top of the stack. */
-	"	ldr r0, [r1]									\n" /* The first item on the stack is the task's xSecureContext. */
-	"	cmp r0, #0										\n" /* Raise svc if task's xSecureContext is not NULL. */
-	"	beq free_secure_context							\n"
-	"	bx lr											\n" /* There is no secure context (xSecureContext is NULL). */
-	" free_secure_context:								\n"
-	"	svc %0											\n" /* Secure context is freed in the supervisor call. */
-	"	bx lr											\n" /* Return. */
-	:: "i" ( portSVC_FREE_SECURE_CONTEXT ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.h b/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portmacro.h
deleted file mode 100644
index 2f469ad..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/non_secure/portmacro.h
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M23"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__attribute__(( used ))
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							__asm volatile ( " cpsid i " ::: "memory" )
-#define portENABLE_INTERRUPTS()								__asm volatile ( " cpsie i " ::: "memory" )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.c b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.c
deleted file mode 100644
index b19f801..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.c
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief CONTROL value for privileged tasks.
- *
- * Bit[0] - 0 --> Thread mode is privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_PRIVILEGED		0x02
-
-/**
- * @brief CONTROL value for un-privileged tasks.
- *
- * Bit[0] - 1 --> Thread mode is un-privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_UNPRIVILEGED		0x03
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Structure to represent secure context.
- *
- * @note Since stack grows down, pucStackStart is the highest address while
- * pucStackLimit is the first addess of the allocated memory.
- */
-typedef struct SecureContext
-{
-	uint8_t *pucCurrentStackPointer;	/**< Current value of stack pointer (PSP). */
-	uint8_t *pucStackLimit;				/**< Last location of the stack memory (PSPLIM). */
-	uint8_t *pucStackStart;				/**< First location of the stack memory. */
-} SecureContext_t;
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_Init( void )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* No stack for thread mode until a task's context is loaded. */
-		secureportSET_PSPLIM( securecontextNO_STACK );
-		secureportSET_PSP( securecontextNO_STACK );
-
-		#if( configENABLE_MPU == 1 )
-		{
-			/* Configure thread mode to use PSP and to be unprivileged. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_UNPRIVILEGED );
-		}
-		#else /* configENABLE_MPU */
-		{
-			/* Configure thread mode to use PSP and to be privileged.. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_PRIVILEGED );
-		}
-		#endif /* configENABLE_MPU */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged )
-#else /* configENABLE_MPU */
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize )
-#endif /* configENABLE_MPU */
-{
-	uint8_t *pucStackMemory = NULL;
-	uint32_t ulIPSR;
-	SecureContextHandle_t xSecureContextHandle = NULL;
-	#if( configENABLE_MPU == 1 )
-		uint32_t *pulCurrentStackPointer = NULL;
-	#endif /* configENABLE_MPU */
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Allocate the context structure. */
-		xSecureContextHandle = ( SecureContextHandle_t ) pvPortMalloc( sizeof( SecureContext_t ) );
-
-		if( xSecureContextHandle != NULL )
-		{
-			/* Allocate the stack space. */
-			pucStackMemory = pvPortMalloc( ulSecureStackSize );
-
-			if( pucStackMemory != NULL )
-			{
-				/* Since stack grows down, the starting point will be the last
-				 * location. Note that this location is next to the last
-				 * allocated byte because the hardware decrements the stack
-				 * pointer before writing i.e. if stack pointer is 0x2, a push
-				 * operation will decrement the stack pointer to 0x1 and then
-				 * write at 0x1. */
-				xSecureContextHandle->pucStackStart = pucStackMemory + ulSecureStackSize;
-
-				/* The stack cannot go beyond this location. This value is
-				 * programmed in the PSPLIM register on context switch.*/
-				xSecureContextHandle->pucStackLimit = pucStackMemory;
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Store the correct CONTROL value for the task on the stack.
-					 * This value is programmed in the CONTROL register on
-					 * context switch. */
-					pulCurrentStackPointer = ( uint32_t * ) xSecureContextHandle->pucStackStart;
-					pulCurrentStackPointer--;
-					if( ulIsTaskPrivileged )
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_PRIVILEGED;
-					}
-					else
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_UNPRIVILEGED;
-					}
-
-					/* Store the current stack pointer. This value is programmed in
-					 * the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = ( uint8_t * ) pulCurrentStackPointer;
-				}
-				#else /* configENABLE_MPU */
-				{
-					/* Current SP is set to the starting of the stack. This
-					 * value programmed in the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = xSecureContextHandle->pucStackStart;
-
-				}
-				#endif /* configENABLE_MPU */
-			}
-			else
-			{
-				/* Free the context to avoid memory leak and make sure to return
-				 * NULL to indicate failure. */
-				vPortFree( xSecureContextHandle );
-				xSecureContextHandle = NULL;
-			}
-		}
-	}
-
-	return xSecureContextHandle;
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Ensure that valid parameters are passed. */
-		secureportASSERT( xSecureContextHandle != NULL );
-
-		/* Free the stack space. */
-		vPortFree( xSecureContextHandle->pucStackLimit );
-
-		/* Free the context itself. */
-		vPortFree( xSecureContextHandle );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.h b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.h
deleted file mode 100644
index 7323f8f..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_CONTEXT_H__
-#define __SECURE_CONTEXT_H__
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* FreeRTOS includes. */
-#include "FreeRTOSConfig.h"
-
-/**
- * @brief PSP value when no task's context is loaded.
- */
-#define securecontextNO_STACK	0x0
-
-/**
- * @brief Opaque handle.
- */
-struct SecureContext;
-typedef struct SecureContext*	SecureContextHandle_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Initializes the secure context management system.
- *
- * PSP is set to NULL and therefore a task must allocate and load a context
- * before calling any secure side function in the thread mode.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureContext_Init( void );
-
-/**
- * @brief Allocates a context on the secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] ulSecureStackSize Size of the stack to allocate on secure side.
- * @param[in] ulIsTaskPrivileged 1 if the calling task is privileged, 0 otherwise.
- *
- * @return Opaque context handle if context is successfully allocated, NULL
- * otherwise.
- */
-#if( configENABLE_MPU == 1 )
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged );
-#else /* configENABLE_MPU */
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize );
-#endif /* configENABLE_MPU */
-
-/**
- * @brief Frees the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the
- * context to be freed.
- */
-void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Loads the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be loaded.
- */
-void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Saves the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be saved.
- */
-void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle );
-
-#endif /* __SECURE_CONTEXT_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context_port.c b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context_port.c
deleted file mode 100644
index 7bd72d8..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_context_port.c
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-#if( configENABLE_FPU == 1 )
-	#error Cortex-M23 does not have a Floating Point Unit (FPU) and therefore configENABLE_FPU must be set to 0.
-#endif
-
-secureportNON_SECURE_CALLABLE void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle )
-{
-	/* xSecureContextHandle value is in r0. */
-	__asm volatile
-	(
-	"	.syntax unified							\n"
-	"											\n"
-	"	mrs r1, ipsr							\n" /* r1 = IPSR. */
-	"	cbz r1, load_ctx_therad_mode			\n" /* Do nothing if the processor is running in the Thread Mode. */
-	"	ldmia r0!, {r1, r2}						\n" /* r1 = xSecureContextHandle->pucCurrentStackPointer, r2 = xSecureContextHandle->pucStackLimit. */
-	#if( configENABLE_MPU == 1 )
-	"	ldmia r1!, {r3}							\n" /* Read CONTROL register value from task's stack. r3 = CONTROL. */
-	"	msr control, r3							\n" /* CONTROL = r3. */
-	#endif /* configENABLE_MPU */
-	"	msr psplim, r2							\n" /* PSPLIM = r2. */
-	"	msr psp, r1								\n" /* PSP = r1. */
-	"											\n"
-	" load_ctx_therad_mode:						\n"
-	"	nop										\n"
-	"											\n"
-	:::"r0", "r1", "r2"
-	);
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle )
-{
-	/* xSecureContextHandle value is in r0. */
-	__asm volatile
-	(
-	"	.syntax unified							\n"
-	"											\n"
-	"	mrs r1, ipsr							\n" /* r1 = IPSR. */
-	"	cbz r1, save_ctx_therad_mode			\n" /* Do nothing if the processor is running in the Thread Mode. */
-	"	mrs r1, psp								\n" /* r1 = PSP. */
-	#if( configENABLE_MPU == 1 )
-	"	mrs r2, control							\n" /* r2 = CONTROL. */
-	"	subs r1, r1, #4							\n" /* Make space for the CONTROL value on the stack. */
-	"	str r1, [r0]							\n" /* Save the top of stack in context. xSecureContextHandle->pucCurrentStackPointer = r1. */
-	"	stmia r1!, {r2}							\n" /* Store CONTROL value on the stack. */
-	#else /* configENABLE_MPU */
-	"	str r1, [r0]							\n" /* Save the top of stack in context. xSecureContextHandle->pucCurrentStackPointer = r1. */
-	#endif /* configENABLE_MPU */
-	"	movs r1, %0								\n" /* r1 = securecontextNO_STACK. */
-	"	msr psplim, r1							\n" /* PSPLIM = securecontextNO_STACK. */
-	"	msr psp, r1								\n" /* PSP = securecontextNO_STACK i.e. No stack for thread mode until next task's context is loaded. */
-	"											\n"
-	" save_ctx_therad_mode:						\n"
-	"	nop										\n"
-	"											\n"
-	:: "i" ( securecontextNO_STACK ) : "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.c b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.c
deleted file mode 100644
index 098f24e..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.c
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure context heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Total heap size.
- */
-#define secureconfigTOTAL_HEAP_SIZE		( ( ( size_t ) ( 10 * 1024 ) ) )
-
-/* No test marker by default. */
-#ifndef mtCOVERAGE_TEST_MARKER
-	#define mtCOVERAGE_TEST_MARKER()
-#endif
-
-/* No tracing by default. */
-#ifndef traceMALLOC
-	#define traceMALLOC( pvReturn, xWantedSize )
-#endif
-
-/* No tracing by default. */
-#ifndef traceFREE
-	#define traceFREE( pv, xBlockSize )
-#endif
-
-/* Block sizes must not get too small. */
-#define secureheapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
-
-/* Assumes 8bit bytes! */
-#define secureheapBITS_PER_BYTE			( ( size_t ) 8 )
-/*-----------------------------------------------------------*/
-
-/* Allocate the memory for the heap. */
-#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
-	/* The application writer has already defined the array used for the RTOS
-	 * heap - probably so it can be placed in a special segment or address. */
-	extern uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#else /* configAPPLICATION_ALLOCATED_HEAP */
-	static uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#endif /* configAPPLICATION_ALLOCATED_HEAP */
-
-/**
- * @brief The linked list structure.
- *
- * This is used to link free blocks in order of their memory address.
- */
-typedef struct A_BLOCK_LINK
-{
-	struct A_BLOCK_LINK *pxNextFreeBlock;	/**< The next free block in the list. */
-	size_t xBlockSize;						/**< The size of the free block. */
-} BlockLink_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Called automatically to setup the required heap structures the first
- * time pvPortMalloc() is called.
- */
-static void prvHeapInit( void );
-
-/**
- * @brief Inserts a block of memory that is being freed into the correct
- * position in the list of free memory blocks.
- *
- * The block being freed will be merged with the block in front it and/or the
- * block behind it if the memory blocks are adjacent to each other.
- *
- * @param[in] pxBlockToInsert The block being freed.
- */
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The size of the structure placed at the beginning of each allocated
- * memory block must by correctly byte aligned.
- */
-static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( secureportBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-
-/**
- * @brief Create a couple of list links to mark the start and end of the list.
- */
-static BlockLink_t xStart, *pxEnd = NULL;
-
-/**
- * @brief Keeps track of the number of free bytes remaining, but says nothing
- * about fragmentation.
- */
-static size_t xFreeBytesRemaining = 0U;
-static size_t xMinimumEverFreeBytesRemaining = 0U;
-
-/**
- * @brief Gets set to the top bit of an size_t type.
- *
- * When this bit in the xBlockSize member of an BlockLink_t structure is set
- * then the block belongs to the application. When the bit is free the block is
- * still part of the free heap space.
- */
-static size_t xBlockAllocatedBit = 0;
-/*-----------------------------------------------------------*/
-
-static void prvHeapInit( void )
-{
-BlockLink_t *pxFirstFreeBlock;
-uint8_t *pucAlignedHeap;
-size_t uxAddress;
-size_t xTotalHeapSize = secureconfigTOTAL_HEAP_SIZE;
-
-	/* Ensure the heap starts on a correctly aligned boundary. */
-	uxAddress = ( size_t ) ucHeap;
-
-	if( ( uxAddress & secureportBYTE_ALIGNMENT_MASK ) != 0 )
-	{
-		uxAddress += ( secureportBYTE_ALIGNMENT - 1 );
-		uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
-	}
-
-	pucAlignedHeap = ( uint8_t * ) uxAddress;
-
-	/* xStart is used to hold a pointer to the first item in the list of free
-	 * blocks.  The void cast is used to prevent compiler warnings. */
-	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
-	xStart.xBlockSize = ( size_t ) 0;
-
-	/* pxEnd is used to mark the end of the list of free blocks and is inserted
-	 * at the end of the heap space. */
-	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
-	uxAddress -= xHeapStructSize;
-	uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-	pxEnd = ( void * ) uxAddress;
-	pxEnd->xBlockSize = 0;
-	pxEnd->pxNextFreeBlock = NULL;
-
-	/* To start with there is a single free block that is sized to take up the
-	 * entire heap space, minus the space taken by pxEnd. */
-	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
-	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
-	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
-
-	/* Only one block exists - and it covers the entire usable heap space. */
-	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-
-	/* Work out the position of the top bit in a size_t variable. */
-	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * secureheapBITS_PER_BYTE ) - 1 );
-}
-/*-----------------------------------------------------------*/
-
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
-{
-BlockLink_t *pxIterator;
-uint8_t *puc;
-
-	/* Iterate through the list until a block is found that has a higher address
-	 * than the block being inserted. */
-	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
-	{
-		/* Nothing to do here, just iterate to the right position. */
-	}
-
-	/* Do the block being inserted, and the block it is being inserted after
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxIterator;
-	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
-	{
-		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
-		pxBlockToInsert = pxIterator;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Do the block being inserted, and the block it is being inserted before
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxBlockToInsert;
-	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
-	{
-		if( pxIterator->pxNextFreeBlock != pxEnd )
-		{
-			/* Form one big block from the two blocks. */
-			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
-			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
-		}
-		else
-		{
-			pxBlockToInsert->pxNextFreeBlock = pxEnd;
-		}
-	}
-	else
-	{
-		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
-	}
-
-	/* If the block being inserted plugged a gab, so was merged with the block
-	 * before and the block after, then it's pxNextFreeBlock pointer will have
-	 * already been set, and should not be set here as that would make it point
-	 * to itself. */
-	if( pxIterator != pxBlockToInsert )
-	{
-		pxIterator->pxNextFreeBlock = pxBlockToInsert;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
-void *pvReturn = NULL;
-
-	/* If this is the first call to malloc then the heap will require
-	 * initialisation to setup the list of free blocks. */
-	if( pxEnd == NULL )
-	{
-		prvHeapInit();
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Check the requested block size is not so large that the top bit is set.
-	 * The top bit of the block size member of the BlockLink_t structure is used
-	 * to determine who owns the block - the application or the kernel, so it
-	 * must be free. */
-	if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
-	{
-		/* The wanted size is increased so it can contain a BlockLink_t
-		 * structure in addition to the requested amount of bytes. */
-		if( xWantedSize > 0 )
-		{
-			xWantedSize += xHeapStructSize;
-
-			/* Ensure that blocks are always aligned to the required number of
-			 * bytes. */
-			if( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) != 0x00 )
-			{
-				/* Byte alignment required. */
-				xWantedSize += ( secureportBYTE_ALIGNMENT - ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) );
-				secureportASSERT( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
-		{
-			/* Traverse the list from the start (lowest address) block until
-			 * one of adequate size is found. */
-			pxPreviousBlock = &xStart;
-			pxBlock = xStart.pxNextFreeBlock;
-			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
-			{
-				pxPreviousBlock = pxBlock;
-				pxBlock = pxBlock->pxNextFreeBlock;
-			}
-
-			/* If the end marker was reached then a block of adequate size was
-			 * not found. */
-			if( pxBlock != pxEnd )
-			{
-				/* Return the memory space pointed to - jumping over the
-				 * BlockLink_t structure at its start. */
-				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
-
-				/* This block is being returned for use so must be taken out
-				 * of the list of free blocks. */
-				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
-
-				/* If the block is larger than required it can be split into
-				 * two. */
-				if( ( pxBlock->xBlockSize - xWantedSize ) > secureheapMINIMUM_BLOCK_SIZE )
-				{
-					/* This block is to be split into two.  Create a new
-					 * block following the number of bytes requested. The void
-					 * cast is used to prevent byte alignment warnings from the
-					 * compiler. */
-					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
-					secureportASSERT( ( ( ( size_t ) pxNewBlockLink ) & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-
-					/* Calculate the sizes of two blocks split from the single
-					 * block. */
-					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
-					pxBlock->xBlockSize = xWantedSize;
-
-					/* Insert the new block into the list of free blocks. */
-					prvInsertBlockIntoFreeList( pxNewBlockLink );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				xFreeBytesRemaining -= pxBlock->xBlockSize;
-
-				if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
-				{
-					xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* The block is being returned - it is allocated and owned by
-				 * the application and has no "next" block. */
-				pxBlock->xBlockSize |= xBlockAllocatedBit;
-				pxBlock->pxNextFreeBlock = NULL;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	traceMALLOC( pvReturn, xWantedSize );
-
-	#if( secureconfigUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#endif
-
-	secureportASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) secureportBYTE_ALIGNMENT_MASK ) == 0 );
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-uint8_t *puc = ( uint8_t * ) pv;
-BlockLink_t *pxLink;
-
-	if( pv != NULL )
-	{
-		/* The memory being freed will have an BlockLink_t structure immediately
-		 * before it. */
-		puc -= xHeapStructSize;
-
-		/* This casting is to keep the compiler from issuing warnings. */
-		pxLink = ( void * ) puc;
-
-		/* Check the block is actually allocated. */
-		secureportASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
-		secureportASSERT( pxLink->pxNextFreeBlock == NULL );
-
-		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
-		{
-			if( pxLink->pxNextFreeBlock == NULL )
-			{
-				/* The block is being returned to the heap - it is no longer
-				 * allocated. */
-				pxLink->xBlockSize &= ~xBlockAllocatedBit;
-
-				secureportDISABLE_NON_SECURE_INTERRUPTS();
-				{
-					/* Add this block to the list of free blocks. */
-					xFreeBytesRemaining += pxLink->xBlockSize;
-					traceFREE( pv, pxLink->xBlockSize );
-					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
-				}
-				secureportENABLE_NON_SECURE_INTERRUPTS();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return xFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetMinimumEverFreeHeapSize( void )
-{
-	return xMinimumEverFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-void vPortInitialiseBlocks( void )
-{
-	/* This just exists to keep the linker quiet. */
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.h b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.h
deleted file mode 100644
index b7e071a..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_heap.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_HEAP_H__
-#define __SECURE_HEAP_H__
-
-/* Standard includes. */
-#include <stdlib.h>
-
-/**
- * @brief Allocates memory from heap.
- *
- * @param[in] xWantedSize The size of the memory to be allocated.
- *
- * @return Pointer to the memory region if the allocation is successful, NULL
- * otherwise.
- */
-void *pvPortMalloc( size_t xWantedSize );
-
-/**
- * @brief Frees the previously allocated memory.
- *
- * @param[in] pv Pointer to the memory to be freed.
- */
-void vPortFree( void *pv );
-
-#endif /* __SECURE_HEAP_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.c b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.c
deleted file mode 100644
index fdabd11..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure init includes. */
-#include "secure_init.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define secureinitSCB_AIRCR					( ( volatile uint32_t * ) 0xe000ed0c )  /* Application Interrupt and Reset Control Register. */
-#define secureinitSCB_AIRCR_VECTKEY_POS		( 16UL )
-#define secureinitSCB_AIRCR_VECTKEY_MASK	( 0xFFFFUL << secureinitSCB_AIRCR_VECTKEY_POS )
-#define secureinitSCB_AIRCR_PRIS_POS		( 14UL )
-#define secureinitSCB_AIRCR_PRIS_MASK		( 1UL << secureinitSCB_AIRCR_PRIS_POS )
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define secureinitFPCCR						( ( volatile uint32_t * ) 0xe000ef34 )  /* Floating Point Context Control Register. */
-#define secureinitFPCCR_LSPENS_POS			( 29UL )
-#define secureinitFPCCR_LSPENS_MASK			( 1UL << secureinitFPCCR_LSPENS_POS )
-#define secureinitFPCCR_TS_POS				( 26UL )
-#define secureinitFPCCR_TS_MASK				( 1UL << secureinitFPCCR_TS_POS )
-
-#define secureinitNSACR						( ( volatile uint32_t * ) 0xe000ed8c )  /* Non-secure Access Control Register. */
-#define secureinitNSACR_CP10_POS			( 10UL )
-#define secureinitNSACR_CP10_MASK			( 1UL << secureinitNSACR_CP10_POS )
-#define secureinitNSACR_CP11_POS			( 11UL )
-#define secureinitNSACR_CP11_MASK			( 1UL << secureinitNSACR_CP11_POS )
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_DePrioritizeNSExceptions( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
-									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
-									( ( 0x1UL	<< secureinitSCB_AIRCR_PRIS_POS )	& secureinitSCB_AIRCR_PRIS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_EnableNSFPUAccess( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* CP10 = 1 ==> Non-secure access to the Floating Point Unit is
-		 * permitted. CP11 should be programmed to the same value as CP10. */
-		*( secureinitNSACR ) |= ( secureinitNSACR_CP10_MASK | secureinitNSACR_CP11_MASK );
-
-		/* LSPENS = 0 ==> LSPEN is writable fron non-secure state. This ensures
-		 * that we can enable/disable lazy stacking in port.c file. */
-		*( secureinitFPCCR ) &= ~ ( secureinitFPCCR_LSPENS_MASK );
-
-		/* TS = 1 ==> Treat FP registers as secure i.e. callee saved FP
-		 * registers (S16-S31) are also pushed to stack on exception entry and
-		 * restored on exception return. */
-		*( secureinitFPCCR ) |= ( secureinitFPCCR_TS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.h b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.h
deleted file mode 100644
index 34e4b48..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_init.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_INIT_H__
-#define __SECURE_INIT_H__
-
-/**
- * @brief De-prioritizes the non-secure exceptions.
- *
- * This is needed to ensure that the non-secure PendSV runs at the lowest
- * priority. Context switch is done in the non-secure PendSV handler.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_DePrioritizeNSExceptions( void );
-
-/**
- * @brief Sets up the Floating Point Unit (FPU) for Non-Secure access.
- *
- * Also sets FPCCR.TS=1 to ensure that the content of the Floating Point
- * Registers are not leaked to the non-secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_EnableNSFPUAccess( void );
-
-#endif /* __SECURE_INIT_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_port_macros.h b/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_port_macros.h
deleted file mode 100644
index e59c06b..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23/secure/secure_port_macros.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_PORT_MACROS_H__
-#define __SECURE_PORT_MACROS_H__
-
-/**
- * @brief Byte alignment requirements.
- */
-#define secureportBYTE_ALIGNMENT					8
-#define secureportBYTE_ALIGNMENT_MASK				( 0x0007 )
-
-/**
- * @brief Macro to declare a function as non-secure callable.
- */
-#if defined( __IAR_SYSTEMS_ICC__ )
-	#define secureportNON_SECURE_CALLABLE			__cmse_nonsecure_entry __root
-#else
-	#define secureportNON_SECURE_CALLABLE			__attribute__((cmse_nonsecure_entry)) __attribute__((used))
-#endif
-
-/**
- * @brief Set the secure PRIMASK value.
- */
-#define secureportSET_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Set the non-secure PRIMASK value.
- */
-#define secureportSET_NON_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask_ns, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Read the PSP value in the given variable.
- */
-#define secureportREAD_PSP( pucOutCurrentStackPointer ) \
-	__asm volatile ( "mrs %0, psp"  : "=r" ( pucOutCurrentStackPointer ) )
-
-/**
- * @brief Set the PSP to the given value.
- */
-#define secureportSET_PSP( pucCurrentStackPointer ) \
-	__asm volatile ( "msr psp, %0" : : "r" ( pucCurrentStackPointer ) )
-
-/**
- * @brief Set the PSPLIM to the given value.
- */
-#define secureportSET_PSPLIM( pucStackLimit ) \
-	__asm volatile ( "msr psplim, %0" : : "r" ( pucStackLimit ) )
-
-/**
- * @brief Set the NonSecure MSP to the given value.
- */
-#define secureportSET_MSP_NS( pucMainStackPointer ) \
-	__asm volatile ( "msr msp_ns, %0" : : "r" ( pucMainStackPointer ) )
-
-/**
- * @brief Set the CONTROL register to the given value.
- */
-#define secureportSET_CONTROL( ulControl ) \
-	__asm volatile ( "msr control, %0" : : "r" ( ulControl ) : "memory" )
-
-/**
- * @brief Read the Interrupt Program Status Register (IPSR) value in the given
- * variable.
- */
-#define secureportREAD_IPSR( ulIPSR ) \
-	__asm volatile ( "mrs %0, ipsr"  : "=r" ( ulIPSR ) )
-
-/**
- * @brief PRIMASK value to enable interrupts.
- */
-#define secureportPRIMASK_ENABLE_INTERRUPTS_VAL		0
-
-/**
- * @brief PRIMASK value to disable interrupts.
- */
-#define secureportPRIMASK_DISABLE_INTERRUPTS_VAL	1
-
-/**
- * @brief Disable secure interrupts.
- */
-#define secureportDISABLE_SECURE_INTERRUPTS()		secureportSET_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Disable non-secure interrupts.
- *
- * This effectively disables context switches.
- */
-#define secureportDISABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Enable non-secure interrupts.
- */
-#define secureportENABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_ENABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Assert definition.
- */
-#define secureportASSERT( x )						\
-	if( ( x ) == 0 )								\
-	{												\
-		secureportDISABLE_SECURE_INTERRUPTS();		\
-		secureportDISABLE_NON_SECURE_INTERRUPTS();	\
-		for( ;; );									\
-	}
-
-#endif /* __SECURE_PORT_MACROS_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/port.c b/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.c b/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.c
deleted file mode 100644
index abda927..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.c
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE ensures that PRIVILEGED_FUNCTION
- * is defined correctly and privileged functions are placed in correct sections. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Portasm includes. */
-#include "portasm.h"
-
-/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE is needed to be defined only for the
- * header files. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#if( configENABLE_FPU == 1 )
-	#error Cortex-M23 does not have a Floating Point Unit (FPU) and therefore configENABLE_FPU must be set to 0.
-#endif
-
-void vRestoreContextOfFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"													\n"
-	"	ldr  r2, pxCurrentTCBConst2						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr  r1, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr  r0, [r1]									\n" /* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r3, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r4, #1										\n" /* r4 = 1. */
-	"	bics r3, r4										\n" /* r3 = r3 & ~r4 i.e. Clear the bit 0 in r3. */
-	"	str r3, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	"	ldr  r4, [r1]									\n" /* r4 = *r1 i.e. r4 = MAIR0. */
-	"	ldr  r2, xMAIR0Const2							\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str  r4, [r2]									\n" /* Program MAIR0. */
-	"	ldr  r2, xRNRConst2								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	"	movs r4, #4										\n" /* r4 = 4. */
-	"	str  r4, [r2]									\n" /* Program RNR = 4. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read first set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst2							\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write first set of RBAR/RLAR registers. */
-	"	movs r4, #5										\n" /* r4 = 5. */
-	"	str  r4, [r2]									\n" /* Program RNR = 5. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read second set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst2							\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write second set of RBAR/RLAR registers. */
-	"	movs r4, #6										\n" /* r4 = 6. */
-	"	str  r4, [r2]									\n" /* Program RNR = 6. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read third set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst2							\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write third set of RBAR/RLAR registers. */
-	"	movs r4, #7										\n" /* r4 = 7. */
-	"	str  r4, [r2]									\n" /* Program RNR = 7. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read fourth set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst2							\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write fourth set of RBAR/RLAR registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r3, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r4, #1										\n" /* r4 = 1. */
-	"	orrs r3, r4										\n" /* r3 = r3 | r4 i.e. Set the bit 0 in r3. */
-	"	str r3, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	ldm  r0!, {r1-r3}								\n" /* Read from stack - r1 = PSPLIM, r2 = CONTROL and r3 = EXC_RETURN. */
-	"	msr  psplim, r1									\n" /* Set this task's PSPLIM value. */
-	"	msr  control, r2								\n" /* Set this task's CONTROL value. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r3											\n" /* Finally, branch to EXC_RETURN. */
-	#else /* configENABLE_MPU */
-	"	ldm  r0!, {r1-r2}								\n" /* Read from stack - r1 = PSPLIM and r2 = EXC_RETURN. */
-	"	msr  psplim, r1									\n" /* Set this task's PSPLIM value. */
-	"	movs r1, #2										\n" /* r1 = 2. */
-	"	msr  CONTROL, r1								\n" /* Switch to use PSP in the thread mode. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r2											\n" /* Finally, branch to EXC_RETURN. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst2: .word 0xe000ed94					\n"
-	"xMAIR0Const2: .word 0xe000edc0						\n"
-	"xRNRConst2: .word 0xe000ed98						\n"
-	"xRBARConst2: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	);
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	movs r1, #1										\n" /* r1 = 1. */
-	"	tst r0, r1										\n" /* Perform r0 & r1 (bitwise AND) and update the conditions flag. */
-	"	beq running_privileged							\n" /* If the result of previous AND operation was 0, branch. */
-	"	movs r0, #0										\n" /* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	"	bx lr											\n" /* Return. */
-	" running_privileged:								\n"
-	"	movs r0, #1										\n" /* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	"	bx lr											\n" /* Return. */
-	"													\n"
-	"	.align 4										\n"
-	::: "r0", "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vRaisePrivilege( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	 __asm volatile
-	(
-	"	mrs  r0, control								\n" /* Read the CONTROL register. */
-	"	movs r1, #1										\n" /* r1 = 1. */
-	"	bics r0, r1										\n" /* Clear the bit 0. */
-	"	msr  control, r0								\n" /* Write back the new CONTROL value. */
-	"	bx lr											\n" /* Return to the caller. */
-	::: "r0", "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vResetPrivilege( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	movs r1, #1										\n" /* r1 = 1. */
-	"	orrs r0, r1										\n" /* r0 = r0 | r1. */
-	"	msr control, r0									\n" /* CONTROL = r0. */
-	"	bx lr											\n" /* Return to the caller. */
-	:::"r0", "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vStartFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	ldr r0, xVTORConst								\n" /* Use the NVIC offset register to locate the stack. */
-	"	ldr r0, [r0]									\n" /* Read the VTOR register which gives the address of vector table. */
-	"	ldr r0, [r0]									\n" /* The first entry in vector table is stack pointer. */
-	"	msr msp, r0										\n" /* Set the MSP back to the start of the stack. */
-	"	cpsie i											\n" /* Globally enable interrupts. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	svc %0											\n" /* System call to start the first task. */
-	"	nop												\n"
-	"													\n"
-	"   .align 4										\n"
-	"xVTORConst: .word 0xe000ed08						\n"
-	:: "i" ( portSVC_START_SCHEDULER ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	mrs r0, PRIMASK									\n"
-	"	cpsid i											\n"
-	"	bx lr											\n"
-	::: "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vClearInterruptMask( __attribute__( ( unused ) ) uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	msr PRIMASK, r0									\n"
-	"	bx lr											\n"
-	::: "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void PendSV_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"													\n"
-	"	mrs r0, psp										\n" /* Read PSP in r0. */
-	"	ldr r2, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r1, [r2]									\n" /* Read pxCurrentTCB. */
-	#if( configENABLE_MPU == 1 )
-	"	subs r0, r0, #44								\n" /* Make space for PSPLIM, CONTROL, LR and the remaining registers on the stack. */
-	"	str r0, [r1]									\n" /* Save the new top of stack in TCB. */
-	"	mrs r1, psplim									\n" /* r1 = PSPLIM. */
-	"	mrs r2, control									\n" /* r2 = CONTROL. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	stmia r0!, {r1-r7}								\n" /* Store on the stack - PSPLIM, CONTROL, LR and low registers that are not automatically saved. */
-	"	mov r4, r8										\n" /* r4 = r8. */
-	"	mov r5, r9										\n" /* r5 = r9. */
-	"	mov r6, r10										\n" /* r6 = r10. */
-	"	mov r7, r11										\n" /* r7 = r11. */
-	"	stmia r0!, {r4-r7}								\n" /* Store the high registers that are not saved automatically. */
-	#else /* configENABLE_MPU */
-	"	subs r0, r0, #40								\n" /* Make space for PSPLIM, LR and the remaining registers on the stack. */
-	"	str r0, [r1]									\n" /* Save the new top of stack in TCB. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	stmia r0!, {r2-r7}								\n" /* Store on the stack - PSPLIM, LR and low registers that are not automatically saved. */
-	"	mov r4, r8										\n" /* r4 = r8. */
-	"	mov r5, r9										\n" /* r5 = r9. */
-	"	mov r6, r10										\n" /* r6 = r10. */
-	"	mov r7, r11										\n" /* r7 = r11. */
-	"	stmia r0!, {r4-r7}								\n" /* Store the high registers that are not saved automatically. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	"	cpsid i											\n"
-	"	bl vTaskSwitchContext							\n"
-	"	cpsie i											\n"
-	"													\n"
-	"	ldr r2, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r1, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr r0, [r1]									\n" /* The first item in pxCurrentTCB is the task top of stack. r0 now points to the top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r3, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r4, #1										\n" /* r4 = 1. */
-	"	bics r3, r4										\n" /* r3 = r3 & ~r4 i.e. Clear the bit 0 in r3. */
-	"	str r3, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	"	ldr  r4, [r1]									\n" /* r4 = *r1 i.e. r4 = MAIR0. */
-	"	ldr  r2, xMAIR0Const							\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str  r4, [r2]									\n" /* Program MAIR0. */
-	"	ldr  r2, xRNRConst								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	"	movs r4, #4										\n" /* r4 = 4. */
-	"	str  r4, [r2]									\n" /* Program RNR = 4. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read first set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst								\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write first set of RBAR/RLAR registers. */
-	"	movs r4, #5										\n" /* r4 = 5. */
-	"	str  r4, [r2]									\n" /* Program RNR = 5. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read second set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst								\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write second set of RBAR/RLAR registers. */
-	"	movs r4, #6										\n" /* r4 = 6. */
-	"	str  r4, [r2]									\n" /* Program RNR = 6. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read third set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst								\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write third set of RBAR/RLAR registers. */
-	"	movs r4, #7										\n" /* r4 = 7. */
-	"	str  r4, [r2]									\n" /* Program RNR = 7. */
-	"	ldmia r1!, {r5,r6}								\n" /* Read fourth set of RBAR/RLAR from TCB. */
-	"	ldr  r3, xRBARConst								\n" /* r3 = 0xe000ed9c [Location of RBAR]. */
-	"	stmia r3!, {r5,r6}								\n" /* Write fourth set of RBAR/RLAR registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r3, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	movs r4, #1										\n" /* r4 = 1. */
-	"	orrs r3, r4										\n" /* r3 = r3 | r4 i.e. Set the bit 0 in r3. */
-	"	str r3, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	adds r0, r0, #28								\n" /* Move to the high registers. */
-	"	ldmia r0!, {r4-r7}								\n" /* Restore the high registers that are not automatically restored. */
-	"	mov r8, r4										\n" /* r8 = r4. */
-	"	mov r9, r5										\n" /* r9 = r5. */
-	"	mov r10, r6										\n" /* r10 = r6. */
-	"	mov r11, r7										\n" /* r11 = r7. */
-	"	msr psp, r0										\n" /* Remember the new top of stack for the task. */
-	"	subs r0, r0, #44								\n" /* Move to the starting of the saved context. */
-	"	ldmia r0!, {r1-r7}								\n" /* Read from stack - r1 = PSPLIM, r2 = CONTROL, r3 = LR and r4-r7 restored. */
-	"	msr psplim, r1									\n" /* Restore the PSPLIM register value for the task. */
-	"	msr control, r2									\n" /* Restore the CONTROL register value for the task. */
-	"	bx r3											\n"
-	#else /* configENABLE_MPU */
-	"	adds r0, r0, #24								\n" /* Move to the high registers. */
-	"	ldmia r0!, {r4-r7}								\n" /* Restore the high registers that are not automatically restored. */
-	"	mov r8, r4										\n" /* r8 = r4. */
-	"	mov r9, r5										\n" /* r9 = r5. */
-	"	mov r10, r6										\n" /* r10 = r6. */
-	"	mov r11, r7										\n" /* r11 = r7. */
-	"	msr psp, r0										\n" /* Remember the new top of stack for the task. */
-	"	subs r0, r0, #40								\n" /* Move to the starting of the saved context. */
-	"	ldmia r0!, {r2-r7}								\n" /* Read from stack - r2 = PSPLIM, r3 = LR and r4-r7 restored. */
-	"	msr psplim, r2									\n" /* Restore the PSPLIM register value for the task. */
-	"	bx r3											\n"
-	#endif /* configENABLE_MPU */
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB				\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst: .word 0xe000ed94					\n"
-	"xMAIR0Const: .word 0xe000edc0						\n"
-	"xRNRConst: .word 0xe000ed98						\n"
-	"xRBARConst: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	);
-}
-/*-----------------------------------------------------------*/
-
-void SVC_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	movs r0, #4										\n"
-	"	mov r1, lr										\n"
-	"	tst r0, r1										\n"
-	"	beq stacking_used_msp							\n"
-	"	mrs r0, psp										\n"
-	"	ldr r2, svchandler_address_const				\n"
-	"	bx r2											\n"
-	" stacking_used_msp:								\n"
-	"	mrs r0, msp										\n"
-	"	ldr r2, svchandler_address_const				\n"
-	"	bx r2											\n"
-	"													\n"
-	"	.align 4										\n"
-	"svchandler_address_const: .word vPortSVCHandler_C	\n"
-	);
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.h b/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portmacro.h
deleted file mode 100644
index 2f469ad..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM23_NTZ/non_secure/portmacro.h
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M23"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__attribute__(( used ))
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							__asm volatile ( " cpsid i " ::: "memory" )
-#define portENABLE_INTERRUPTS()								__asm volatile ( " cpsie i " ::: "memory" )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM3/port.c b/osal/src/freertos/portable/GCC/ARM_CM3/port.c
deleted file mode 100644
index 9418e18..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM3/port.c
+++ /dev/null
@@ -1,717 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM3 port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* For backward compatibility, ensure configKERNEL_INTERRUPT_PRIORITY is
-defined.  The value should also ensure backward compatibility.
-FreeRTOS.org versions prior to V4.4.0 did not include this definition. */
-#ifndef configKERNEL_INTERRUPT_PRIORITY
-	#define configKERNEL_INTERRUPT_PRIORITY 255
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000UL )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/* Let the user override the pre-loading of the initial LR with the address of
-prvTaskExitError() in case it messes up unwinding of the stack in the
-debugger. */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS	prvTaskExitError
-#endif
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void ) __attribute__ (( naked ));
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void ) __attribute__ (( naked ));
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvPortStartFirstTask( void ) __attribute__ (( naked ));
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		started to remove a compiler warning about the function being defined
-		but never called.  ulDummy is used purely to quieten other warnings
-		about code appearing after this function is called - making ulDummy
-		volatile makes the compiler think the function could return and
-		therefore not output an 'unreachable code' warning for code that appears
-		after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	__asm volatile (
-					"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
-					"	ldr r1, [r3]					\n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
-					"	ldr r0, [r1]					\n" /* The first item in pxCurrentTCB is the task top of stack. */
-					"	ldmia r0!, {r4-r11}				\n" /* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
-					"	msr psp, r0						\n" /* Restore the task stack pointer. */
-					"	isb								\n"
-					"	mov r0, #0 						\n"
-					"	msr	basepri, r0					\n"
-					"	orr r14, #0xd					\n"
-					"	bx r14							\n"
-					"									\n"
-					"	.align 4						\n"
-					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
-				);
-}
-/*-----------------------------------------------------------*/
-
-static void prvPortStartFirstTask( void )
-{
-	__asm volatile(
-					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
-					" ldr r0, [r0] 			\n"
-					" ldr r0, [r0] 			\n"
-					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
-					" cpsie i				\n" /* Globally enable interrupts. */
-					" cpsie f				\n"
-					" dsb					\n"
-					" isb					\n"
-					" svc 0					\n" /* System call to start first task. */
-					" nop					\n"
-				);
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Start the first task. */
-	prvPortStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing!  Call the task
-	exit error function to prevent compiler warnings about a static function
-	not being called in the case that the application writer overrides this
-	functionality by defining configTASK_RETURN_ADDRESS.  Call
-	vTaskSwitchContext() so link time optimisation does not remove the
-	symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void xPortPendSVHandler( void )
-{
-	/* This is a naked function. */
-
-	__asm volatile
-	(
-	"	mrs r0, psp							\n"
-	"	isb									\n"
-	"										\n"
-	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
-	"	ldr	r2, [r3]						\n"
-	"										\n"
-	"	stmdb r0!, {r4-r11}					\n" /* Save the remaining registers. */
-	"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
-	"										\n"
-	"	stmdb sp!, {r3, r14}				\n"
-	"	mov r0, %0							\n"
-	"	msr basepri, r0						\n"
-	"	bl vTaskSwitchContext				\n"
-	"	mov r0, #0							\n"
-	"	msr basepri, r0						\n"
-	"	ldmia sp!, {r3, r14}				\n"
-	"										\n" /* Restore the context, including the critical nesting count. */
-	"	ldr r1, [r3]						\n"
-	"	ldr r0, [r1]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
-	"	ldmia r0!, {r4-r11}					\n" /* Pop the registers. */
-	"	msr psp, r0							\n"
-	"	isb									\n"
-	"	bx r14								\n"
-	"										\n"
-	"	.align 4							\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
-	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
-	);
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM3/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM3/portmacro.h
deleted file mode 100644
index 98aa040..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM3/portmacro.h
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* Scheduler utilities. */
-#define portYIELD() 															\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__asm volatile( "dsb" ::: "memory" );										\
-	__asm volatile( "isb" );													\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Generic helper function. */
-	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
-	{
-	uint8_t ucReturn;
-
-		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
-		return ucReturn;
-	}
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mov %0, %1												\n" \
-		"	msr basepri, %0											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mrs %0, basepri											\n" \
-		"	mov %1, %2												\n" \
-		"	msr basepri, %1											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-
-	/* This return will not be reached but is necessary to prevent compiler
-	warnings. */
-	return ulOriginalBASEPRI;
-}
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
-{
-	__asm volatile
-	(
-		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/port.c b/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.c b/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.c
deleted file mode 100644
index 432a837..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.c
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE ensures that PRIVILEGED_FUNCTION
- * is defined correctly and privileged functions are placed in correct sections. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Portasm includes. */
-#include "portasm.h"
-
-/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE is needed to be defined only for the
- * header files. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-void vRestoreContextOfFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"													\n"
-	"	ldr  r2, pxCurrentTCBConst2						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr  r3, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr  r0, [r3]									\n" /* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	bic r4, #1										\n" /* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-	"	ldr  r4, [r3]									\n" /* r4 = *r3 i.e. r4 = MAIR0. */
-	"	ldr  r2, xMAIR0Const2							\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str  r4, [r2]									\n" /* Program MAIR0. */
-	"	ldr  r2, xRNRConst2								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	movs r4, #4										\n" /* r4 = 4. */
-	"	str  r4, [r2]									\n" /* Program RNR = 4. */
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-	"	ldr  r2, xRBARConst2							\n" /* r2 = 0xe000ed9c [Location of RBAR]. */
-	"	ldmia r3!, {r4-r11}								\n" /* Read 4 set of RBAR/RLAR registers from TCB. */
-	"	stmia r2!, {r4-r11}								\n" /* Write 4 set of RBAR/RLAR registers using alias registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	orr r4, #1										\n" /* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	ldm  r0!, {r1-r4}								\n" /* Read from stack - r1 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = EXC_RETURN. */
-	"	ldr  r5, xSecureContextConst2					\n"
-	"	str  r1, [r5]									\n" /* Set xSecureContext to this task's value for the same. */
-	"	msr  psplim, r2									\n" /* Set this task's PSPLIM value. */
-	"	msr  control, r3								\n" /* Set this task's CONTROL value. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r4											\n" /* Finally, branch to EXC_RETURN. */
-	#else /* configENABLE_MPU */
-	"	ldm  r0!, {r1-r3}								\n" /* Read from stack - r1 = xSecureContext, r2 = PSPLIM and r3 = EXC_RETURN. */
-	"	ldr  r4, xSecureContextConst2					\n"
-	"	str  r1, [r4]									\n" /* Set xSecureContext to this task's value for the same. */
-	"	msr  psplim, r2									\n" /* Set this task's PSPLIM value. */
-	"	movs r1, #2										\n" /* r1 = 2. */
-	"	msr  CONTROL, r1								\n" /* Switch to use PSP in the thread mode. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r3											\n" /* Finally, branch to EXC_RETURN. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
-	"xSecureContextConst2: .word xSecureContext			\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst2: .word 0xe000ed94					\n"
-	"xMAIR0Const2: .word 0xe000edc0						\n"
-	"xRNRConst2: .word 0xe000ed98						\n"
-	"xRBARConst2: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	);
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	tst r0, #1										\n" /* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	"	ite ne											\n"
-	"	movne r0, #0									\n" /* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	"	moveq r0, #1									\n" /* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	"	bx lr											\n" /* Return. */
-	"													\n"
-	"	.align 4										\n"
-	::: "r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vRaisePrivilege( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	 __asm volatile
-	(
-	"	mrs r0, control									\n" /* Read the CONTROL register. */
-	"	bic r0, #1										\n" /* Clear the bit 0. */
-	"	msr control, r0									\n" /* Write back the new CONTROL value. */
-	"	bx lr											\n" /* Return to the caller. */
-	::: "r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vResetPrivilege( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	orr r0, #1										\n" /* r0 = r0 | 1. */
-	"	msr control, r0									\n" /* CONTROL = r0. */
-	"	bx lr											\n" /* Return to the caller. */
-	:::"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vStartFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	ldr r0, xVTORConst								\n" /* Use the NVIC offset register to locate the stack. */
-	"	ldr r0, [r0]									\n" /* Read the VTOR register which gives the address of vector table. */
-	"	ldr r0, [r0]									\n" /* The first entry in vector table is stack pointer. */
-	"	msr msp, r0										\n" /* Set the MSP back to the start of the stack. */
-	"	cpsie i											\n" /* Globally enable interrupts. */
-	"	cpsie f											\n"
-	"	dsb												\n"
-	"	isb												\n"
-	"	svc %0											\n" /* System call to start the first task. */
-	"	nop												\n"
-	"													\n"
-	"   .align 4										\n"
-	"xVTORConst: .word 0xe000ed08						\n"
-	:: "i" ( portSVC_START_SCHEDULER ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	mrs r0, basepri									\n" /* r0 = basepri. Return original basepri value. */
-	"	mov r1, %0										\n" /* r1 = configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	"	msr basepri, r1									\n" /* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	bx lr											\n" /* Return. */
-	:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vClearInterruptMask( __attribute__( ( unused ) ) uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	msr basepri, r0									\n" /* basepri = ulMask. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	bx lr											\n" /* Return. */
-	::: "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void PendSV_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"	.extern SecureContext_SaveContext				\n"
-	"	.extern SecureContext_LoadContext				\n"
-	"													\n"
-	"	mrs r1, psp										\n" /* Read PSP in r1. */
-	"	ldr r2, xSecureContextConst						\n" /* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	"	ldr r0, [r2]									\n" /* Read xSecureContext - Value of xSecureContext must be in r0 as it is used as a parameter later. */
-	"													\n"
-	"	cbz r0, save_ns_context							\n" /* No secure context to save. */
-	"	push {r0-r2, r14}								\n"
-	"	bl SecureContext_SaveContext					\n"
-	"	pop {r0-r3}										\n" /* LR is now in r3. */
-	"	mov lr, r3										\n" /* LR = r3. */
-	"	lsls r2, r3, #25								\n" /* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	"	bpl save_ns_context								\n" /* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	"	ldr r3, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r2, [r3]									\n" /* Read pxCurrentTCB. */
-	#if( configENABLE_MPU == 1 )
-	"	subs r1, r1, #16								\n" /* Make space for xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mrs r3, control									\n" /* r3 = CONTROL. */
-	"	mov r4, lr										\n" /* r4 = LR/EXC_RETURN. */
-	"	stmia r1!, {r0, r2-r4}							\n" /* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	#else /* configENABLE_MPU */
-	"	subs r1, r1, #12								\n" /* Make space for xSecureContext, PSPLIM and LR on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	stmia r1!, {r0, r2-r3}							\n" /* Store xSecureContext, PSPLIM and LR on the stack. */
-	#endif /* configENABLE_MPU */
-	"	b select_next_task								\n"
-	"													\n"
-	" save_ns_context:									\n"
-	"	ldr r3, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r2, [r3]									\n" /* Read pxCurrentTCB. */
-	#if( configENABLE_FPU == 1 )
-	"	tst lr, #0x10									\n" /* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-	"	it eq											\n"
-	"	vstmdbeq r1!, {s16-s31}							\n" /* Store the FPU registers which are not saved automatically. */
-	#endif /* configENABLE_FPU */
-	#if( configENABLE_MPU == 1 )
-	"	subs r1, r1, #48								\n" /* Make space for xSecureContext, PSPLIM, CONTROL, LR and the remaining registers on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	adds r1, r1, #16								\n" /* r1 = r1 + 16. */
-	"	stm r1, {r4-r11}								\n" /* Store the registers that are not saved automatically. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mrs r3, control									\n" /* r3 = CONTROL. */
-	"	mov r4, lr										\n" /* r4 = LR/EXC_RETURN. */
-	"	subs r1, r1, #16								\n" /* r1 = r1 - 16. */
-	"	stm r1, {r0, r2-r4}								\n" /* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	#else /* configENABLE_MPU */
-	"	subs r1, r1, #44								\n" /* Make space for xSecureContext, PSPLIM, LR and the remaining registers on the stack. */
-	"	str r1, [r2]									\n" /* Save the new top of stack in TCB. */
-	"	adds r1, r1, #12								\n" /* r1 = r1 + 12. */
-	"	stm r1, {r4-r11}								\n" /* Store the registers that are not saved automatically. */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	subs r1, r1, #12								\n" /* r1 = r1 - 12. */
-	"	stmia r1!, {r0, r2-r3}							\n" /* Store xSecureContext, PSPLIM and LR on the stack. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	" select_next_task:									\n"
-	"	mov r0, %0										\n" /* r0 = configMAX_SYSCALL_INTERRUPT_PRIORITY */
-	"	msr basepri, r0									\n" /* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	bl vTaskSwitchContext							\n"
-	"	mov r0, #0										\n" /* r0 = 0. */
-	"	msr basepri, r0									\n" /* Enable interrupts. */
-	"													\n"
-	"	ldr r2, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r3, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr r1, [r3]									\n" /* The first item in pxCurrentTCB is the task top of stack. r1 now points to the top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	bic r4, #1										\n" /* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-	"	ldr r4, [r3]									\n" /* r4 = *r3 i.e. r4 = MAIR0. */
-	"	ldr r2, xMAIR0Const								\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str r4, [r2]									\n" /* Program MAIR0. */
-	"	ldr r2, xRNRConst								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	movs r4, #4										\n" /* r4 = 4. */
-	"	str r4, [r2]									\n" /* Program RNR = 4. */
-	"	adds r3, #4										\n" /* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-	"	ldr  r2, xRBARConst								\n" /* r2 = 0xe000ed9c [Location of RBAR]. */
-	"	ldmia r3!, {r4-r11}								\n" /* Read 4 sets of RBAR/RLAR registers from TCB. */
-	"	stmia r2!, {r4-r11}								\n" /* Write 4 set of RBAR/RLAR registers using alias registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	orr r4, #1										\n" /* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	ldmia r1!, {r0, r2-r4}							\n" /* Read from stack - r0 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = LR. */
-	"	msr psplim, r2									\n" /* Restore the PSPLIM register value for the task. */
-	"	msr control, r3									\n" /* Restore the CONTROL register value for the task. */
-	"	mov lr, r4										\n" /* LR = r4. */
-	"	ldr r2, xSecureContextConst						\n" /* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	"	str r0, [r2]									\n" /* Restore the task's xSecureContext. */
-	"	cbz r0, restore_ns_context						\n" /* If there is no secure context for the task, restore the non-secure context. */
-	"	push {r1,r4}									\n"
-	"	bl SecureContext_LoadContext					\n" /* Restore the secure context. */
-	"	pop {r1,r4}										\n"
-	"	mov lr, r4										\n" /* LR = r4. */
-	"	lsls r2, r4, #25								\n" /* r2 = r4 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	"	bpl restore_ns_context							\n" /* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	"	msr psp, r1										\n" /* Remember the new top of stack for the task. */
-	"	bx lr											\n"
-	#else /* configENABLE_MPU */
-	"	ldmia r1!, {r0, r2-r3}							\n" /* Read from stack - r0 = xSecureContext, r2 = PSPLIM and r3 = LR. */
-	"	msr psplim, r2									\n" /* Restore the PSPLIM register value for the task. */
-	"	mov lr, r3										\n" /* LR = r3. */
-	"	ldr r2, xSecureContextConst						\n" /* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	"	str r0, [r2]									\n" /* Restore the task's xSecureContext. */
-	"	cbz r0, restore_ns_context						\n" /* If there is no secure context for the task, restore the non-secure context. */
-	"	push {r1,r3}									\n"
-	"	bl SecureContext_LoadContext					\n" /* Restore the secure context. */
-	"	pop {r1,r3}										\n"
-	"	mov lr, r3										\n" /* LR = r3. */
-	"	lsls r2, r3, #25								\n" /* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	"	bpl restore_ns_context							\n" /* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	"	msr psp, r1										\n" /* Remember the new top of stack for the task. */
-	"	bx lr											\n"
-	#endif /* configENABLE_MPU */
-	"													\n"
-	" restore_ns_context:								\n"
-	"	ldmia r1!, {r4-r11}								\n" /* Restore the registers that are not automatically restored. */
-	#if( configENABLE_FPU == 1 )
-	"	tst lr, #0x10									\n" /* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-	"	it eq											\n"
-	"	vldmiaeq r1!, {s16-s31}							\n" /* Restore the FPU registers which are not restored automatically. */
-	#endif /* configENABLE_FPU */
-	"	msr psp, r1										\n" /* Remember the new top of stack for the task. */
-	"	bx lr											\n"
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB				\n"
-	"xSecureContextConst: .word xSecureContext			\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst: .word 0xe000ed94					\n"
-	"xMAIR0Const: .word 0xe000edc0						\n"
-	"xRNRConst: .word 0xe000ed98						\n"
-	"xRBARConst: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	:: "i"( configMAX_SYSCALL_INTERRUPT_PRIORITY )
-	);
-}
-/*-----------------------------------------------------------*/
-
-void SVC_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	tst lr, #4										\n"
-	"	ite eq											\n"
-	"	mrseq r0, msp									\n"
-	"	mrsne r0, psp									\n"
-	"	ldr r1, svchandler_address_const				\n"
-	"	bx r1											\n"
-	"													\n"
-	"	.align 4										\n"
-	"svchandler_address_const: .word vPortSVCHandler_C	\n"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	svc %0											\n" /* Secure context is allocated in the supervisor call. */
-	"	bx lr											\n" /* Return. */
-	:: "i" ( portSVC_ALLOCATE_SECURE_CONTEXT ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	ldr r1, [r0]									\n" /* The first item in the TCB is the top of the stack. */
-	"	ldr r0, [r1]									\n" /* The first item on the stack is the task's xSecureContext. */
-	"	cmp r0, #0										\n" /* Raise svc if task's xSecureContext is not NULL. */
-	"	it ne											\n"
-	"	svcne %0										\n" /* Secure context is freed in the supervisor call. */
-	"	bx lr											\n" /* Return. */
-	:: "i" ( portSVC_FREE_SECURE_CONTEXT ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.h b/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portmacro.h
deleted file mode 100644
index 34191e3..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/non_secure/portmacro.h
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M33"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__attribute__(( used ))
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							ulSetInterruptMask()
-#define portENABLE_INTERRUPTS()								vClearInterruptMask( 0 )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.c b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.c
deleted file mode 100644
index b19f801..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.c
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief CONTROL value for privileged tasks.
- *
- * Bit[0] - 0 --> Thread mode is privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_PRIVILEGED		0x02
-
-/**
- * @brief CONTROL value for un-privileged tasks.
- *
- * Bit[0] - 1 --> Thread mode is un-privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_UNPRIVILEGED		0x03
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Structure to represent secure context.
- *
- * @note Since stack grows down, pucStackStart is the highest address while
- * pucStackLimit is the first addess of the allocated memory.
- */
-typedef struct SecureContext
-{
-	uint8_t *pucCurrentStackPointer;	/**< Current value of stack pointer (PSP). */
-	uint8_t *pucStackLimit;				/**< Last location of the stack memory (PSPLIM). */
-	uint8_t *pucStackStart;				/**< First location of the stack memory. */
-} SecureContext_t;
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_Init( void )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* No stack for thread mode until a task's context is loaded. */
-		secureportSET_PSPLIM( securecontextNO_STACK );
-		secureportSET_PSP( securecontextNO_STACK );
-
-		#if( configENABLE_MPU == 1 )
-		{
-			/* Configure thread mode to use PSP and to be unprivileged. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_UNPRIVILEGED );
-		}
-		#else /* configENABLE_MPU */
-		{
-			/* Configure thread mode to use PSP and to be privileged.. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_PRIVILEGED );
-		}
-		#endif /* configENABLE_MPU */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged )
-#else /* configENABLE_MPU */
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize )
-#endif /* configENABLE_MPU */
-{
-	uint8_t *pucStackMemory = NULL;
-	uint32_t ulIPSR;
-	SecureContextHandle_t xSecureContextHandle = NULL;
-	#if( configENABLE_MPU == 1 )
-		uint32_t *pulCurrentStackPointer = NULL;
-	#endif /* configENABLE_MPU */
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Allocate the context structure. */
-		xSecureContextHandle = ( SecureContextHandle_t ) pvPortMalloc( sizeof( SecureContext_t ) );
-
-		if( xSecureContextHandle != NULL )
-		{
-			/* Allocate the stack space. */
-			pucStackMemory = pvPortMalloc( ulSecureStackSize );
-
-			if( pucStackMemory != NULL )
-			{
-				/* Since stack grows down, the starting point will be the last
-				 * location. Note that this location is next to the last
-				 * allocated byte because the hardware decrements the stack
-				 * pointer before writing i.e. if stack pointer is 0x2, a push
-				 * operation will decrement the stack pointer to 0x1 and then
-				 * write at 0x1. */
-				xSecureContextHandle->pucStackStart = pucStackMemory + ulSecureStackSize;
-
-				/* The stack cannot go beyond this location. This value is
-				 * programmed in the PSPLIM register on context switch.*/
-				xSecureContextHandle->pucStackLimit = pucStackMemory;
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Store the correct CONTROL value for the task on the stack.
-					 * This value is programmed in the CONTROL register on
-					 * context switch. */
-					pulCurrentStackPointer = ( uint32_t * ) xSecureContextHandle->pucStackStart;
-					pulCurrentStackPointer--;
-					if( ulIsTaskPrivileged )
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_PRIVILEGED;
-					}
-					else
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_UNPRIVILEGED;
-					}
-
-					/* Store the current stack pointer. This value is programmed in
-					 * the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = ( uint8_t * ) pulCurrentStackPointer;
-				}
-				#else /* configENABLE_MPU */
-				{
-					/* Current SP is set to the starting of the stack. This
-					 * value programmed in the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = xSecureContextHandle->pucStackStart;
-
-				}
-				#endif /* configENABLE_MPU */
-			}
-			else
-			{
-				/* Free the context to avoid memory leak and make sure to return
-				 * NULL to indicate failure. */
-				vPortFree( xSecureContextHandle );
-				xSecureContextHandle = NULL;
-			}
-		}
-	}
-
-	return xSecureContextHandle;
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Ensure that valid parameters are passed. */
-		secureportASSERT( xSecureContextHandle != NULL );
-
-		/* Free the stack space. */
-		vPortFree( xSecureContextHandle->pucStackLimit );
-
-		/* Free the context itself. */
-		vPortFree( xSecureContextHandle );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.h b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.h
deleted file mode 100644
index 7323f8f..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_CONTEXT_H__
-#define __SECURE_CONTEXT_H__
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* FreeRTOS includes. */
-#include "FreeRTOSConfig.h"
-
-/**
- * @brief PSP value when no task's context is loaded.
- */
-#define securecontextNO_STACK	0x0
-
-/**
- * @brief Opaque handle.
- */
-struct SecureContext;
-typedef struct SecureContext*	SecureContextHandle_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Initializes the secure context management system.
- *
- * PSP is set to NULL and therefore a task must allocate and load a context
- * before calling any secure side function in the thread mode.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureContext_Init( void );
-
-/**
- * @brief Allocates a context on the secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] ulSecureStackSize Size of the stack to allocate on secure side.
- * @param[in] ulIsTaskPrivileged 1 if the calling task is privileged, 0 otherwise.
- *
- * @return Opaque context handle if context is successfully allocated, NULL
- * otherwise.
- */
-#if( configENABLE_MPU == 1 )
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged );
-#else /* configENABLE_MPU */
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize );
-#endif /* configENABLE_MPU */
-
-/**
- * @brief Frees the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the
- * context to be freed.
- */
-void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Loads the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be loaded.
- */
-void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Saves the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be saved.
- */
-void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle );
-
-#endif /* __SECURE_CONTEXT_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context_port.c b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context_port.c
deleted file mode 100644
index 968aafb..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_context_port.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-secureportNON_SECURE_CALLABLE void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle )
-{
-	/* xSecureContextHandle value is in r0. */
-	__asm volatile
-	(
-	"	.syntax unified							\n"
-	"											\n"
-	"	mrs r1, ipsr							\n" /* r1 = IPSR. */
-	"	cbz r1, load_ctx_therad_mode			\n" /* Do nothing if the processor is running in the Thread Mode. */
-	"	ldmia r0!, {r1, r2}						\n" /* r1 = xSecureContextHandle->pucCurrentStackPointer, r2 = xSecureContextHandle->pucStackLimit. */
-	#if( configENABLE_MPU == 1 )
-	"	ldmia r1!, {r3}							\n" /* Read CONTROL register value from task's stack. r3 = CONTROL. */
-	"	msr control, r3							\n" /* CONTROL = r3. */
-	#endif /* configENABLE_MPU */
-	"	msr psplim, r2							\n" /* PSPLIM = r2. */
-	"	msr psp, r1								\n" /* PSP = r1. */
-	"											\n"
-	" load_ctx_therad_mode:						\n"
-	"	nop										\n"
-	"											\n"
-	:::"r0", "r1", "r2"
-	);
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle )
-{
-	/* xSecureContextHandle value is in r0. */
-	__asm volatile
-	(
-	"	.syntax unified							\n"
-	"											\n"
-	"	mrs r1, ipsr							\n" /* r1 = IPSR. */
-	"	cbz r1, save_ctx_therad_mode			\n" /* Do nothing if the processor is running in the Thread Mode. */
-	"	mrs r1, psp								\n" /* r1 = PSP. */
-	#if( configENABLE_FPU == 1 )
-	"	vstmdb r1!, {s0}						\n" /* Trigger the defferred stacking of FPU registers. */
-	"	vldmia r1!, {s0}						\n" /* Nullify the effect of the pervious statement. */
-	#endif /* configENABLE_FPU */
-	#if( configENABLE_MPU == 1 )
-	"	mrs r2, control							\n" /* r2 = CONTROL. */
-	"	stmdb r1!, {r2}							\n" /* Store CONTROL value on the stack. */
-	#endif /* configENABLE_MPU */
-	"	str r1, [r0]							\n" /* Save the top of stack in context. xSecureContextHandle->pucCurrentStackPointer = r1. */
-	"	movs r1, %0								\n" /* r1 = securecontextNO_STACK. */
-	"	msr psplim, r1							\n" /* PSPLIM = securecontextNO_STACK. */
-	"	msr psp, r1								\n" /* PSP = securecontextNO_STACK i.e. No stack for thread mode until next task's context is loaded. */
-	"											\n"
-	" save_ctx_therad_mode:						\n"
-	"	nop										\n"
-	"											\n"
-	:: "i" ( securecontextNO_STACK ) : "r1", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.c b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.c
deleted file mode 100644
index 098f24e..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.c
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure context heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Total heap size.
- */
-#define secureconfigTOTAL_HEAP_SIZE		( ( ( size_t ) ( 10 * 1024 ) ) )
-
-/* No test marker by default. */
-#ifndef mtCOVERAGE_TEST_MARKER
-	#define mtCOVERAGE_TEST_MARKER()
-#endif
-
-/* No tracing by default. */
-#ifndef traceMALLOC
-	#define traceMALLOC( pvReturn, xWantedSize )
-#endif
-
-/* No tracing by default. */
-#ifndef traceFREE
-	#define traceFREE( pv, xBlockSize )
-#endif
-
-/* Block sizes must not get too small. */
-#define secureheapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
-
-/* Assumes 8bit bytes! */
-#define secureheapBITS_PER_BYTE			( ( size_t ) 8 )
-/*-----------------------------------------------------------*/
-
-/* Allocate the memory for the heap. */
-#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
-	/* The application writer has already defined the array used for the RTOS
-	 * heap - probably so it can be placed in a special segment or address. */
-	extern uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#else /* configAPPLICATION_ALLOCATED_HEAP */
-	static uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#endif /* configAPPLICATION_ALLOCATED_HEAP */
-
-/**
- * @brief The linked list structure.
- *
- * This is used to link free blocks in order of their memory address.
- */
-typedef struct A_BLOCK_LINK
-{
-	struct A_BLOCK_LINK *pxNextFreeBlock;	/**< The next free block in the list. */
-	size_t xBlockSize;						/**< The size of the free block. */
-} BlockLink_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Called automatically to setup the required heap structures the first
- * time pvPortMalloc() is called.
- */
-static void prvHeapInit( void );
-
-/**
- * @brief Inserts a block of memory that is being freed into the correct
- * position in the list of free memory blocks.
- *
- * The block being freed will be merged with the block in front it and/or the
- * block behind it if the memory blocks are adjacent to each other.
- *
- * @param[in] pxBlockToInsert The block being freed.
- */
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The size of the structure placed at the beginning of each allocated
- * memory block must by correctly byte aligned.
- */
-static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( secureportBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-
-/**
- * @brief Create a couple of list links to mark the start and end of the list.
- */
-static BlockLink_t xStart, *pxEnd = NULL;
-
-/**
- * @brief Keeps track of the number of free bytes remaining, but says nothing
- * about fragmentation.
- */
-static size_t xFreeBytesRemaining = 0U;
-static size_t xMinimumEverFreeBytesRemaining = 0U;
-
-/**
- * @brief Gets set to the top bit of an size_t type.
- *
- * When this bit in the xBlockSize member of an BlockLink_t structure is set
- * then the block belongs to the application. When the bit is free the block is
- * still part of the free heap space.
- */
-static size_t xBlockAllocatedBit = 0;
-/*-----------------------------------------------------------*/
-
-static void prvHeapInit( void )
-{
-BlockLink_t *pxFirstFreeBlock;
-uint8_t *pucAlignedHeap;
-size_t uxAddress;
-size_t xTotalHeapSize = secureconfigTOTAL_HEAP_SIZE;
-
-	/* Ensure the heap starts on a correctly aligned boundary. */
-	uxAddress = ( size_t ) ucHeap;
-
-	if( ( uxAddress & secureportBYTE_ALIGNMENT_MASK ) != 0 )
-	{
-		uxAddress += ( secureportBYTE_ALIGNMENT - 1 );
-		uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
-	}
-
-	pucAlignedHeap = ( uint8_t * ) uxAddress;
-
-	/* xStart is used to hold a pointer to the first item in the list of free
-	 * blocks.  The void cast is used to prevent compiler warnings. */
-	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
-	xStart.xBlockSize = ( size_t ) 0;
-
-	/* pxEnd is used to mark the end of the list of free blocks and is inserted
-	 * at the end of the heap space. */
-	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
-	uxAddress -= xHeapStructSize;
-	uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-	pxEnd = ( void * ) uxAddress;
-	pxEnd->xBlockSize = 0;
-	pxEnd->pxNextFreeBlock = NULL;
-
-	/* To start with there is a single free block that is sized to take up the
-	 * entire heap space, minus the space taken by pxEnd. */
-	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
-	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
-	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
-
-	/* Only one block exists - and it covers the entire usable heap space. */
-	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-
-	/* Work out the position of the top bit in a size_t variable. */
-	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * secureheapBITS_PER_BYTE ) - 1 );
-}
-/*-----------------------------------------------------------*/
-
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
-{
-BlockLink_t *pxIterator;
-uint8_t *puc;
-
-	/* Iterate through the list until a block is found that has a higher address
-	 * than the block being inserted. */
-	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
-	{
-		/* Nothing to do here, just iterate to the right position. */
-	}
-
-	/* Do the block being inserted, and the block it is being inserted after
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxIterator;
-	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
-	{
-		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
-		pxBlockToInsert = pxIterator;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Do the block being inserted, and the block it is being inserted before
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxBlockToInsert;
-	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
-	{
-		if( pxIterator->pxNextFreeBlock != pxEnd )
-		{
-			/* Form one big block from the two blocks. */
-			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
-			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
-		}
-		else
-		{
-			pxBlockToInsert->pxNextFreeBlock = pxEnd;
-		}
-	}
-	else
-	{
-		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
-	}
-
-	/* If the block being inserted plugged a gab, so was merged with the block
-	 * before and the block after, then it's pxNextFreeBlock pointer will have
-	 * already been set, and should not be set here as that would make it point
-	 * to itself. */
-	if( pxIterator != pxBlockToInsert )
-	{
-		pxIterator->pxNextFreeBlock = pxBlockToInsert;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
-void *pvReturn = NULL;
-
-	/* If this is the first call to malloc then the heap will require
-	 * initialisation to setup the list of free blocks. */
-	if( pxEnd == NULL )
-	{
-		prvHeapInit();
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Check the requested block size is not so large that the top bit is set.
-	 * The top bit of the block size member of the BlockLink_t structure is used
-	 * to determine who owns the block - the application or the kernel, so it
-	 * must be free. */
-	if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
-	{
-		/* The wanted size is increased so it can contain a BlockLink_t
-		 * structure in addition to the requested amount of bytes. */
-		if( xWantedSize > 0 )
-		{
-			xWantedSize += xHeapStructSize;
-
-			/* Ensure that blocks are always aligned to the required number of
-			 * bytes. */
-			if( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) != 0x00 )
-			{
-				/* Byte alignment required. */
-				xWantedSize += ( secureportBYTE_ALIGNMENT - ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) );
-				secureportASSERT( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
-		{
-			/* Traverse the list from the start (lowest address) block until
-			 * one of adequate size is found. */
-			pxPreviousBlock = &xStart;
-			pxBlock = xStart.pxNextFreeBlock;
-			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
-			{
-				pxPreviousBlock = pxBlock;
-				pxBlock = pxBlock->pxNextFreeBlock;
-			}
-
-			/* If the end marker was reached then a block of adequate size was
-			 * not found. */
-			if( pxBlock != pxEnd )
-			{
-				/* Return the memory space pointed to - jumping over the
-				 * BlockLink_t structure at its start. */
-				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
-
-				/* This block is being returned for use so must be taken out
-				 * of the list of free blocks. */
-				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
-
-				/* If the block is larger than required it can be split into
-				 * two. */
-				if( ( pxBlock->xBlockSize - xWantedSize ) > secureheapMINIMUM_BLOCK_SIZE )
-				{
-					/* This block is to be split into two.  Create a new
-					 * block following the number of bytes requested. The void
-					 * cast is used to prevent byte alignment warnings from the
-					 * compiler. */
-					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
-					secureportASSERT( ( ( ( size_t ) pxNewBlockLink ) & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-
-					/* Calculate the sizes of two blocks split from the single
-					 * block. */
-					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
-					pxBlock->xBlockSize = xWantedSize;
-
-					/* Insert the new block into the list of free blocks. */
-					prvInsertBlockIntoFreeList( pxNewBlockLink );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				xFreeBytesRemaining -= pxBlock->xBlockSize;
-
-				if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
-				{
-					xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* The block is being returned - it is allocated and owned by
-				 * the application and has no "next" block. */
-				pxBlock->xBlockSize |= xBlockAllocatedBit;
-				pxBlock->pxNextFreeBlock = NULL;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	traceMALLOC( pvReturn, xWantedSize );
-
-	#if( secureconfigUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#endif
-
-	secureportASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) secureportBYTE_ALIGNMENT_MASK ) == 0 );
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-uint8_t *puc = ( uint8_t * ) pv;
-BlockLink_t *pxLink;
-
-	if( pv != NULL )
-	{
-		/* The memory being freed will have an BlockLink_t structure immediately
-		 * before it. */
-		puc -= xHeapStructSize;
-
-		/* This casting is to keep the compiler from issuing warnings. */
-		pxLink = ( void * ) puc;
-
-		/* Check the block is actually allocated. */
-		secureportASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
-		secureportASSERT( pxLink->pxNextFreeBlock == NULL );
-
-		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
-		{
-			if( pxLink->pxNextFreeBlock == NULL )
-			{
-				/* The block is being returned to the heap - it is no longer
-				 * allocated. */
-				pxLink->xBlockSize &= ~xBlockAllocatedBit;
-
-				secureportDISABLE_NON_SECURE_INTERRUPTS();
-				{
-					/* Add this block to the list of free blocks. */
-					xFreeBytesRemaining += pxLink->xBlockSize;
-					traceFREE( pv, pxLink->xBlockSize );
-					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
-				}
-				secureportENABLE_NON_SECURE_INTERRUPTS();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return xFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetMinimumEverFreeHeapSize( void )
-{
-	return xMinimumEverFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-void vPortInitialiseBlocks( void )
-{
-	/* This just exists to keep the linker quiet. */
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.h b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.h
deleted file mode 100644
index b7e071a..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_heap.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_HEAP_H__
-#define __SECURE_HEAP_H__
-
-/* Standard includes. */
-#include <stdlib.h>
-
-/**
- * @brief Allocates memory from heap.
- *
- * @param[in] xWantedSize The size of the memory to be allocated.
- *
- * @return Pointer to the memory region if the allocation is successful, NULL
- * otherwise.
- */
-void *pvPortMalloc( size_t xWantedSize );
-
-/**
- * @brief Frees the previously allocated memory.
- *
- * @param[in] pv Pointer to the memory to be freed.
- */
-void vPortFree( void *pv );
-
-#endif /* __SECURE_HEAP_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.c b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.c
deleted file mode 100644
index fdabd11..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure init includes. */
-#include "secure_init.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define secureinitSCB_AIRCR					( ( volatile uint32_t * ) 0xe000ed0c )  /* Application Interrupt and Reset Control Register. */
-#define secureinitSCB_AIRCR_VECTKEY_POS		( 16UL )
-#define secureinitSCB_AIRCR_VECTKEY_MASK	( 0xFFFFUL << secureinitSCB_AIRCR_VECTKEY_POS )
-#define secureinitSCB_AIRCR_PRIS_POS		( 14UL )
-#define secureinitSCB_AIRCR_PRIS_MASK		( 1UL << secureinitSCB_AIRCR_PRIS_POS )
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define secureinitFPCCR						( ( volatile uint32_t * ) 0xe000ef34 )  /* Floating Point Context Control Register. */
-#define secureinitFPCCR_LSPENS_POS			( 29UL )
-#define secureinitFPCCR_LSPENS_MASK			( 1UL << secureinitFPCCR_LSPENS_POS )
-#define secureinitFPCCR_TS_POS				( 26UL )
-#define secureinitFPCCR_TS_MASK				( 1UL << secureinitFPCCR_TS_POS )
-
-#define secureinitNSACR						( ( volatile uint32_t * ) 0xe000ed8c )  /* Non-secure Access Control Register. */
-#define secureinitNSACR_CP10_POS			( 10UL )
-#define secureinitNSACR_CP10_MASK			( 1UL << secureinitNSACR_CP10_POS )
-#define secureinitNSACR_CP11_POS			( 11UL )
-#define secureinitNSACR_CP11_MASK			( 1UL << secureinitNSACR_CP11_POS )
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_DePrioritizeNSExceptions( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
-									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
-									( ( 0x1UL	<< secureinitSCB_AIRCR_PRIS_POS )	& secureinitSCB_AIRCR_PRIS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_EnableNSFPUAccess( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* CP10 = 1 ==> Non-secure access to the Floating Point Unit is
-		 * permitted. CP11 should be programmed to the same value as CP10. */
-		*( secureinitNSACR ) |= ( secureinitNSACR_CP10_MASK | secureinitNSACR_CP11_MASK );
-
-		/* LSPENS = 0 ==> LSPEN is writable fron non-secure state. This ensures
-		 * that we can enable/disable lazy stacking in port.c file. */
-		*( secureinitFPCCR ) &= ~ ( secureinitFPCCR_LSPENS_MASK );
-
-		/* TS = 1 ==> Treat FP registers as secure i.e. callee saved FP
-		 * registers (S16-S31) are also pushed to stack on exception entry and
-		 * restored on exception return. */
-		*( secureinitFPCCR ) |= ( secureinitFPCCR_TS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.h b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.h
deleted file mode 100644
index 34e4b48..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_init.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_INIT_H__
-#define __SECURE_INIT_H__
-
-/**
- * @brief De-prioritizes the non-secure exceptions.
- *
- * This is needed to ensure that the non-secure PendSV runs at the lowest
- * priority. Context switch is done in the non-secure PendSV handler.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_DePrioritizeNSExceptions( void );
-
-/**
- * @brief Sets up the Floating Point Unit (FPU) for Non-Secure access.
- *
- * Also sets FPCCR.TS=1 to ensure that the content of the Floating Point
- * Registers are not leaked to the non-secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_EnableNSFPUAccess( void );
-
-#endif /* __SECURE_INIT_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_port_macros.h b/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_port_macros.h
deleted file mode 100644
index e59c06b..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33/secure/secure_port_macros.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_PORT_MACROS_H__
-#define __SECURE_PORT_MACROS_H__
-
-/**
- * @brief Byte alignment requirements.
- */
-#define secureportBYTE_ALIGNMENT					8
-#define secureportBYTE_ALIGNMENT_MASK				( 0x0007 )
-
-/**
- * @brief Macro to declare a function as non-secure callable.
- */
-#if defined( __IAR_SYSTEMS_ICC__ )
-	#define secureportNON_SECURE_CALLABLE			__cmse_nonsecure_entry __root
-#else
-	#define secureportNON_SECURE_CALLABLE			__attribute__((cmse_nonsecure_entry)) __attribute__((used))
-#endif
-
-/**
- * @brief Set the secure PRIMASK value.
- */
-#define secureportSET_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Set the non-secure PRIMASK value.
- */
-#define secureportSET_NON_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask_ns, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Read the PSP value in the given variable.
- */
-#define secureportREAD_PSP( pucOutCurrentStackPointer ) \
-	__asm volatile ( "mrs %0, psp"  : "=r" ( pucOutCurrentStackPointer ) )
-
-/**
- * @brief Set the PSP to the given value.
- */
-#define secureportSET_PSP( pucCurrentStackPointer ) \
-	__asm volatile ( "msr psp, %0" : : "r" ( pucCurrentStackPointer ) )
-
-/**
- * @brief Set the PSPLIM to the given value.
- */
-#define secureportSET_PSPLIM( pucStackLimit ) \
-	__asm volatile ( "msr psplim, %0" : : "r" ( pucStackLimit ) )
-
-/**
- * @brief Set the NonSecure MSP to the given value.
- */
-#define secureportSET_MSP_NS( pucMainStackPointer ) \
-	__asm volatile ( "msr msp_ns, %0" : : "r" ( pucMainStackPointer ) )
-
-/**
- * @brief Set the CONTROL register to the given value.
- */
-#define secureportSET_CONTROL( ulControl ) \
-	__asm volatile ( "msr control, %0" : : "r" ( ulControl ) : "memory" )
-
-/**
- * @brief Read the Interrupt Program Status Register (IPSR) value in the given
- * variable.
- */
-#define secureportREAD_IPSR( ulIPSR ) \
-	__asm volatile ( "mrs %0, ipsr"  : "=r" ( ulIPSR ) )
-
-/**
- * @brief PRIMASK value to enable interrupts.
- */
-#define secureportPRIMASK_ENABLE_INTERRUPTS_VAL		0
-
-/**
- * @brief PRIMASK value to disable interrupts.
- */
-#define secureportPRIMASK_DISABLE_INTERRUPTS_VAL	1
-
-/**
- * @brief Disable secure interrupts.
- */
-#define secureportDISABLE_SECURE_INTERRUPTS()		secureportSET_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Disable non-secure interrupts.
- *
- * This effectively disables context switches.
- */
-#define secureportDISABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Enable non-secure interrupts.
- */
-#define secureportENABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_ENABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Assert definition.
- */
-#define secureportASSERT( x )						\
-	if( ( x ) == 0 )								\
-	{												\
-		secureportDISABLE_SECURE_INTERRUPTS();		\
-		secureportDISABLE_NON_SECURE_INTERRUPTS();	\
-		for( ;; );									\
-	}
-
-#endif /* __SECURE_PORT_MACROS_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/port.c b/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.c b/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.c
deleted file mode 100644
index bea63d0..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.c
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE ensures that PRIVILEGED_FUNCTION
- * is defined correctly and privileged functions are placed in correct sections. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Portasm includes. */
-#include "portasm.h"
-
-/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE is needed to be defined only for the
- * header files. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-void vRestoreContextOfFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"													\n"
-	"	ldr  r2, pxCurrentTCBConst2						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr  r1, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr  r0, [r1]									\n" /* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	bic r4, #1										\n" /* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	"	ldr  r3, [r1]									\n" /* r3 = *r1 i.e. r3 = MAIR0. */
-	"	ldr  r2, xMAIR0Const2							\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str  r3, [r2]									\n" /* Program MAIR0. */
-	"	ldr  r2, xRNRConst2								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	movs r3, #4										\n" /* r3 = 4. */
-	"	str  r3, [r2]									\n" /* Program RNR = 4. */
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	"	ldr  r2, xRBARConst2							\n" /* r2 = 0xe000ed9c [Location of RBAR]. */
-	"	ldmia r1!, {r4-r11}								\n" /* Read 4 set of RBAR/RLAR registers from TCB. */
-	"	stmia r2!, {r4-r11}								\n" /* Write 4 set of RBAR/RLAR registers using alias registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst2							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	orr r4, #1										\n" /* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	ldm  r0!, {r1-r3}								\n" /* Read from stack - r1 = PSPLIM, r2 = CONTROL and r3 = EXC_RETURN. */
-	"	msr  psplim, r1									\n" /* Set this task's PSPLIM value. */
-	"	msr  control, r2								\n" /* Set this task's CONTROL value. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r3											\n" /* Finally, branch to EXC_RETURN. */
-	#else /* configENABLE_MPU */
-	"	ldm  r0!, {r1-r2}								\n" /* Read from stack - r1 = PSPLIM and r2 = EXC_RETURN. */
-	"	msr  psplim, r1									\n" /* Set this task's PSPLIM value. */
-	"	movs r1, #2										\n" /* r1 = 2. */
-	"	msr  CONTROL, r1								\n" /* Switch to use PSP in the thread mode. */
-	"	adds r0, #32									\n" /* Discard everything up to r0. */
-	"	msr  psp, r0									\n" /* This is now the new top of stack to use in the task. */
-	"	isb												\n"
-	"	bx   r2											\n" /* Finally, branch to EXC_RETURN. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst2: .word 0xe000ed94					\n"
-	"xMAIR0Const2: .word 0xe000edc0						\n"
-	"xRNRConst2: .word 0xe000ed98						\n"
-	"xRBARConst2: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	);
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	tst r0, #1										\n" /* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	"	ite ne											\n"
-	"	movne r0, #0									\n" /* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	"	moveq r0, #1									\n" /* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	"	bx lr											\n" /* Return. */
-	"													\n"
-	"	.align 4										\n"
-	::: "r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vRaisePrivilege( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	 __asm volatile
-	(
-	"	mrs  r0, control								\n" /* Read the CONTROL register. */
-	"	bic r0, #1										\n" /* Clear the bit 0. */
-	"	msr  control, r0								\n" /* Write back the new CONTROL value. */
-	"	bx lr											\n" /* Return to the caller. */
-	::: "r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vResetPrivilege( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control									\n" /* r0 = CONTROL. */
-	"	orr r0, #1										\n" /* r0 = r0 | 1. */
-	"	msr control, r0									\n" /* CONTROL = r0. */
-	"	bx lr											\n" /* Return to the caller. */
-	:::"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vStartFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	ldr r0, xVTORConst								\n" /* Use the NVIC offset register to locate the stack. */
-	"	ldr r0, [r0]									\n" /* Read the VTOR register which gives the address of vector table. */
-	"	ldr r0, [r0]									\n" /* The first entry in vector table is stack pointer. */
-	"	msr msp, r0										\n" /* Set the MSP back to the start of the stack. */
-	"	cpsie i											\n" /* Globally enable interrupts. */
-	"	cpsie f											\n"
-	"	dsb												\n"
-	"	isb												\n"
-	"	svc %0											\n" /* System call to start the first task. */
-	"	nop												\n"
-	"													\n"
-	"   .align 4										\n"
-	"xVTORConst: .word 0xe000ed08						\n"
-	:: "i" ( portSVC_START_SCHEDULER ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	mrs r0, basepri									\n" /* r0 = basepri. Return original basepri value. */
-	"	mov r1, %0										\n" /* r1 = configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	"	msr basepri, r1									\n" /* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	bx lr											\n" /* Return. */
-	:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vClearInterruptMask( __attribute__( ( unused ) ) uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	msr basepri, r0									\n" /* basepri = ulMask. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	bx lr											\n" /* Return. */
-	::: "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void PendSV_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	.syntax unified									\n"
-	"													\n"
-	"	mrs r0, psp										\n" /* Read PSP in r0. */
-	#if( configENABLE_FPU == 1 )
-	"	tst lr, #0x10									\n" /* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-	"	it eq											\n"
-	"	vstmdbeq r0!, {s16-s31}							\n" /* Store the FPU registers which are not saved automatically. */
-	#endif /* configENABLE_FPU */
-	#if( configENABLE_MPU == 1 )
-	"	mrs r1, psplim									\n" /* r1 = PSPLIM. */
-	"	mrs r2, control									\n" /* r2 = CONTROL. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	stmdb r0!, {r1-r11}								\n" /* Store on the stack - PSPLIM, CONTROL, LR and registers that are not automatically saved. */
-	#else /* configENABLE_MPU */
-	"	mrs r2, psplim									\n" /* r2 = PSPLIM. */
-	"	mov r3, lr										\n" /* r3 = LR/EXC_RETURN. */
-	"	stmdb r0!, {r2-r11}								\n" /* Store on the stack - PSPLIM, LR and registers that are not automatically saved. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	"	ldr r2, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r1, [r2]									\n" /* Read pxCurrentTCB. */
-	"	str r0, [r1]									\n" /* Save the new top of stack in TCB. */
-	"													\n"
-	"	mov r0, %0										\n" /* r0 = configMAX_SYSCALL_INTERRUPT_PRIORITY */
-	"	msr basepri, r0									\n" /* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	"	dsb												\n"
-	"	isb												\n"
-	"	bl vTaskSwitchContext							\n"
-	"	mov r0, #0										\n" /* r0 = 0. */
-	"	msr basepri, r0									\n" /* Enable interrupts. */
-	"													\n"
-	"	ldr r2, pxCurrentTCBConst						\n" /* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	"	ldr r1, [r2]									\n" /* Read pxCurrentTCB. */
-	"	ldr r0, [r1]									\n" /* The first item in pxCurrentTCB is the task top of stack. r0 now points to the top of stack. */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	dmb												\n" /* Complete outstanding transfers before disabling MPU. */
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	bic r4, #1										\n" /* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Disable MPU. */
-	"													\n"
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	"	ldr r3, [r1]									\n" /* r3 = *r1 i.e. r3 = MAIR0. */
-	"	ldr r2, xMAIR0Const								\n" /* r2 = 0xe000edc0 [Location of MAIR0]. */
-	"	str r3, [r2]									\n" /* Program MAIR0. */
-	"	ldr r2, xRNRConst								\n" /* r2 = 0xe000ed98 [Location of RNR]. */
-	"	movs r3, #4										\n" /* r3 = 4. */
-	"	str r3, [r2]									\n" /* Program RNR = 4. */
-	"	adds r1, #4										\n" /* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	"	ldr r2, xRBARConst								\n" /* r2 = 0xe000ed9c [Location of RBAR]. */
-	"	ldmia r1!, {r4-r11}								\n" /* Read 4 sets of RBAR/RLAR registers from TCB. */
-	"	stmia r2!, {r4-r11}								\n" /* Write 4 set of RBAR/RLAR registers using alias registers. */
-	"													\n"
-	"	ldr r2, xMPUCTRLConst							\n" /* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	"	ldr r4, [r2]									\n" /* Read the value of MPU_CTRL. */
-	"	orr r4, #1										\n" /* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-	"	str r4, [r2]									\n" /* Enable MPU. */
-	"	dsb												\n" /* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	ldmia r0!, {r1-r11}								\n" /* Read from stack - r1 = PSPLIM, r2 = CONTROL, r3 = LR and r4-r11 restored. */
-	#else /* configENABLE_MPU */
-	"	ldmia r0!, {r2-r11}								\n" /* Read from stack - r2 = PSPLIM, r3 = LR and r4-r11 restored. */
-	#endif /* configENABLE_MPU */
-	"													\n"
-	#if( configENABLE_FPU == 1 )
-	"	tst r3, #0x10									\n" /* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-	"	it eq											\n"
-	"	vldmiaeq r0!, {s16-s31}							\n" /* Restore the FPU registers which are not restored automatically. */
-	#endif /* configENABLE_FPU */
-	"													\n"
-	#if( configENABLE_MPU == 1 )
-	"	msr psplim, r1									\n" /* Restore the PSPLIM register value for the task. */
-	"	msr control, r2									\n" /* Restore the CONTROL register value for the task. */
-	#else /* configENABLE_MPU */
-	"	msr psplim, r2									\n" /* Restore the PSPLIM register value for the task. */
-	#endif /* configENABLE_MPU */
-	"	msr psp, r0										\n" /* Remember the new top of stack for the task. */
-	"	bx r3											\n"
-	"													\n"
-	"	.align 4										\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB				\n"
-	#if( configENABLE_MPU == 1 )
-	"xMPUCTRLConst: .word 0xe000ed94					\n"
-	"xMAIR0Const: .word 0xe000edc0						\n"
-	"xRNRConst: .word 0xe000ed98						\n"
-	"xRBARConst: .word 0xe000ed9c						\n"
-	#endif /* configENABLE_MPU */
-	:: "i"( configMAX_SYSCALL_INTERRUPT_PRIORITY )
-	);
-}
-/*-----------------------------------------------------------*/
-
-void SVC_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
-{
-	__asm volatile
-	(
-	"	tst lr, #4										\n"
-	"	ite eq											\n"
-	"	mrseq r0, msp									\n"
-	"	mrsne r0, psp									\n"
-	"	ldr r1, svchandler_address_const				\n"
-	"	bx r1											\n"
-	"													\n"
-	"	.align 4										\n"
-	"svchandler_address_const: .word vPortSVCHandler_C	\n"
-	);
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.h b/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portmacro.h
deleted file mode 100644
index 1d8fa3e..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM33_NTZ/non_secure/portmacro.h
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M33"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__attribute__(( used ))
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							ulSetInterruptMask()
-#define portENABLE_INTERRUPTS()								vClearInterruptMask( 0 )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/GCC/ARM_CM3_MPU/port.c b/osal/src/freertos/portable/GCC/ARM_CM3_MPU/port.c
deleted file mode 100644
index 1fbfc78..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM3_MPU/port.c
+++ /dev/null
@@ -1,857 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM3 port.
- *----------------------------------------------------------*/
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers.  That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	 * as the core. */
-	#define portNVIC_SYSTICK_CLK	( 0 )
-#endif
-
-/* Constants required to access and manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG				( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG		( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG					( *	( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSPRI1_REG					( * ( ( volatile uint32_t * ) 0xe000ed1c ) )
-#define portNVIC_SYS_CTRL_STATE_REG				( * ( ( volatile uint32_t * ) 0xe000ed24 ) )
-#define portNVIC_MEM_FAULT_ENABLE				( 1UL << 16UL )
-
-/* Constants required to access and manipulate the MPU. */
-#define portMPU_TYPE_REG						( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_REGION_BASE_ADDRESS_REG			( * ( ( volatile uint32_t * ) 0xe000ed9C ) )
-#define portMPU_REGION_ATTRIBUTE_REG			( * ( ( volatile uint32_t * ) 0xe000edA0 ) )
-#define portMPU_CTRL_REG						( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portEXPECTED_MPU_TYPE_VALUE				( 8UL << 8UL ) /* 8 regions, unified. */
-#define portMPU_ENABLE							( 0x01UL )
-#define portMPU_BACKGROUND_ENABLE				( 1UL << 2UL )
-#define portPRIVILEGED_EXECUTION_START_ADDRESS	( 0UL )
-#define portMPU_REGION_VALID					( 0x10UL )
-#define portMPU_REGION_ENABLE					( 0x01UL )
-#define portPERIPHERALS_START_ADDRESS			0x40000000UL
-#define portPERIPHERALS_END_ADDRESS				0x5FFFFFFFUL
-
-/* Constants required to access and manipulate the SysTick. */
-#define portNVIC_SYSTICK_INT					( 0x00000002UL )
-#define portNVIC_SYSTICK_ENABLE					( 0x00000001UL )
-#define portNVIC_PENDSV_PRI						( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-#define portNVIC_SVC_PRI						( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR						( 0x01000000 )
-#define portINITIAL_CONTROL_IF_UNPRIVILEGED		( 0x03 )
-#define portINITIAL_CONTROL_IF_PRIVILEGED		( 0x02 )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER			( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 		( 0xE000E3F0 )
-#define portAIRCR_REG							( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE						( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE						( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS					( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK					( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT						( 8UL )
-
-/* Offsets in the stack to the parameters when inside the SVC handler. */
-#define portOFFSET_TO_PC						( 6 )
-
-/* For strict compliance with the Cortex-M spec the task start address should
- * have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK					( ( StackType_t ) 0xfffffffeUL )
-/*-----------------------------------------------------------*/
-
-/*
- * Configure a number of standard MPU regions that are used by all tasks.
- */
-static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the smallest MPU region size that a given number of bytes will fit
- * into.  The region size is returned as the value that should be programmed
- * into the region attribute register for that region.
- */
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes ) PRIVILEGED_FUNCTION;
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Standard FreeRTOS exception handlers.
- */
-void xPortPendSVHandler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-void xPortSysTickHandler( void )  __attribute__ ((optimize("3"))) PRIVILEGED_FUNCTION;
-void vPortSVCHandler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/*
- * Starts the scheduler by restoring the context of the first task to run.
- */
-static void prvRestoreContextOfFirstTask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/*
- * C portion of the SVC handler.  The SVC handler is split between an asm entry
- * and a C wrapper for simplicity of coding and maintenance.
- */
-static void prvSVCHandler( uint32_t *pulRegisters ) __attribute__(( noinline )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-extern BaseType_t xPortRaisePrivilege( void );
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-extern void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
- * variable.  Note this is not saved as part of the task context as context
- * switches can only occur when uxCriticalNesting is zero. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = 0;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	if( xRunPrivileged == pdTRUE )
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_PRIVILEGED;
-	}
-	else
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
-	}
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	/* Assumes psp was in use. */
-	__asm volatile
-	(
-		#ifndef USE_PROCESS_STACK	/* Code should not be required if a main() is using the process stack. */
-			"	tst lr, #4						\n"
-			"	ite eq							\n"
-			"	mrseq r0, msp					\n"
-			"	mrsne r0, psp					\n"
-		#else
-			"	mrs r0, psp						\n"
-		#endif
-			"	b %0							\n"
-			::"i"(prvSVCHandler):"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-static void prvSVCHandler(	uint32_t *pulParam )
-{
-uint8_t ucSVCNumber;
-uint32_t ulPC;
-#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* #if defined( __ARMCC_VERSION ) */
-#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-	/* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR.  The first
-	 * argument (r0) is pulParam[ 0 ]. */
-	ulPC = pulParam[ portOFFSET_TO_PC ];
-	ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		case portSVC_START_SCHEDULER	:	portNVIC_SYSPRI1_REG |= portNVIC_SVC_PRI;
-											prvRestoreContextOfFirstTask();
-											break;
-
-		case portSVC_YIELD				:	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-											/* Barriers are normally not required
-											 * but do ensure the code is completely
-											 * within the specified behaviour for the
-											 * architecture. */
-											__asm volatile( "dsb" ::: "memory" );
-											__asm volatile( "isb" );
-
-											break;
-
-
-	#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-		case portSVC_RAISE_PRIVILEGE	:	/* Only raise the privilege, if the
-											 * svc was raised from any of the
-											 * system calls. */
-											if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-												ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-											{
-												__asm volatile
-												(
-													"	mrs r1, control		\n" /* Obtain current control value. */
-													"	bic r1, #1			\n" /* Set privilege bit. */
-													"	msr control, r1		\n" /* Write back new control value. */
-													::: "r1", "memory"
-												);
-											}
-											break;
-	#else
-		case portSVC_RAISE_PRIVILEGE	:	__asm volatile
-											(
-												"	mrs r1, control		\n" /* Obtain current control value. */
-												"	bic r1, #1			\n" /* Set privilege bit. */
-												"	msr control, r1		\n" /* Write back new control value. */
-												::: "r1", "memory"
-											);
-											break;
-	#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-		default							:	/* Unknown SVC call. */
-											break;
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvRestoreContextOfFirstTask( void )
-{
-	__asm volatile
-	(
-		"	ldr r0, =0xE000ED08				\n" /* Use the NVIC offset register to locate the stack. */
-		"	ldr r0, [r0]					\n"
-		"	ldr r0, [r0]					\n"
-		"	msr msp, r0						\n" /* Set the msp back to the start of the stack. */
-		"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
-		"	ldr r1, [r3]					\n"
-		"	ldr r0, [r1]					\n" /* The first item in the TCB is the task top of stack. */
-		"	add r1, r1, #4					\n" /* Move onto the second item in the TCB... */
-		"									\n"
-		"	dmb								\n" /* Complete outstanding transfers before disabling MPU. */
-		"	ldr r2, =0xe000ed94				\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]					\n" /* Read the value of MPU_CTRL. */
-		"	bic r3, #1						\n" /* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-		"	str r3, [r2]					\n" /* Disable MPU. */
-		"									\n"
-		"	ldr r2, =0xe000ed9c				\n" /* Region Base Address register. */
-		"	ldmia r1!, {r4-r11}				\n" /* Read 4 sets of MPU registers. */
-		"	stmia r2!, {r4-r11}				\n" /* Write 4 sets of MPU registers. */
-		"									\n"
-		"	ldr r2, =0xe000ed94				\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]					\n" /* Read the value of MPU_CTRL. */
-		"	orr r3, #1						\n" /* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-		"	str r3, [r2]					\n" /* Enable MPU. */
-		"	dsb								\n" /* Force memory writes before continuing. */
-		"									\n"
-		"	ldmia r0!, {r3, r4-r11}			\n" /* Pop the registers that are not automatically saved on exception entry. */
-		"	msr control, r3					\n"
-		"	msr psp, r0						\n" /* Restore the task stack pointer. */
-		"	mov r0, #0						\n"
-		"	msr	basepri, r0					\n"
-		"	ldr r14, =0xfffffffd			\n" /* Load exec return code. */
-		"	bx r14							\n"
-		"									\n"
-		"	.align 4						\n"
-		"pxCurrentTCBConst2: .word pxCurrentTCB	\n"
-	);
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See
-	 * http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		 * functions can be called.  ISR safe functions are those that end in
-		 * "FromISR".  FreeRTOS maintains separate thread and ISR API functions
-		 * to ensure interrupt entry is as fast and simple as possible.
-
-		 * Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		 * possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		 * of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		 * register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		 * value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the same priority as the kernel, and the SVC
-	 * handler higher priority so it can be used to exit a critical section (where
-	 * lower priorities are masked). */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Configure the regions in the MPU that are common to all tasks. */
-	prvSetupMPU();
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Start the first task. */
-	__asm volatile(
-					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
-					" ldr r0, [r0] 			\n"
-					" ldr r0, [r0] 			\n"
-					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
-					" cpsie i				\n" /* Globally enable interrupts. */
-					" cpsie f				\n"
-					" dsb					\n"
-					" isb					\n"
-					" svc %0				\n" /* System call to start first task. */
-					" nop					\n"
-					:: "i" (portSVC_START_SCHEDULER) : "memory" );
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void xPortPendSVHandler( void )
-{
-	/* This is a naked function. */
-
-	__asm volatile
-	(
-		"	mrs r0, psp							\n"
-		"										\n"
-		"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
-		"	ldr	r2, [r3]						\n"
-		"										\n"
-		"	mrs r1, control						\n"
-		"	stmdb r0!, {r1, r4-r11}				\n" /* Save the remaining registers. */
-		"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
-		"										\n"
-		"	stmdb sp!, {r3, r14}				\n"
-		"	mov r0, %0							\n"
-		"	msr basepri, r0						\n"
-		"	dsb									\n"
-		"	isb									\n"
-		"	bl vTaskSwitchContext				\n"
-		"	mov r0, #0							\n"
-		"	msr basepri, r0						\n"
-		"	ldmia sp!, {r3, r14}				\n"
-		"										\n"	/* Restore the context. */
-		"	ldr r1, [r3]						\n"
-		"	ldr r0, [r1]						\n" /* The first item in the TCB is the task top of stack. */
-		"	add r1, r1, #4						\n" /* Move onto the second item in the TCB... */
-		"										\n"
-		"	dmb									\n" /* Complete outstanding transfers before disabling MPU. */
-		"	ldr r2, =0xe000ed94					\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]						\n" /* Read the value of MPU_CTRL. */
-		"	bic r3, #1							\n" /* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-		"	str r3, [r2]						\n" /* Disable MPU. */
-		"										\n"
-		"	ldr r2, =0xe000ed9c					\n" /* Region Base Address register. */
-		"	ldmia r1!, {r4-r11}					\n" /* Read 4 sets of MPU registers. */
-		"	stmia r2!, {r4-r11}					\n" /* Write 4 sets of MPU registers. */
-		"										\n"
-		"	ldr r2, =0xe000ed94					\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]						\n" /* Read the value of MPU_CTRL. */
-		"	orr r3, #1							\n" /* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-		"	str r3, [r2]						\n" /* Enable MPU. */
-		"	dsb									\n" /* Force memory writes before continuing. */
-		"										\n"
-		"	ldmia r0!, {r3, r4-r11}				\n" /* Pop the registers that are not automatically saved on exception entry. */
-		"	msr control, r3						\n"
-		"										\n"
-		"	msr psp, r0							\n"
-		"	bx r14								\n"
-		"										\n"
-		"	.align 4							\n"
-		"pxCurrentTCBConst: .word pxCurrentTCB	\n"
-		::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
-	);
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulDummy;
-
-	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
-{
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE );
-}
-/*-----------------------------------------------------------*/
-
-static void prvSetupMPU( void )
-{
-extern uint32_t __privileged_functions_end__[];
-extern uint32_t __FLASH_segment_start__[];
-extern uint32_t __FLASH_segment_end__[];
-extern uint32_t __privileged_data_start__[];
-extern uint32_t __privileged_data_end__[];
-
-	/* Check the expected MPU is present. */
-	if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-	{
-		/* First setup the entire flash for unprivileged read only access. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portUNPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the first 16K for privileged only access (even though less
-		 * than 10K is actually being used).  This is where the kernel code is
-		 * placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged data RAM region.  This is where the kernel data
-		 * is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_RAM_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-										( portMPU_REGION_ENABLE );
-
-		/* By default allow everything to access the general peripherals.  The
-		 * system peripherals and registers are protected. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( portPERIPHERALS_START_ADDRESS ) |
-											( portMPU_REGION_VALID ) |
-											( portGENERAL_PERIPHERALS_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
-										( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Enable the memory fault exception. */
-		portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
-
-		/* Enable the MPU with the background region configured. */
-		portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes )
-{
-uint32_t ulRegionSize, ulReturnValue = 4;
-
-	/* 32 is the smallest region size, 31 is the largest valid value for
-	 * ulReturnValue. */
-	for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
-	{
-		if( ulActualSizeInBytes <= ulRegionSize )
-		{
-			break;
-		}
-		else
-		{
-			ulReturnValue++;
-		}
-	}
-
-	/* Shift the code by one before returning so it can be written directly
-	 * into the the correct bit position of the attribute register. */
-	return ( ulReturnValue << 1UL );
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control							\n" /* r0 = CONTROL. */
-	"	tst r0, #1								\n" /* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	"	ite ne									\n"
-	"	movne r0, #0							\n" /* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	"	moveq r0, #1							\n" /* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	"	bx lr									\n" /* Return. */
-	"											\n"
-	"	.align 4								\n"
-	::: "r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vResetPrivilege( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control							\n" /* r0 = CONTROL. */
-	"	orr r0, #1								\n" /* r0 = r0 | 1. */
-	"	msr control, r0							\n" /* CONTROL = r0. */
-	"	bx lr									\n" /* Return to the caller. */
-	:::"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-{
-extern uint32_t __SRAM_segment_start__[];
-extern uint32_t __SRAM_segment_end__[];
-extern uint32_t __privileged_data_start__[];
-extern uint32_t __privileged_data_end__[];
-int32_t lIndex;
-uint32_t ul;
-
-	if( xRegions == NULL )
-	{
-		/* No MPU regions are specified so allow access to all RAM. */
-		xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-				( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION );
-
-		xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-				( portMPU_REGION_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Re-instate the privileged only RAM region as xRegion[ 0 ] will have
-		 * just removed the privileged only parameters. */
-		xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
-				( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION + 1 );
-
-		xMPUSettings->xRegion[ 1 ].ulRegionAttribute =
-				( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Invalidate all other regions. */
-		for( ul = 2; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-			xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-		}
-	}
-	else
-	{
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that the
-		 * stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-					( ( uint32_t ) pxBottomOfStack ) |
-					( portMPU_REGION_VALID ) |
-					( portSTACK_REGION ); /* Region number. */
-
-			xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-					( portMPU_REGION_READ_WRITE ) | /* Read and write. */
-					( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
-					( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-					( portMPU_REGION_ENABLE );
-		}
-
-		lIndex = 0;
-
-		for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
-			{
-				/* Translate the generic region definition contained in
-				 * xRegions into the CM3 specific MPU settings that are then
-				 * stored in xMPUSettings. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
-						( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) |
-						( portMPU_REGION_VALID ) |
-						( portSTACK_REGION + ul ); /* Region number. */
-
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute =
-						( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
-						( xRegions[ lIndex ].ulParameters ) |
-						( portMPU_REGION_ENABLE );
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			 * an interrupt that has been assigned a priority above
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			 * function.  ISR safe FreeRTOS API functions must *only* be called
-			 * from interrupts that have been assigned a priority at or below
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Numerically low interrupt priority numbers represent logically high
-			 * interrupt priorities, therefore the priority of the interrupt must
-			 * be set to a value equal to or numerically *higher* than
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Interrupts that	use the FreeRTOS API must not be left at their
-			 * default priority of	zero as that is the highest possible priority,
-			 * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			 * and	therefore also guaranteed to be invalid.
-
-			 * FreeRTOS maintains separate thread and ISR API functions to ensure
-			 * interrupt entry is as fast and simple as possible.
-
-			 * The following links provide detailed information:
-			 * http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			 * http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		 * that define each interrupt's priority to be split between bits that
-		 * define the interrupt's pre-emption priority bits and bits that define
-		 * the interrupt's sub-priority.  For simplicity all bits must be defined
-		 * to be pre-emption priority bits.  The following assertion will fail if
-		 * this is not the case (if some bits represent a sub-priority).
-
-		 * If the application only uses CMSIS libraries for interrupt
-		 * configuration then the correct setting can be achieved on all Cortex-M
-		 * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		 * scheduler.  Note however that some vendor specific peripheral libraries
-		 * assume a non-zero priority group setting, in which cases using a value
-		 * of zero will result in unpredicable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/GCC/ARM_CM3_MPU/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM3_MPU/portmacro.h
deleted file mode 100644
index 224d430..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM3_MPU/portmacro.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* MPU specific constants. */
-#define portUSING_MPU_WRAPPERS		1
-#define portPRIVILEGE_BIT			( 0x80000000UL )
-
-#define portMPU_REGION_READ_WRITE								( 0x03UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY						( 0x05UL << 24UL )
-#define portMPU_REGION_READ_ONLY								( 0x06UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE					( 0x01UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY	( 0x02UL << 24UL )
-#define portMPU_REGION_CACHEABLE_BUFFERABLE						( 0x07UL << 16UL )
-#define portMPU_REGION_EXECUTE_NEVER							( 0x01UL << 28UL )
-
-#define portUNPRIVILEGED_FLASH_REGION		( 0UL )
-#define portPRIVILEGED_FLASH_REGION			( 1UL )
-#define portPRIVILEGED_RAM_REGION			( 2UL )
-#define portGENERAL_PERIPHERALS_REGION		( 3UL )
-#define portSTACK_REGION					( 4UL )
-#define portFIRST_CONFIGURABLE_REGION	    ( 5UL )
-#define portLAST_CONFIGURABLE_REGION		( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS		( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS				( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-#define portSWITCH_TO_USER_MODE() __asm volatile ( " mrs r0, control \n orr r0, #1 \n msr control, r0 " ::: "r0", "memory" )
-
-typedef struct MPU_REGION_REGISTERS
-{
-	uint32_t ulRegionBaseAddress;
-	uint32_t ulRegionAttribute;
-} xMPU_REGION_REGISTERS;
-
-/* Plus 1 to create space for the stack region. */
-typedef struct MPU_SETTINGS
-{
-	xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS ];
-} xMPU_SETTINGS;
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* SVC numbers for various services. */
-#define portSVC_START_SCHEDULER				0
-#define portSVC_YIELD						1
-#define portSVC_RAISE_PRIVILEGE				2
-
-/* Scheduler utilities. */
-
-#define portYIELD()				__asm volatile ( "	SVC	%0	\n" :: "i" (portSVC_YIELD) : "memory" )
-#define portYIELD_WITHIN_API() 													\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__asm volatile( "dsb" ::: "memory" );										\
-	__asm volatile( "isb" );													\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Generic helper function. */
-	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
-	{
-	uint8_t ucReturn;
-
-		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
-		return ucReturn;
-	}
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-/*-----------------------------------------------------------*/
-
-extern BaseType_t xIsPrivileged( void );
-extern void vResetPrivilege( void );
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-#define portIS_PRIVILEGED()			xIsPrivileged()
-
-/**
- * @brief Raise an SVC request to raise privilege.
-*/
-#define portRAISE_PRIVILEGE()		__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- */
-#define portRESET_PRIVILEGE()		vResetPrivilege()
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mov %0, %1												\n"	\
-		"	msr basepri, %0											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mrs %0, basepri											\n" \
-		"	mov %1, %2												\n"	\
-		"	msr basepri, %1											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-
-	/* This return will not be reached but is necessary to prevent compiler
-	warnings. */
-	return ulOriginalBASEPRI;
-}
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
-{
-	__asm volatile
-	(
-		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-
-#ifndef configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY
-	#warning "configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not defined. We recommend defining it to 1 in FreeRTOSConfig.h for better security. https://www.freertos.org/FreeRTOS-V10.3.x.html"
-	#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 0
-#endif
-/*-----------------------------------------------------------*/
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM4F/port.c b/osal/src/freertos/portable/GCC/ARM_CM4F/port.c
deleted file mode 100644
index 89a912c..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM4F/port.c
+++ /dev/null
@@ -1,775 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __VFP_FP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-/* Constants used to detect a Cortex-M7 r0p1 core, which should use the ARM_CM7
-r0p1 port. */
-#define portCPUID							( * ( ( volatile uint32_t * ) 0xE000ed00 ) )
-#define portCORTEX_M7_r0p1_ID				( 0x410FC271UL )
-#define portCORTEX_M7_r0p0_ID				( 0x410FC270UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS			( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000 )
-#define portINITIAL_EXC_RETURN				( 0xfffffffd )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK		( ( StackType_t ) 0xfffffffeUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* Let the user override the pre-loading of the initial LR with the address of
-prvTaskExitError() in case it messes up unwinding of the stack in the
-debugger. */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS	prvTaskExitError
-#endif
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void ) __attribute__ (( naked ));
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void ) __attribute__ (( naked ));
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvPortStartFirstTask( void ) __attribute__ (( naked ));
-
-/*
- * Function to enable the VFP.
- */
-static void vPortEnableVFP( void ) __attribute__ (( naked ));
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0;
-
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		started to remove a compiler warning about the function being defined
-		but never called.  ulDummy is used purely to quieten other warnings
-		about code appearing after this function is called - making ulDummy
-		volatile makes the compiler think the function could return and
-		therefore not output an 'unreachable code' warning for code that appears
-		after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	__asm volatile (
-					"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
-					"	ldr r1, [r3]					\n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
-					"	ldr r0, [r1]					\n" /* The first item in pxCurrentTCB is the task top of stack. */
-					"	ldmia r0!, {r4-r11, r14}		\n" /* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
-					"	msr psp, r0						\n" /* Restore the task stack pointer. */
-					"	isb								\n"
-					"	mov r0, #0 						\n"
-					"	msr	basepri, r0					\n"
-					"	bx r14							\n"
-					"									\n"
-					"	.align 4						\n"
-					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
-				);
-}
-/*-----------------------------------------------------------*/
-
-static void prvPortStartFirstTask( void )
-{
-	/* Start the first task.  This also clears the bit that indicates the FPU is
-	in use in case the FPU was used before the scheduler was started - which
-	would otherwise result in the unnecessary leaving of space in the SVC stack
-	for lazy saving of FPU registers. */
-	__asm volatile(
-					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
-					" ldr r0, [r0] 			\n"
-					" ldr r0, [r0] 			\n"
-					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
-					" mov r0, #0			\n" /* Clear the bit that indicates the FPU is in use, see comment above. */
-					" msr control, r0		\n"
-					" cpsie i				\n" /* Globally enable interrupts. */
-					" cpsie f				\n"
-					" dsb					\n"
-					" isb					\n"
-					" svc 0					\n" /* System call to start first task. */
-					" nop					\n"
-				);
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	/* This port can be used on all revisions of the Cortex-M7 core other than
-	the r0p1 parts.  r0p1 parts should use the port from the
-	/source/portable/GCC/ARM_CM7/r0p1 directory. */
-	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
-	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	prvPortStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing!  Call the task
-	exit error function to prevent compiler warnings about a static function
-	not being called in the case that the application writer overrides this
-	functionality by defining configTASK_RETURN_ADDRESS.  Call
-	vTaskSwitchContext() so link time optimisation does not remove the
-	symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void xPortPendSVHandler( void )
-{
-	/* This is a naked function. */
-
-	__asm volatile
-	(
-	"	mrs r0, psp							\n"
-	"	isb									\n"
-	"										\n"
-	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
-	"	ldr	r2, [r3]						\n"
-	"										\n"
-	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, push high vfp registers. */
-	"	it eq								\n"
-	"	vstmdbeq r0!, {s16-s31}				\n"
-	"										\n"
-	"	stmdb r0!, {r4-r11, r14}			\n" /* Save the core registers. */
-	"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
-	"										\n"
-	"	stmdb sp!, {r0, r3}					\n"
-	"	mov r0, %0 							\n"
-	"	msr basepri, r0						\n"
-	"	dsb									\n"
-	"	isb									\n"
-	"	bl vTaskSwitchContext				\n"
-	"	mov r0, #0							\n"
-	"	msr basepri, r0						\n"
-	"	ldmia sp!, {r0, r3}					\n"
-	"										\n"
-	"	ldr r1, [r3]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
-	"	ldr r0, [r1]						\n"
-	"										\n"
-	"	ldmia r0!, {r4-r11, r14}			\n" /* Pop the core registers. */
-	"										\n"
-	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
-	"	it eq								\n"
-	"	vldmiaeq r0!, {s16-s31}				\n"
-	"										\n"
-	"	msr psp, r0							\n"
-	"	isb									\n"
-	"										\n"
-	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */
-		#if WORKAROUND_PMU_CM001 == 1
-	"			push { r14 }				\n"
-	"			pop { pc }					\n"
-		#endif
-	#endif
-	"										\n"
-	"	bx r14								\n"
-	"										\n"
-	"	.align 4							\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
-	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
-	);
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-
-#endif /* #if configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-/* This is a naked function. */
-static void vPortEnableVFP( void )
-{
-	__asm volatile
-	(
-		"	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
-		"	ldr r1, [r0]				\n"
-		"								\n"
-		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
-		"	str r1, [r0]				\n"
-		"	bx r14						"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM4F/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM4F/portmacro.h
deleted file mode 100644
index d0a566a..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM4F/portmacro.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* Scheduler utilities. */
-#define portYIELD() 															\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__asm volatile( "dsb" ::: "memory" );										\
-	__asm volatile( "isb" );													\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Generic helper function. */
-	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
-	{
-	uint8_t ucReturn;
-
-		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
-		return ucReturn;
-	}
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mov %0, %1												\n"	\
-		"	msr basepri, %0											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mrs %0, basepri											\n" \
-		"	mov %1, %2												\n"	\
-		"	msr basepri, %1											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-
-	/* This return will not be reached but is necessary to prevent compiler
-	warnings. */
-	return ulOriginalBASEPRI;
-}
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
-{
-	__asm volatile
-	(
-		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM4_MPU/port.c b/osal/src/freertos/portable/GCC/ARM_CM4_MPU/port.c
deleted file mode 100644
index bfb84c7..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM4_MPU/port.c
+++ /dev/null
@@ -1,933 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM3 port.
- *----------------------------------------------------------*/
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __VFP_FP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK	( 0 )
-#endif
-
-/* Constants required to access and manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG				( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG		( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG					( *	( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSPRI1_REG					( * ( ( volatile uint32_t * ) 0xe000ed1c ) )
-#define portNVIC_SYS_CTRL_STATE_REG				( * ( ( volatile uint32_t * ) 0xe000ed24 ) )
-#define portNVIC_MEM_FAULT_ENABLE				( 1UL << 16UL )
-
-/* Constants required to access and manipulate the MPU. */
-#define portMPU_TYPE_REG						( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_REGION_BASE_ADDRESS_REG			( * ( ( volatile uint32_t * ) 0xe000ed9C ) )
-#define portMPU_REGION_ATTRIBUTE_REG			( * ( ( volatile uint32_t * ) 0xe000edA0 ) )
-#define portMPU_CTRL_REG						( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portEXPECTED_MPU_TYPE_VALUE				( 8UL << 8UL ) /* 8 regions, unified. */
-#define portMPU_ENABLE							( 0x01UL )
-#define portMPU_BACKGROUND_ENABLE				( 1UL << 2UL )
-#define portPRIVILEGED_EXECUTION_START_ADDRESS	( 0UL )
-#define portMPU_REGION_VALID					( 0x10UL )
-#define portMPU_REGION_ENABLE					( 0x01UL )
-#define portPERIPHERALS_START_ADDRESS			0x40000000UL
-#define portPERIPHERALS_END_ADDRESS				0x5FFFFFFFUL
-
-/* Constants required to access and manipulate the SysTick. */
-#define portNVIC_SYSTICK_INT					( 0x00000002UL )
-#define portNVIC_SYSTICK_ENABLE					( 0x00000001UL )
-#define portNVIC_PENDSV_PRI						( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-#define portNVIC_SVC_PRI						( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR								( ( volatile uint32_t * ) 0xe000ef34UL ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS				( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR						( 0x01000000UL )
-#define portINITIAL_EXC_RETURN					( 0xfffffffdUL )
-#define portINITIAL_CONTROL_IF_UNPRIVILEGED		( 0x03 )
-#define portINITIAL_CONTROL_IF_PRIVILEGED		( 0x02 )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Offsets in the stack to the parameters when inside the SVC handler. */
-#define portOFFSET_TO_PC						( 6 )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Configure a number of standard MPU regions that are used by all tasks.
- */
-static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the smallest MPU region size that a given number of bytes will fit
- * into.  The region size is returned as the value that should be programmed
- * into the region attribute register for that region.
- */
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes ) PRIVILEGED_FUNCTION;
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Standard FreeRTOS exception handlers.
- */
-void xPortPendSVHandler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-void xPortSysTickHandler( void ) PRIVILEGED_FUNCTION;
-void vPortSVCHandler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/*
- * Starts the scheduler by restoring the context of the first task to run.
- */
-static void prvRestoreContextOfFirstTask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/*
- * C portion of the SVC handler.  The SVC handler is split between an asm entry
- * and a C wrapper for simplicity of coding and maintenance.
- */
-static void prvSVCHandler( uint32_t *pulRegisters ) __attribute__(( noinline )) PRIVILEGED_FUNCTION;
-
-/*
- * Function to enable the VFP.
- */
- static void vPortEnableVFP( void ) __attribute__ (( naked ));
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-extern BaseType_t xPortRaisePrivilege( void );
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-extern void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable.  Note this is not saved as part of the task context as context
-switches can only occur when uxCriticalNesting is zero. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = 0;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	if( xRunPrivileged == pdTRUE )
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_PRIVILEGED;
-	}
-	else
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
-	}
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	/* Assumes psp was in use. */
-	__asm volatile
-	(
-		#ifndef USE_PROCESS_STACK	/* Code should not be required if a main() is using the process stack. */
-			"	tst lr, #4						\n"
-			"	ite eq							\n"
-			"	mrseq r0, msp					\n"
-			"	mrsne r0, psp					\n"
-		#else
-			"	mrs r0, psp						\n"
-		#endif
-			"	b %0							\n"
-			::"i"(prvSVCHandler):"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-static void prvSVCHandler(	uint32_t *pulParam )
-{
-uint8_t ucSVCNumber;
-uint32_t ulPC;
-#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		* exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* #if defined( __ARMCC_VERSION ) */
-#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-	/* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR.  The first
-	argument (r0) is pulParam[ 0 ]. */
-	ulPC = pulParam[ portOFFSET_TO_PC ];
-	ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		case portSVC_START_SCHEDULER	:	portNVIC_SYSPRI1_REG |= portNVIC_SVC_PRI;
-											prvRestoreContextOfFirstTask();
-											break;
-
-		case portSVC_YIELD				:	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-											/* Barriers are normally not required
-											but do ensure the code is completely
-											within the specified behaviour for the
-											architecture. */
-											__asm volatile( "dsb" ::: "memory" );
-											__asm volatile( "isb" );
-
-											break;
-
-	#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-		case portSVC_RAISE_PRIVILEGE	:	/* Only raise the privilege, if the
-											 * svc was raised from any of the
-											 * system calls. */
-											if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-												ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-											{
-												__asm volatile
-												(
-													"	mrs r1, control		\n" /* Obtain current control value. */
-													"	bic r1, #1			\n" /* Set privilege bit. */
-													"	msr control, r1		\n" /* Write back new control value. */
-													::: "r1", "memory"
-												);
-											}
-											break;
-	#else
-		case portSVC_RAISE_PRIVILEGE	:	__asm volatile
-											(
-												"	mrs r1, control		\n" /* Obtain current control value. */
-												"	bic r1, #1			\n" /* Set privilege bit. */
-												"	msr control, r1		\n" /* Write back new control value. */
-												::: "r1", "memory"
-											);
-											break;
-	#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-		default							:	/* Unknown SVC call. */
-											break;
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvRestoreContextOfFirstTask( void )
-{
-	__asm volatile
-	(
-		"	ldr r0, =0xE000ED08				\n" /* Use the NVIC offset register to locate the stack. */
-		"	ldr r0, [r0]					\n"
-		"	ldr r0, [r0]					\n"
-		"	msr msp, r0						\n" /* Set the msp back to the start of the stack. */
-		"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
-		"	ldr r1, [r3]					\n"
-		"	ldr r0, [r1]					\n" /* The first item in the TCB is the task top of stack. */
-		"	add r1, r1, #4					\n" /* Move onto the second item in the TCB... */
-		"									\n"
-		"	dmb								\n" /* Complete outstanding transfers before disabling MPU. */
-		"	ldr r2, =0xe000ed94				\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]					\n" /* Read the value of MPU_CTRL. */
-		"	bic r3, #1						\n" /* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-		"	str r3, [r2]					\n" /* Disable MPU. */
-		"									\n"
-		"	ldr r2, =0xe000ed9c				\n" /* Region Base Address register. */
-		"	ldmia r1!, {r4-r11}				\n" /* Read 4 sets of MPU registers from TCB. */
-		"	stmia r2!, {r4-r11}				\n" /* Write 4 sets of MPU registers. */
-		"									\n"
-		"	ldr r2, =0xe000ed94				\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]					\n" /* Read the value of MPU_CTRL. */
-		"	orr r3, #1						\n" /* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-		"	str r3, [r2]					\n" /* Enable MPU. */
-		"	dsb								\n" /* Force memory writes before continuing. */
-		"									\n"
-		"	ldmia r0!, {r3-r11, r14}		\n" /* Pop the registers that are not automatically saved on exception entry. */
-		"	msr control, r3					\n"
-		"	msr psp, r0						\n" /* Restore the task stack pointer. */
-		"	mov r0, #0						\n"
-		"	msr	basepri, r0					\n"
-		"	bx r14							\n"
-		"									\n"
-		"	.align 4						\n"
-		"pxCurrentTCBConst2: .word pxCurrentTCB	\n"
-	);
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See
-	http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the same priority as the kernel, and the SVC
-	handler higher priority so it can be used to exit a critical section (where
-	lower priorities are masked). */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Configure the regions in the MPU that are common to all tasks. */
-	prvSetupMPU();
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task.  This also clears the bit that indicates the FPU is
-	in use in case the FPU was used before the scheduler was started - which
-	would otherwise result in the unnecessary leaving of space in the SVC stack
-	for lazy saving of FPU registers. */
-	__asm volatile(
-					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
-					" ldr r0, [r0] 			\n"
-					" ldr r0, [r0] 			\n"
-					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
-					" mov r0, #0			\n" /* Clear the bit that indicates the FPU is in use, see comment above. */
-					" msr control, r0		\n"
-					" cpsie i				\n" /* Globally enable interrupts. */
-					" cpsie f				\n"
-					" dsb					\n"
-					" isb					\n"
-					" svc %0				\n" /* System call to start first task. */
-					" nop					\n"
-					:: "i" (portSVC_START_SCHEDULER) : "memory" );
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void xPortPendSVHandler( void )
-{
-	/* This is a naked function. */
-
-	__asm volatile
-	(
-		"	mrs r0, psp							\n"
-		"	isb									\n"
-		"										\n"
-		"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
-		"	ldr	r2, [r3]						\n"
-		"										\n"
-		"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, push high vfp registers. */
-		"	it eq								\n"
-		"	vstmdbeq r0!, {s16-s31}				\n"
-		"										\n"
-		"	mrs r1, control						\n"
-		"	stmdb r0!, {r1, r4-r11, r14}		\n" /* Save the remaining registers. */
-		"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
-		"										\n"
-		"	stmdb sp!, {r0, r3}					\n"
-		"	mov r0, %0							\n"
-		"	msr basepri, r0						\n"
-		"	dsb									\n"
-		"	isb									\n"
-		"	bl vTaskSwitchContext				\n"
-		"	mov r0, #0							\n"
-		"	msr basepri, r0						\n"
-		"	ldmia sp!, {r0, r3}					\n"
-		"										\n" /* Restore the context. */
-		"	ldr r1, [r3]						\n"
-		"	ldr r0, [r1]						\n" /* The first item in the TCB is the task top of stack. */
-		"	add r1, r1, #4						\n" /* Move onto the second item in the TCB... */
-		"										\n"
-		"	dmb									\n" /* Complete outstanding transfers before disabling MPU. */
-		"	ldr r2, =0xe000ed94					\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]						\n" /* Read the value of MPU_CTRL. */
-		"	bic r3, #1							\n" /* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-		"	str r3, [r2]						\n" /* Disable MPU. */
-		"										\n"
-		"	ldr r2, =0xe000ed9c					\n" /* Region Base Address register. */
-		"	ldmia r1!, {r4-r11}					\n" /* Read 4 sets of MPU registers from TCB. */
-		"	stmia r2!, {r4-r11}					\n" /* Write 4 sets of MPU registers. */
-		"										\n"
-		"	ldr r2, =0xe000ed94					\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]						\n" /* Read the value of MPU_CTRL. */
-		"	orr r3, #1							\n" /* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-		"	str r3, [r2]						\n" /* Enable MPU. */
-		"	dsb									\n" /* Force memory writes before continuing. */
-		"										\n"
-		"	ldmia r0!, {r3-r11, r14}			\n" /* Pop the registers that are not automatically saved on exception entry. */
-		"	msr control, r3						\n"
-		"										\n"
-		"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
-		"	it eq								\n"
-		"	vldmiaeq r0!, {s16-s31}				\n"
-		"										\n"
-		"	msr psp, r0							\n"
-		"	bx r14								\n"
-		"										\n"
-		"	.align 4							\n"
-		"pxCurrentTCBConst: .word pxCurrentTCB	\n"
-		::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
-	);
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulDummy;
-
-	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
-{
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE );
-}
-/*-----------------------------------------------------------*/
-
-/* This is a naked function. */
-static void vPortEnableVFP( void )
-{
-	__asm volatile
-	(
-		"	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
-		"	ldr r1, [r0]				\n"
-		"								\n"
-		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
-		"	str r1, [r0]				\n"
-		"	bx r14						"
-	);
-}
-/*-----------------------------------------------------------*/
-
-static void prvSetupMPU( void )
-{
-#if defined( __ARMCC_VERSION )
-	/* Declaration when these variable are defined in code instead of being
-	 * exported from linker scripts. */
-	extern uint32_t * __privileged_functions_end__;
-	extern uint32_t * __FLASH_segment_start__;
-	extern uint32_t * __FLASH_segment_end__;
-	extern uint32_t * __privileged_data_start__;
-	extern uint32_t * __privileged_data_end__;
-#else
-	/* Declaration when these variable are exported from linker scripts. */
-	extern uint32_t __privileged_functions_end__[];
-	extern uint32_t __FLASH_segment_start__[];
-	extern uint32_t __FLASH_segment_end__[];
-	extern uint32_t __privileged_data_start__[];
-	extern uint32_t __privileged_data_end__[];
-#endif
-	/* Check the expected MPU is present. */
-	if( ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )  || ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE << 1 ))
-	{
-		/* First setup the entire flash for unprivileged read only access. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portUNPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the first nK for privileged only access (even though less
-		than 10K is actually being used).  This is where the kernel code is
-		placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged data RAM region.  This is where the kernel data
-		is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_RAM_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-										( portMPU_REGION_ENABLE );
-
-		/* By default allow everything to access the general peripherals.  The
-		system peripherals and registers are protected. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( portPERIPHERALS_START_ADDRESS ) |
-											( portMPU_REGION_VALID ) |
-											( portGENERAL_PERIPHERALS_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
-										( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Enable the memory fault exception. */
-		portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
-
-		/* Enable the MPU with the background region configured. */
-		portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes )
-{
-uint32_t ulRegionSize, ulReturnValue = 4;
-
-	/* 32 is the smallest region size, 31 is the largest valid value for
-	ulReturnValue. */
-	for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
-	{
-		if( ulActualSizeInBytes <= ulRegionSize )
-		{
-			break;
-		}
-		else
-		{
-			ulReturnValue++;
-		}
-	}
-
-	/* Shift the code by one before returning so it can be written directly
-	into the the correct bit position of the attribute register. */
-	return ( ulReturnValue << 1UL );
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control							\n" /* r0 = CONTROL. */
-	"	tst r0, #1								\n" /* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	"	ite ne									\n"
-	"	movne r0, #0							\n" /* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	"	moveq r0, #1							\n" /* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	"	bx lr									\n" /* Return. */
-	"											\n"
-	"	.align 4								\n"
-	::: "r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vResetPrivilege( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control							\n" /* r0 = CONTROL. */
-	"	orr r0, #1								\n" /* r0 = r0 | 1. */
-	"	msr control, r0							\n" /* CONTROL = r0. */
-	"	bx lr									\n" /* Return to the caller. */
-	:::"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-{
-#if defined( __ARMCC_VERSION )
-	/* Declaration when these variable are defined in code instead of being
-	 * exported from linker scripts. */
-	extern uint32_t * __SRAM_segment_start__;
-	extern uint32_t * __SRAM_segment_end__;
-	extern uint32_t * __privileged_data_start__;
-	extern uint32_t * __privileged_data_end__;
-#else
-	/* Declaration when these variable are exported from linker scripts. */
-	extern uint32_t __SRAM_segment_start__[];
-	extern uint32_t __SRAM_segment_end__[];
-	extern uint32_t __privileged_data_start__[];
-	extern uint32_t __privileged_data_end__[];
-#endif
-
-int32_t lIndex;
-uint32_t ul;
-
-	if( xRegions == NULL )
-	{
-		/* No MPU regions are specified so allow access to all RAM. */
-		xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-				( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION );
-
-		xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-				( portMPU_REGION_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Re-instate the privileged only RAM region as xRegion[ 0 ] will have
-		just removed the privileged only parameters. */
-		xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
-				( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION + 1 );
-
-		xMPUSettings->xRegion[ 1 ].ulRegionAttribute =
-				( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Invalidate all other regions. */
-		for( ul = 2; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-			xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-		}
-	}
-	else
-	{
-		/* This function is called automatically when the task is created - in
-		which case the stack region parameters will be valid.  At all other
-		times the stack parameters will not be valid and it is assumed that the
-		stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-					( ( uint32_t ) pxBottomOfStack ) |
-					( portMPU_REGION_VALID ) |
-					( portSTACK_REGION ); /* Region number. */
-
-			xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-					( portMPU_REGION_READ_WRITE ) | /* Read and write. */
-					( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
-					( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-					( portMPU_REGION_ENABLE );
-		}
-
-		lIndex = 0;
-
-		for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
-			{
-				/* Translate the generic region definition contained in
-				xRegions into the CM3 specific MPU settings that are then
-				stored in xMPUSettings. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
-						( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) |
-						( portMPU_REGION_VALID ) |
-						( portSTACK_REGION + ul ); /* Region number. */
-
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute =
-						( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
-						( xRegions[ lIndex ].ulParameters ) |
-						( portMPU_REGION_ENABLE );
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredicable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
-
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM4_MPU/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM4_MPU/portmacro.h
deleted file mode 100644
index 2b5f09e..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM4_MPU/portmacro.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* MPU specific constants. */
-#define portUSING_MPU_WRAPPERS		1
-#define portPRIVILEGE_BIT			( 0x80000000UL )
-
-#define portMPU_REGION_READ_WRITE								( 0x03UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY						( 0x05UL << 24UL )
-#define portMPU_REGION_READ_ONLY								( 0x06UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE					( 0x01UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY	( 0x02UL << 24UL )
-#define portMPU_REGION_CACHEABLE_BUFFERABLE						( 0x03UL << 16UL )
-#define portMPU_REGION_EXECUTE_NEVER							( 0x01UL << 28UL )
-
-#define portUNPRIVILEGED_FLASH_REGION		( 0UL )
-#define portPRIVILEGED_FLASH_REGION			( 1UL )
-#define portPRIVILEGED_RAM_REGION			( 2UL )
-#define portGENERAL_PERIPHERALS_REGION		( 3UL )
-#define portSTACK_REGION					( 4UL )
-#define portFIRST_CONFIGURABLE_REGION	    ( 5UL )
-#define portLAST_CONFIGURABLE_REGION		( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS		( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS				( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-#define portSWITCH_TO_USER_MODE() __asm volatile ( " mrs r0, control \n orr r0, #1 \n msr control, r0 " ::: "r0", "memory" )
-
-typedef struct MPU_REGION_REGISTERS
-{
-	uint32_t ulRegionBaseAddress;
-	uint32_t ulRegionAttribute;
-} xMPU_REGION_REGISTERS;
-
-/* Plus 1 to create space for the stack region. */
-typedef struct MPU_SETTINGS
-{
-	xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS ];
-} xMPU_SETTINGS;
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* SVC numbers for various services. */
-#define portSVC_START_SCHEDULER				0
-#define portSVC_YIELD						1
-#define portSVC_RAISE_PRIVILEGE				2
-
-/* Scheduler utilities. */
-
-#define portYIELD()				__asm volatile ( "	SVC	%0	\n" :: "i" (portSVC_YIELD) : "memory" )
-#define portYIELD_WITHIN_API() 													\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__asm volatile( "dsb" ::: "memory" );										\
-	__asm volatile( "isb" );													\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Generic helper function. */
-	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
-	{
-	uint8_t ucReturn;
-
-		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
-		return ucReturn;
-	}
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-/*-----------------------------------------------------------*/
-
-extern BaseType_t xIsPrivileged( void );
-extern void vResetPrivilege( void );
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-#define portIS_PRIVILEGED()			xIsPrivileged()
-
-/**
- * @brief Raise an SVC request to raise privilege.
-*/
-#define portRAISE_PRIVILEGE()		__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- */
-#define portRESET_PRIVILEGE()		vResetPrivilege()
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mov %0, %1												\n"	\
-		"	msr basepri, %0											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mrs %0, basepri											\n" \
-		"	mov %1, %2												\n"	\
-		"	msr basepri, %1											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-
-	/* This return will not be reached but is necessary to prevent compiler
-	warnings. */
-	return ulOriginalBASEPRI;
-}
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
-{
-	__asm volatile
-	(
-		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-
-#ifndef configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY
-	#warning "configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not defined. We recommend defining it to 1 in FreeRTOSConfig.h for better security. https://www.freertos.org/FreeRTOS-V10.3.x.html"
-	#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 0
-#endif
-/*-----------------------------------------------------------*/
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM7/ReadMe.txt b/osal/src/freertos/portable/GCC/ARM_CM7/ReadMe.txt
deleted file mode 100644
index 4cf25c5..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM7/ReadMe.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-There are two options for running FreeRTOS on ARM Cortex-M7 microcontrollers.
-The best option depends on the revision of the ARM Cortex-M7 core in use.  The
-revision is specified by an 'r' number, and a 'p' number, so will look something
-like 'r0p1'.  Check the documentation for the microcontroller in use to find the 
-revision of the Cortex-M7 core used in that microcontroller.  If in doubt, use 
-the FreeRTOS port provided specifically for r0p1 revisions, as that can be used
-with all core revisions.
-
-The first option is to use the ARM Cortex-M4F port, and the second option is to
-use the Cortex-M7 r0p1 port - the latter containing a minor errata workaround.
-
-If the revision of the ARM Cortex-M7 core is not r0p1 then either option can be
-used, but it is recommended to use the FreeRTOS ARM Cortex-M4F port located in 
-the /FreeRTOS/Source/portable/GCC/ARM_CM4F directory.
-
-If the revision of the ARM Cortex-M7 core is r0p1 then use the FreeRTOS ARM
-Cortex-M7 r0p1 port located in the /FreeRTOS/Source/portable/GCC/ARM_CM7/r0p1
-directory.
\ No newline at end of file
diff --git a/osal/src/freertos/portable/GCC/ARM_CM7/r0p1/port.c b/osal/src/freertos/portable/GCC/ARM_CM7/r0p1/port.c
deleted file mode 100644
index 696b11d..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM7/r0p1/port.c
+++ /dev/null
@@ -1,765 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __VFP_FP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS			( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000 )
-#define portINITIAL_EXC_RETURN				( 0xfffffffd )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK		( ( StackType_t ) 0xfffffffeUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* Let the user override the pre-loading of the initial LR with the address of
-prvTaskExitError() in case it messes up unwinding of the stack in the
-debugger. */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS	prvTaskExitError
-#endif
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void ) __attribute__ (( naked ));
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void ) __attribute__ (( naked ));
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvPortStartFirstTask( void ) __attribute__ (( naked ));
-
-/*
- * Function to enable the VFP.
- */
-static void vPortEnableVFP( void ) __attribute__ (( naked ));
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0;
-
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		started to remove a compiler warning about the function being defined
-		but never called.  ulDummy is used purely to quieten other warnings
-		about code appearing after this function is called - making ulDummy
-		volatile makes the compiler think the function could return and
-		therefore not output an 'unreachable code' warning for code that appears
-		after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	__asm volatile (
-					"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
-					"	ldr r1, [r3]					\n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
-					"	ldr r0, [r1]					\n" /* The first item in pxCurrentTCB is the task top of stack. */
-					"	ldmia r0!, {r4-r11, r14}		\n" /* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
-					"	msr psp, r0						\n" /* Restore the task stack pointer. */
-					"	isb								\n"
-					"	mov r0, #0 						\n"
-					"	msr	basepri, r0					\n"
-					"	bx r14							\n"
-					"									\n"
-					"	.align 4						\n"
-					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
-				);
-}
-/*-----------------------------------------------------------*/
-
-static void prvPortStartFirstTask( void )
-{
-	/* Start the first task.  This also clears the bit that indicates the FPU is
-	in use in case the FPU was used before the scheduler was started - which
-	would otherwise result in the unnecessary leaving of space in the SVC stack
-	for lazy saving of FPU registers. */
-	__asm volatile(
-					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
-					" ldr r0, [r0] 			\n"
-					" ldr r0, [r0] 			\n"
-					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
-					" mov r0, #0			\n" /* Clear the bit that indicates the FPU is in use, see comment above. */
-					" msr control, r0		\n"
-					" cpsie i				\n" /* Globally enable interrupts. */
-					" cpsie f				\n"
-					" dsb					\n"
-					" isb					\n"
-					" svc 0					\n" /* System call to start first task. */
-					" nop					\n"
-				);
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	prvPortStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing!  Call the task
-	exit error function to prevent compiler warnings about a static function
-	not being called in the case that the application writer overrides this
-	functionality by defining configTASK_RETURN_ADDRESS.  Call
-	vTaskSwitchContext() so link time optimisation does not remove the
-	symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void xPortPendSVHandler( void )
-{
-	/* This is a naked function. */
-
-	__asm volatile
-	(
-	"	mrs r0, psp							\n"
-	"	isb									\n"
-	"										\n"
-	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
-	"	ldr	r2, [r3]						\n"
-	"										\n"
-	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, push high vfp registers. */
-	"	it eq								\n"
-	"	vstmdbeq r0!, {s16-s31}				\n"
-	"										\n"
-	"	stmdb r0!, {r4-r11, r14}			\n" /* Save the core registers. */
-	"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
-	"										\n"
-	"	stmdb sp!, {r0, r3}					\n"
-	"	mov r0, %0 							\n"
-	"	cpsid i								\n" /* Errata workaround. */
-	"	msr basepri, r0						\n"
-	"	dsb									\n"
-	"	isb									\n"
-	"	cpsie i								\n" /* Errata workaround. */
-	"	bl vTaskSwitchContext				\n"
-	"	mov r0, #0							\n"
-	"	msr basepri, r0						\n"
-	"	ldmia sp!, {r0, r3}					\n"
-	"										\n"
-	"	ldr r1, [r3]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
-	"	ldr r0, [r1]						\n"
-	"										\n"
-	"	ldmia r0!, {r4-r11, r14}			\n" /* Pop the core registers. */
-	"										\n"
-	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
-	"	it eq								\n"
-	"	vldmiaeq r0!, {s16-s31}				\n"
-	"										\n"
-	"	msr psp, r0							\n"
-	"	isb									\n"
-	"										\n"
-	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */
-		#if WORKAROUND_PMU_CM001 == 1
-	"			push { r14 }				\n"
-	"			pop { pc }					\n"
-		#endif
-	#endif
-	"										\n"
-	"	bx r14								\n"
-	"										\n"
-	"	.align 4							\n"
-	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
-	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
-	);
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-
-#endif /* #if configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-/* This is a naked function. */
-static void vPortEnableVFP( void )
-{
-	__asm volatile
-	(
-		"	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
-		"	ldr r1, [r0]				\n"
-		"								\n"
-		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
-		"	str r1, [r0]				\n"
-		"	bx r14						"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM7/r0p1/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM7/r0p1/portmacro.h
deleted file mode 100644
index 367b432..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM7/r0p1/portmacro.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* Scheduler utilities. */
-#define portYIELD() 															\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__asm volatile( "dsb" ::: "memory" );										\
-	__asm volatile( "isb" );													\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Generic helper function. */
-	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
-	{
-	uint8_t ucReturn;
-
-		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
-		return ucReturn;
-	}
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mov %0, %1												\n"	\
-		"	cpsid i													\n" \
-		"	msr basepri, %0											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		"	cpsie i													\n" \
-		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mrs %0, basepri											\n" \
-		"	mov %1, %2												\n"	\
-		"	cpsid i													\n" \
-		"	msr basepri, %1											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		"	cpsie i													\n" \
-		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-
-	/* This return will not be reached but is necessary to prevent compiler
-	warnings. */
-	return ulOriginalBASEPRI;
-}
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
-{
-	__asm volatile
-	(
-		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM7_MPU/ReadMe.txt b/osal/src/freertos/portable/GCC/ARM_CM7_MPU/ReadMe.txt
deleted file mode 100644
index ff4e74c..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM7_MPU/ReadMe.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-There are two options for running FreeRTOS on ARM Cortex-M7 microcontrollers.
-The best option depends on the revision of the ARM Cortex-M7 core in use.  The
-revision is specified by an 'r' number, and a 'p' number, so will look something
-like 'r0p1'.  Check the documentation for the microcontroller in use to find the 
-revision of the Cortex-M7 core used in that microcontroller.  If in doubt, use 
-the FreeRTOS port provided specifically for r0p1 revisions, as that can be used
-with all core revisions.
-
-The first option is to use the ARM Cortex-M4F port, and the second option is to
-use the Cortex-M7 r0p1 port - the latter containing a minor errata workaround.
-
-If the revision of the ARM Cortex-M7 core is not r0p1 then either option can be
-used, but it is recommended to use the FreeRTOS ARM Cortex-M4F port located in 
-the /FreeRTOS/Source/portable/GCC/ARM_CM4F directory.
-
-If the revision of the ARM Cortex-M7 core is r0p1 then use the FreeRTOS ARM
-Cortex-M7 r0p1 port located in the /FreeRTOS/Source/portable/GCC/ARM_CM7_GCC/r0p1
-directory.
diff --git a/osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/port.c b/osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/port.c
deleted file mode 100644
index e423c4f..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/port.c
+++ /dev/null
@@ -1,936 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Portion Copyright  2020 STMicroelectronics International N.V. All rights reserved.
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM7 port.
- *----------------------------------------------------------*/
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __VFP_FP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK	( 0 )
-#endif
-
-/* Constants required to access and manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG				( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG		( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG					( *	( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSPRI1_REG					( * ( ( volatile uint32_t * ) 0xe000ed1c ) )
-#define portNVIC_SYS_CTRL_STATE_REG				( * ( ( volatile uint32_t * ) 0xe000ed24 ) )
-#define portNVIC_MEM_FAULT_ENABLE				( 1UL << 16UL )
-
-/* Constants required to access and manipulate the MPU. */
-#define portMPU_TYPE_REG						( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_REGION_BASE_ADDRESS_REG			( * ( ( volatile uint32_t * ) 0xe000ed9C ) )
-#define portMPU_REGION_ATTRIBUTE_REG			( * ( ( volatile uint32_t * ) 0xe000edA0 ) )
-#define portMPU_CTRL_REG						( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portEXPECTED_MPU_TYPE_VALUE				( 8UL << 8UL ) /* 8 regions, unified. */
-#define portMPU_ENABLE							( 0x01UL )
-#define portMPU_BACKGROUND_ENABLE				( 1UL << 2UL )
-#define portPRIVILEGED_EXECUTION_START_ADDRESS	( 0UL )
-#define portMPU_REGION_VALID					( 0x10UL )
-#define portMPU_REGION_ENABLE					( 0x01UL )
-#define portPERIPHERALS_START_ADDRESS			0x40000000UL
-#define portPERIPHERALS_END_ADDRESS				0x5FFFFFFFUL
-
-/* Constants required to access and manipulate the SysTick. */
-#define portNVIC_SYSTICK_INT					( 0x00000002UL )
-#define portNVIC_SYSTICK_ENABLE					( 0x00000001UL )
-#define portNVIC_PENDSV_PRI						( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-#define portNVIC_SVC_PRI						( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR								( ( volatile uint32_t * ) 0xe000ef34UL ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS				( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR						( 0x01000000UL )
-#define portINITIAL_EXC_RETURN					( 0xfffffffdUL )
-#define portINITIAL_CONTROL_IF_UNPRIVILEGED		( 0x03 )
-#define portINITIAL_CONTROL_IF_PRIVILEGED		( 0x02 )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Offsets in the stack to the parameters when inside the SVC handler. */
-#define portOFFSET_TO_PC						( 6 )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Configure a number of standard MPU regions that are used by all tasks.
- */
-static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the smallest MPU region size that a given number of bytes will fit
- * into.  The region size is returned as the value that should be programmed
- * into the region attribute register for that region.
- */
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes ) PRIVILEGED_FUNCTION;
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Standard FreeRTOS exception handlers.
- */
-void xPortPendSVHandler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-void xPortSysTickHandler( void ) PRIVILEGED_FUNCTION;
-void vPortSVCHandler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/*
- * Starts the scheduler by restoring the context of the first task to run.
- */
-static void prvRestoreContextOfFirstTask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/*
- * C portion of the SVC handler.  The SVC handler is split between an asm entry
- * and a C wrapper for simplicity of coding and maintenance.
- */
-static void prvSVCHandler( uint32_t *pulRegisters ) __attribute__(( noinline )) PRIVILEGED_FUNCTION;
-
-/*
- * Function to enable the VFP.
- */
- static void vPortEnableVFP( void ) __attribute__ (( naked ));
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-extern BaseType_t xPortRaisePrivilege( void );
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-extern void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable.  Note this is not saved as part of the task context as context
-switches can only occur when uxCriticalNesting is zero. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = 0;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	if( xRunPrivileged == pdTRUE )
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_PRIVILEGED;
-	}
-	else
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
-	}
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	/* Assumes psp was in use. */
-	__asm volatile
-	(
-		#ifndef USE_PROCESS_STACK	/* Code should not be required if a main() is using the process stack. */
-			"	tst lr, #4						\n"
-			"	ite eq							\n"
-			"	mrseq r0, msp					\n"
-			"	mrsne r0, psp					\n"
-		#else
-			"	mrs r0, psp						\n"
-		#endif
-			"	b %0							\n"
-			::"i"(prvSVCHandler):"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-static void prvSVCHandler(	uint32_t *pulParam )
-{
-uint8_t ucSVCNumber;
-uint32_t ulPC;
-#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		* exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* #if defined( __ARMCC_VERSION ) */
-#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-	/* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR.  The first
-	argument (r0) is pulParam[ 0 ]. */
-	ulPC = pulParam[ portOFFSET_TO_PC ];
-	ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		case portSVC_START_SCHEDULER	:	portNVIC_SYSPRI1_REG |= portNVIC_SVC_PRI;
-											prvRestoreContextOfFirstTask();
-											break;
-
-		case portSVC_YIELD				:	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-											/* Barriers are normally not required
-											but do ensure the code is completely
-											within the specified behaviour for the
-											architecture. */
-											__asm volatile( "dsb" ::: "memory" );
-											__asm volatile( "isb" );
-
-											break;
-
-	#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-		case portSVC_RAISE_PRIVILEGE	:	/* Only raise the privilege, if the
-											 * svc was raised from any of the
-											 * system calls. */
-											if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-												ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-											{
-												__asm volatile
-												(
-													"	mrs r1, control		\n" /* Obtain current control value. */
-													"	bic r1, #1			\n" /* Set privilege bit. */
-													"	msr control, r1		\n" /* Write back new control value. */
-													::: "r1", "memory"
-												);
-											}
-											break;
-	#else
-		case portSVC_RAISE_PRIVILEGE	:	__asm volatile
-											(
-												"	mrs r1, control		\n" /* Obtain current control value. */
-												"	bic r1, #1			\n" /* Set privilege bit. */
-												"	msr control, r1		\n" /* Write back new control value. */
-												::: "r1", "memory"
-											);
-											break;
-	#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-		default							:	/* Unknown SVC call. */
-											break;
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvRestoreContextOfFirstTask( void )
-{
-	__asm volatile
-	(
-		"	ldr r0, =0xE000ED08				\n" /* Use the NVIC offset register to locate the stack. */
-		"	ldr r0, [r0]					\n"
-		"	ldr r0, [r0]					\n"
-		"	msr msp, r0						\n" /* Set the msp back to the start of the stack. */
-		"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
-		"	ldr r1, [r3]					\n"
-		"	ldr r0, [r1]					\n" /* The first item in the TCB is the task top of stack. */
-		"	add r1, r1, #4					\n" /* Move onto the second item in the TCB... */
-		"									\n"
-		"	dmb								\n" /* Complete outstanding transfers before disabling MPU. */
-		"	ldr r2, =0xe000ed94				\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]					\n" /* Read the value of MPU_CTRL. */
-		"	bic r3, #1						\n" /* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-		"	str r3, [r2]					\n" /* Disable MPU. */
-		"									\n"
-		"	ldr r2, =0xe000ed9c				\n" /* Region Base Address register. */
-		"	ldmia r1!, {r4-r11}				\n" /* Read 4 sets of MPU registers from TCB. */
-		"	stmia r2!, {r4-r11}				\n" /* Write 4 sets of MPU registers. */
-		"									\n"
-		"	ldr r2, =0xe000ed94				\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]					\n" /* Read the value of MPU_CTRL. */
-		"	orr r3, #1						\n" /* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-		"	str r3, [r2]					\n" /* Enable MPU. */
-		"	dsb								\n" /* Force memory writes before continuing. */
-		"									\n"
-		"	ldmia r0!, {r3-r11, r14}		\n" /* Pop the registers that are not automatically saved on exception entry. */
-		"	msr control, r3					\n"
-		"	msr psp, r0						\n" /* Restore the task stack pointer. */
-		"	mov r0, #0						\n"
-		"	msr	basepri, r0					\n"
-		"	bx r14							\n"
-		"									\n"
-		"	.align 4						\n"
-		"pxCurrentTCBConst2: .word pxCurrentTCB	\n"
-	);
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See
-	http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the same priority as the kernel, and the SVC
-	handler higher priority so it can be used to exit a critical section (where
-	lower priorities are masked). */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Configure the regions in the MPU that are common to all tasks. */
-	prvSetupMPU();
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task.  This also clears the bit that indicates the FPU is
-	in use in case the FPU was used before the scheduler was started - which
-	would otherwise result in the unnecessary leaving of space in the SVC stack
-	for lazy saving of FPU registers. */
-	__asm volatile(
-					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
-					" ldr r0, [r0] 			\n"
-					" ldr r0, [r0] 			\n"
-					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
-					" mov r0, #0			\n" /* Clear the bit that indicates the FPU is in use, see comment above. */
-					" msr control, r0		\n"
-					" cpsie i				\n" /* Globally enable interrupts. */
-					" cpsie f				\n"
-					" dsb					\n"
-					" isb					\n"
-					" svc %0				\n" /* System call to start first task. */
-					" nop					\n"
-					:: "i" (portSVC_START_SCHEDULER) : "memory" );
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void xPortPendSVHandler( void )
-{
-	/* This is a naked function. */
-
-	__asm volatile
-	(
-		"	mrs r0, psp							\n"
-		"	isb									\n"
-		"										\n"
-		"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
-		"	ldr	r2, [r3]						\n"
-		"										\n"
-		"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, push high vfp registers. */
-		"	it eq								\n"
-		"	vstmdbeq r0!, {s16-s31}				\n"
-		"										\n"
-		"	mrs r1, control						\n"
-		"	stmdb r0!, {r1, r4-r11, r14}		\n" /* Save the remaining registers. */
-		"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
-		"										\n"
-		"	stmdb sp!, {r0, r3}					\n"
-		"	mov r0, %0							\n"
-	  "	cpsid i								\n" /* Errata workaround. */
-		"	msr basepri, r0						\n"
-		"	dsb									\n"
-		"	isb									\n"
-	  "	cpsie i								\n" /* Errata workaround. */
-		"	bl vTaskSwitchContext				\n"
-		"	mov r0, #0							\n"
-		"	msr basepri, r0						\n"
-		"	ldmia sp!, {r0, r3}					\n"
-		"										\n" /* Restore the context. */
-		"	ldr r1, [r3]						\n"
-		"	ldr r0, [r1]						\n" /* The first item in the TCB is the task top of stack. */
-		"	add r1, r1, #4						\n" /* Move onto the second item in the TCB... */
-		"										\n"
-		"	dmb									\n" /* Complete outstanding transfers before disabling MPU. */
-		"	ldr r2, =0xe000ed94					\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]						\n" /* Read the value of MPU_CTRL. */
-		"	bic r3, #1							\n" /* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-		"	str r3, [r2]						\n" /* Disable MPU. */
-		"										\n"
-		"	ldr r2, =0xe000ed9c					\n" /* Region Base Address register. */
-		"	ldmia r1!, {r4-r11}					\n" /* Read 4 sets of MPU registers from TCB. */
-		"	stmia r2!, {r4-r11}					\n" /* Write 4 sets of MPU registers. */
-		"										\n"
-		"	ldr r2, =0xe000ed94					\n" /* MPU_CTRL register. */
-		"	ldr r3, [r2]						\n" /* Read the value of MPU_CTRL. */
-		"	orr r3, #1							\n" /* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-		"	str r3, [r2]						\n" /* Enable MPU. */
-		"	dsb									\n" /* Force memory writes before continuing. */
-		"										\n"
-		"	ldmia r0!, {r3-r11, r14}			\n" /* Pop the registers that are not automatically saved on exception entry. */
-		"	msr control, r3						\n"
-		"										\n"
-		"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
-		"	it eq								\n"
-		"	vldmiaeq r0!, {s16-s31}				\n"
-		"										\n"
-		"	msr psp, r0							\n"
-		"	bx r14								\n"
-		"										\n"
-		"	.align 4							\n"
-		"pxCurrentTCBConst: .word pxCurrentTCB	\n"
-		::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
-	);
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulDummy;
-
-	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
-{
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE );
-}
-/*-----------------------------------------------------------*/
-
-/* This is a naked function. */
-static void vPortEnableVFP( void )
-{
-	__asm volatile
-	(
-		"	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
-		"	ldr r1, [r0]				\n"
-		"								\n"
-		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
-		"	str r1, [r0]				\n"
-		"	bx r14						"
-	);
-}
-/*-----------------------------------------------------------*/
-
-static void prvSetupMPU( void )
-{
-#if defined( __ARMCC_VERSION )
-	/* Declaration when these variable are defined in code instead of being
-	 * exported from linker scripts. */
-	extern uint32_t * __privileged_functions_end__;
-	extern uint32_t * __FLASH_segment_start__;
-	extern uint32_t * __FLASH_segment_end__;
-	extern uint32_t * __privileged_data_start__;
-	extern uint32_t * __privileged_data_end__;
-#else
-	/* Declaration when these variable are exported from linker scripts. */
-	extern uint32_t __privileged_functions_end__[];
-	extern uint32_t __FLASH_segment_start__[];
-	extern uint32_t __FLASH_segment_end__[];
-	extern uint32_t __privileged_data_start__[];
-	extern uint32_t __privileged_data_end__[];
-#endif
-	/* Check the expected MPU is present. */
-	if( ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )  || ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE << 1 ))
-	{
-		/* First setup the entire flash for unprivileged read only access. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portUNPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the first nK for privileged only access (even though less
-		than 10K is actually being used).  This is where the kernel code is
-		placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged data RAM region.  This is where the kernel data
-		is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_RAM_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-										( portMPU_REGION_ENABLE );
-
-		/* By default allow everything to access the general peripherals.  The
-		system peripherals and registers are protected. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( portPERIPHERALS_START_ADDRESS ) |
-											( portMPU_REGION_VALID ) |
-											( portGENERAL_PERIPHERALS_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
-										( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Enable the memory fault exception. */
-		portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
-
-		/* Enable the MPU with the background region configured. */
-		portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes )
-{
-uint32_t ulRegionSize, ulReturnValue = 4;
-
-	/* 32 is the smallest region size, 31 is the largest valid value for
-	ulReturnValue. */
-	for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
-	{
-		if( ulActualSizeInBytes <= ulRegionSize )
-		{
-			break;
-		}
-		else
-		{
-			ulReturnValue++;
-		}
-	}
-
-	/* Shift the code by one before returning so it can be written directly
-	into the the correct bit position of the attribute register. */
-	return ( ulReturnValue << 1UL );
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control							\n" /* r0 = CONTROL. */
-	"	tst r0, #1								\n" /* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	"	ite ne									\n"
-	"	movne r0, #0							\n" /* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	"	moveq r0, #1							\n" /* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	"	bx lr									\n" /* Return. */
-	"											\n"
-	"	.align 4								\n"
-	::: "r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vResetPrivilege( void ) /* __attribute__ (( naked )) */
-{
-	__asm volatile
-	(
-	"	mrs r0, control							\n" /* r0 = CONTROL. */
-	"	orr r0, #1								\n" /* r0 = r0 | 1. */
-	"	msr control, r0							\n" /* CONTROL = r0. */
-	"	bx lr									\n" /* Return to the caller. */
-	:::"r0", "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-{
-#if defined( __ARMCC_VERSION )
-	/* Declaration when these variable are defined in code instead of being
-	 * exported from linker scripts. */
-	extern uint32_t * __SRAM_segment_start__;
-	extern uint32_t * __SRAM_segment_end__;
-	extern uint32_t * __privileged_data_start__;
-	extern uint32_t * __privileged_data_end__;
-#else
-	/* Declaration when these variable are exported from linker scripts. */
-	extern uint32_t __SRAM_segment_start__[];
-	extern uint32_t __SRAM_segment_end__[];
-	extern uint32_t __privileged_data_start__[];
-	extern uint32_t __privileged_data_end__[];
-#endif
-
-int32_t lIndex;
-uint32_t ul;
-
-	if( xRegions == NULL )
-	{
-		/* No MPU regions are specified so allow access to all RAM. */
-		xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-				( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION );
-
-		xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-				( portMPU_REGION_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Re-instate the privileged only RAM region as xRegion[ 0 ] will have
-		just removed the privileged only parameters. */
-		xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
-				( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION + 1 );
-
-		xMPUSettings->xRegion[ 1 ].ulRegionAttribute =
-				( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Invalidate all other regions. */
-		for( ul = 2; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-			xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-		}
-	}
-	else
-	{
-		/* This function is called automatically when the task is created - in
-		which case the stack region parameters will be valid.  At all other
-		times the stack parameters will not be valid and it is assumed that the
-		stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-					( ( uint32_t ) pxBottomOfStack ) |
-					( portMPU_REGION_VALID ) |
-					( portSTACK_REGION ); /* Region number. */
-
-			xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-					( portMPU_REGION_READ_WRITE ) | /* Read and write. */
-					( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
-					( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-					( portMPU_REGION_ENABLE );
-		}
-
-		lIndex = 0;
-
-		for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
-			{
-				/* Translate the generic region definition contained in
-				xRegions into the CM3 specific MPU settings that are then
-				stored in xMPUSettings. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
-						( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) |
-						( portMPU_REGION_VALID ) |
-						( portSTACK_REGION + ul ); /* Region number. */
-
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute =
-						( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
-						( xRegions[ lIndex ].ulParameters ) |
-						( portMPU_REGION_ENABLE );
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredicable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
-
-
diff --git a/osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/portmacro.h b/osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/portmacro.h
deleted file mode 100644
index 356b626..0000000
--- a/osal/src/freertos/portable/GCC/ARM_CM7_MPU/r0p1/portmacro.h
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Portion Copyright  2020 STMicroelectronics International N.V. All rights reserved.
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* MPU specific constants. */
-#define portUSING_MPU_WRAPPERS		1
-#define portPRIVILEGE_BIT			( 0x80000000UL )
-
-#define portMPU_REGION_READ_WRITE								( 0x03UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY						( 0x05UL << 24UL )
-#define portMPU_REGION_READ_ONLY								( 0x06UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE					( 0x01UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY	( 0x02UL << 24UL )
-#define portMPU_REGION_CACHEABLE_BUFFERABLE						( 0x03UL << 16UL )
-#define portMPU_REGION_EXECUTE_NEVER							( 0x01UL << 28UL )
-
-#define portUNPRIVILEGED_FLASH_REGION		( 0UL )
-#define portPRIVILEGED_FLASH_REGION			( 1UL )
-#define portPRIVILEGED_RAM_REGION			( 2UL )
-#define portGENERAL_PERIPHERALS_REGION		( 3UL )
-#define portSTACK_REGION					( 4UL )
-#define portFIRST_CONFIGURABLE_REGION	    ( 5UL )
-#define portLAST_CONFIGURABLE_REGION		( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS		( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS				( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-#define portSWITCH_TO_USER_MODE() __asm volatile ( " mrs r0, control \n orr r0, #1 \n msr control, r0 " ::: "r0", "memory" )
-
-typedef struct MPU_REGION_REGISTERS
-{
-	uint32_t ulRegionBaseAddress;
-	uint32_t ulRegionAttribute;
-} xMPU_REGION_REGISTERS;
-
-/* Plus 1 to create space for the stack region. */
-typedef struct MPU_SETTINGS
-{
-	xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS ];
-} xMPU_SETTINGS;
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* SVC numbers for various services. */
-#define portSVC_START_SCHEDULER				0
-#define portSVC_YIELD						1
-#define portSVC_RAISE_PRIVILEGE				2
-
-/* Scheduler utilities. */
-
-#define portYIELD()				__asm volatile ( "	SVC	%0	\n" :: "i" (portSVC_YIELD) : "memory" )
-#define portYIELD_WITHIN_API() 													\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__asm volatile( "dsb" ::: "memory" );										\
-	__asm volatile( "isb" );													\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Generic helper function. */
-	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
-	{
-	uint8_t ucReturn;
-
-		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
-		return ucReturn;
-	}
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-/*-----------------------------------------------------------*/
-
-extern BaseType_t xIsPrivileged( void );
-extern void vResetPrivilege( void );
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-#define portIS_PRIVILEGED()			xIsPrivileged()
-
-/**
- * @brief Raise an SVC request to raise privilege.
-*/
-#define portRAISE_PRIVILEGE()		__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- */
-#define portRESET_PRIVILEGE()		vResetPrivilege()
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mov %0, %1												\n"	\
-		"	cpsid i													\n" \
-		"	msr basepri, %0											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		"	cpsie i													\n" \
-		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-}
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
-
-	__asm volatile
-	(
-		"	mrs %0, basepri											\n" \
-		"	mov %1, %2												\n"	\
-		"	cpsid i													\n" \
-		"	msr basepri, %1											\n" \
-		"	isb														\n" \
-		"	dsb														\n" \
-		"	cpsie i													\n" \
-		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
-	);
-
-	/* This return will not be reached but is necessary to prevent compiler
-	warnings. */
-	return ulOriginalBASEPRI;
-}
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
-{
-	__asm volatile
-	(
-		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
-	);
-}
-/*-----------------------------------------------------------*/
-
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-
-#ifndef configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY
-	#warning "configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not defined. We recommend defining it to 1 in FreeRTOSConfig.h for better security. https://www.freertos.org/FreeRTOS-V10.3.x.html"
-	#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 0
-#endif
-/*-----------------------------------------------------------*/
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM0/port.c b/osal/src/freertos/portable/IAR/ARM_CM0/port.c
deleted file mode 100644
index bc9f256..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM0/port.c
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM0 port.
- *----------------------------------------------------------*/
-
-/* IAR includes. */
-#include "intrinsics.h"
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* Constants required to manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_INT_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t *) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_CLK_BIT			( 1UL << 2UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY	( 255UL )
-#define portNVIC_PENDSV_PRI			( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI		( portMIN_INTERRUPT_PRIORITY << 24UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR			( 0x01000000 )
-
-/* For backward compatibility, ensure configKERNEL_INTERRUPT_PRIORITY is
-defined.  The value 255 should also ensure backward compatibility.
-FreeRTOS.org versions prior to V4.3.0 did not include this definition. */
-#ifndef configKERNEL_INTERRUPT_PRIORITY
-	#define configKERNEL_INTERRUPT_PRIORITY 0
-#endif
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#ifndef portMISSED_COUNTS_FACTOR
-	#define portMISSED_COUNTS_FACTOR			( 45UL )
-#endif
-
-/* The number of SysTick increments that make up one tick period. */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/* The maximum number of tick periods that can be suppressed is limited by the
-24 bit resolution of the SysTick timer. */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/* Compensate for the CPU cycles that pass while the SysTick is stopped (low
-power functionality only. */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-#pragma weak vPortSetupTimerInterrupt
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortSysTickHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-extern void vPortStartFirstTask( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-	pxTopOfStack -= 8; /* R11..R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortYield( void )
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET;
-
-	/* Barriers are normally not required but do ensure the code is completely
-	within the specified behaviour for the architecture. */
-	__DSB();
-	__ISB();
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-	__DSB();
-	__ISB();
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-{
-uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-TickType_t xModifiableIdleTime;
-
-	/* Make sure the SysTick reload value does not overflow the counter. */
-	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-	{
-		xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-	}
-
-	/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-	is accounted for as best it can be, but using the tickless mode will
-	inevitably result in some tiny drift of the time maintained by the
-	kernel with respect to calendar time. */
-	portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-	/* Calculate the reload value required to wait xExpectedIdleTime
-	tick periods.  -1 is used because this code will execute part way
-	through one of the tick periods. */
-	ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-	if( ulReloadValue > ulStoppedTimerCompensation )
-	{
-		ulReloadValue -= ulStoppedTimerCompensation;
-	}
-
-	/* Enter a critical section but don't use the taskENTER_CRITICAL()
-	method as that will mask interrupts that should exit sleep mode. */
-	__disable_interrupt();
-	__DSB();
-	__ISB();
-
-	/* If a context switch is pending or a task is waiting for the scheduler
-	to be unsuspended then abandon the low power entry. */
-	if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-	{
-		/* Restart from whatever is left in the count register to complete
-		this tick period. */
-		portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-		/* Restart SysTick. */
-		portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Reset the reload register to the value required for normal tick
-		periods. */
-		portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-		/* Re-enable interrupts - see comments above __disable_interrupt()
-		call above. */
-		__enable_interrupt();
-	}
-	else
-	{
-		/* Set the new reload value. */
-		portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-		/* Clear the SysTick count flag and set the count value back to
-		zero. */
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-		/* Restart SysTick. */
-		portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-		set its parameter to 0 to indicate that its implementation contains
-		its own wait for interrupt or wait for event instruction, and so wfi
-		should not be executed again.  However, the original expected idle
-		time variable must remain unmodified, so a copy is taken. */
-		xModifiableIdleTime = xExpectedIdleTime;
-		configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-		if( xModifiableIdleTime > 0 )
-		{
-			__DSB();
-			__WFI();
-			__ISB();
-		}
-		configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-		/* Re-enable interrupts to allow the interrupt that brought the MCU
-		out of sleep mode to execute immediately.  see comments above
-		__disable_interrupt() call above. */
-		__enable_interrupt();
-		__DSB();
-		__ISB();
-
-		/* Disable interrupts again because the clock is about to be stopped
-		and interrupts that execute while the clock is stopped will increase
-		any slippage between the time maintained by the RTOS and calendar
-		time. */
-		__disable_interrupt();
-		__DSB();
-		__ISB();
-
-		/* Disable the SysTick clock without reading the
-		portNVIC_SYSTICK_CTRL_REG register to ensure the
-		portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-		the time the SysTick is stopped for is accounted for as best it can
-		be, but using the tickless mode will inevitably result in some tiny
-		drift of the time maintained by the kernel with respect to calendar
-		time*/
-		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-		/* Determine if the SysTick clock has already counted to zero and
-		been set back to the current reload value (the reload back being
-		correct for the entire expected idle time) or if the SysTick is yet
-		to count to zero (in which case an interrupt other than the SysTick
-		must have brought the system out of sleep mode). */
-		if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-		{
-			uint32_t ulCalculatedLoadValue;
-
-			/* The tick interrupt is already pending, and the SysTick count
-			reloaded with ulReloadValue.  Reset the
-			portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-			period. */
-			ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-			/* Don't allow a tiny value, or values that have somehow
-			underflowed because the post sleep hook did something
-			that took too long. */
-			if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-			{
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-			}
-
-			portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-			/* As the pending tick will be processed as soon as this
-			function exits, the tick value maintained by the tick is stepped
-			forward by one less than the time spent waiting. */
-			ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-		}
-		else
-		{
-			/* Something other than the tick interrupt ended the sleep.
-			Work out how long the sleep lasted rounded to complete tick
-			periods (not the ulReload value which accounted for part
-			ticks). */
-			ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG ;
-
-			/* How many complete tick periods passed while the processor
-			was waiting? */
-			ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-			/* The reload value is set to whatever fraction of a single tick
-			period remains. */
-			portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-		}
-
-		/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-		again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-		value. */
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-		portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-		vTaskStepTick( ulCompleteTickPeriods );
-		portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-		/* Exit with interrpts enabled. */
-		__enable_interrupt();
-	}
-}
-
-#endif /* configUSE_TICKLESS_IDLE */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM0/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM0/portasm.s
deleted file mode 100644
index d5a7154..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM0/portasm.s
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#include <FreeRTOSConfig.h>
-
-	RSEG    CODE:CODE(2)
-	thumb
-
-	EXTERN vPortYieldFromISR
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-
-	PUBLIC vSetMSP
-	PUBLIC xPortPendSVHandler
-	PUBLIC vPortSVCHandler
-	PUBLIC vPortStartFirstTask
-	PUBLIC ulSetInterruptMaskFromISR
-	PUBLIC vClearInterruptMaskFromISR
-
-/*-----------------------------------------------------------*/
-
-vSetMSP
-	msr msp, r0
-	bx lr
-
-/*-----------------------------------------------------------*/
-
-xPortPendSVHandler:
-	mrs r0, psp
-
-	ldr	r3, =pxCurrentTCB	/* Get the location of the current TCB. */
-	ldr	r2, [r3]
-
-	subs r0, r0, #32		/* Make space for the remaining low registers. */
-	str r0, [r2]			/* Save the new top of stack. */
-	stmia r0!, {r4-r7}		/* Store the low registers that are not saved automatically. */
-	mov r4, r8				/* Store the high registers. */
-	mov r5, r9
-	mov r6, r10
-	mov r7, r11
-	stmia r0!, {r4-r7}
-
-	push {r3, r14}
-	cpsid i
-	bl vTaskSwitchContext
-	cpsie i
-	pop {r2, r3}			/* lr goes in r3. r2 now holds tcb pointer. */
-
-	ldr r1, [r2]
-	ldr r0, [r1]			/* The first item in pxCurrentTCB is the task top of stack. */
-	adds r0, r0, #16		/* Move to the high registers. */
-	ldmia r0!, {r4-r7}		/* Pop the high registers. */
-	mov r8, r4
-	mov r9, r5
-	mov r10, r6
-	mov r11, r7
-
-	msr psp, r0				/* Remember the new top of stack for the task. */
-
-	subs r0, r0, #32		/* Go back for the low registers that are not automatically restored. */
-	ldmia r0!, {r4-r7}		/* Pop low registers.  */
-
-	bx r3
-
-/*-----------------------------------------------------------*/
-
-vPortSVCHandler;
-	/* This function is no longer used, but retained for backward
-	compatibility. */
-	bx lr
-
-/*-----------------------------------------------------------*/
-
-vPortStartFirstTask
-	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
-	table offset register that can be used to locate the initial stack value.
-	Not all M0 parts have the application vector table at address 0. */
-
-	ldr	r3, =pxCurrentTCB	/* Obtain location of pxCurrentTCB. */
-	ldr r1, [r3]
-	ldr r0, [r1]			/* The first item in pxCurrentTCB is the task top of stack. */
-	adds r0, #32			/* Discard everything up to r0. */
-	msr psp, r0				/* This is now the new top of stack to use in the task. */
-	movs r0, #2				/* Switch to the psp stack. */
-	msr CONTROL, r0
-	isb
-	pop {r0-r5}				/* Pop the registers that are saved automatically. */
-	mov lr, r5				/* lr is now in r5. */
-	pop {r3}				/* The return address is now in r3. */
-	pop {r2}				/* Pop and discard the XPSR. */
-	cpsie i					/* The first task has its context and interrupts can be enabled. */
-	bx r3					/* Jump to the user defined task code. */
-
-/*-----------------------------------------------------------*/
-
-ulSetInterruptMaskFromISR
-	mrs r0, PRIMASK
-	cpsid i
-	bx lr
-
-/*-----------------------------------------------------------*/
-
-vClearInterruptMaskFromISR
-	msr PRIMASK, r0
-	bx lr
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM0/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM0/portmacro.h
deleted file mode 100644
index dabe18e..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM0/portmacro.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-
-/* Scheduler utilities. */
-extern void vPortYield( void );
-#define portNVIC_INT_CTRL			( ( volatile uint32_t *) 0xe000ed04 )
-#define portNVIC_PENDSVSET			0x10000000
-#define portYIELD()					vPortYield()
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) 	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-
-/* Critical section management. */
-
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-extern uint32_t ulSetInterruptMaskFromISR( void );
-extern void vClearInterruptMaskFromISR( uint32_t ulMask );
-
-#define portDISABLE_INTERRUPTS()				__asm volatile( "cpsid i" )
-#define portENABLE_INTERRUPTS()					__asm volatile( "cpsie i" )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulSetInterruptMaskFromISR()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vClearInterruptMaskFromISR( x )
-
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-
-#define portNOP()
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
-the source code because to do so would cause other compilers to generate
-warnings. */
-#pragma diag_suppress=Pa082
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/port.c b/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.h b/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.s
deleted file mode 100644
index ccab3f8..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portasm.s
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-	EXTERN pxCurrentTCB
-	EXTERN xSecureContext
-	EXTERN vTaskSwitchContext
-	EXTERN vPortSVCHandler_C
-	EXTERN SecureContext_SaveContext
-	EXTERN SecureContext_LoadContext
-
-	PUBLIC xIsPrivileged
-	PUBLIC vResetPrivilege
-	PUBLIC vPortAllocateSecureContext
-	PUBLIC vRestoreContextOfFirstTask
-	PUBLIC vRaisePrivilege
-	PUBLIC vStartFirstTask
-	PUBLIC ulSetInterruptMask
-	PUBLIC vClearInterruptMask
-	PUBLIC PendSV_Handler
-	PUBLIC SVC_Handler
-	PUBLIC vPortFreeSecureContext
-
-#if ( configENABLE_FPU == 1 )
-	#error Cortex-M23 does not have a Floating Point Unit (FPU) and therefore configENABLE_FPU must be set to 0.
-#endif
-/*-----------------------------------------------------------*/
-
-/*---------------- Unprivileged Functions -------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION .text:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-xIsPrivileged:
-	mrs r0, control							/* r0 = CONTROL. */
-	movs r1, #1								/* r1 = 1. */
-	tst r0, r1								/* Perform r0 & r1 (bitwise AND) and update the conditions flag. */
-	beq running_privileged					/* If the result of previous AND operation was 0, branch. */
-	movs r0, #0								/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	bx lr									/* Return. */
-	running_privileged:
-		movs r0, #1							/* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-		bx lr								/* Return. */
-/*-----------------------------------------------------------*/
-
-vResetPrivilege:
-	mrs r0, control							/* r0 = CONTROL. */
-	movs r1, #1								/* r1 = 1. */
-	orrs r0, r1								/* r0 = r0 | r1. */
-	msr control, r0							/* CONTROL = r0. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-vPortAllocateSecureContext:
-	svc 0									/* Secure context is allocated in the supervisor call. portSVC_ALLOCATE_SECURE_CONTEXT = 0. */
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-/*----------------- Privileged Functions --------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION privileged_functions:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-vRestoreContextOfFirstTask:
-	ldr  r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr  r3, [r2]							/* Read pxCurrentTCB. */
-	ldr  r0, [r3]							/* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-
-#if ( configENABLE_MPU == 1 )
-	dmb										/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	movs r5, #1								/* r5 = 1. */
-	bics r4, r5								/* r4 = r4 & ~r5 i.e. Clear the bit 0 in r4. */
-	str r4, [r2]							/* Disable MPU. */
-
-	adds r3, #4								/* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-	ldr  r4, [r3]							/* r4 = *r3 i.e. r4 = MAIR0. */
-	ldr  r2, =0xe000edc0					/* r2 = 0xe000edc0 [Location of MAIR0]. */
-	str  r4, [r2]							/* Program MAIR0. */
-	ldr  r2, =0xe000ed98					/* r2 = 0xe000ed98 [Location of RNR]. */
-	adds r3, #4								/* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-	movs r5, #4								/* r5 = 4. */
-	str  r5, [r2]							/* Program RNR = 4. */
-	ldmia r3!, {r6,r7}						/* Read first set of RBAR/RLAR from TCB. */
-	ldr  r4, =0xe000ed9c					/* r4 = 0xe000ed9c [Location of RBAR]. */
-	stmia r4!, {r6,r7}						/* Write first set of RBAR/RLAR registers. */
-	movs r5, #5								/* r5 = 5. */
-	str  r5, [r2]							/* Program RNR = 5. */
-	ldmia r3!, {r6,r7}						/* Read second set of RBAR/RLAR from TCB. */
-	ldr  r4, =0xe000ed9c					/* r4 = 0xe000ed9c [Location of RBAR]. */
-	stmia r4!, {r6,r7}						/* Write second set of RBAR/RLAR registers. */
-	movs r5, #6								/* r5 = 6. */
-	str  r5, [r2]							/* Program RNR = 6. */
-	ldmia r3!, {r6,r7}						/* Read third set of RBAR/RLAR from TCB. */
-	ldr  r4, =0xe000ed9c					/* r4 = 0xe000ed9c [Location of RBAR]. */
-	stmia r4!, {r6,r7}						/* Write third set of RBAR/RLAR registers. */
-	movs r5, #7								/* r5 = 7. */
-	str  r5, [r2]							/* Program RNR = 7. */
-	ldmia r3!, {r6,r7}						/* Read fourth set of RBAR/RLAR from TCB. */
-	ldr  r4, =0xe000ed9c					/* r4 = 0xe000ed9c [Location of RBAR]. */
-	stmia r4!, {r6,r7}						/* Write fourth set of RBAR/RLAR registers. */
-
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	movs r5, #1								/* r5 = 1. */
-	orrs r4, r5								/* r4 = r4 | r5 i.e. Set the bit 0 in r4. */
-	str r4, [r2]							/* Enable MPU. */
-	dsb										/* Force memory writes before continuing. */
-#endif /* configENABLE_MPU */
-
-#if ( configENABLE_MPU == 1 )
-	ldm  r0!, {r1-r4}						/* Read from stack - r1 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = EXC_RETURN. */
-	ldr  r5, =xSecureContext
-	str  r1, [r5]							/* Set xSecureContext to this task's value for the same. */
-	msr  psplim, r2							/* Set this task's PSPLIM value. */
-	msr  control, r3						/* Set this task's CONTROL value. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r4									/* Finally, branch to EXC_RETURN. */
-#else /* configENABLE_MPU */
-	ldm  r0!, {r1-r3}						/* Read from stack - r1 = xSecureContext, r2 = PSPLIM and r3 = EXC_RETURN. */
-	ldr  r4, =xSecureContext
-	str  r1, [r4]							/* Set xSecureContext to this task's value for the same. */
-	msr  psplim, r2							/* Set this task's PSPLIM value. */
-	movs r1, #2								/* r1 = 2. */
-	msr  CONTROL, r1						/* Switch to use PSP in the thread mode. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r3									/* Finally, branch to EXC_RETURN. */
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-vRaisePrivilege:
-	mrs r0, control							/* Read the CONTROL register. */
-	movs r1, #1								/* r1 = 1. */
-	bics r0, r1								/* Clear the bit 0. */
-	msr control, r0							/* Write back the new CONTROL value. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-vStartFirstTask:
-	ldr r0, =0xe000ed08						/* Use the NVIC offset register to locate the stack. */
-	ldr r0, [r0]							/* Read the VTOR register which gives the address of vector table. */
-	ldr r0, [r0]							/* The first entry in vector table is stack pointer. */
-	msr msp, r0								/* Set the MSP back to the start of the stack. */
-	cpsie i									/* Globally enable interrupts. */
-	dsb
-	isb
-	svc 2									/* System call to start the first task. portSVC_START_SCHEDULER = 2. */
-/*-----------------------------------------------------------*/
-
-ulSetInterruptMask:
-	mrs r0, PRIMASK
-	cpsid i
-	bx lr
-/*-----------------------------------------------------------*/
-
-vClearInterruptMask:
-	msr PRIMASK, r0
-	bx lr
-/*-----------------------------------------------------------*/
-
-PendSV_Handler:
-	mrs r1, psp								/* Read PSP in r1. */
-	ldr r2, =xSecureContext					/* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	ldr r0, [r2]							/* Read xSecureContext - Value of xSecureContext must be in r0 as it is used as a parameter later. */
-
-	cbz r0, save_ns_context					/* No secure context to save. */
-	push {r0-r2, r14}
-	bl SecureContext_SaveContext
-	pop {r0-r3}								/* LR is now in r3. */
-	mov lr, r3								/* LR = r3. */
-	lsls r2, r3, #25						/* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	bpl save_ns_context						/* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	ldr r3, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr r2, [r3]							/* Read pxCurrentTCB. */
-#if ( configENABLE_MPU == 1 )
-	subs r1, r1, #16						/* Make space for xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	str r1, [r2]							/* Save the new top of stack in TCB. */
-	mrs r2, psplim							/* r2 = PSPLIM. */
-	mrs r3, control							/* r3 = CONTROL. */
-	mov r4, lr								/* r4 = LR/EXC_RETURN. */
-	stmia r1!, {r0, r2-r4}					/* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-#else /* configENABLE_MPU */
-	subs r1, r1, #12						/* Make space for xSecureContext, PSPLIM and LR on the stack. */
-	str r1, [r2]							/* Save the new top of stack in TCB. */
-	mrs r2, psplim							/* r2 = PSPLIM. */
-	mov r3, lr								/* r3 = LR/EXC_RETURN. */
-	stmia r1!, {r0, r2-r3}					/* Store xSecureContext, PSPLIM and LR on the stack. */
-#endif /* configENABLE_MPU */
-	b select_next_task
-
-	save_ns_context:
-		ldr r3, =pxCurrentTCB				/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-		ldr r2, [r3]						/* Read pxCurrentTCB. */
-	#if ( configENABLE_MPU == 1 )
-		subs r1, r1, #48					/* Make space for xSecureContext, PSPLIM, CONTROL, LR and the remaining registers on the stack. */
-		str r1, [r2]						/* Save the new top of stack in TCB. */
-		adds r1, r1, #16					/* r1 = r1 + 16. */
-		stmia r1!, {r4-r7}					/* Store the low registers that are not saved automatically. */
-		mov r4, r8							/* r4 = r8. */
-		mov r5, r9							/* r5 = r9. */
-		mov r6, r10							/* r6 = r10. */
-		mov r7, r11							/* r7 = r11. */
-		stmia r1!, {r4-r7}					/* Store the high registers that are not saved automatically. */
-		mrs r2, psplim						/* r2 = PSPLIM. */
-		mrs r3, control						/* r3 = CONTROL. */
-		mov r4, lr							/* r4 = LR/EXC_RETURN. */
-		subs r1, r1, #48					/* r1 = r1 - 48. */
-		stmia r1!, {r0, r2-r4}				/* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	#else /* configENABLE_MPU */
-		subs r1, r1, #44					/* Make space for xSecureContext, PSPLIM, LR and the remaining registers on the stack. */
-		str r1, [r2]						/* Save the new top of stack in TCB. */
-		mrs r2, psplim						/* r2 = PSPLIM. */
-		mov r3, lr							/* r3 = LR/EXC_RETURN. */
-		stmia r1!, {r0, r2-r7}				/* Store xSecureContext, PSPLIM, LR and the low registers that are not saved automatically. */
-		mov r4, r8							/* r4 = r8. */
-		mov r5, r9							/* r5 = r9. */
-		mov r6, r10							/* r6 = r10. */
-		mov r7, r11							/* r7 = r11. */
-		stmia r1!, {r4-r7}					/* Store the high registers that are not saved automatically. */
-	#endif /* configENABLE_MPU */
-
-	select_next_task:
-		cpsid i
-		bl vTaskSwitchContext
-		cpsie i
-
-		ldr r2, =pxCurrentTCB				/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-		ldr r3, [r2]						/* Read pxCurrentTCB. */
-		ldr r1, [r3]						/* The first item in pxCurrentTCB is the task top of stack. r1 now points to the top of stack. */
-
-	#if ( configENABLE_MPU == 1 )
-		dmb									/* Complete outstanding transfers before disabling MPU. */
-		ldr r2, =0xe000ed94					/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-		ldr r4, [r2]						/* Read the value of MPU_CTRL. */
-		movs r5, #1							/* r5 = 1. */
-		bics r4, r5							/* r4 = r4 & ~r5 i.e. Clear the bit 0 in r4. */
-		str r4, [r2]						/* Disable MPU. */
-
-		adds r3, #4							/* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-		ldr r4, [r3]						/* r4 = *r3 i.e. r4 = MAIR0. */
-		ldr r2, =0xe000edc0					/* r2 = 0xe000edc0 [Location of MAIR0]. */
-		str r4, [r2]						/* Program MAIR0. */
-		ldr r2, =0xe000ed98					/* r2 = 0xe000ed98 [Location of RNR]. */
-		adds r3, #4							/* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-		movs r5, #4							/* r5 = 4. */
-		str  r5, [r2]						/* Program RNR = 4. */
-		ldmia r3!, {r6,r7}					/* Read first set of RBAR/RLAR from TCB. */
-		ldr  r4, =0xe000ed9c				/* r4 = 0xe000ed9c [Location of RBAR]. */
-		stmia r4!, {r6,r7}					/* Write first set of RBAR/RLAR registers. */
-		movs r5, #5							/* r5 = 5. */
-		str  r5, [r2]						/* Program RNR = 5. */
-		ldmia r3!, {r6,r7}					/* Read second set of RBAR/RLAR from TCB. */
-		ldr  r4, =0xe000ed9c				/* r4 = 0xe000ed9c [Location of RBAR]. */
-		stmia r4!, {r6,r7}					/* Write second set of RBAR/RLAR registers. */
-		movs r5, #6							/* r5 = 6. */
-		str  r5, [r2]						/* Program RNR = 6. */
-		ldmia r3!, {r6,r7}					/* Read third set of RBAR/RLAR from TCB. */
-		ldr  r4, =0xe000ed9c				/* r4 = 0xe000ed9c [Location of RBAR]. */
-		stmia r4!, {r6,r7}					/* Write third set of RBAR/RLAR registers. */
-		movs r5, #7							/* r5 = 7. */
-		str  r5, [r2]						/* Program RNR = 7. */
-		ldmia r3!, {r6,r7}					/* Read fourth set of RBAR/RLAR from TCB. */
-		ldr  r4, =0xe000ed9c				/* r4 = 0xe000ed9c [Location of RBAR]. */
-		stmia r4!, {r6,r7}					/* Write fourth set of RBAR/RLAR registers. */
-
-		ldr r2, =0xe000ed94					/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-		ldr r4, [r2]						/* Read the value of MPU_CTRL. */
-		movs r5, #1							/* r5 = 1. */
-		orrs r4, r5							/* r4 = r4 | r5 i.e. Set the bit 0 in r4. */
-		str r4, [r2]						/* Enable MPU. */
-		dsb									/* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-
-	#if ( configENABLE_MPU == 1 )
-		ldmia r1!, {r0, r2-r4}				/* Read from stack - r0 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = LR. */
-		msr psplim, r2						/* Restore the PSPLIM register value for the task. */
-		msr control, r3						/* Restore the CONTROL register value for the task. */
-		mov lr, r4							/* LR = r4. */
-		ldr r2, =xSecureContext				/* Read the location of xSecureContext i.e. &( xSecureContext ). */
-		str r0, [r2]						/* Restore the task's xSecureContext. */
-		cbz r0, restore_ns_context			/* If there is no secure context for the task, restore the non-secure context. */
-		push {r1,r4}
-		bl SecureContext_LoadContext		/* Restore the secure context. */
-		pop {r1,r4}
-		mov lr, r4							/* LR = r4. */
-		lsls r2, r4, #25					/* r2 = r4 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-		bpl restore_ns_context				/* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-		msr psp, r1							/* Remember the new top of stack for the task. */
-		bx lr
-	#else /* configENABLE_MPU */
-		ldmia r1!, {r0, r2-r3}				/* Read from stack - r0 = xSecureContext, r2 = PSPLIM and r3 = LR. */
-		msr psplim, r2						/* Restore the PSPLIM register value for the task. */
-		mov lr, r3							/* LR = r3. */
-		ldr r2, =xSecureContext				/* Read the location of xSecureContext i.e. &( xSecureContext ). */
-		str r0, [r2]						/* Restore the task's xSecureContext. */
-		cbz r0, restore_ns_context			/* If there is no secure context for the task, restore the non-secure context. */
-		push {r1,r3}
-		bl SecureContext_LoadContext		/* Restore the secure context. */
-		pop {r1,r3}
-		mov lr, r3							/* LR = r3. */
-		lsls r2, r3, #25					/* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-		bpl restore_ns_context				/* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-		msr psp, r1							/* Remember the new top of stack for the task. */
-		bx lr
-	#endif /* configENABLE_MPU */
-
-	restore_ns_context:
-		adds r1, r1, #16					/* Move to the high registers. */
-		ldmia r1!, {r4-r7}					/* Restore the high registers that are not automatically restored. */
-		mov r8, r4							/* r8 = r4. */
-		mov r9, r5							/* r9 = r5. */
-		mov r10, r6							/* r10 = r6. */
-		mov r11, r7							/* r11 = r7. */
-		msr psp, r1							/* Remember the new top of stack for the task. */
-		subs r1, r1, #32					/* Go back to the low registers. */
-		ldmia r1!, {r4-r7}					/* Restore the low registers that are not automatically restored. */
-		bx lr
-/*-----------------------------------------------------------*/
-
-SVC_Handler:
-	movs r0, #4
-	mov r1, lr
-	tst r0, r1
-	beq stacking_used_msp
-	mrs r0, psp
-	b vPortSVCHandler_C
-	stacking_used_msp:
-		mrs r0, msp
-		b vPortSVCHandler_C
-/*-----------------------------------------------------------*/
-
-vPortFreeSecureContext:
-	ldr r1, [r0]							/* The first item in the TCB is the top of the stack. */
-	ldr r0, [r1]							/* The first item on the stack is the task's xSecureContext. */
-	cmp r0, #0								/* Raise svc if task's xSecureContext is not NULL. */
-	beq free_secure_context
-	bx lr									/* There is no secure context (xSecureContext is NULL). */
-	free_secure_context:
-		svc 1								/* Secure context is freed in the supervisor call. portSVC_FREE_SECURE_CONTEXT = 1. */
-		bx lr								/* Return. */
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portmacro.h
deleted file mode 100644
index 2fa4ba6..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/non_secure/portmacro.h
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M23"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__root
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							__asm volatile ( " cpsid i " ::: "memory" )
-#define portENABLE_INTERRUPTS()								__asm volatile ( " cpsie i " ::: "memory" )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
- * the source code because to do so would cause other compilers to generate
- * warnings. */
-#pragma diag_suppress=Be006
-#pragma diag_suppress=Pa082
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.c b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.c
deleted file mode 100644
index b19f801..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.c
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief CONTROL value for privileged tasks.
- *
- * Bit[0] - 0 --> Thread mode is privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_PRIVILEGED		0x02
-
-/**
- * @brief CONTROL value for un-privileged tasks.
- *
- * Bit[0] - 1 --> Thread mode is un-privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_UNPRIVILEGED		0x03
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Structure to represent secure context.
- *
- * @note Since stack grows down, pucStackStart is the highest address while
- * pucStackLimit is the first addess of the allocated memory.
- */
-typedef struct SecureContext
-{
-	uint8_t *pucCurrentStackPointer;	/**< Current value of stack pointer (PSP). */
-	uint8_t *pucStackLimit;				/**< Last location of the stack memory (PSPLIM). */
-	uint8_t *pucStackStart;				/**< First location of the stack memory. */
-} SecureContext_t;
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_Init( void )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* No stack for thread mode until a task's context is loaded. */
-		secureportSET_PSPLIM( securecontextNO_STACK );
-		secureportSET_PSP( securecontextNO_STACK );
-
-		#if( configENABLE_MPU == 1 )
-		{
-			/* Configure thread mode to use PSP and to be unprivileged. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_UNPRIVILEGED );
-		}
-		#else /* configENABLE_MPU */
-		{
-			/* Configure thread mode to use PSP and to be privileged.. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_PRIVILEGED );
-		}
-		#endif /* configENABLE_MPU */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged )
-#else /* configENABLE_MPU */
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize )
-#endif /* configENABLE_MPU */
-{
-	uint8_t *pucStackMemory = NULL;
-	uint32_t ulIPSR;
-	SecureContextHandle_t xSecureContextHandle = NULL;
-	#if( configENABLE_MPU == 1 )
-		uint32_t *pulCurrentStackPointer = NULL;
-	#endif /* configENABLE_MPU */
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Allocate the context structure. */
-		xSecureContextHandle = ( SecureContextHandle_t ) pvPortMalloc( sizeof( SecureContext_t ) );
-
-		if( xSecureContextHandle != NULL )
-		{
-			/* Allocate the stack space. */
-			pucStackMemory = pvPortMalloc( ulSecureStackSize );
-
-			if( pucStackMemory != NULL )
-			{
-				/* Since stack grows down, the starting point will be the last
-				 * location. Note that this location is next to the last
-				 * allocated byte because the hardware decrements the stack
-				 * pointer before writing i.e. if stack pointer is 0x2, a push
-				 * operation will decrement the stack pointer to 0x1 and then
-				 * write at 0x1. */
-				xSecureContextHandle->pucStackStart = pucStackMemory + ulSecureStackSize;
-
-				/* The stack cannot go beyond this location. This value is
-				 * programmed in the PSPLIM register on context switch.*/
-				xSecureContextHandle->pucStackLimit = pucStackMemory;
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Store the correct CONTROL value for the task on the stack.
-					 * This value is programmed in the CONTROL register on
-					 * context switch. */
-					pulCurrentStackPointer = ( uint32_t * ) xSecureContextHandle->pucStackStart;
-					pulCurrentStackPointer--;
-					if( ulIsTaskPrivileged )
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_PRIVILEGED;
-					}
-					else
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_UNPRIVILEGED;
-					}
-
-					/* Store the current stack pointer. This value is programmed in
-					 * the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = ( uint8_t * ) pulCurrentStackPointer;
-				}
-				#else /* configENABLE_MPU */
-				{
-					/* Current SP is set to the starting of the stack. This
-					 * value programmed in the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = xSecureContextHandle->pucStackStart;
-
-				}
-				#endif /* configENABLE_MPU */
-			}
-			else
-			{
-				/* Free the context to avoid memory leak and make sure to return
-				 * NULL to indicate failure. */
-				vPortFree( xSecureContextHandle );
-				xSecureContextHandle = NULL;
-			}
-		}
-	}
-
-	return xSecureContextHandle;
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Ensure that valid parameters are passed. */
-		secureportASSERT( xSecureContextHandle != NULL );
-
-		/* Free the stack space. */
-		vPortFree( xSecureContextHandle->pucStackLimit );
-
-		/* Free the context itself. */
-		vPortFree( xSecureContextHandle );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.h b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.h
deleted file mode 100644
index 7323f8f..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_CONTEXT_H__
-#define __SECURE_CONTEXT_H__
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* FreeRTOS includes. */
-#include "FreeRTOSConfig.h"
-
-/**
- * @brief PSP value when no task's context is loaded.
- */
-#define securecontextNO_STACK	0x0
-
-/**
- * @brief Opaque handle.
- */
-struct SecureContext;
-typedef struct SecureContext*	SecureContextHandle_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Initializes the secure context management system.
- *
- * PSP is set to NULL and therefore a task must allocate and load a context
- * before calling any secure side function in the thread mode.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureContext_Init( void );
-
-/**
- * @brief Allocates a context on the secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] ulSecureStackSize Size of the stack to allocate on secure side.
- * @param[in] ulIsTaskPrivileged 1 if the calling task is privileged, 0 otherwise.
- *
- * @return Opaque context handle if context is successfully allocated, NULL
- * otherwise.
- */
-#if( configENABLE_MPU == 1 )
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged );
-#else /* configENABLE_MPU */
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize );
-#endif /* configENABLE_MPU */
-
-/**
- * @brief Frees the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the
- * context to be freed.
- */
-void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Loads the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be loaded.
- */
-void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Saves the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be saved.
- */
-void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle );
-
-#endif /* __SECURE_CONTEXT_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port.c b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port.c
deleted file mode 100644
index e09bd97..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/* Functions implemented in assembler file. */
-extern void SecureContext_LoadContextAsm( SecureContextHandle_t xSecureContextHandle );
-extern void SecureContext_SaveContextAsm( SecureContextHandle_t xSecureContextHandle );
-
-secureportNON_SECURE_CALLABLE void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle )
-{
-	SecureContext_LoadContextAsm( xSecureContextHandle );
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle )
-{
-	SecureContext_SaveContextAsm( xSecureContextHandle );
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port_asm.s b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port_asm.s
deleted file mode 100644
index d7bc0de..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_context_port_asm.s
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-	SECTION .text:CODE:NOROOT(2)
-	THUMB
-
-	PUBLIC SecureContext_LoadContextAsm
-	PUBLIC SecureContext_SaveContextAsm
-
-#if ( configENABLE_FPU == 1 )
-	#error Cortex-M23 does not have a Floating Point Unit (FPU) and therefore configENABLE_FPU must be set to 0.
-#endif
-/*-----------------------------------------------------------*/
-
-SecureContext_LoadContextAsm:
-	/* xSecureContextHandle value is in r0. */
-	mrs r1, ipsr							/* r1 = IPSR. */
-	cbz r1, load_ctx_therad_mode			/* Do nothing if the processor is running in the Thread Mode. */
-	ldmia r0!, {r1, r2}						/* r1 = xSecureContextHandle->pucCurrentStackPointer, r2 = xSecureContextHandle->pucStackLimit. */
-#if ( configENABLE_MPU == 1 )
-	ldmia r1!, {r3}							/* Read CONTROL register value from task's stack. r3 = CONTROL. */
-	msr control, r3							/* CONTROL = r3. */
-#endif /* configENABLE_MPU */
-	msr psplim, r2							/* PSPLIM = r2. */
-	msr psp, r1								/* PSP = r1. */
-
-	load_ctx_therad_mode:
-		bx lr
-/*-----------------------------------------------------------*/
-
-SecureContext_SaveContextAsm:
-	/* xSecureContextHandle value is in r0. */
-	mrs r1, ipsr							/* r1 = IPSR. */
-	cbz r1, save_ctx_therad_mode			/* Do nothing if the processor is running in the Thread Mode. */
-	mrs r1, psp								/* r1 = PSP. */
-#if ( configENABLE_MPU == 1 )
-	mrs r2, control							/* r2 = CONTROL. */
-	subs r1, r1, #4							/* Make space for the CONTROL value on the stack. */
-	str r1, [r0]							/* Save the top of stack in context. xSecureContextHandle->pucCurrentStackPointer = r1. */
-	stmia r1!, {r2}							/* Store CONTROL value on the stack. */
-#else /* configENABLE_MPU */
-	str r1, [r0]							/* Save the top of stack in context. xSecureContextHandle->pucCurrentStackPointer = r1. */
-#endif /* configENABLE_MPU */
-	movs r1, #0								/* r1 = securecontextNO_STACK. */
-	msr psplim, r1							/* PSPLIM = securecontextNO_STACK. */
-	msr psp, r1								/* PSP = securecontextNO_STACK i.e. No stack for thread mode until next task's context is loaded. */
-
-	save_ctx_therad_mode:
-		bx lr
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.c b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.c
deleted file mode 100644
index 098f24e..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.c
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure context heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Total heap size.
- */
-#define secureconfigTOTAL_HEAP_SIZE		( ( ( size_t ) ( 10 * 1024 ) ) )
-
-/* No test marker by default. */
-#ifndef mtCOVERAGE_TEST_MARKER
-	#define mtCOVERAGE_TEST_MARKER()
-#endif
-
-/* No tracing by default. */
-#ifndef traceMALLOC
-	#define traceMALLOC( pvReturn, xWantedSize )
-#endif
-
-/* No tracing by default. */
-#ifndef traceFREE
-	#define traceFREE( pv, xBlockSize )
-#endif
-
-/* Block sizes must not get too small. */
-#define secureheapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
-
-/* Assumes 8bit bytes! */
-#define secureheapBITS_PER_BYTE			( ( size_t ) 8 )
-/*-----------------------------------------------------------*/
-
-/* Allocate the memory for the heap. */
-#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
-	/* The application writer has already defined the array used for the RTOS
-	 * heap - probably so it can be placed in a special segment or address. */
-	extern uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#else /* configAPPLICATION_ALLOCATED_HEAP */
-	static uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#endif /* configAPPLICATION_ALLOCATED_HEAP */
-
-/**
- * @brief The linked list structure.
- *
- * This is used to link free blocks in order of their memory address.
- */
-typedef struct A_BLOCK_LINK
-{
-	struct A_BLOCK_LINK *pxNextFreeBlock;	/**< The next free block in the list. */
-	size_t xBlockSize;						/**< The size of the free block. */
-} BlockLink_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Called automatically to setup the required heap structures the first
- * time pvPortMalloc() is called.
- */
-static void prvHeapInit( void );
-
-/**
- * @brief Inserts a block of memory that is being freed into the correct
- * position in the list of free memory blocks.
- *
- * The block being freed will be merged with the block in front it and/or the
- * block behind it if the memory blocks are adjacent to each other.
- *
- * @param[in] pxBlockToInsert The block being freed.
- */
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The size of the structure placed at the beginning of each allocated
- * memory block must by correctly byte aligned.
- */
-static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( secureportBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-
-/**
- * @brief Create a couple of list links to mark the start and end of the list.
- */
-static BlockLink_t xStart, *pxEnd = NULL;
-
-/**
- * @brief Keeps track of the number of free bytes remaining, but says nothing
- * about fragmentation.
- */
-static size_t xFreeBytesRemaining = 0U;
-static size_t xMinimumEverFreeBytesRemaining = 0U;
-
-/**
- * @brief Gets set to the top bit of an size_t type.
- *
- * When this bit in the xBlockSize member of an BlockLink_t structure is set
- * then the block belongs to the application. When the bit is free the block is
- * still part of the free heap space.
- */
-static size_t xBlockAllocatedBit = 0;
-/*-----------------------------------------------------------*/
-
-static void prvHeapInit( void )
-{
-BlockLink_t *pxFirstFreeBlock;
-uint8_t *pucAlignedHeap;
-size_t uxAddress;
-size_t xTotalHeapSize = secureconfigTOTAL_HEAP_SIZE;
-
-	/* Ensure the heap starts on a correctly aligned boundary. */
-	uxAddress = ( size_t ) ucHeap;
-
-	if( ( uxAddress & secureportBYTE_ALIGNMENT_MASK ) != 0 )
-	{
-		uxAddress += ( secureportBYTE_ALIGNMENT - 1 );
-		uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
-	}
-
-	pucAlignedHeap = ( uint8_t * ) uxAddress;
-
-	/* xStart is used to hold a pointer to the first item in the list of free
-	 * blocks.  The void cast is used to prevent compiler warnings. */
-	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
-	xStart.xBlockSize = ( size_t ) 0;
-
-	/* pxEnd is used to mark the end of the list of free blocks and is inserted
-	 * at the end of the heap space. */
-	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
-	uxAddress -= xHeapStructSize;
-	uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-	pxEnd = ( void * ) uxAddress;
-	pxEnd->xBlockSize = 0;
-	pxEnd->pxNextFreeBlock = NULL;
-
-	/* To start with there is a single free block that is sized to take up the
-	 * entire heap space, minus the space taken by pxEnd. */
-	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
-	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
-	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
-
-	/* Only one block exists - and it covers the entire usable heap space. */
-	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-
-	/* Work out the position of the top bit in a size_t variable. */
-	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * secureheapBITS_PER_BYTE ) - 1 );
-}
-/*-----------------------------------------------------------*/
-
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
-{
-BlockLink_t *pxIterator;
-uint8_t *puc;
-
-	/* Iterate through the list until a block is found that has a higher address
-	 * than the block being inserted. */
-	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
-	{
-		/* Nothing to do here, just iterate to the right position. */
-	}
-
-	/* Do the block being inserted, and the block it is being inserted after
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxIterator;
-	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
-	{
-		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
-		pxBlockToInsert = pxIterator;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Do the block being inserted, and the block it is being inserted before
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxBlockToInsert;
-	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
-	{
-		if( pxIterator->pxNextFreeBlock != pxEnd )
-		{
-			/* Form one big block from the two blocks. */
-			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
-			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
-		}
-		else
-		{
-			pxBlockToInsert->pxNextFreeBlock = pxEnd;
-		}
-	}
-	else
-	{
-		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
-	}
-
-	/* If the block being inserted plugged a gab, so was merged with the block
-	 * before and the block after, then it's pxNextFreeBlock pointer will have
-	 * already been set, and should not be set here as that would make it point
-	 * to itself. */
-	if( pxIterator != pxBlockToInsert )
-	{
-		pxIterator->pxNextFreeBlock = pxBlockToInsert;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
-void *pvReturn = NULL;
-
-	/* If this is the first call to malloc then the heap will require
-	 * initialisation to setup the list of free blocks. */
-	if( pxEnd == NULL )
-	{
-		prvHeapInit();
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Check the requested block size is not so large that the top bit is set.
-	 * The top bit of the block size member of the BlockLink_t structure is used
-	 * to determine who owns the block - the application or the kernel, so it
-	 * must be free. */
-	if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
-	{
-		/* The wanted size is increased so it can contain a BlockLink_t
-		 * structure in addition to the requested amount of bytes. */
-		if( xWantedSize > 0 )
-		{
-			xWantedSize += xHeapStructSize;
-
-			/* Ensure that blocks are always aligned to the required number of
-			 * bytes. */
-			if( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) != 0x00 )
-			{
-				/* Byte alignment required. */
-				xWantedSize += ( secureportBYTE_ALIGNMENT - ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) );
-				secureportASSERT( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
-		{
-			/* Traverse the list from the start (lowest address) block until
-			 * one of adequate size is found. */
-			pxPreviousBlock = &xStart;
-			pxBlock = xStart.pxNextFreeBlock;
-			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
-			{
-				pxPreviousBlock = pxBlock;
-				pxBlock = pxBlock->pxNextFreeBlock;
-			}
-
-			/* If the end marker was reached then a block of adequate size was
-			 * not found. */
-			if( pxBlock != pxEnd )
-			{
-				/* Return the memory space pointed to - jumping over the
-				 * BlockLink_t structure at its start. */
-				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
-
-				/* This block is being returned for use so must be taken out
-				 * of the list of free blocks. */
-				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
-
-				/* If the block is larger than required it can be split into
-				 * two. */
-				if( ( pxBlock->xBlockSize - xWantedSize ) > secureheapMINIMUM_BLOCK_SIZE )
-				{
-					/* This block is to be split into two.  Create a new
-					 * block following the number of bytes requested. The void
-					 * cast is used to prevent byte alignment warnings from the
-					 * compiler. */
-					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
-					secureportASSERT( ( ( ( size_t ) pxNewBlockLink ) & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-
-					/* Calculate the sizes of two blocks split from the single
-					 * block. */
-					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
-					pxBlock->xBlockSize = xWantedSize;
-
-					/* Insert the new block into the list of free blocks. */
-					prvInsertBlockIntoFreeList( pxNewBlockLink );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				xFreeBytesRemaining -= pxBlock->xBlockSize;
-
-				if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
-				{
-					xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* The block is being returned - it is allocated and owned by
-				 * the application and has no "next" block. */
-				pxBlock->xBlockSize |= xBlockAllocatedBit;
-				pxBlock->pxNextFreeBlock = NULL;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	traceMALLOC( pvReturn, xWantedSize );
-
-	#if( secureconfigUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#endif
-
-	secureportASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) secureportBYTE_ALIGNMENT_MASK ) == 0 );
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-uint8_t *puc = ( uint8_t * ) pv;
-BlockLink_t *pxLink;
-
-	if( pv != NULL )
-	{
-		/* The memory being freed will have an BlockLink_t structure immediately
-		 * before it. */
-		puc -= xHeapStructSize;
-
-		/* This casting is to keep the compiler from issuing warnings. */
-		pxLink = ( void * ) puc;
-
-		/* Check the block is actually allocated. */
-		secureportASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
-		secureportASSERT( pxLink->pxNextFreeBlock == NULL );
-
-		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
-		{
-			if( pxLink->pxNextFreeBlock == NULL )
-			{
-				/* The block is being returned to the heap - it is no longer
-				 * allocated. */
-				pxLink->xBlockSize &= ~xBlockAllocatedBit;
-
-				secureportDISABLE_NON_SECURE_INTERRUPTS();
-				{
-					/* Add this block to the list of free blocks. */
-					xFreeBytesRemaining += pxLink->xBlockSize;
-					traceFREE( pv, pxLink->xBlockSize );
-					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
-				}
-				secureportENABLE_NON_SECURE_INTERRUPTS();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return xFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetMinimumEverFreeHeapSize( void )
-{
-	return xMinimumEverFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-void vPortInitialiseBlocks( void )
-{
-	/* This just exists to keep the linker quiet. */
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.h b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.h
deleted file mode 100644
index b7e071a..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_heap.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_HEAP_H__
-#define __SECURE_HEAP_H__
-
-/* Standard includes. */
-#include <stdlib.h>
-
-/**
- * @brief Allocates memory from heap.
- *
- * @param[in] xWantedSize The size of the memory to be allocated.
- *
- * @return Pointer to the memory region if the allocation is successful, NULL
- * otherwise.
- */
-void *pvPortMalloc( size_t xWantedSize );
-
-/**
- * @brief Frees the previously allocated memory.
- *
- * @param[in] pv Pointer to the memory to be freed.
- */
-void vPortFree( void *pv );
-
-#endif /* __SECURE_HEAP_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.c b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.c
deleted file mode 100644
index fdabd11..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure init includes. */
-#include "secure_init.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define secureinitSCB_AIRCR					( ( volatile uint32_t * ) 0xe000ed0c )  /* Application Interrupt and Reset Control Register. */
-#define secureinitSCB_AIRCR_VECTKEY_POS		( 16UL )
-#define secureinitSCB_AIRCR_VECTKEY_MASK	( 0xFFFFUL << secureinitSCB_AIRCR_VECTKEY_POS )
-#define secureinitSCB_AIRCR_PRIS_POS		( 14UL )
-#define secureinitSCB_AIRCR_PRIS_MASK		( 1UL << secureinitSCB_AIRCR_PRIS_POS )
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define secureinitFPCCR						( ( volatile uint32_t * ) 0xe000ef34 )  /* Floating Point Context Control Register. */
-#define secureinitFPCCR_LSPENS_POS			( 29UL )
-#define secureinitFPCCR_LSPENS_MASK			( 1UL << secureinitFPCCR_LSPENS_POS )
-#define secureinitFPCCR_TS_POS				( 26UL )
-#define secureinitFPCCR_TS_MASK				( 1UL << secureinitFPCCR_TS_POS )
-
-#define secureinitNSACR						( ( volatile uint32_t * ) 0xe000ed8c )  /* Non-secure Access Control Register. */
-#define secureinitNSACR_CP10_POS			( 10UL )
-#define secureinitNSACR_CP10_MASK			( 1UL << secureinitNSACR_CP10_POS )
-#define secureinitNSACR_CP11_POS			( 11UL )
-#define secureinitNSACR_CP11_MASK			( 1UL << secureinitNSACR_CP11_POS )
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_DePrioritizeNSExceptions( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
-									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
-									( ( 0x1UL	<< secureinitSCB_AIRCR_PRIS_POS )	& secureinitSCB_AIRCR_PRIS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_EnableNSFPUAccess( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* CP10 = 1 ==> Non-secure access to the Floating Point Unit is
-		 * permitted. CP11 should be programmed to the same value as CP10. */
-		*( secureinitNSACR ) |= ( secureinitNSACR_CP10_MASK | secureinitNSACR_CP11_MASK );
-
-		/* LSPENS = 0 ==> LSPEN is writable fron non-secure state. This ensures
-		 * that we can enable/disable lazy stacking in port.c file. */
-		*( secureinitFPCCR ) &= ~ ( secureinitFPCCR_LSPENS_MASK );
-
-		/* TS = 1 ==> Treat FP registers as secure i.e. callee saved FP
-		 * registers (S16-S31) are also pushed to stack on exception entry and
-		 * restored on exception return. */
-		*( secureinitFPCCR ) |= ( secureinitFPCCR_TS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.h b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.h
deleted file mode 100644
index 34e4b48..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_init.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_INIT_H__
-#define __SECURE_INIT_H__
-
-/**
- * @brief De-prioritizes the non-secure exceptions.
- *
- * This is needed to ensure that the non-secure PendSV runs at the lowest
- * priority. Context switch is done in the non-secure PendSV handler.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_DePrioritizeNSExceptions( void );
-
-/**
- * @brief Sets up the Floating Point Unit (FPU) for Non-Secure access.
- *
- * Also sets FPCCR.TS=1 to ensure that the content of the Floating Point
- * Registers are not leaked to the non-secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_EnableNSFPUAccess( void );
-
-#endif /* __SECURE_INIT_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_port_macros.h b/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_port_macros.h
deleted file mode 100644
index e59c06b..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23/secure/secure_port_macros.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_PORT_MACROS_H__
-#define __SECURE_PORT_MACROS_H__
-
-/**
- * @brief Byte alignment requirements.
- */
-#define secureportBYTE_ALIGNMENT					8
-#define secureportBYTE_ALIGNMENT_MASK				( 0x0007 )
-
-/**
- * @brief Macro to declare a function as non-secure callable.
- */
-#if defined( __IAR_SYSTEMS_ICC__ )
-	#define secureportNON_SECURE_CALLABLE			__cmse_nonsecure_entry __root
-#else
-	#define secureportNON_SECURE_CALLABLE			__attribute__((cmse_nonsecure_entry)) __attribute__((used))
-#endif
-
-/**
- * @brief Set the secure PRIMASK value.
- */
-#define secureportSET_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Set the non-secure PRIMASK value.
- */
-#define secureportSET_NON_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask_ns, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Read the PSP value in the given variable.
- */
-#define secureportREAD_PSP( pucOutCurrentStackPointer ) \
-	__asm volatile ( "mrs %0, psp"  : "=r" ( pucOutCurrentStackPointer ) )
-
-/**
- * @brief Set the PSP to the given value.
- */
-#define secureportSET_PSP( pucCurrentStackPointer ) \
-	__asm volatile ( "msr psp, %0" : : "r" ( pucCurrentStackPointer ) )
-
-/**
- * @brief Set the PSPLIM to the given value.
- */
-#define secureportSET_PSPLIM( pucStackLimit ) \
-	__asm volatile ( "msr psplim, %0" : : "r" ( pucStackLimit ) )
-
-/**
- * @brief Set the NonSecure MSP to the given value.
- */
-#define secureportSET_MSP_NS( pucMainStackPointer ) \
-	__asm volatile ( "msr msp_ns, %0" : : "r" ( pucMainStackPointer ) )
-
-/**
- * @brief Set the CONTROL register to the given value.
- */
-#define secureportSET_CONTROL( ulControl ) \
-	__asm volatile ( "msr control, %0" : : "r" ( ulControl ) : "memory" )
-
-/**
- * @brief Read the Interrupt Program Status Register (IPSR) value in the given
- * variable.
- */
-#define secureportREAD_IPSR( ulIPSR ) \
-	__asm volatile ( "mrs %0, ipsr"  : "=r" ( ulIPSR ) )
-
-/**
- * @brief PRIMASK value to enable interrupts.
- */
-#define secureportPRIMASK_ENABLE_INTERRUPTS_VAL		0
-
-/**
- * @brief PRIMASK value to disable interrupts.
- */
-#define secureportPRIMASK_DISABLE_INTERRUPTS_VAL	1
-
-/**
- * @brief Disable secure interrupts.
- */
-#define secureportDISABLE_SECURE_INTERRUPTS()		secureportSET_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Disable non-secure interrupts.
- *
- * This effectively disables context switches.
- */
-#define secureportDISABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Enable non-secure interrupts.
- */
-#define secureportENABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_ENABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Assert definition.
- */
-#define secureportASSERT( x )						\
-	if( ( x ) == 0 )								\
-	{												\
-		secureportDISABLE_SECURE_INTERRUPTS();		\
-		secureportDISABLE_NON_SECURE_INTERRUPTS();	\
-		for( ;; );									\
-	}
-
-#endif /* __SECURE_PORT_MACROS_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/port.c b/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.h b/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.s
deleted file mode 100644
index 4a76b82..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portasm.s
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-	EXTERN vPortSVCHandler_C
-
-	PUBLIC xIsPrivileged
-	PUBLIC vResetPrivilege
-	PUBLIC vRestoreContextOfFirstTask
-	PUBLIC vRaisePrivilege
-	PUBLIC vStartFirstTask
-	PUBLIC ulSetInterruptMask
-	PUBLIC vClearInterruptMask
-	PUBLIC PendSV_Handler
-	PUBLIC SVC_Handler
-
-#if ( configENABLE_FPU == 1 )
-	#error Cortex-M23 does not have a Floating Point Unit (FPU) and therefore configENABLE_FPU must be set to 0.
-#endif
-/*-----------------------------------------------------------*/
-
-/*---------------- Unprivileged Functions -------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION .text:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-xIsPrivileged:
-	mrs r0, control							/* r0 = CONTROL. */
-	movs r1, #1								/* r1 = 1. */
-	tst r0, r1								/* Perform r0 & r1 (bitwise AND) and update the conditions flag. */
-	beq running_privileged					/* If the result of previous AND operation was 0, branch. */
-	movs r0, #0								/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	bx lr									/* Return. */
-	running_privileged:
-		movs r0, #1							/* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-		bx lr								/* Return. */
-
-/*-----------------------------------------------------------*/
-
-vResetPrivilege:
-	mrs r0, control							/* r0 = CONTROL. */
-	movs r1, #1								/* r1 = 1. */
-	orrs r0, r1								/* r0 = r0 | r1. */
-	msr control, r0							/* CONTROL = r0. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-/*----------------- Privileged Functions --------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION privileged_functions:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-vRestoreContextOfFirstTask:
-	ldr  r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr  r1, [r2]							/* Read pxCurrentTCB. */
-	ldr  r0, [r1]							/* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-
-#if ( configENABLE_MPU == 1 )
-	dmb										/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r3, [r2]							/* Read the value of MPU_CTRL. */
-	movs r4, #1								/* r4 = 1. */
-	bics r3, r4								/* r3 = r3 & ~r4 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]							/* Disable MPU. */
-
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	ldr  r4, [r1]							/* r4 = *r1 i.e. r4 = MAIR0. */
-	ldr  r2, =0xe000edc0					/* r2 = 0xe000edc0 [Location of MAIR0]. */
-	str  r4, [r2]							/* Program MAIR0. */
-	ldr  r2, =0xe000ed98					/* r2 = 0xe000ed98 [Location of RNR]. */
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	movs r4, #4								/* r4 = 4. */
-	str  r4, [r2]							/* Program RNR = 4. */
-	ldmia r1!, {r5,r6}						/* Read first set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write first set of RBAR/RLAR registers. */
-	movs r4, #5								/* r4 = 5. */
-	str  r4, [r2]							/* Program RNR = 5. */
-	ldmia r1!, {r5,r6}						/* Read second set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write second set of RBAR/RLAR registers. */
-	movs r4, #6								/* r4 = 6. */
-	str  r4, [r2]							/* Program RNR = 6. */
-	ldmia r1!, {r5,r6}						/* Read third set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write third set of RBAR/RLAR registers. */
-	movs r4, #7								/* r4 = 7. */
-	str  r4, [r2]							/* Program RNR = 7. */
-	ldmia r1!, {r5,r6}						/* Read fourth set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write fourth set of RBAR/RLAR registers. */
-
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r3, [r2]							/* Read the value of MPU_CTRL. */
-	movs r4, #1								/* r4 = 1. */
-	orrs r3, r4								/* r3 = r3 | r4 i.e. Set the bit 0 in r3. */
-	str r3, [r2]							/* Enable MPU. */
-	dsb										/* Force memory writes before continuing. */
-#endif /* configENABLE_MPU */
-
-#if ( configENABLE_MPU == 1 )
-	ldm  r0!, {r1-r3}						/* Read from stack - r1 = PSPLIM, r2 = CONTROL and r3 = EXC_RETURN. */
-	msr  psplim, r1							/* Set this task's PSPLIM value. */
-	msr  control, r2						/* Set this task's CONTROL value. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r3									/* Finally, branch to EXC_RETURN. */
-#else /* configENABLE_MPU */
-	ldm  r0!, {r1-r2}						/* Read from stack - r1 = PSPLIM and r2 = EXC_RETURN. */
-	msr  psplim, r1							/* Set this task's PSPLIM value. */
-	movs r1, #2								/* r1 = 2. */
-	msr  CONTROL, r1						/* Switch to use PSP in the thread mode. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r2									/* Finally, branch to EXC_RETURN. */
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-vRaisePrivilege:
-	mrs  r0, control						/* Read the CONTROL register. */
-	movs r1, #1								/* r1 = 1. */
-	bics r0, r1								/* Clear the bit 0. */
-	msr  control, r0						/* Write back the new CONTROL value. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-vStartFirstTask:
-	ldr r0, =0xe000ed08						/* Use the NVIC offset register to locate the stack. */
-	ldr r0, [r0]							/* Read the VTOR register which gives the address of vector table. */
-	ldr r0, [r0]							/* The first entry in vector table is stack pointer. */
-	msr msp, r0								/* Set the MSP back to the start of the stack. */
-	cpsie i									/* Globally enable interrupts. */
-	dsb
-	isb
-	svc 2									/* System call to start the first task. portSVC_START_SCHEDULER = 2. */
-	nop
-/*-----------------------------------------------------------*/
-
-ulSetInterruptMask:
-	mrs r0, PRIMASK
-	cpsid i
-	bx lr
-/*-----------------------------------------------------------*/
-
-vClearInterruptMask:
-	msr PRIMASK, r0
-	bx lr
-/*-----------------------------------------------------------*/
-
-PendSV_Handler:
-	mrs r0, psp								/* Read PSP in r0. */
-	ldr r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr r1, [r2]							/* Read pxCurrentTCB. */
-#if ( configENABLE_MPU == 1 )
-	subs r0, r0, #44						/* Make space for PSPLIM, CONTROL, LR and the remaining registers on the stack. */
-	str r0, [r1]							/* Save the new top of stack in TCB. */
-	mrs r1, psplim							/* r1 = PSPLIM. */
-	mrs r2, control							/* r2 = CONTROL. */
-	mov r3, lr								/* r3 = LR/EXC_RETURN. */
-	stmia r0!, {r1-r7}						/* Store on the stack - PSPLIM, CONTROL, LR and low registers that are not automatically saved. */
-	mov r4, r8								/* r4 = r8. */
-	mov r5, r9								/* r5 = r9. */
-	mov r6, r10								/* r6 = r10. */
-	mov r7, r11								/* r7 = r11. */
-	stmia r0!, {r4-r7}						/* Store the high registers that are not saved automatically. */
-#else /* configENABLE_MPU */
-	subs r0, r0, #40						/* Make space for PSPLIM, LR and the remaining registers on the stack. */
-	str r0, [r1]							/* Save the new top of stack in TCB. */
-	mrs r2, psplim							/* r2 = PSPLIM. */
-	mov r3, lr								/* r3 = LR/EXC_RETURN. */
-	stmia r0!, {r2-r7}						/* Store on the stack - PSPLIM, LR and low registers that are not automatically saved. */
-	mov r4, r8								/* r4 = r8. */
-	mov r5, r9								/* r5 = r9. */
-	mov r6, r10								/* r6 = r10. */
-	mov r7, r11								/* r7 = r11. */
-	stmia r0!, {r4-r7}						/* Store the high registers that are not saved automatically. */
-#endif /* configENABLE_MPU */
-
-	cpsid i
-	bl vTaskSwitchContext
-	cpsie i
-
-	ldr r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr r1, [r2]							/* Read pxCurrentTCB. */
-	ldr r0, [r1]							/* The first item in pxCurrentTCB is the task top of stack. r0 now points to the top of stack. */
-
-#if ( configENABLE_MPU == 1 )
-	dmb										/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r3, [r2]							/* Read the value of MPU_CTRL. */
-	movs r4, #1								/* r4 = 1. */
-	bics r3, r4								/* r3 = r3 & ~r4 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]							/* Disable MPU. */
-
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	ldr  r4, [r1]							/* r4 = *r1 i.e. r4 = MAIR0. */
-	ldr  r2, =0xe000edc0					/* r2 = 0xe000edc0 [Location of MAIR0]. */
-	str  r4, [r2]							/* Program MAIR0. */
-	ldr  r2, =0xe000ed98					/* r2 = 0xe000ed98 [Location of RNR]. */
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	movs r4, #4								/* r4 = 4. */
-	str  r4, [r2]							/* Program RNR = 4. */
-	ldmia r1!, {r5,r6}						/* Read first set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write first set of RBAR/RLAR registers. */
-	movs r4, #5								/* r4 = 5. */
-	str  r4, [r2]							/* Program RNR = 5. */
-	ldmia r1!, {r5,r6}						/* Read second set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write second set of RBAR/RLAR registers. */
-	movs r4, #6								/* r4 = 6. */
-	str  r4, [r2]							/* Program RNR = 6. */
-	ldmia r1!, {r5,r6}						/* Read third set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write third set of RBAR/RLAR registers. */
-	movs r4, #7								/* r4 = 7. */
-	str  r4, [r2]							/* Program RNR = 7. */
-	ldmia r1!, {r5,r6}						/* Read fourth set of RBAR/RLAR from TCB. */
-	ldr  r3, =0xe000ed9c					/* r3 = 0xe000ed9c [Location of RBAR]. */
-	stmia r3!, {r5,r6}						/* Write fourth set of RBAR/RLAR registers. */
-
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r3, [r2]							/* Read the value of MPU_CTRL. */
-	movs r4, #1								/* r4 = 1. */
-	orrs r3, r4								/* r3 = r3 | r4 i.e. Set the bit 0 in r3. */
-	str r3, [r2]							/* Enable MPU. */
-	dsb										/* Force memory writes before continuing. */
-#endif /* configENABLE_MPU */
-
-#if ( configENABLE_MPU == 1 )
-	adds r0, r0, #28						/* Move to the high registers. */
-	ldmia r0!, {r4-r7}						/* Restore the high registers that are not automatically restored. */
-	mov r8, r4								/* r8 = r4. */
-	mov r9, r5								/* r9 = r5. */
-	mov r10, r6								/* r10 = r6. */
-	mov r11, r7								/* r11 = r7. */
-	msr psp, r0								/* Remember the new top of stack for the task. */
-	subs r0, r0, #44						/* Move to the starting of the saved context. */
-	ldmia r0!, {r1-r7}						/* Read from stack - r1 = PSPLIM, r2 = CONTROL, r3 = LR and r4-r7 restored. */
-	msr psplim, r1							/* Restore the PSPLIM register value for the task. */
-	msr control, r2							/* Restore the CONTROL register value for the task. */
-	bx r3
-#else /* configENABLE_MPU */
-	adds r0, r0, #24						/* Move to the high registers. */
-	ldmia r0!, {r4-r7}						/* Restore the high registers that are not automatically restored. */
-	mov r8, r4								/* r8 = r4. */
-	mov r9, r5								/* r9 = r5. */
-	mov r10, r6								/* r10 = r6. */
-	mov r11, r7								/* r11 = r7. */
-	msr psp, r0								/* Remember the new top of stack for the task. */
-	subs r0, r0, #40						/* Move to the starting of the saved context. */
-	ldmia r0!, {r2-r7}						/* Read from stack - r2 = PSPLIM, r3 = LR and r4-r7 restored. */
-	msr psplim, r2							/* Restore the PSPLIM register value for the task. */
-	bx r3
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-SVC_Handler:
-	movs r0, #4
-	mov r1, lr
-	tst r0, r1
-	beq stacking_used_msp
-	mrs r0, psp
-	b vPortSVCHandler_C
-	stacking_used_msp:
-		mrs r0, msp
-		b vPortSVCHandler_C
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portmacro.h
deleted file mode 100644
index c127f23..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM23_NTZ/non_secure/portmacro.h
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M23"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__root
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							__asm volatile ( " cpsid i " ::: "memory" )
-#define portENABLE_INTERRUPTS()								__asm volatile ( " cpsie i " ::: "memory" )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
- * the source code because to do so would cause other compilers to generate
- * warnings. */
-#pragma diag_suppress=Be006
-#pragma diag_suppress=Pa082
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM3/port.c b/osal/src/freertos/portable/IAR/ARM_CM3/port.c
deleted file mode 100644
index ccc0840..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM3/port.c
+++ /dev/null
@@ -1,619 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM3 port.
- *----------------------------------------------------------*/
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#if( configMAX_SYSCALL_INTERRUPT_PRIORITY == 0 )
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/* For backward compatibility, ensure configKERNEL_INTERRUPT_PRIORITY is
-defined.  The value 255 should also ensure backward compatibility.
-FreeRTOS.org versions prior to V4.3.0 did not include this definition. */
-#ifndef configKERNEL_INTERRUPT_PRIORITY
-	#define configKERNEL_INTERRUPT_PRIORITY 255
-#endif
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortSysTickHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-extern void vPortStartFirstTask( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__disable_interrupt();
-		__DSB();
-		__ISB();
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above __disable_interrupt()
-			call above. */
-			__enable_interrupt();
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__DSB();
-				__WFI();
-				__ISB();
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__enable_interrupt();
-			__DSB();
-			__ISB();
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__disable_interrupt();
-			__DSB();
-			__ISB();
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__enable_interrupt();
-		}
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__weak void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM3/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM3/portasm.s
deleted file mode 100644
index 4b13f51..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM3/portasm.s
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#include <FreeRTOSConfig.h>
-
-	RSEG    CODE:CODE(2)
-	thumb
-
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-
-	PUBLIC xPortPendSVHandler
-	PUBLIC vPortSVCHandler
-	PUBLIC vPortStartFirstTask
-
-
-
-/*-----------------------------------------------------------*/
-
-xPortPendSVHandler:
-	mrs r0, psp
-	isb
-	ldr	r3, =pxCurrentTCB			/* Get the location of the current TCB. */
-	ldr	r2, [r3]
-
-	stmdb r0!, {r4-r11}				/* Save the remaining registers. */
-	str r0, [r2]					/* Save the new top of stack into the first member of the TCB. */
-
-	stmdb sp!, {r3, r14}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r3, r14}
-
-	ldr r1, [r3]
-	ldr r0, [r1]					/* The first item in pxCurrentTCB is the task top of stack. */
-	ldmia r0!, {r4-r11}				/* Pop the registers. */
-	msr psp, r0
-	isb
-	bx r14
-
-
-/*-----------------------------------------------------------*/
-
-vPortSVCHandler:
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	ldr r0, [r1]
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11}
-	msr psp, r0
-	isb
-	mov r0, #0
-	msr	basepri, r0
-	orr r14, r14, #13
-	bx r14
-
-/*-----------------------------------------------------------*/
-
-vPortStartFirstTask
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Call SVC to start the first task, ensuring interrupts are enabled. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc 0
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM3/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM3/portmacro.h
deleted file mode 100644
index 886cc8e..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM3/portmacro.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* Compiler directives. */
-#define portWEAK_SYMBOL				__attribute__( ( weak ) )
-
-/*-----------------------------------------------------------*/
-
-
-/* Scheduler utilities. */
-#define portYIELD()											\
-{															\
-	/* Set a PendSV to request a context switch. */			\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;			\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 1 )
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ( uint32_t ) __CLZ( ( uxReadyPriorities ) ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()							\
-{															\
-	__set_BASEPRI( configMAX_SYSCALL_INTERRUPT_PRIORITY );	\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portENABLE_INTERRUPTS()					__set_BASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		__get_BASEPRI(); portDISABLE_INTERRUPTS()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	__set_BASEPRI( x )
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
-the source code because to do so would cause other compilers to generate
-warnings. */
-#pragma diag_suppress=Pe191
-#pragma diag_suppress=Pa082
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/port.c b/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.h b/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.s
deleted file mode 100644
index 6ffefe1..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portasm.s
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-/* Including FreeRTOSConfig.h here will cause build errors if the header file
-contains code not understood by the assembler - for example the 'extern' keyword.
-To avoid errors place any such code inside a #ifdef __ICCARM__/#endif block so
-the code is included in C files but excluded by the preprocessor in assembly
-files (__ICCARM__ is defined by the IAR C compiler but not by the IAR assembler. */
-#include "FreeRTOSConfig.h"
-
-	EXTERN pxCurrentTCB
-	EXTERN xSecureContext
-	EXTERN vTaskSwitchContext
-	EXTERN vPortSVCHandler_C
-	EXTERN SecureContext_SaveContext
-	EXTERN SecureContext_LoadContext
-
-	PUBLIC xIsPrivileged
-	PUBLIC vResetPrivilege
-	PUBLIC vPortAllocateSecureContext
-	PUBLIC vRestoreContextOfFirstTask
-	PUBLIC vRaisePrivilege
-	PUBLIC vStartFirstTask
-	PUBLIC ulSetInterruptMask
-	PUBLIC vClearInterruptMask
-	PUBLIC PendSV_Handler
-	PUBLIC SVC_Handler
-	PUBLIC vPortFreeSecureContext
-/*-----------------------------------------------------------*/
-
-/*---------------- Unprivileged Functions -------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION .text:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-xIsPrivileged:
-	mrs r0, control							/* r0 = CONTROL. */
-	tst r0, #1								/* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	ite ne
-	movne r0, #0							/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	moveq r0, #1							/* CONTROL[0]==0. Return true to indicate that the processor is not privileged. */
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-vResetPrivilege:
-	mrs r0, control							/* r0 = CONTROL. */
-	orr r0, r0, #1							/* r0 = r0 | 1. */
-	msr control, r0							/* CONTROL = r0. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-vPortAllocateSecureContext:
-	svc 0									/* Secure context is allocated in the supervisor call. portSVC_ALLOCATE_SECURE_CONTEXT = 0. */
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-/*----------------- Privileged Functions --------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION privileged_functions:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-vRestoreContextOfFirstTask:
-	ldr  r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr  r3, [r2]							/* Read pxCurrentTCB. */
-	ldr  r0, [r3]							/* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-
-#if ( configENABLE_MPU == 1 )
-	dmb										/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	bic r4, r4, #1							/* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-	str r4, [r2]							/* Disable MPU. */
-
-	adds r3, #4								/* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-	ldr  r4, [r3]							/* r4 = *r3 i.e. r4 = MAIR0. */
-	ldr  r2, =0xe000edc0					/* r2 = 0xe000edc0 [Location of MAIR0]. */
-	str  r4, [r2]							/* Program MAIR0. */
-	ldr  r2, =0xe000ed98					/* r2 = 0xe000ed98 [Location of RNR]. */
-	movs r4, #4								/* r4 = 4. */
-	str  r4, [r2]							/* Program RNR = 4. */
-	adds r3, #4								/* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-	ldr  r2, =0xe000ed9c					/* r2 = 0xe000ed9c [Location of RBAR]. */
-	ldmia r3!, {r4-r11}						/* Read 4 set of RBAR/RLAR registers from TCB. */
-	stmia r2!, {r4-r11}						/* Write 4 set of RBAR/RLAR registers using alias registers. */
-
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	orr r4, r4, #1							/* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-	str r4, [r2]							/* Enable MPU. */
-	dsb										/* Force memory writes before continuing. */
-#endif /* configENABLE_MPU */
-
-#if ( configENABLE_MPU == 1 )
-	ldm  r0!, {r1-r4}						/* Read from stack - r1 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = EXC_RETURN. */
-	ldr  r5, =xSecureContext
-	str  r1, [r5]							/* Set xSecureContext to this task's value for the same. */
-	msr  psplim, r2							/* Set this task's PSPLIM value. */
-	msr  control, r3						/* Set this task's CONTROL value. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r4									/* Finally, branch to EXC_RETURN. */
-#else /* configENABLE_MPU */
-	ldm  r0!, {r1-r3}						/* Read from stack - r1 = xSecureContext, r2 = PSPLIM and r3 = EXC_RETURN. */
-	ldr  r4, =xSecureContext
-	str  r1, [r4]							/* Set xSecureContext to this task's value for the same. */
-	msr  psplim, r2							/* Set this task's PSPLIM value. */
-	movs r1, #2								/* r1 = 2. */
-	msr  CONTROL, r1						/* Switch to use PSP in the thread mode. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r3									/* Finally, branch to EXC_RETURN. */
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-vRaisePrivilege:
-	mrs  r0, control						/* Read the CONTROL register. */
-	bic r0, r0, #1							/* Clear the bit 0. */
-	msr  control, r0						/* Write back the new CONTROL value. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-vStartFirstTask:
-	ldr r0, =0xe000ed08						/* Use the NVIC offset register to locate the stack. */
-	ldr r0, [r0]							/* Read the VTOR register which gives the address of vector table. */
-	ldr r0, [r0]							/* The first entry in vector table is stack pointer. */
-	msr msp, r0								/* Set the MSP back to the start of the stack. */
-	cpsie i									/* Globally enable interrupts. */
-	cpsie f
-	dsb
-	isb
-	svc 2									/* System call to start the first task. portSVC_START_SCHEDULER = 2. */
-/*-----------------------------------------------------------*/
-
-ulSetInterruptMask:
-	mrs r0, basepri							/* r0 = basepri. Return original basepri value. */
-	mov r1, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r1							/* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	dsb
-	isb
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-vClearInterruptMask:
-	msr basepri, r0							/* basepri = ulMask. */
-	dsb
-	isb
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-PendSV_Handler:
-	mrs r1, psp								/* Read PSP in r1. */
-	ldr r2, =xSecureContext					/* Read the location of xSecureContext i.e. &( xSecureContext ). */
-	ldr r0, [r2]							/* Read xSecureContext - Value of xSecureContext must be in r0 as it is used as a parameter later. */
-
-	cbz r0, save_ns_context					/* No secure context to save. */
-	push {r0-r2, r14}
-	bl SecureContext_SaveContext
-	pop {r0-r3}								/* LR is now in r3. */
-	mov lr, r3								/* LR = r3. */
-	lsls r2, r3, #25						/* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-	bpl save_ns_context						/* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-	ldr r3, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr r2, [r3]							/* Read pxCurrentTCB. */
-#if ( configENABLE_MPU == 1 )
-	subs r1, r1, #16						/* Make space for xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	str r1, [r2]							/* Save the new top of stack in TCB. */
-	mrs r2, psplim							/* r2 = PSPLIM. */
-	mrs r3, control							/* r3 = CONTROL. */
-	mov r4, lr								/* r4 = LR/EXC_RETURN. */
-	stmia r1!, {r0, r2-r4}					/* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-#else /* configENABLE_MPU */
-	subs r1, r1, #12						/* Make space for xSecureContext, PSPLIM and LR on the stack. */
-	str r1, [r2]							/* Save the new top of stack in TCB. */
-	mrs r2, psplim							/* r2 = PSPLIM. */
-	mov r3, lr								/* r3 = LR/EXC_RETURN. */
-	stmia r1!, {r0, r2-r3}					/* Store xSecureContext, PSPLIM and LR on the stack. */
-#endif /* configENABLE_MPU */
-	b select_next_task
-
-	save_ns_context:
-		ldr r3, =pxCurrentTCB				/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-		ldr r2, [r3]						/* Read pxCurrentTCB. */
-	#if ( configENABLE_FPU == 1 )
-		tst lr, #0x10						/* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-		it eq
-		vstmdbeq r1!, {s16-s31}				/* Store the FPU registers which are not saved automatically. */
-	#endif /* configENABLE_FPU */
-	#if ( configENABLE_MPU == 1 )
-		subs r1, r1, #48					/* Make space for xSecureContext, PSPLIM, CONTROL, LR and the remaining registers on the stack. */
-		str r1, [r2]						/* Save the new top of stack in TCB. */
-		adds r1, r1, #16					/* r1 = r1 + 16. */
-		stm r1, {r4-r11}					/* Store the registers that are not saved automatically. */
-		mrs r2, psplim						/* r2 = PSPLIM. */
-		mrs r3, control						/* r3 = CONTROL. */
-		mov r4, lr							/* r4 = LR/EXC_RETURN. */
-		subs r1, r1, #16					/* r1 = r1 - 16. */
-		stm r1, {r0, r2-r4}					/* Store xSecureContext, PSPLIM, CONTROL and LR on the stack. */
-	#else /* configENABLE_MPU */
-		subs r1, r1, #44					/* Make space for xSecureContext, PSPLIM, LR and the remaining registers on the stack. */
-		str r1, [r2]						/* Save the new top of stack in TCB. */
-		adds r1, r1, #12					/* r1 = r1 + 12. */
-		stm r1, {r4-r11}					/* Store the registers that are not saved automatically. */
-		mrs r2, psplim						/* r2 = PSPLIM. */
-		mov r3, lr							/* r3 = LR/EXC_RETURN. */
-		subs r1, r1, #12					/* r1 = r1 - 12. */
-		stmia r1!, {r0, r2-r3}				/* Store xSecureContext, PSPLIM and LR on the stack. */
-	#endif /* configENABLE_MPU */
-
-	select_next_task:
-		mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-		msr basepri, r0						/* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-		dsb
-		isb
-		bl vTaskSwitchContext
-		mov r0, #0							/* r0 = 0. */
-		msr basepri, r0						/* Enable interrupts. */
-
-		ldr r2, =pxCurrentTCB				/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-		ldr r3, [r2]						/* Read pxCurrentTCB. */
-		ldr r1, [r3]						/* The first item in pxCurrentTCB is the task top of stack. r1 now points to the top of stack. */
-
-	#if ( configENABLE_MPU == 1 )
-		dmb									/* Complete outstanding transfers before disabling MPU. */
-		ldr r2, =0xe000ed94					/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-		ldr r4, [r2]						/* Read the value of MPU_CTRL. */
-		bic r4, r4, #1						/* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-		str r4, [r2]						/* Disable MPU. */
-
-		adds r3, #4							/* r3 = r3 + 4. r3 now points to MAIR0 in TCB. */
-		ldr r4, [r3]						/* r4 = *r3 i.e. r4 = MAIR0. */
-		ldr r2, =0xe000edc0					/* r2 = 0xe000edc0 [Location of MAIR0]. */
-		str r4, [r2]						/* Program MAIR0. */
-		ldr r2, =0xe000ed98					/* r2 = 0xe000ed98 [Location of RNR]. */
-		movs r4, #4							/* r4 = 4. */
-		str r4, [r2]						/* Program RNR = 4. */
-		adds r3, #4							/* r3 = r3 + 4. r3 now points to first RBAR in TCB. */
-		ldr  r2, =0xe000ed9c				/* r2 = 0xe000ed9c [Location of RBAR]. */
-		ldmia r3!, {r4-r11}					/* Read 4 sets of RBAR/RLAR registers from TCB. */
-		stmia r2!, {r4-r11}					/* Write 4 set of RBAR/RLAR registers using alias registers. */
-
-		ldr r2, =0xe000ed94					/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-		ldr r4, [r2]						/* Read the value of MPU_CTRL. */
-		orr r4, r4, #1						/* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-		str r4, [r2]						/* Enable MPU. */
-		dsb									/* Force memory writes before continuing. */
-	#endif /* configENABLE_MPU */
-
-	#if ( configENABLE_MPU == 1 )
-		ldmia r1!, {r0, r2-r4}				/* Read from stack - r0 = xSecureContext, r2 = PSPLIM, r3 = CONTROL and r4 = LR. */
-		msr psplim, r2						/* Restore the PSPLIM register value for the task. */
-		msr control, r3						/* Restore the CONTROL register value for the task. */
-		mov lr, r4							/* LR = r4. */
-		ldr r2, =xSecureContext				/* Read the location of xSecureContext i.e. &( xSecureContext ). */
-		str r0, [r2]						/* Restore the task's xSecureContext. */
-		cbz r0, restore_ns_context			/* If there is no secure context for the task, restore the non-secure context. */
-		push {r1,r4}
-		bl SecureContext_LoadContext		/* Restore the secure context. */
-		pop {r1,r4}
-		mov lr, r4							/* LR = r4. */
-		lsls r2, r4, #25					/* r2 = r4 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-		bpl restore_ns_context				/* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-		msr psp, r1							/* Remember the new top of stack for the task. */
-		bx lr
-	#else /* configENABLE_MPU */
-		ldmia r1!, {r0, r2-r3}				/* Read from stack - r0 = xSecureContext, r2 = PSPLIM and r3 = LR. */
-		msr psplim, r2						/* Restore the PSPLIM register value for the task. */
-		mov lr, r3							/* LR = r3. */
-		ldr r2, =xSecureContext				/* Read the location of xSecureContext i.e. &( xSecureContext ). */
-		str r0, [r2]						/* Restore the task's xSecureContext. */
-		cbz r0, restore_ns_context			/* If there is no secure context for the task, restore the non-secure context. */
-		push {r1,r3}
-		bl SecureContext_LoadContext		/* Restore the secure context. */
-		pop {r1,r3}
-		mov lr, r3							/* LR = r3. */
-		lsls r2, r3, #25					/* r2 = r3 << 25. Bit[6] of EXC_RETURN is 1 if secure stack was used, 0 if non-secure stack was used to store stack frame. */
-		bpl restore_ns_context				/* bpl - branch if positive or zero. If r2 >= 0 ==> Bit[6] in EXC_RETURN is 0 i.e. non-secure stack was used. */
-		msr psp, r1							/* Remember the new top of stack for the task. */
-		bx lr
-	#endif /* configENABLE_MPU */
-
-	restore_ns_context:
-		ldmia r1!, {r4-r11}					/* Restore the registers that are not automatically restored. */
-	#if ( configENABLE_FPU == 1 )
-		tst lr, #0x10						/* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-		it eq
-		vldmiaeq r1!, {s16-s31}				/* Restore the FPU registers which are not restored automatically. */
-	#endif /* configENABLE_FPU */
-		msr psp, r1							/* Remember the new top of stack for the task. */
-		bx lr
-/*-----------------------------------------------------------*/
-
-SVC_Handler:
-	tst lr, #4
-	ite eq
-	mrseq r0, msp
-	mrsne r0, psp
-	b vPortSVCHandler_C
-/*-----------------------------------------------------------*/
-
-vPortFreeSecureContext:
-	/* r0 = uint32_t *pulTCB. */
-	ldr r1, [r0]							/* The first item in the TCB is the top of the stack. */
-	ldr r0, [r1]							/* The first item on the stack is the task's xSecureContext. */
-	cmp r0, #0								/* Raise svc if task's xSecureContext is not NULL. */
-	it ne
-	svcne 1									/* Secure context is freed in the supervisor call. portSVC_FREE_SECURE_CONTEXT = 1. */
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portmacro.h
deleted file mode 100644
index ebb16fd..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/non_secure/portmacro.h
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M33"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__root
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							ulSetInterruptMask()
-#define portENABLE_INTERRUPTS()								vClearInterruptMask( 0 )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
- * the source code because to do so would cause other compilers to generate
- * warnings. */
-#pragma diag_suppress=Be006
-#pragma diag_suppress=Pa082
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.c b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.c
deleted file mode 100644
index b19f801..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.c
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief CONTROL value for privileged tasks.
- *
- * Bit[0] - 0 --> Thread mode is privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_PRIVILEGED		0x02
-
-/**
- * @brief CONTROL value for un-privileged tasks.
- *
- * Bit[0] - 1 --> Thread mode is un-privileged.
- * Bit[1] - 1 --> Thread mode uses PSP.
- */
-#define securecontextCONTROL_VALUE_UNPRIVILEGED		0x03
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Structure to represent secure context.
- *
- * @note Since stack grows down, pucStackStart is the highest address while
- * pucStackLimit is the first addess of the allocated memory.
- */
-typedef struct SecureContext
-{
-	uint8_t *pucCurrentStackPointer;	/**< Current value of stack pointer (PSP). */
-	uint8_t *pucStackLimit;				/**< Last location of the stack memory (PSPLIM). */
-	uint8_t *pucStackStart;				/**< First location of the stack memory. */
-} SecureContext_t;
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_Init( void )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* No stack for thread mode until a task's context is loaded. */
-		secureportSET_PSPLIM( securecontextNO_STACK );
-		secureportSET_PSP( securecontextNO_STACK );
-
-		#if( configENABLE_MPU == 1 )
-		{
-			/* Configure thread mode to use PSP and to be unprivileged. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_UNPRIVILEGED );
-		}
-		#else /* configENABLE_MPU */
-		{
-			/* Configure thread mode to use PSP and to be privileged.. */
-			secureportSET_CONTROL( securecontextCONTROL_VALUE_PRIVILEGED );
-		}
-		#endif /* configENABLE_MPU */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged )
-#else /* configENABLE_MPU */
-	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize )
-#endif /* configENABLE_MPU */
-{
-	uint8_t *pucStackMemory = NULL;
-	uint32_t ulIPSR;
-	SecureContextHandle_t xSecureContextHandle = NULL;
-	#if( configENABLE_MPU == 1 )
-		uint32_t *pulCurrentStackPointer = NULL;
-	#endif /* configENABLE_MPU */
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Allocate the context structure. */
-		xSecureContextHandle = ( SecureContextHandle_t ) pvPortMalloc( sizeof( SecureContext_t ) );
-
-		if( xSecureContextHandle != NULL )
-		{
-			/* Allocate the stack space. */
-			pucStackMemory = pvPortMalloc( ulSecureStackSize );
-
-			if( pucStackMemory != NULL )
-			{
-				/* Since stack grows down, the starting point will be the last
-				 * location. Note that this location is next to the last
-				 * allocated byte because the hardware decrements the stack
-				 * pointer before writing i.e. if stack pointer is 0x2, a push
-				 * operation will decrement the stack pointer to 0x1 and then
-				 * write at 0x1. */
-				xSecureContextHandle->pucStackStart = pucStackMemory + ulSecureStackSize;
-
-				/* The stack cannot go beyond this location. This value is
-				 * programmed in the PSPLIM register on context switch.*/
-				xSecureContextHandle->pucStackLimit = pucStackMemory;
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Store the correct CONTROL value for the task on the stack.
-					 * This value is programmed in the CONTROL register on
-					 * context switch. */
-					pulCurrentStackPointer = ( uint32_t * ) xSecureContextHandle->pucStackStart;
-					pulCurrentStackPointer--;
-					if( ulIsTaskPrivileged )
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_PRIVILEGED;
-					}
-					else
-					{
-						*( pulCurrentStackPointer ) = securecontextCONTROL_VALUE_UNPRIVILEGED;
-					}
-
-					/* Store the current stack pointer. This value is programmed in
-					 * the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = ( uint8_t * ) pulCurrentStackPointer;
-				}
-				#else /* configENABLE_MPU */
-				{
-					/* Current SP is set to the starting of the stack. This
-					 * value programmed in the PSP register on context switch. */
-					xSecureContextHandle->pucCurrentStackPointer = xSecureContextHandle->pucStackStart;
-
-				}
-				#endif /* configENABLE_MPU */
-			}
-			else
-			{
-				/* Free the context to avoid memory leak and make sure to return
-				 * NULL to indicate failure. */
-				vPortFree( xSecureContextHandle );
-				xSecureContextHandle = NULL;
-			}
-		}
-	}
-
-	return xSecureContextHandle;
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle )
-{
-	uint32_t ulIPSR;
-
-	/* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* Ensure that valid parameters are passed. */
-		secureportASSERT( xSecureContextHandle != NULL );
-
-		/* Free the stack space. */
-		vPortFree( xSecureContextHandle->pucStackLimit );
-
-		/* Free the context itself. */
-		vPortFree( xSecureContextHandle );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.h b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.h
deleted file mode 100644
index 7323f8f..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_CONTEXT_H__
-#define __SECURE_CONTEXT_H__
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* FreeRTOS includes. */
-#include "FreeRTOSConfig.h"
-
-/**
- * @brief PSP value when no task's context is loaded.
- */
-#define securecontextNO_STACK	0x0
-
-/**
- * @brief Opaque handle.
- */
-struct SecureContext;
-typedef struct SecureContext*	SecureContextHandle_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Initializes the secure context management system.
- *
- * PSP is set to NULL and therefore a task must allocate and load a context
- * before calling any secure side function in the thread mode.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureContext_Init( void );
-
-/**
- * @brief Allocates a context on the secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] ulSecureStackSize Size of the stack to allocate on secure side.
- * @param[in] ulIsTaskPrivileged 1 if the calling task is privileged, 0 otherwise.
- *
- * @return Opaque context handle if context is successfully allocated, NULL
- * otherwise.
- */
-#if( configENABLE_MPU == 1 )
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged );
-#else /* configENABLE_MPU */
-	SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize );
-#endif /* configENABLE_MPU */
-
-/**
- * @brief Frees the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the
- * context to be freed.
- */
-void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Loads the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be loaded.
- */
-void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle );
-
-/**
- * @brief Saves the given context.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- *
- * @param[in] xSecureContextHandle Context handle corresponding to the context
- * to be saved.
- */
-void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle );
-
-#endif /* __SECURE_CONTEXT_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port.c b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port.c
deleted file mode 100644
index e09bd97..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Secure context includes. */
-#include "secure_context.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/* Functions implemented in assembler file. */
-extern void SecureContext_LoadContextAsm( SecureContextHandle_t xSecureContextHandle );
-extern void SecureContext_SaveContextAsm( SecureContextHandle_t xSecureContextHandle );
-
-secureportNON_SECURE_CALLABLE void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle )
-{
-	SecureContext_LoadContextAsm( xSecureContextHandle );
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle )
-{
-	SecureContext_SaveContextAsm( xSecureContextHandle );
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port_asm.s b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port_asm.s
deleted file mode 100644
index ca84fd4..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_context_port_asm.s
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-	SECTION .text:CODE:NOROOT(2)
-	THUMB
-
-	PUBLIC SecureContext_LoadContextAsm
-	PUBLIC SecureContext_SaveContextAsm
-/*-----------------------------------------------------------*/
-
-SecureContext_LoadContextAsm:
-	/* xSecureContextHandle value is in r0. */
-	mrs r1, ipsr							/* r1 = IPSR. */
-	cbz r1, load_ctx_therad_mode			/* Do nothing if the processor is running in the Thread Mode. */
-	ldmia r0!, {r1, r2}						/* r1 = xSecureContextHandle->pucCurrentStackPointer, r2 = xSecureContextHandle->pucStackLimit. */
-#if ( configENABLE_MPU == 1 )
-	ldmia r1!, {r3}							/* Read CONTROL register value from task's stack. r3 = CONTROL. */
-	msr control, r3							/* CONTROL = r3. */
-#endif /* configENABLE_MPU */
-	msr psplim, r2							/* PSPLIM = r2. */
-	msr psp, r1								/* PSP = r1. */
-
-	load_ctx_therad_mode:
-		bx lr
-/*-----------------------------------------------------------*/
-
-SecureContext_SaveContextAsm:
-	/* xSecureContextHandle value is in r0. */
-	mrs r1, ipsr							/* r1 = IPSR. */
-	cbz r1, save_ctx_therad_mode			/* Do nothing if the processor is running in the Thread Mode. */
-	mrs r1, psp								/* r1 = PSP. */
-#if ( configENABLE_FPU == 1 )
-	vstmdb r1!, {s0}						/* Trigger the defferred stacking of FPU registers. */
-	vldmia r1!, {s0}						/* Nullify the effect of the pervious statement. */
-#endif /* configENABLE_FPU */
-#if ( configENABLE_MPU == 1 )
-	mrs r2, control							/* r2 = CONTROL. */
-	stmdb r1!, {r2}							/* Store CONTROL value on the stack. */
-#endif /* configENABLE_MPU */
-	str r1, [r0]							/* Save the top of stack in context. xSecureContextHandle->pucCurrentStackPointer = r1. */
-	movs r1, #0								/* r1 = securecontextNO_STACK. */
-	msr psplim, r1							/* PSPLIM = securecontextNO_STACK. */
-	msr psp, r1								/* PSP = securecontextNO_STACK i.e. No stack for thread mode until next task's context is loaded. */
-
-	save_ctx_therad_mode:
-		bx lr
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.c b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.c
deleted file mode 100644
index 098f24e..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.c
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure context heap includes. */
-#include "secure_heap.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Total heap size.
- */
-#define secureconfigTOTAL_HEAP_SIZE		( ( ( size_t ) ( 10 * 1024 ) ) )
-
-/* No test marker by default. */
-#ifndef mtCOVERAGE_TEST_MARKER
-	#define mtCOVERAGE_TEST_MARKER()
-#endif
-
-/* No tracing by default. */
-#ifndef traceMALLOC
-	#define traceMALLOC( pvReturn, xWantedSize )
-#endif
-
-/* No tracing by default. */
-#ifndef traceFREE
-	#define traceFREE( pv, xBlockSize )
-#endif
-
-/* Block sizes must not get too small. */
-#define secureheapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
-
-/* Assumes 8bit bytes! */
-#define secureheapBITS_PER_BYTE			( ( size_t ) 8 )
-/*-----------------------------------------------------------*/
-
-/* Allocate the memory for the heap. */
-#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
-	/* The application writer has already defined the array used for the RTOS
-	 * heap - probably so it can be placed in a special segment or address. */
-	extern uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#else /* configAPPLICATION_ALLOCATED_HEAP */
-	static uint8_t ucHeap[ secureconfigTOTAL_HEAP_SIZE ];
-#endif /* configAPPLICATION_ALLOCATED_HEAP */
-
-/**
- * @brief The linked list structure.
- *
- * This is used to link free blocks in order of their memory address.
- */
-typedef struct A_BLOCK_LINK
-{
-	struct A_BLOCK_LINK *pxNextFreeBlock;	/**< The next free block in the list. */
-	size_t xBlockSize;						/**< The size of the free block. */
-} BlockLink_t;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Called automatically to setup the required heap structures the first
- * time pvPortMalloc() is called.
- */
-static void prvHeapInit( void );
-
-/**
- * @brief Inserts a block of memory that is being freed into the correct
- * position in the list of free memory blocks.
- *
- * The block being freed will be merged with the block in front it and/or the
- * block behind it if the memory blocks are adjacent to each other.
- *
- * @param[in] pxBlockToInsert The block being freed.
- */
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The size of the structure placed at the beginning of each allocated
- * memory block must by correctly byte aligned.
- */
-static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( secureportBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-
-/**
- * @brief Create a couple of list links to mark the start and end of the list.
- */
-static BlockLink_t xStart, *pxEnd = NULL;
-
-/**
- * @brief Keeps track of the number of free bytes remaining, but says nothing
- * about fragmentation.
- */
-static size_t xFreeBytesRemaining = 0U;
-static size_t xMinimumEverFreeBytesRemaining = 0U;
-
-/**
- * @brief Gets set to the top bit of an size_t type.
- *
- * When this bit in the xBlockSize member of an BlockLink_t structure is set
- * then the block belongs to the application. When the bit is free the block is
- * still part of the free heap space.
- */
-static size_t xBlockAllocatedBit = 0;
-/*-----------------------------------------------------------*/
-
-static void prvHeapInit( void )
-{
-BlockLink_t *pxFirstFreeBlock;
-uint8_t *pucAlignedHeap;
-size_t uxAddress;
-size_t xTotalHeapSize = secureconfigTOTAL_HEAP_SIZE;
-
-	/* Ensure the heap starts on a correctly aligned boundary. */
-	uxAddress = ( size_t ) ucHeap;
-
-	if( ( uxAddress & secureportBYTE_ALIGNMENT_MASK ) != 0 )
-	{
-		uxAddress += ( secureportBYTE_ALIGNMENT - 1 );
-		uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
-	}
-
-	pucAlignedHeap = ( uint8_t * ) uxAddress;
-
-	/* xStart is used to hold a pointer to the first item in the list of free
-	 * blocks.  The void cast is used to prevent compiler warnings. */
-	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
-	xStart.xBlockSize = ( size_t ) 0;
-
-	/* pxEnd is used to mark the end of the list of free blocks and is inserted
-	 * at the end of the heap space. */
-	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
-	uxAddress -= xHeapStructSize;
-	uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
-	pxEnd = ( void * ) uxAddress;
-	pxEnd->xBlockSize = 0;
-	pxEnd->pxNextFreeBlock = NULL;
-
-	/* To start with there is a single free block that is sized to take up the
-	 * entire heap space, minus the space taken by pxEnd. */
-	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
-	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
-	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
-
-	/* Only one block exists - and it covers the entire usable heap space. */
-	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
-
-	/* Work out the position of the top bit in a size_t variable. */
-	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * secureheapBITS_PER_BYTE ) - 1 );
-}
-/*-----------------------------------------------------------*/
-
-static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
-{
-BlockLink_t *pxIterator;
-uint8_t *puc;
-
-	/* Iterate through the list until a block is found that has a higher address
-	 * than the block being inserted. */
-	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
-	{
-		/* Nothing to do here, just iterate to the right position. */
-	}
-
-	/* Do the block being inserted, and the block it is being inserted after
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxIterator;
-	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
-	{
-		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
-		pxBlockToInsert = pxIterator;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Do the block being inserted, and the block it is being inserted before
-	 * make a contiguous block of memory? */
-	puc = ( uint8_t * ) pxBlockToInsert;
-	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
-	{
-		if( pxIterator->pxNextFreeBlock != pxEnd )
-		{
-			/* Form one big block from the two blocks. */
-			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
-			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
-		}
-		else
-		{
-			pxBlockToInsert->pxNextFreeBlock = pxEnd;
-		}
-	}
-	else
-	{
-		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
-	}
-
-	/* If the block being inserted plugged a gab, so was merged with the block
-	 * before and the block after, then it's pxNextFreeBlock pointer will have
-	 * already been set, and should not be set here as that would make it point
-	 * to itself. */
-	if( pxIterator != pxBlockToInsert )
-	{
-		pxIterator->pxNextFreeBlock = pxBlockToInsert;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void *pvPortMalloc( size_t xWantedSize )
-{
-BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
-void *pvReturn = NULL;
-
-	/* If this is the first call to malloc then the heap will require
-	 * initialisation to setup the list of free blocks. */
-	if( pxEnd == NULL )
-	{
-		prvHeapInit();
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Check the requested block size is not so large that the top bit is set.
-	 * The top bit of the block size member of the BlockLink_t structure is used
-	 * to determine who owns the block - the application or the kernel, so it
-	 * must be free. */
-	if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
-	{
-		/* The wanted size is increased so it can contain a BlockLink_t
-		 * structure in addition to the requested amount of bytes. */
-		if( xWantedSize > 0 )
-		{
-			xWantedSize += xHeapStructSize;
-
-			/* Ensure that blocks are always aligned to the required number of
-			 * bytes. */
-			if( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) != 0x00 )
-			{
-				/* Byte alignment required. */
-				xWantedSize += ( secureportBYTE_ALIGNMENT - ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) );
-				secureportASSERT( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
-		{
-			/* Traverse the list from the start (lowest address) block until
-			 * one of adequate size is found. */
-			pxPreviousBlock = &xStart;
-			pxBlock = xStart.pxNextFreeBlock;
-			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
-			{
-				pxPreviousBlock = pxBlock;
-				pxBlock = pxBlock->pxNextFreeBlock;
-			}
-
-			/* If the end marker was reached then a block of adequate size was
-			 * not found. */
-			if( pxBlock != pxEnd )
-			{
-				/* Return the memory space pointed to - jumping over the
-				 * BlockLink_t structure at its start. */
-				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
-
-				/* This block is being returned for use so must be taken out
-				 * of the list of free blocks. */
-				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
-
-				/* If the block is larger than required it can be split into
-				 * two. */
-				if( ( pxBlock->xBlockSize - xWantedSize ) > secureheapMINIMUM_BLOCK_SIZE )
-				{
-					/* This block is to be split into two.  Create a new
-					 * block following the number of bytes requested. The void
-					 * cast is used to prevent byte alignment warnings from the
-					 * compiler. */
-					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
-					secureportASSERT( ( ( ( size_t ) pxNewBlockLink ) & secureportBYTE_ALIGNMENT_MASK ) == 0 );
-
-					/* Calculate the sizes of two blocks split from the single
-					 * block. */
-					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
-					pxBlock->xBlockSize = xWantedSize;
-
-					/* Insert the new block into the list of free blocks. */
-					prvInsertBlockIntoFreeList( pxNewBlockLink );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				xFreeBytesRemaining -= pxBlock->xBlockSize;
-
-				if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
-				{
-					xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* The block is being returned - it is allocated and owned by
-				 * the application and has no "next" block. */
-				pxBlock->xBlockSize |= xBlockAllocatedBit;
-				pxBlock->pxNextFreeBlock = NULL;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	traceMALLOC( pvReturn, xWantedSize );
-
-	#if( secureconfigUSE_MALLOC_FAILED_HOOK == 1 )
-	{
-		if( pvReturn == NULL )
-		{
-			extern void vApplicationMallocFailedHook( void );
-			vApplicationMallocFailedHook();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#endif
-
-	secureportASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) secureportBYTE_ALIGNMENT_MASK ) == 0 );
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vPortFree( void *pv )
-{
-uint8_t *puc = ( uint8_t * ) pv;
-BlockLink_t *pxLink;
-
-	if( pv != NULL )
-	{
-		/* The memory being freed will have an BlockLink_t structure immediately
-		 * before it. */
-		puc -= xHeapStructSize;
-
-		/* This casting is to keep the compiler from issuing warnings. */
-		pxLink = ( void * ) puc;
-
-		/* Check the block is actually allocated. */
-		secureportASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
-		secureportASSERT( pxLink->pxNextFreeBlock == NULL );
-
-		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
-		{
-			if( pxLink->pxNextFreeBlock == NULL )
-			{
-				/* The block is being returned to the heap - it is no longer
-				 * allocated. */
-				pxLink->xBlockSize &= ~xBlockAllocatedBit;
-
-				secureportDISABLE_NON_SECURE_INTERRUPTS();
-				{
-					/* Add this block to the list of free blocks. */
-					xFreeBytesRemaining += pxLink->xBlockSize;
-					traceFREE( pv, pxLink->xBlockSize );
-					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
-				}
-				secureportENABLE_NON_SECURE_INTERRUPTS();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetFreeHeapSize( void )
-{
-	return xFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-size_t xPortGetMinimumEverFreeHeapSize( void )
-{
-	return xMinimumEverFreeBytesRemaining;
-}
-/*-----------------------------------------------------------*/
-
-void vPortInitialiseBlocks( void )
-{
-	/* This just exists to keep the linker quiet. */
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.h b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.h
deleted file mode 100644
index b7e071a..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_heap.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_HEAP_H__
-#define __SECURE_HEAP_H__
-
-/* Standard includes. */
-#include <stdlib.h>
-
-/**
- * @brief Allocates memory from heap.
- *
- * @param[in] xWantedSize The size of the memory to be allocated.
- *
- * @return Pointer to the memory region if the allocation is successful, NULL
- * otherwise.
- */
-void *pvPortMalloc( size_t xWantedSize );
-
-/**
- * @brief Frees the previously allocated memory.
- *
- * @param[in] pv Pointer to the memory to be freed.
- */
-void vPortFree( void *pv );
-
-#endif /* __SECURE_HEAP_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.c b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.c
deleted file mode 100644
index fdabd11..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-
-/* Secure init includes. */
-#include "secure_init.h"
-
-/* Secure port macros. */
-#include "secure_port_macros.h"
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define secureinitSCB_AIRCR					( ( volatile uint32_t * ) 0xe000ed0c )  /* Application Interrupt and Reset Control Register. */
-#define secureinitSCB_AIRCR_VECTKEY_POS		( 16UL )
-#define secureinitSCB_AIRCR_VECTKEY_MASK	( 0xFFFFUL << secureinitSCB_AIRCR_VECTKEY_POS )
-#define secureinitSCB_AIRCR_PRIS_POS		( 14UL )
-#define secureinitSCB_AIRCR_PRIS_MASK		( 1UL << secureinitSCB_AIRCR_PRIS_POS )
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define secureinitFPCCR						( ( volatile uint32_t * ) 0xe000ef34 )  /* Floating Point Context Control Register. */
-#define secureinitFPCCR_LSPENS_POS			( 29UL )
-#define secureinitFPCCR_LSPENS_MASK			( 1UL << secureinitFPCCR_LSPENS_POS )
-#define secureinitFPCCR_TS_POS				( 26UL )
-#define secureinitFPCCR_TS_MASK				( 1UL << secureinitFPCCR_TS_POS )
-
-#define secureinitNSACR						( ( volatile uint32_t * ) 0xe000ed8c )  /* Non-secure Access Control Register. */
-#define secureinitNSACR_CP10_POS			( 10UL )
-#define secureinitNSACR_CP10_MASK			( 1UL << secureinitNSACR_CP10_POS )
-#define secureinitNSACR_CP11_POS			( 11UL )
-#define secureinitNSACR_CP11_MASK			( 1UL << secureinitNSACR_CP11_POS )
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_DePrioritizeNSExceptions( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
-									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
-									( ( 0x1UL	<< secureinitSCB_AIRCR_PRIS_POS )	& secureinitSCB_AIRCR_PRIS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
-
-secureportNON_SECURE_CALLABLE void SecureInit_EnableNSFPUAccess( void )
-{
-	uint32_t ulIPSR;
-
-	 /* Read the Interrupt Program Status Register (IPSR) value. */
-	secureportREAD_IPSR( ulIPSR );
-
-	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
-	 * when the processor is running in the Thread Mode. */
-	if( ulIPSR != 0 )
-	{
-		/* CP10 = 1 ==> Non-secure access to the Floating Point Unit is
-		 * permitted. CP11 should be programmed to the same value as CP10. */
-		*( secureinitNSACR ) |= ( secureinitNSACR_CP10_MASK | secureinitNSACR_CP11_MASK );
-
-		/* LSPENS = 0 ==> LSPEN is writable fron non-secure state. This ensures
-		 * that we can enable/disable lazy stacking in port.c file. */
-		*( secureinitFPCCR ) &= ~ ( secureinitFPCCR_LSPENS_MASK );
-
-		/* TS = 1 ==> Treat FP registers as secure i.e. callee saved FP
-		 * registers (S16-S31) are also pushed to stack on exception entry and
-		 * restored on exception return. */
-		*( secureinitFPCCR ) |= ( secureinitFPCCR_TS_MASK );
-	}
-}
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.h b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.h
deleted file mode 100644
index 34e4b48..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_init.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_INIT_H__
-#define __SECURE_INIT_H__
-
-/**
- * @brief De-prioritizes the non-secure exceptions.
- *
- * This is needed to ensure that the non-secure PendSV runs at the lowest
- * priority. Context switch is done in the non-secure PendSV handler.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_DePrioritizeNSExceptions( void );
-
-/**
- * @brief Sets up the Floating Point Unit (FPU) for Non-Secure access.
- *
- * Also sets FPCCR.TS=1 to ensure that the content of the Floating Point
- * Registers are not leaked to the non-secure side.
- *
- * @note This function must be called in the handler mode. It is no-op if called
- * in the thread mode.
- */
-void SecureInit_EnableNSFPUAccess( void );
-
-#endif /* __SECURE_INIT_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_port_macros.h b/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_port_macros.h
deleted file mode 100644
index e59c06b..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33/secure/secure_port_macros.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __SECURE_PORT_MACROS_H__
-#define __SECURE_PORT_MACROS_H__
-
-/**
- * @brief Byte alignment requirements.
- */
-#define secureportBYTE_ALIGNMENT					8
-#define secureportBYTE_ALIGNMENT_MASK				( 0x0007 )
-
-/**
- * @brief Macro to declare a function as non-secure callable.
- */
-#if defined( __IAR_SYSTEMS_ICC__ )
-	#define secureportNON_SECURE_CALLABLE			__cmse_nonsecure_entry __root
-#else
-	#define secureportNON_SECURE_CALLABLE			__attribute__((cmse_nonsecure_entry)) __attribute__((used))
-#endif
-
-/**
- * @brief Set the secure PRIMASK value.
- */
-#define secureportSET_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Set the non-secure PRIMASK value.
- */
-#define secureportSET_NON_SECURE_PRIMASK( ulPrimaskValue ) \
-	__asm volatile ( "msr primask_ns, %0" : : "r" ( ulPrimaskValue ) : "memory" )
-
-/**
- * @brief Read the PSP value in the given variable.
- */
-#define secureportREAD_PSP( pucOutCurrentStackPointer ) \
-	__asm volatile ( "mrs %0, psp"  : "=r" ( pucOutCurrentStackPointer ) )
-
-/**
- * @brief Set the PSP to the given value.
- */
-#define secureportSET_PSP( pucCurrentStackPointer ) \
-	__asm volatile ( "msr psp, %0" : : "r" ( pucCurrentStackPointer ) )
-
-/**
- * @brief Set the PSPLIM to the given value.
- */
-#define secureportSET_PSPLIM( pucStackLimit ) \
-	__asm volatile ( "msr psplim, %0" : : "r" ( pucStackLimit ) )
-
-/**
- * @brief Set the NonSecure MSP to the given value.
- */
-#define secureportSET_MSP_NS( pucMainStackPointer ) \
-	__asm volatile ( "msr msp_ns, %0" : : "r" ( pucMainStackPointer ) )
-
-/**
- * @brief Set the CONTROL register to the given value.
- */
-#define secureportSET_CONTROL( ulControl ) \
-	__asm volatile ( "msr control, %0" : : "r" ( ulControl ) : "memory" )
-
-/**
- * @brief Read the Interrupt Program Status Register (IPSR) value in the given
- * variable.
- */
-#define secureportREAD_IPSR( ulIPSR ) \
-	__asm volatile ( "mrs %0, ipsr"  : "=r" ( ulIPSR ) )
-
-/**
- * @brief PRIMASK value to enable interrupts.
- */
-#define secureportPRIMASK_ENABLE_INTERRUPTS_VAL		0
-
-/**
- * @brief PRIMASK value to disable interrupts.
- */
-#define secureportPRIMASK_DISABLE_INTERRUPTS_VAL	1
-
-/**
- * @brief Disable secure interrupts.
- */
-#define secureportDISABLE_SECURE_INTERRUPTS()		secureportSET_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Disable non-secure interrupts.
- *
- * This effectively disables context switches.
- */
-#define secureportDISABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_DISABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Enable non-secure interrupts.
- */
-#define secureportENABLE_NON_SECURE_INTERRUPTS()	secureportSET_NON_SECURE_PRIMASK( secureportPRIMASK_ENABLE_INTERRUPTS_VAL )
-
-/**
- * @brief Assert definition.
- */
-#define secureportASSERT( x )						\
-	if( ( x ) == 0 )								\
-	{												\
-		secureportDISABLE_SECURE_INTERRUPTS();		\
-		secureportDISABLE_NON_SECURE_INTERRUPTS();	\
-		for( ;; );									\
-	}
-
-#endif /* __SECURE_PORT_MACROS_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/port.c b/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/port.c
deleted file mode 100644
index d029775..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/port.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers. That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/* Portasm includes. */
-#include "portasm.h"
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/* Secure components includes. */
-	#include "secure_context.h"
-	#include "secure_init.h"
-#endif /* configENABLE_TRUSTZONE */
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/**
- * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
- * i.e. the processor boots as secure and never jumps to the non-secure side.
- * The Trust Zone support in the port must be disabled in order to run FreeRTOS
- * on the secure side. The following are the valid configuration seetings:
- *
- * 1. Run FreeRTOS on the Secure Side:
- *		configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
- *
- * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
- *
- * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
- *		configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
- */
-#if( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
-	#error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the NVIC.
- */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ			configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the
-	 * same a the core. */
-	#define portNVIC_SYSTICK_CLK_BIT		( 0 )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the SCB.
- */
-#define portSCB_SYS_HANDLER_CTRL_STATE_REG	( * ( volatile uint32_t * ) 0xe000ed24 )
-#define portSCB_MEM_FAULT_ENABLE_BIT		( 1UL << 16UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the FPU.
- */
-#define portCPACR							( ( volatile uint32_t * ) 0xe000ed88 )	/* Coprocessor Access Control Register. */
-#define portCPACR_CP10_VALUE				( 3UL )
-#define portCPACR_CP11_VALUE				portCPACR_CP10_VALUE
-#define portCPACR_CP10_POS					( 20UL )
-#define portCPACR_CP11_POS					( 22UL )
-
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 )	/* Floating Point Context Control Register. */
-#define portFPCCR_ASPEN_POS					( 31UL )
-#define portFPCCR_ASPEN_MASK				( 1UL << portFPCCR_ASPEN_POS )
-#define portFPCCR_LSPEN_POS					( 30UL )
-#define portFPCCR_LSPEN_MASK				( 1UL << portFPCCR_LSPEN_POS )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to manipulate the MPU.
- */
-#define portMPU_TYPE_REG					( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_CTRL_REG					( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portMPU_RNR_REG						( * ( ( volatile uint32_t * ) 0xe000ed98 ) )
-
-#define portMPU_RBAR_REG					( * ( ( volatile uint32_t * ) 0xe000ed9c ) )
-#define portMPU_RLAR_REG					( * ( ( volatile uint32_t * ) 0xe000eda0 ) )
-
-#define portMPU_RBAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda4 ) )
-#define portMPU_RLAR_A1_REG					( * ( ( volatile uint32_t * ) 0xe000eda8 ) )
-
-#define portMPU_RBAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edac ) )
-#define portMPU_RLAR_A2_REG					( * ( ( volatile uint32_t * ) 0xe000edb0 ) )
-
-#define portMPU_RBAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb4 ) )
-#define portMPU_RLAR_A3_REG					( * ( ( volatile uint32_t * ) 0xe000edb8 ) )
-
-#define portMPU_MAIR0_REG					( * ( ( volatile uint32_t * ) 0xe000edc0 ) )
-#define portMPU_MAIR1_REG					( * ( ( volatile uint32_t * ) 0xe000edc4 ) )
-
-#define portMPU_RBAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-#define portMPU_RLAR_ADDRESS_MASK			( 0xffffffe0 ) /* Must be 32-byte aligned. */
-
-#define portMPU_MAIR_ATTR0_POS				( 0UL )
-#define portMPU_MAIR_ATTR0_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR1_POS				( 8UL )
-#define portMPU_MAIR_ATTR1_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR2_POS				( 16UL )
-#define portMPU_MAIR_ATTR2_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR3_POS				( 24UL )
-#define portMPU_MAIR_ATTR3_MASK				( 0xff000000 )
-
-#define portMPU_MAIR_ATTR4_POS				( 0UL )
-#define portMPU_MAIR_ATTR4_MASK				( 0x000000ff )
-
-#define portMPU_MAIR_ATTR5_POS				( 8UL )
-#define portMPU_MAIR_ATTR5_MASK				( 0x0000ff00 )
-
-#define portMPU_MAIR_ATTR6_POS				( 16UL )
-#define portMPU_MAIR_ATTR6_MASK				( 0x00ff0000 )
-
-#define portMPU_MAIR_ATTR7_POS				( 24UL )
-#define portMPU_MAIR_ATTR7_MASK				( 0xff000000 )
-
-#define portMPU_RLAR_ATTR_INDEX0			( 0UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX1			( 1UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX2			( 2UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX3			( 3UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX4			( 4UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX5			( 5UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX6			( 6UL << 1UL )
-#define portMPU_RLAR_ATTR_INDEX7			( 7UL << 1UL )
-
-#define portMPU_RLAR_REGION_ENABLE			( 1UL )
-
-/* Enable privileged access to unmapped region. */
-#define portMPU_PRIV_BACKGROUND_ENABLE_BIT	( 1UL << 2UL )
-
-/* Enable MPU. */
-#define portMPU_ENABLE_BIT					( 1UL << 0UL )
-
-/* Expected value of the portMPU_TYPE register. */
-#define portEXPECTED_MPU_TYPE_VALUE			( 8UL << 8UL ) /* 8 regions, unified. */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief The maximum 24-bit number.
- *
- * It is needed because the systick is a 24-bit counter.
- */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/**
- * @brief A fiddle factor to estimate the number of SysTick counts that would
- * have occurred while the SysTick counter is stopped during tickless idle
- * calculations.
- */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Constants required to set up the initial stack.
- */
-#define portINITIAL_XPSR					( 0x01000000 )
-
-#if( configRUN_FREERTOS_SECURE_ONLY == 1 )
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         FD
-	 * 1111 1111  1111 1111  1111 1111  1111 1101
-	 *
-	 * Bit[6] - 1 --> The exception was taken from the Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 1 --> The exception was taken to the Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xfffffffd )
-#else
-	/**
-	 * @brief Initial EXC_RETURN value.
-	 *
-	 *     FF         FF         FF         BC
-	 * 1111 1111  1111 1111  1111 1111  1011 1100
-	 *
-	 * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
-	 * Bit[5] - 1 --> Do not skip stacking of additional state context.
-	 * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
-	 * Bit[3] - 1 --> Return to the Thread mode.
-	 * Bit[2] - 1 --> Restore registers from the process stack.
-	 * Bit[1] - 0 --> Reserved, 0.
-	 * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
-	 */
-	#define portINITIAL_EXC_RETURN			( 0xffffffbc )
-#endif /* configRUN_FREERTOS_SECURE_ONLY */
-
-/**
- * @brief CONTROL register privileged bit mask.
- *
- * Bit[0] in CONTROL register tells the privilege:
- *  Bit[0] = 0 ==> The task is privileged.
- *  Bit[0] = 1 ==> The task is not privileged.
- */
-#define portCONTROL_PRIVILEGED_MASK			( 1UL << 0UL )
-
-/**
- * @brief Initial CONTROL register values.
- */
-#define portINITIAL_CONTROL_UNPRIVILEGED	( 0x3 )
-#define portINITIAL_CONTROL_PRIVILEGED		( 0x2 )
-
-/**
- * @brief Let the user override the pre-loading of the initial LR with the
- * address of prvTaskExitError() in case it messes up unwinding of the stack
- * in the debugger.
- */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS			configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS			prvTaskExitError
-#endif
-
-/**
- * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
- * when a task is created. This helps in debugging at the cost of code size.
- */
-#define portPRELOAD_REGISTERS				1
-
-/**
- * @brief A task is created without a secure context, and must call
- * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
- * any secure calls.
- */
-#define portNO_SECURE_CONTEXT				0
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Used to catch tasks that attempt to return from their implementing
- * function.
- */
-static void prvTaskExitError( void );
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Setup the Memory Protection Unit (MPU).
-	 */
-	static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_MPU */
-
-#if( configENABLE_FPU == 1 )
-	/**
-	 * @brief Setup the Floating Point Unit (FPU).
-	 */
-	static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
-#endif /* configENABLE_FPU */
-
-/**
- * @brief Setup the timer to generate the tick interrupts.
- *
- * The implementation in this file is weak to allow application writers to
- * change the timer used to generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether the current execution context is interrupt.
- *
- * @return pdTRUE if the current execution context is interrupt, pdFALSE
- * otherwise.
- */
-BaseType_t xPortIsInsideInterrupt( void );
-
-/**
- * @brief Yield the processor.
- */
-void vPortYield( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enter critical section.
- */
-void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Exit from critical section.
- */
-void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SysTick handler.
- */
-void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief C part of SVC handler.
- */
-portDONT_DISCARD void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Each task maintains its own interrupt status in the critical nesting
- * variable.
- */
-static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Saved as part of the task context to indicate which context the
-	 * task is using on the secure side.
-	 */
-	portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_CONTEXT;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	/**
-	 * @brief The number of SysTick increments that make up one tick period.
-	 */
-	static uint32_t ulTimerCountsForOneTick = 0;
-
-	/**
-	 * @brief The maximum number of tick periods that can be suppressed is
-	 * limited by the 24 bit resolution of the SysTick timer.
-	 */
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-
-	/**
-	 * @brief Compensate for the CPU cycles that pass while the SysTick is
-	 * stopped (low power functionality only).
-	 */
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-	__attribute__(( weak )) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily. The time the SysTick is stopped for is
-		 * accounted for as best it can be, but using the tickless mode will
-		 * inevitably result in some tiny drift of the time maintained by the
-		 * kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		 * tick periods. -1 is used because this code will execute part way
-		 * through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		 * method as that will mask interrupts that should exit sleep mode. */
-		__asm volatile( "cpsid i" ::: "memory" );
-		__asm volatile( "dsb" );
-		__asm volatile( "isb" );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		 * to be un-suspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			 * this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			 * periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above the cpsid instruction()
-			 * above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			 * zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-			 * set its parameter to 0 to indicate that its implementation
-			 * contains its own wait for interrupt or wait for event
-			 * instruction, and so wfi should not be executed again. However,
-			 * the original expected idle time variable must remain unmodified,
-			 * so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__asm volatile( "dsb" ::: "memory" );
-				__asm volatile( "wfi" );
-				__asm volatile( "isb" );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			 * out of sleep mode to execute immediately. See comments above
-			 * the cpsid instruction above. */
-			__asm volatile( "cpsie i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			 * and interrupts that execute while the clock is stopped will
-			 * increase any slippage between the time maintained by the RTOS and
-			 * calendar time. */
-			__asm volatile( "cpsid i" ::: "memory" );
-			__asm volatile( "dsb" );
-			__asm volatile( "isb" );
-
-			/* Disable the SysTick clock without reading the
-			 * portNVIC_SYSTICK_CTRL_REG register to ensure the
-			 * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.
-			 * Again, the time the SysTick is stopped for is accounted for as
-			 * best it can be, but using the tickless mode will inevitably
-			 * result in some tiny drift of the time maintained by the kernel
-			 * with respect to calendar time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			 * been set back to the current reload value (the reload back being
-			 * correct for the entire expected idle time) or if the SysTick is
-			 * yet to count to zero (in which case an interrupt other than the
-			 * SysTick must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				 * reloaded with ulReloadValue.  Reset the
-				 * portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				 * period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				 * underflowed because the post sleep hook did something
-				 * that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				 * function exits, the tick value maintained by the tick is
-				 * stepped forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				 * Work out how long the sleep lasted rounded to complete tick
-				 * periods (not the ulReload value which accounted for part
-				 * ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				 * was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				 * period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			 * again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			 * value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__asm volatile( "cpsie i" ::: "memory" );
-		}
-	}
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-__attribute__(( weak )) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-volatile uint32_t ulDummy = 0UL;
-
-	/* A function that implements a task must not exit or attempt to return to
-	 * its caller as there is nothing to return to. If a task wants to exit it
-	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
-	 * to be triggered if configASSERT() is defined, then stop here so
-	 * application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-
-	while( ulDummy == 0 )
-	{
-		/* This file calls prvTaskExitError() after the scheduler has been
-		 * started to remove a compiler warning about the function being
-		 * defined but never called.  ulDummy is used purely to quieten other
-		 * warnings about code appearing after this function is called - making
-		 * ulDummy volatile makes the compiler think the function could return
-		 * and therefore not output an 'unreachable code' warning for code that
-		 * appears after it. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __privileged_functions_start__;
-		extern uint32_t * __privileged_functions_end__;
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-		extern uint32_t * __unprivileged_flash_start__;
-		extern uint32_t * __unprivileged_flash_end__;
-		extern uint32_t * __privileged_sram_start__;
-		extern uint32_t * __privileged_sram_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __privileged_functions_start__[];
-		extern uint32_t __privileged_functions_end__[];
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-		extern uint32_t __unprivileged_flash_start__[];
-		extern uint32_t __unprivileged_flash_end__[];
-		extern uint32_t __privileged_sram_start__[];
-		extern uint32_t __privileged_sram_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-
-		/* Check that the MPU is present. */
-		if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
-		{
-			/* MAIR0 - Index 0. */
-			portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-			/* MAIR0 - Index 1. */
-			portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-			/* Setup privileged flash as Read Only so that privileged tasks can
-			 * read it but not modify. */
-			portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged flash as Read Only by both privileged and
-			 * unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup unprivileged syscalls flash as Read Only by both privileged
-			 * and unprivileged tasks. All tasks can read it but no-one can modify. */
-			portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_READ_ONLY );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Setup RAM containing kernel data for privileged access only. */
-			portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
-			portMPU_RBAR_REG =	( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
-								( portMPU_REGION_NON_SHAREABLE ) |
-								( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-								( portMPU_REGION_EXECUTE_NEVER );
-			portMPU_RLAR_REG =	( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
-								( portMPU_RLAR_ATTR_INDEX0 ) |
-								( portMPU_RLAR_REGION_ENABLE );
-
-			/* Enable mem fault. */
-			portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
-
-			/* Enable MPU with privileged background access i.e. unmapped
-			 * regions have privileged access. */
-			portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_FPU == 1 )
-	static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			/* Enable non-secure access to the FPU. */
-			SecureInit_EnableNSFPUAccess();
-		}
-		#endif /* configENABLE_TRUSTZONE */
-
-		/* CP10 = 11 ==> Full access to FPU i.e. both privileged and
-		 * unprivileged code should be able to access FPU. CP11 should be
-		 * programmed to the same value as CP10. */
-		*( portCPACR ) |=	(	( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
-								( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
-							);
-
-		/* ASPEN = 1 ==> Hardware should automatically preserve floating point
-		 * context on exception entry and restore on exception return.
-		 * LSPEN = 1 ==> Enable lazy context save of FP state. */
-		*( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
-	}
-#endif /* configENABLE_FPU */
-/*-----------------------------------------------------------*/
-
-void vPortYield( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-
-	/* Barriers are normally not required but do ensure the code is
-	 * completely within the specified behaviour for the architecture. */
-	__asm volatile( "dsb" ::: "memory" );
-	__asm volatile( "isb" );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
-{
-#if( configENABLE_MPU == 1 )
-	#if defined( __ARMCC_VERSION )
-		/* Declaration when these variable are defined in code instead of being
-		 * exported from linker scripts. */
-		extern uint32_t * __syscalls_flash_start__;
-		extern uint32_t * __syscalls_flash_end__;
-	#else
-		/* Declaration when these variable are exported from linker scripts. */
-		extern uint32_t __syscalls_flash_start__[];
-		extern uint32_t __syscalls_flash_end__[];
-	#endif /* defined( __ARMCC_VERSION ) */
-#endif /* configENABLE_MPU */
-
-uint32_t ulPC;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	uint32_t ulR0;
-	#if( configENABLE_MPU == 1 )
-		uint32_t ulControl, ulIsTaskPrivileged;
-	#endif /* configENABLE_MPU */
-#endif /* configENABLE_TRUSTZONE */
-uint8_t ucSVCNumber;
-
-	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
-	 * R12, LR, PC, xPSR. */
-	ulPC = pulCallerStackAddress[ 6 ];
-	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
-
-	switch( ucSVCNumber )
-	{
-		#if( configENABLE_TRUSTZONE == 1 )
-			case portSVC_ALLOCATE_SECURE_CONTEXT:
-			{
-				/* R0 contains the stack size passed as parameter to the
-				 * vPortAllocateSecureContext function. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				#if( configENABLE_MPU == 1 )
-				{
-					/* Read the CONTROL register value. */
-					__asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
-
-					/* The task that raised the SVC is privileged if Bit[0]
-					 * in the CONTROL register is 0. */
-					ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
-
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged );
-				}
-				#else
-				{
-					/* Allocate and load a context for the secure task. */
-					xSecureContext = SecureContext_AllocateContext( ulR0 );
-				}
-				#endif /* configENABLE_MPU */
-
-				configASSERT( xSecureContext != NULL );
-				SecureContext_LoadContext( xSecureContext );
-			}
-			break;
-
-			case portSVC_FREE_SECURE_CONTEXT:
-			{
-				/* R0 contains the secure context handle to be freed. */
-				ulR0 = pulCallerStackAddress[ 0 ];
-
-				/* Free the secure context. */
-				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
-			}
-			break;
-		#endif /* configENABLE_TRUSTZONE */
-
-		case portSVC_START_SCHEDULER:
-		{
-			#if( configENABLE_TRUSTZONE == 1 )
-			{
-				/* De-prioritize the non-secure exceptions so that the
-				 * non-secure pendSV runs at the lowest priority. */
-				SecureInit_DePrioritizeNSExceptions();
-
-				/* Initialize the secure context management system. */
-				SecureContext_Init();
-			}
-			#endif /* configENABLE_TRUSTZONE */
-
-			#if( configENABLE_FPU == 1 )
-			{
-				/* Setup the Floating Point Unit (FPU). */
-				prvSetupFPU();
-			}
-			#endif /* configENABLE_FPU */
-
-			/* Setup the context of the first task so that the first task starts
-			 * executing. */
-			vRestoreContextOfFirstTask();
-		}
-		break;
-
-		#if( configENABLE_MPU == 1 )
-			case portSVC_RAISE_PRIVILEGE:
-			{
-				/* Only raise the privilege, if the svc was raised from any of
-				 * the system calls. */
-				if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-					ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-				{
-					vRaisePrivilege();
-				}
-			}
-			break;
-		#endif /* configENABLE_MPU */
-
-		default:
-		{
-			/* Incorrect SVC call. */
-			configASSERT( pdFALSE );
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
-#endif /* configENABLE_MPU */
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	#if( portPRELOAD_REGISTERS == 0 )
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack -= 5;											/* R12, R3, R2 and R1. */
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack -= 9;											/* R11..R4, EXC_RETURN. */
-		*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#else /* portPRELOAD_REGISTERS */
-	{
-		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
-		pxTopOfStack--;
-		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
-
-		#if( configENABLE_MPU == 1 )
-		{
-			pxTopOfStack--;
-			if( xRunPrivileged == pdTRUE )
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_PRIVILEGED;		/* Slot used to hold this task's CONTROL value. */
-			}
-			else
-			{
-				*pxTopOfStack = portINITIAL_CONTROL_UNPRIVILEGED;	/* Slot used to hold this task's CONTROL value. */
-			}
-		}
-		#endif /* configENABLE_MPU */
-
-		pxTopOfStack--;
-		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
-
-		#if( configENABLE_TRUSTZONE == 1 )
-		{
-			pxTopOfStack--;
-			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
-		}
-		#endif /* configENABLE_TRUSTZONE */
-	}
-	#endif /* portPRELOAD_REGISTERS */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	#if( configENABLE_MPU == 1 )
-	{
-		/* Setup the Memory Protection Unit (MPU). */
-		prvSetupMPU();
-	}
-	#endif /* configENABLE_MPU */
-
-	/* Start the timer that generates the tick ISR. Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialize the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Start the first task. */
-	vStartFirstTask();
-
-	/* Should never get here as the tasks will now be executing. Call the task
-	 * exit error function to prevent compiler warnings about a static function
-	 * not being called in the case that the application writer overrides this
-	 * functionality by defining configTASK_RETURN_ADDRESS. Call
-	 * vTaskSwitchContext() so link time optimization does not remove the
-	 * symbol. */
-	vTaskSwitchContext();
-	prvTaskExitError();
-
-	/* Should not get here. */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-	{
-	uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
-	int32_t lIndex = 0;
-
-		/* Setup MAIR0. */
-		xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
-		xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
-
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that
-		 * the stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			ulRegionStartAddress = ( ( uint32_t ) pxBottomOfStack ) & portMPU_RBAR_ADDRESS_MASK;
-			ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
-			ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRBAR =	( ulRegionStartAddress ) |
-															( portMPU_REGION_NON_SHAREABLE ) |
-															( portMPU_REGION_READ_WRITE ) |
-															( portMPU_REGION_EXECUTE_NEVER );
-
-			xMPUSettings->xRegionsSettings[ 0 ].ulRLAR =	( ulRegionEndAddress ) |
-															( portMPU_RLAR_ATTR_INDEX0 ) |
-															( portMPU_RLAR_REGION_ENABLE );
-		}
-
-		/* User supplied configurable regions. */
-		for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
-		{
-			/* If xRegions is NULL i.e. the task has not specified any MPU
-			 * region, the else part ensures that all the configurable MPU
-			 * regions are invalidated. */
-			if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
-			{
-				/* Translate the generic region definition contained in xRegions
-				 * into the ARMv8 specific MPU settings that are then stored in
-				 * xMPUSettings. */
-				ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
-				ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
-				ulRegionEndAddress  &= portMPU_RLAR_ADDRESS_MASK;
-
-				/* Start address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR =	( ulRegionStartAddress ) |
-																			( portMPU_REGION_NON_SHAREABLE );
-
-				/* RO/RW. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
-				}
-				else
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
-				}
-
-				/* XN. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
-				{
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
-				}
-
-				/* End Address. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR =	( ulRegionEndAddress ) |
-																			( portMPU_RLAR_REGION_ENABLE );
-
-				/* Normal memory/ Device memory. */
-				if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
-				{
-					/* Attr1 in MAIR0 is configured as device memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
-				}
-				else
-				{
-					/* Attr1 in MAIR0 is configured as normal memory. */
-					xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX0;
-				}
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
-				xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. Interrupt Program
-	 * Status Register (IPSR) holds the exception number of the currently-executing
-	 * exception or zero for Thread mode.*/
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
\ No newline at end of file
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.h b/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.h
deleted file mode 100644
index 5f84bd8..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORT_ASM_H__
-#define __PORT_ASM_H__
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-
-/* MPU wrappers includes. */
-#include "mpu_wrappers.h"
-
-/**
- * @brief Restore the context of the first task so that the first task starts
- * executing.
- */
-void vRestoreContextOfFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void ) __attribute__ (( naked ));
-
-/**
- * @brief Raises the privilege level by clearing the bit 0 of the CONTROL
- * register.
- *
- * @note This is a privileged function and should only be called from the kenrel
- * code.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vRaisePrivilege( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void ) __attribute__ (( naked ));
-
-/**
- * @brief Starts the first task.
- */
-void vStartFirstTask( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Disables interrupts.
- */
-uint32_t ulSetInterruptMask( void ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Enables interrupts.
- */
-void vClearInterruptMask( uint32_t ulMask ) __attribute__(( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief PendSV Exception handler.
- */
-void PendSV_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief SVC Handler.
- */
-void SVC_Handler( void ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Allocate a Secure context for the calling task.
- *
- * @param[in] ulSecureStackSize The size of the stack to be allocated on the
- * secure side for the calling task.
- */
-void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) __attribute__ (( naked ));
-
-/**
- * @brief Free the task's secure context.
- *
- * @param[in] pulTCB Pointer to the Task Control Block (TCB) of the task.
- */
-void vPortFreeSecureContext( uint32_t *pulTCB ) __attribute__ (( naked )) PRIVILEGED_FUNCTION;
-
-#endif /* __PORT_ASM_H__ */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.s
deleted file mode 100644
index 0621f5b..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portasm.s
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-/* Including FreeRTOSConfig.h here will cause build errors if the header file
-contains code not understood by the assembler - for example the 'extern' keyword.
-To avoid errors place any such code inside a #ifdef __ICCARM__/#endif block so
-the code is included in C files but excluded by the preprocessor in assembly
-files (__ICCARM__ is defined by the IAR C compiler but not by the IAR assembler. */
-#include "FreeRTOSConfig.h"
-
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-	EXTERN vPortSVCHandler_C
-
-	PUBLIC xIsPrivileged
-	PUBLIC vResetPrivilege
-	PUBLIC vRestoreContextOfFirstTask
-	PUBLIC vRaisePrivilege
-	PUBLIC vStartFirstTask
-	PUBLIC ulSetInterruptMask
-	PUBLIC vClearInterruptMask
-	PUBLIC PendSV_Handler
-	PUBLIC SVC_Handler
-/*-----------------------------------------------------------*/
-
-/*---------------- Unprivileged Functions -------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION .text:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-xIsPrivileged:
-	mrs r0, control							/* r0 = CONTROL. */
-	tst r0, #1								/* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	ite ne
-	movne r0, #0							/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	moveq r0, #1							/* CONTROL[0]==0. Return true to indicate that the processor is not privileged. */
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-vResetPrivilege:
-	mrs r0, control							/* r0 = CONTROL. */
-	orr r0, r0, #1							/* r0 = r0 | 1. */
-	msr control, r0							/* CONTROL = r0. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-/*----------------- Privileged Functions --------------------*/
-
-/*-----------------------------------------------------------*/
-
-	SECTION privileged_functions:CODE:NOROOT(2)
-	THUMB
-/*-----------------------------------------------------------*/
-
-vRestoreContextOfFirstTask:
-	ldr  r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr  r1, [r2]							/* Read pxCurrentTCB. */
-	ldr  r0, [r1]							/* Read top of stack from TCB - The first item in pxCurrentTCB is the task top of stack. */
-
-#if ( configENABLE_MPU == 1 )
-	dmb										/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	bic r4, r4, #1							/* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-	str r4, [r2]							/* Disable MPU. */
-
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	ldr r3, [r1]							/* r3 = *r1 i.e. r3 = MAIR0. */
-	ldr r2, =0xe000edc0						/* r2 = 0xe000edc0 [Location of MAIR0]. */
-	str r3, [r2]							/* Program MAIR0. */
-	ldr r2, =0xe000ed98						/* r2 = 0xe000ed98 [Location of RNR]. */
-	movs r3, #4								/* r3 = 4. */
-	str r3, [r2]							/* Program RNR = 4. */
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	ldr r2, =0xe000ed9c						/* r2 = 0xe000ed9c [Location of RBAR]. */
-	ldmia r1!, {r4-r11}						/* Read 4 sets of RBAR/RLAR registers from TCB. */
-	stmia r2!, {r4-r11}						/* Write 4 set of RBAR/RLAR registers using alias registers. */
-
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	orr r4, r4, #1							/* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-	str r4, [r2]							/* Enable MPU. */
-	dsb										/* Force memory writes before continuing. */
-#endif /* configENABLE_MPU */
-
-#if ( configENABLE_MPU == 1 )
-	ldm  r0!, {r1-r3}						/* Read from stack - r1 = PSPLIM, r2 = CONTROL and r3 = EXC_RETURN. */
-	msr  psplim, r1							/* Set this task's PSPLIM value. */
-	msr  control, r2						/* Set this task's CONTROL value. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r3									/* Finally, branch to EXC_RETURN. */
-#else /* configENABLE_MPU */
-	ldm  r0!, {r1-r2}						/* Read from stack - r1 = PSPLIM and r2 = EXC_RETURN. */
-	msr  psplim, r1							/* Set this task's PSPLIM value. */
-	movs r1, #2								/* r1 = 2. */
-	msr  CONTROL, r1						/* Switch to use PSP in the thread mode. */
-	adds r0, #32							/* Discard everything up to r0. */
-	msr  psp, r0							/* This is now the new top of stack to use in the task. */
-	isb
-	bx   r2									/* Finally, branch to EXC_RETURN. */
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-vRaisePrivilege:
-	mrs  r0, control						/* Read the CONTROL register. */
-	bic r0, r0, #1							/* Clear the bit 0. */
-	msr  control, r0						/* Write back the new CONTROL value. */
-	bx lr									/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-vStartFirstTask:
-	ldr r0, =0xe000ed08						/* Use the NVIC offset register to locate the stack. */
-	ldr r0, [r0]							/* Read the VTOR register which gives the address of vector table. */
-	ldr r0, [r0]							/* The first entry in vector table is stack pointer. */
-	msr msp, r0								/* Set the MSP back to the start of the stack. */
-	cpsie i									/* Globally enable interrupts. */
-	cpsie f
-	dsb
-	isb
-	svc 2									/* System call to start the first task. portSVC_START_SCHEDULER = 2. */
-/*-----------------------------------------------------------*/
-
-ulSetInterruptMask:
-	mrs r0, basepri							/* r0 = basepri. Return original basepri value. */
-	mov r1, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r1							/* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	dsb
-	isb
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-vClearInterruptMask:
-	msr basepri, r0							/* basepri = ulMask. */
-	dsb
-	isb
-	bx lr									/* Return. */
-/*-----------------------------------------------------------*/
-
-PendSV_Handler:
-	mrs r0, psp								/* Read PSP in r0. */
-#if ( configENABLE_FPU == 1 )
-	tst lr, #0x10							/* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-	it eq
-	vstmdbeq r0!, {s16-s31}					/* Store the FPU registers which are not saved automatically. */
-#endif /* configENABLE_FPU */
-#if ( configENABLE_MPU == 1 )
-	mrs r1, psplim							/* r1 = PSPLIM. */
-	mrs r2, control							/* r2 = CONTROL. */
-	mov r3, lr								/* r3 = LR/EXC_RETURN. */
-	stmdb r0!, {r1-r11}						/* Store on the stack - PSPLIM, CONTROL, LR and registers that are not automatically saved. */
-#else /* configENABLE_MPU */
-	mrs r2, psplim							/* r2 = PSPLIM. */
-	mov r3, lr								/* r3 = LR/EXC_RETURN. */
-	stmdb r0!, {r2-r11}						/* Store on the stack - PSPLIM, LR and registers that are not automatically. */
-#endif /* configENABLE_MPU */
-
-	ldr r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr r1, [r2]							/* Read pxCurrentTCB. */
-	str r0, [r1]							/* Save the new top of stack in TCB. */
-
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0							/* Disable interrupts upto configMAX_SYSCALL_INTERRUPT_PRIORITY. */
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0								/* r0 = 0. */
-	msr basepri, r0							/* Enable interrupts. */
-
-	ldr r2, =pxCurrentTCB					/* Read the location of pxCurrentTCB i.e. &( pxCurrentTCB ). */
-	ldr r1, [r2]							/* Read pxCurrentTCB. */
-	ldr r0, [r1]							/* The first item in pxCurrentTCB is the task top of stack. r0 now points to the top of stack. */
-
-#if ( configENABLE_MPU == 1 )
-	dmb										/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	bic r4, r4, #1							/* r4 = r4 & ~1 i.e. Clear the bit 0 in r4. */
-	str r4, [r2]							/* Disable MPU. */
-
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to MAIR0 in TCB. */
-	ldr r3, [r1]							/* r3 = *r1 i.e. r3 = MAIR0. */
-	ldr r2, =0xe000edc0						/* r2 = 0xe000edc0 [Location of MAIR0]. */
-	str r3, [r2]							/* Program MAIR0. */
-	ldr r2, =0xe000ed98						/* r2 = 0xe000ed98 [Location of RNR]. */
-	movs r3, #4								/* r3 = 4. */
-	str r3, [r2]							/* Program RNR = 4. */
-	adds r1, #4								/* r1 = r1 + 4. r1 now points to first RBAR in TCB. */
-	ldr r2, =0xe000ed9c						/* r2 = 0xe000ed9c [Location of RBAR]. */
-	ldmia r1!, {r4-r11}						/* Read 4 sets of RBAR/RLAR registers from TCB. */
-	stmia r2!, {r4-r11}						/* Write 4 set of RBAR/RLAR registers using alias registers. */
-
-	ldr r2, =0xe000ed94						/* r2 = 0xe000ed94 [Location of MPU_CTRL]. */
-	ldr r4, [r2]							/* Read the value of MPU_CTRL. */
-	orr r4, r4, #1							/* r4 = r4 | 1 i.e. Set the bit 0 in r4. */
-	str r4, [r2]							/* Enable MPU. */
-	dsb										/* Force memory writes before continuing. */
-#endif /* configENABLE_MPU */
-
-#if ( configENABLE_MPU == 1 )
-	ldmia r0!, {r1-r11}						/* Read from stack - r1 = PSPLIM, r2 = CONTROL, r3 = LR and r4-r11 restored. */
-#else /* configENABLE_MPU */
-	ldmia r0!, {r2-r11}						/* Read from stack - r2 = PSPLIM, r3 = LR and r4-r11 restored. */
-#endif /* configENABLE_MPU */
-
-#if ( configENABLE_FPU == 1 )
-	tst r3, #0x10							/* Test Bit[4] in LR. Bit[4] of EXC_RETURN is 0 if the FPU is in use. */
-	it eq
-	vldmiaeq r0!, {s16-s31}					/* Restore the FPU registers which are not restored automatically. */
-#endif /* configENABLE_FPU */
-
- #if ( configENABLE_MPU == 1 )
-	msr psplim, r1							/* Restore the PSPLIM register value for the task. */
-	msr control, r2							/* Restore the CONTROL register value for the task. */
-#else /* configENABLE_MPU */
-	msr psplim, r2							/* Restore the PSPLIM register value for the task. */
-#endif /* configENABLE_MPU */
-	msr psp, r0								/* Remember the new top of stack for the task. */
-	bx r3
-/*-----------------------------------------------------------*/
-
-SVC_Handler:
-	tst lr, #4
-	ite eq
-	mrseq r0, msp
-	mrsne r0, psp
-	b vPortSVCHandler_C
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portmacro.h
deleted file mode 100644
index ebb16fd..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM33_NTZ/non_secure/portmacro.h
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*------------------------------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the given hardware
- * and compiler.
- *
- * These settings should not be altered.
- *------------------------------------------------------------------------------
- */
-
-#ifndef configENABLE_FPU
-	#error configENABLE_FPU must be defined in FreeRTOSConfig.h.  Set configENABLE_FPU to 1 to enable the FPU or 0 to disable the FPU.
-#endif /* configENABLE_FPU */
-
-#ifndef configENABLE_MPU
-	#error configENABLE_MPU must be defined in FreeRTOSConfig.h.  Set configENABLE_MPU to 1 to enable the MPU or 0 to disable the MPU.
-#endif /* configENABLE_MPU */
-
-#ifndef configENABLE_TRUSTZONE
-	#error configENABLE_TRUSTZONE must be defined in FreeRTOSConfig.h.  Set configENABLE_TRUSTZONE to 1 to enable TrustZone or 0 to disable TrustZone.
-#endif /* configENABLE_TRUSTZONE */
-
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Type definitions.
- */
-#define portCHAR											char
-#define portFLOAT											float
-#define portDOUBLE											double
-#define portLONG											long
-#define portSHORT											short
-#define portSTACK_TYPE										uint32_t
-#define portBASE_TYPE										long
-
-typedef portSTACK_TYPE										StackType_t;
-typedef long												BaseType_t;
-typedef unsigned long										UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t )					0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	 * not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC							1
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * Architecture specifics.
- */
-#define portARCH_NAME										"Cortex-M33"
-#define portSTACK_GROWTH									( -1 )
-#define portTICK_PERIOD_MS									( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT									8
-#define portNOP()
-#define portINLINE											__inline
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE								inline __attribute__(( always_inline ))
-#endif
-#define portHAS_STACK_OVERFLOW_CHECKING						1
-#define portDONT_DISCARD									__root
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Extern declarations.
- */
-extern BaseType_t xPortIsInsideInterrupt( void );
-
-extern void vPortYield( void ) /* PRIVILEGED_FUNCTION */;
-
-extern void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */;
-extern void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */;
-
-extern uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-extern void vClearInterruptMask( uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */;
-
-#if( configENABLE_TRUSTZONE == 1 )
-	extern void vPortAllocateSecureContext( uint32_t ulSecureStackSize ); /* __attribute__ (( naked )) */
-	extern void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */;
-#endif /* configENABLE_TRUSTZONE */
-
-#if( configENABLE_MPU == 1 )
-	extern BaseType_t xIsPrivileged( void ) /* __attribute__ (( naked )) */;
-	extern void vResetPrivilege( void ) /* __attribute__ (( naked )) */;
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief MPU specific constants.
- */
-#if( configENABLE_MPU == 1 )
-	#define portUSING_MPU_WRAPPERS							1
-	#define portPRIVILEGE_BIT								( 0x80000000UL )
-#else
-	#define portPRIVILEGE_BIT								( 0x0UL )
-#endif /* configENABLE_MPU */
-
-
-/* MPU regions. */
-#define portPRIVILEGED_FLASH_REGION							( 0UL )
-#define portUNPRIVILEGED_FLASH_REGION						( 1UL )
-#define portUNPRIVILEGED_SYSCALLS_REGION					( 2UL )
-#define portPRIVILEGED_RAM_REGION							( 3UL )
-#define portSTACK_REGION									( 4UL )
-#define portFIRST_CONFIGURABLE_REGION						( 5UL )
-#define portLAST_CONFIGURABLE_REGION						( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS						( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS								( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-/* Device memory attributes used in MPU_MAIR registers.
- *
- * 8-bit values encoded as follows:
- *  Bit[7:4] - 0000 - Device Memory
- *  Bit[3:2] - 00 --> Device-nGnRnE
- *				01 --> Device-nGnRE
- *				10 --> Device-nGRE
- *				11 --> Device-GRE
- *  Bit[1:0] - 00, Reserved.
- */
-#define portMPU_DEVICE_MEMORY_nGnRnE						( 0x00 ) /* 0000 0000 */
-#define portMPU_DEVICE_MEMORY_nGnRE							( 0x04 ) /* 0000 0100 */
-#define portMPU_DEVICE_MEMORY_nGRE							( 0x08 ) /* 0000 1000 */
-#define portMPU_DEVICE_MEMORY_GRE							( 0x0C ) /* 0000 1100 */
-
-/* Normal memory attributes used in MPU_MAIR registers. */
-#define portMPU_NORMAL_MEMORY_NON_CACHEABLE					( 0x44 ) /* Non-cacheable. */
-#define portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE			( 0xFF ) /* Non-Transient, Write-back, Read-Allocate and Write-Allocate. */
-
-/* Attributes used in MPU_RBAR registers. */
-#define portMPU_REGION_NON_SHAREABLE						( 0UL << 3UL )
-#define portMPU_REGION_INNER_SHAREABLE						( 1UL << 3UL )
-#define portMPU_REGION_OUTER_SHAREABLE						( 2UL << 3UL )
-
-#define portMPU_REGION_PRIVILEGED_READ_WRITE				( 0UL << 1UL )
-#define portMPU_REGION_READ_WRITE							( 1UL << 1UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY					( 2UL << 1UL )
-#define portMPU_REGION_READ_ONLY							( 3UL << 1UL )
-
-#define portMPU_REGION_EXECUTE_NEVER						( 1UL )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Settings to define an MPU region.
- */
-typedef struct MPURegionSettings
-{
-	uint32_t ulRBAR;	/**< RBAR for the region. */
-	uint32_t ulRLAR;	/**< RLAR for the region. */
-} MPURegionSettings_t;
-
-/**
- * @brief MPU settings as stored in the TCB.
- */
-typedef struct MPU_SETTINGS
-{
-	uint32_t ulMAIR0;	/**< MAIR0 for the task containing attributes for all the 4 per task regions. */
-	MPURegionSettings_t xRegionsSettings[ portTOTAL_NUM_REGIONS ]; /**< Settings for 4 per task regions. */
-} xMPU_SETTINGS;
-/*-----------------------------------------------------------*/
-
-/**
- * @brief SVC numbers.
- */
-#define portSVC_ALLOCATE_SECURE_CONTEXT						0
-#define portSVC_FREE_SECURE_CONTEXT							1
-#define portSVC_START_SCHEDULER								2
-#define portSVC_RAISE_PRIVILEGE								3
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Scheduler utilities.
- */
-#define portYIELD()											vPortYield()
-#define portNVIC_INT_CTRL_REG								( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT								( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired )			if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x )								portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Critical section management.
- */
-#define portSET_INTERRUPT_MASK_FROM_ISR()					ulSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)				vClearInterruptMask( x )
-#define portDISABLE_INTERRUPTS()							ulSetInterruptMask()
-#define portENABLE_INTERRUPTS()								vClearInterruptMask( 0 )
-#define portENTER_CRITICAL()								vPortEnterCritical()
-#define portEXIT_CRITICAL()									vPortExitCritical()
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Tickless idle/low power functionality.
- */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Task function macros as described on the FreeRTOS.org WEB site.
- */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters )		void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_TRUSTZONE == 1 )
-	/**
-	 * @brief Allocate a secure context for the task.
-	 *
-	 * Tasks are not created with a secure context. Any task that is going to call
-	 * secure functions must call portALLOCATE_SECURE_CONTEXT() to allocate itself a
-	 * secure context before it calls any secure function.
-	 *
-	 * @param[in] ulSecureStackSize The size of the secure stack to be allocated.
-	 */
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )	vPortAllocateSecureContext( ulSecureStackSize )
-
-	/**
-	 * @brief Called when a task is deleted to delete the task's secure context,
-	 * if it has one.
-	 *
-	 * @param[in] pxTCB The TCB of the task being deleted.
-	 */
-	#define portCLEAN_UP_TCB( pxTCB )							vPortFreeSecureContext( ( uint32_t * ) pxTCB )
-#else
-	#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )
-	#define portCLEAN_UP_TCB( pxTCB )
-#endif /* configENABLE_TRUSTZONE */
-/*-----------------------------------------------------------*/
-
-#if( configENABLE_MPU == 1 )
-	/**
-	 * @brief Checks whether or not the processor is privileged.
-	 *
-	 * @return 1 if the processor is already privileged, 0 otherwise.
-	 */
-	#define portIS_PRIVILEGED()									xIsPrivileged()
-
-	/**
-	 * @brief Raise an SVC request to raise privilege.
-	 *
-	 * The SVC handler checks that the SVC was raised from a system call and only
-	 * then it raises the privilege. If this is called from any other place,
-	 * the privilege is not raised.
-	 */
-	#define portRAISE_PRIVILEGE()								__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-	/**
-	 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
-	 * register.
-	 */
-	#define portRESET_PRIVILEGE()								vResetPrivilege()
-#else
-	#define portIS_PRIVILEGED()
-	#define portRAISE_PRIVILEGE()
-	#define portRESET_PRIVILEGE()
-#endif /* configENABLE_MPU */
-/*-----------------------------------------------------------*/
-
-/**
- * @brief Barriers.
- */
-#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
- * the source code because to do so would cause other compilers to generate
- * warnings. */
-#pragma diag_suppress=Be006
-#pragma diag_suppress=Pa082
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
diff --git a/osal/src/freertos/portable/IAR/ARM_CM4F/port.c b/osal/src/freertos/portable/IAR/ARM_CM4F/port.c
deleted file mode 100644
index 5a8572f..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM4F/port.c
+++ /dev/null
@@ -1,656 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __ARMVFP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#if( configMAX_SYSCALL_INTERRUPT_PRIORITY == 0 )
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-/* Constants used to detect a Cortex-M7 r0p1 core, which should use the ARM_CM7
-r0p1 port. */
-#define portCPUID							( * ( ( volatile uint32_t * ) 0xE000ed00 ) )
-#define portCORTEX_M7_r0p1_ID				( 0x410FC271UL )
-#define portCORTEX_M7_r0p0_ID				( 0x410FC270UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS			( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000 )
-#define portINITIAL_EXC_RETURN				( 0xfffffffd )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortSysTickHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-extern void vPortStartFirstTask( void );
-
-/*
- * Turn the VFP on.
- */
-extern void vPortEnableVFP( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	/* This port can be used on all revisions of the Cortex-M7 core other than
-	the r0p1 parts.  r0p1 parts should use the port from the
-	/source/portable/GCC/ARM_CM7/r0p1 directory. */
-	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
-	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__disable_interrupt();
-		__DSB();
-		__ISB();
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above __disable_interrupt()
-			call above. */
-			__enable_interrupt();
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__DSB();
-				__WFI();
-				__ISB();
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__enable_interrupt();
-			__DSB();
-			__ISB();
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__disable_interrupt();
-			__DSB();
-			__ISB();
-			
-			/* Disable the SysTick clock without reading the 
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again, 
-			the time the SysTick is stopped for is accounted for as best it can 
-			be, but using the tickless mode will inevitably result in some tiny 
-			drift of the time maintained by the kernel with respect to calendar 
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__enable_interrupt();
-		}
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__weak void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM4F/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM4F/portasm.s
deleted file mode 100644
index ff37a2a..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM4F/portasm.s
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#include <FreeRTOSConfig.h>
-
-	RSEG    CODE:CODE(2)
-	thumb
-
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-
-	PUBLIC xPortPendSVHandler
-	PUBLIC vPortSVCHandler
-	PUBLIC vPortStartFirstTask
-	PUBLIC vPortEnableVFP
-
-
-/*-----------------------------------------------------------*/
-
-xPortPendSVHandler:
-	mrs r0, psp
-	isb
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	/* Is the task using the FPU context?  If so, push high vfp registers. */
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	/* Save the core registers. */
-	stmdb r0!, {r4-r11, r14}
-
-	/* Save the new top of stack into the first member of the TCB. */
-	str r0, [r2]
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-
-	/* The first item in pxCurrentTCB is the task top of stack. */
-	ldr r1, [r3]
-	ldr r0, [r1]
-
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-
-	/* Is the task using the FPU context?  If so, pop the high vfp registers
-	too. */
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata */
-		#if WORKAROUND_PMU_CM001 == 1
-			push { r14 }
-			pop { pc }
-		#endif
-	#endif
-
-	bx r14
-
-
-/*-----------------------------------------------------------*/
-
-vPortSVCHandler:
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	ldr r0, [r1]
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-	msr psp, r0
-	isb
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-
-/*-----------------------------------------------------------*/
-
-vPortStartFirstTask
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	before the scheduler was started - which would otherwise result in the
-	unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	registers. */
-	mov r0, #0
-	msr control, r0
-	/* Call SVC to start the first task. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc 0
-
-/*-----------------------------------------------------------*/
-
-vPortEnableVFP:
-	/* The FPU enable bits are in the CPACR. */
-	ldr.w r0, =0xE000ED88
-	ldr	r1, [r0]
-
-	/* Enable CP10 and CP11 coprocessors, then save back. */
-	orr	r1, r1, #( 0xf << 20 )
-	str r1, [r0]
-	bx	r14
-
-
-
-	END
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM4F/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM4F/portmacro.h
deleted file mode 100644
index 339e6f6..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM4F/portmacro.h
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* Compiler directives. */
-#define portWEAK_SYMBOL				__attribute__( ( weak ) )
-
-/*-----------------------------------------------------------*/
-
-
-/* Scheduler utilities. */
-#define portYIELD()											\
-{															\
-	/* Set a PendSV to request a context switch. */			\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;			\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 1 )
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ( uint32_t ) __CLZ( ( uxReadyPriorities ) ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()							\
-{															\
-	__set_BASEPRI( configMAX_SYSCALL_INTERRUPT_PRIORITY );	\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portENABLE_INTERRUPTS()					__set_BASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		__get_BASEPRI(); portDISABLE_INTERRUPTS()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	__set_BASEPRI( x )
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
-the source code because to do so would cause other compilers to generate
-warnings. */
-#pragma diag_suppress=Pe191
-#pragma diag_suppress=Pa082
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM4_MPU/port.c b/osal/src/freertos/portable/IAR/ARM_CM4_MPU/port.c
deleted file mode 100644
index 1b8fbf0..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM4_MPU/port.c
+++ /dev/null
@@ -1,749 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers.  That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#ifndef __ARMVFP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#if( configMAX_SYSCALL_INTERRUPT_PRIORITY == 0 )
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG				( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG		( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG					( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSPRI1_REG					( * ( ( volatile uint32_t * ) 0xe000ed1c ) )
-#define portNVIC_SYS_CTRL_STATE_REG				( * ( ( volatile uint32_t * ) 0xe000ed24 ) )
-#define portNVIC_MEM_FAULT_ENABLE				( 1UL << 16UL )
-
-/* Constants required to access and manipulate the MPU. */
-#define portMPU_TYPE_REG						( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_REGION_BASE_ADDRESS_REG			( * ( ( volatile uint32_t * ) 0xe000ed9C ) )
-#define portMPU_REGION_ATTRIBUTE_REG			( * ( ( volatile uint32_t * ) 0xe000edA0 ) )
-#define portMPU_CTRL_REG						( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portEXPECTED_MPU_TYPE_VALUE				( 8UL << 8UL ) /* 8 regions, unified. */
-#define portMPU_ENABLE							( 0x01UL )
-#define portMPU_BACKGROUND_ENABLE				( 1UL << 2UL )
-#define portPRIVILEGED_EXECUTION_START_ADDRESS	( 0UL )
-#define portMPU_REGION_VALID					( 0x10UL )
-#define portMPU_REGION_ENABLE					( 0x01UL )
-#define portPERIPHERALS_START_ADDRESS			0x40000000UL
-#define portPERIPHERALS_END_ADDRESS				0x5FFFFFFFUL
-
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-/* Constants used to detect a Cortex-M7 r0p1 core, which should use the ARM_CM7
- * r0p1 port. */
-#define portCPUID							( * ( ( volatile uint32_t * ) 0xE000ed00 ) )
-#define portCORTEX_M7_r0p1_ID				( 0x410FC271UL )
-#define portCORTEX_M7_r0p0_ID				( 0x410FC270UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-#define portNVIC_SVC_PRI					( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS			( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000 )
-#define portINITIAL_EXC_RETURN				( 0xfffffffd )
-#define portINITIAL_CONTROL_IF_UNPRIVILEGED	( 0x03 )
-#define portINITIAL_CONTROL_IF_PRIVILEGED	( 0x02 )
-
-/* Offsets in the stack to the parameters when inside the SVC handler. */
-#define portOFFSET_TO_PC						( 6 )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Configure a number of standard MPU regions that are used by all tasks.
- */
-static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the smallest MPU region size that a given number of bytes will fit
- * into.  The region size is returned as the value that should be programmed
- * into the region attribute register for that region.
- */
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes ) PRIVILEGED_FUNCTION;
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortSysTickHandler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-extern void vPortStartFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Turn the VFP on.
- */
-extern void vPortEnableVFP( void );
-
-/*
- * The C portion of the SVC handler.
- */
-void vPortSVCHandler_C( uint32_t *pulParam );
-
-/*
- * Called from the SVC handler used to start the scheduler.
- */
-extern void vPortRestoreContextOfFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-extern BaseType_t xPortRaisePrivilege( void );
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-extern void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	 * of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) 0;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	 * own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	if( xRunPrivileged == pdTRUE )
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_PRIVILEGED;
-	}
-	else
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
-	}
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulParam )
-{
-uint8_t ucSVCNumber;
-uint32_t ulPC;
-#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-	extern uint32_t __syscalls_flash_start__[];
-	extern uint32_t __syscalls_flash_end__[];
-#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-	/* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR. The first
-	 * argument (r0) is pulParam[ 0 ]. */
-	ulPC = pulParam[ portOFFSET_TO_PC ];
-	ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
-	switch( ucSVCNumber )
-	{
-		case portSVC_START_SCHEDULER	:	portNVIC_SYSPRI1_REG |= portNVIC_SVC_PRI;
-											vPortRestoreContextOfFirstTask();
-											break;
-
-		case portSVC_YIELD				:	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-											/* Barriers are normally not required
-											 * but do ensure the code is completely
-											 * within the specified behaviour for the
-											 * architecture. */
-											__asm volatile( "dsb" ::: "memory" );
-											__asm volatile( "isb" );
-
-											break;
-
-	#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-		case portSVC_RAISE_PRIVILEGE	:	/* Only raise the privilege, if the
-											 * svc was raised from any of the
-											 * system calls. */
-											if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-												ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-											{
-												__asm volatile
-												(
-													"	mrs r1, control		\n" /* Obtain current control value. */
-													"	bic r1, r1, #1		\n" /* Set privilege bit. */
-													"	msr control, r1		\n" /* Write back new control value. */
-													::: "r1", "memory"
-												);
-											}
-											break;
-	#else
-		case portSVC_RAISE_PRIVILEGE	:	__asm volatile
-											(
-												"	mrs r1, control		\n" /* Obtain current control value. */
-												"	bic r1, r1, #1		\n" /* Set privilege bit. */
-												"	msr control, r1		\n" /* Write back new control value. */
-												::: "r1", "memory"
-											);
-											break;
-	#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-		default							:	/* Unknown SVC call. */
-											break;
-	}
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	 * See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	/* This port can be used on all revisions of the Cortex-M7 core other than
-	 * the r0p1 parts.  r0p1 parts should use the port from the
-	 * /source/portable/GCC/ARM_CM7/r0p1 directory. */
-	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
-	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		 * functions can be called.  ISR safe functions are those that end in
-		 * "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		 * ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		 * possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		 * of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		 * register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		 * value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Configure the regions in the MPU that are common to all tasks. */
-	prvSetupMPU();
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
- BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	vPortResetPrivilege( xRunningPrivileged );
-
-	/* This is not the interrupt safe version of the enter critical function so
-	 * assert() if it is being called from an interrupt context.  Only API
-	 * functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	 * the critical nesting count is 1 to protect against recursive calls if the
-	 * assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	configASSERT( uxCriticalNesting );
-
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	 * executes all interrupts must be unmasked.  There is therefore no need to
-	 * save and then restore the interrupt mask value as its value is already
-	 * known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			 * the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__weak void vPortSetupTimerInterrupt( void )
-{
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-static void prvSetupMPU( void )
-{
-extern uint32_t __privileged_functions_start__[];
-extern uint32_t __privileged_functions_end__[];
-extern uint32_t __FLASH_segment_start__[];
-extern uint32_t __FLASH_segment_end__[];
-extern uint32_t __privileged_data_start__[];
-extern uint32_t __privileged_data_end__[];
-
-	/* Check the expected MPU is present. */
-	if( ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )  || ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE << 1 ))
-	{
-		/* First setup the unprivileged flash for unprivileged read only access. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portUNPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged flash for privileged only access.  This is where
-		 * the kernel code is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_functions_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __privileged_functions_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged data RAM region.  This is where the kernel data
-		 * is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_RAM_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-										( portMPU_REGION_ENABLE );
-
-		/* By default allow everything to access the general peripherals.  The
-		 * system peripherals and registers are protected. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( portPERIPHERALS_START_ADDRESS ) |
-											( portMPU_REGION_VALID ) |
-											( portGENERAL_PERIPHERALS_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
-										( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Enable the memory fault exception. */
-		portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
-
-		/* Enable the MPU with the background region configured. */
-		portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes )
-{
-uint32_t ulRegionSize, ulReturnValue = 4;
-
-	/* 32 is the smallest region size, 31 is the largest valid value for
-	 * ulReturnValue. */
-	for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
-	{
-		if( ulActualSizeInBytes <= ulRegionSize )
-		{
-			break;
-		}
-		else
-		{
-			ulReturnValue++;
-		}
-	}
-
-	/* Shift the code by one before returning so it can be written directly
-	 * into the the correct bit position of the attribute register. */
-	return ( ulReturnValue << 1UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-{
-extern uint32_t __SRAM_segment_start__[];
-extern uint32_t __SRAM_segment_end__[];
-extern uint32_t __privileged_data_start__[];
-extern uint32_t __privileged_data_end__[];
-int32_t lIndex;
-uint32_t ul;
-
-	if( xRegions == NULL )
-	{
-		/* No MPU regions are specified so allow access to all RAM. */
-		xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-				( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION );
-
-		xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-				( portMPU_REGION_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Re-instate the privileged only RAM region as xRegion[ 0 ] will have
-		 * just removed the privileged only parameters. */
-		xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
-				( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION + 1 );
-
-		xMPUSettings->xRegion[ 1 ].ulRegionAttribute =
-				( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Invalidate all other regions. */
-		for( ul = 2; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-			xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-		}
-	}
-	else
-	{
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that the
-		 * stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-					( ( uint32_t ) pxBottomOfStack ) |
-					( portMPU_REGION_VALID ) |
-					( portSTACK_REGION ); /* Region number. */
-
-			xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-					( portMPU_REGION_READ_WRITE ) | /* Read and write. */
-					( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
-					( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-					( portMPU_REGION_ENABLE );
-		}
-
-		lIndex = 0;
-
-		for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
-			{
-				/* Translate the generic region definition contained in
-				 * xRegions into the CM3 specific MPU settings that are then
-				 * stored in xMPUSettings. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
-						( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) |
-						( portMPU_REGION_VALID ) |
-						( portSTACK_REGION + ul ); /* Region number. */
-
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute =
-						( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
-						( xRegions[ lIndex ].ulParameters ) |
-						( portMPU_REGION_ENABLE );
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			 * an interrupt that has been assigned a priority above
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			 * function.  ISR safe FreeRTOS API functions must *only* be called
-			 * from interrupts that have been assigned a priority at or below
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Numerically low interrupt priority numbers represent logically high
-			 * interrupt priorities, therefore the priority of the interrupt must
-			 * be set to a value equal to or numerically *higher* than
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Interrupts that	use the FreeRTOS API must not be left at their
-			 * default priority of	zero as that is the highest possible priority,
-			 * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			 * and	therefore also guaranteed to be invalid.
-
-			 * FreeRTOS maintains separate thread and ISR API functions to ensure
-			 * interrupt entry is as fast and simple as possible.
-
-			 * The following links provide detailed information:
-			 * http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			 * http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		 * that define each interrupt's priority to be split between bits that
-		 * define the interrupt's pre-emption priority bits and bits that define
-		 * the interrupt's sub-priority.  For simplicity all bits must be defined
-		 * to be pre-emption priority bits.  The following assertion will fail if
-		 * this is not the case (if some bits represent a sub-priority).
-
-		 * If the application only uses CMSIS libraries for interrupt
-		 * configuration then the correct setting can be achieved on all Cortex-M
-		 * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		 * scheduler.  Note however that some vendor specific peripheral libraries
-		 * assume a non-zero priority group setting, in which cases using a value
-		 * of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM4_MPU/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM4_MPU/portasm.s
deleted file mode 100644
index ef0be51..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM4_MPU/portasm.s
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-/* Including FreeRTOSConfig.h here will cause build errors if the header file
-contains code not understood by the assembler - for example the 'extern' keyword.
-To avoid errors place any such code inside a #ifdef __ICCARM__/#endif block so
-the code is included in C files but excluded by the preprocessor in assembly
-files (__ICCARM__ is defined by the IAR C compiler but not by the IAR assembler. */
-#include <FreeRTOSConfig.h>
-
-	RSEG    CODE:CODE(2)
-	thumb
-
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-	EXTERN vPortSVCHandler_C
-
-	PUBLIC xPortPendSVHandler
-	PUBLIC vPortSVCHandler
-	PUBLIC vPortStartFirstTask
-	PUBLIC vPortEnableVFP
-	PUBLIC vPortRestoreContextOfFirstTask
-	PUBLIC xIsPrivileged
-	PUBLIC vResetPrivilege
-
-/*-----------------------------------------------------------*/
-
-xPortPendSVHandler:
-	mrs r0, psp
-	isb
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	/* Is the task using the FPU context?  If so, push high vfp registers. */
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	/* Save the core registers. */
-	mrs r1, control
-	stmdb r0!, {r1, r4-r11, r14}
-
-	/* Save the new top of stack into the first member of the TCB. */
-	str r0, [r2]
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-
-	/* The first item in pxCurrentTCB is the task top of stack. */
-	ldr r1, [r3]
-	ldr r0, [r1]
-	/* Move onto the second item in the TCB... */
-	add r1, r1, #4
-
-	dmb					/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1		/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]		/* Disable MPU. */
-
-	/* Region Base Address register. */
-	ldr r2, =0xe000ed9c
-	/* Read 4 sets of MPU registers. */
-	ldmia r1!, {r4-r11}
-	/* Write 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}
-
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1		/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]		/* Enable MPU. */
-	dsb					/* Force memory writes before continuing. */
-
-	/* Pop the registers that are not automatically saved on exception entry. */
-	ldmia r0!, {r3-r11, r14}
-	msr control, r3
-
-	/* Is the task using the FPU context?  If so, pop the high vfp registers
-	too. */
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-
-	bx r14
-
-
-/*-----------------------------------------------------------*/
-
-vPortSVCHandler:
-	#ifndef USE_PROCESS_STACK	/* Code should not be required if a main() is using the process stack. */
-		tst lr, #4
-		ite eq
-		mrseq r0, msp
-		mrsne r0, psp
-	#else
-		mrs r0, psp
-	#endif
-		b vPortSVCHandler_C
-
-/*-----------------------------------------------------------*/
-
-vPortStartFirstTask:
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	before the scheduler was started - which would otherwise result in the
-	unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	registers. */
-	mov r0, #0
-	msr control, r0
-	/* Call SVC to start the first task. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc 0
-
-/*-----------------------------------------------------------*/
-
-vPortRestoreContextOfFirstTask:
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Restore the context. */
-	ldr	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	/* The first item in the TCB is the task top of stack. */
-	ldr r0, [r1]
-	/* Move onto the second item in the TCB... */
-	add r1, r1, #4
-
-	dmb					/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1		/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]		/* Disable MPU. */
-
-	/* Region Base Address register. */
-	ldr r2, =0xe000ed9c
-	/* Read 4 sets of MPU registers. */
-	ldmia r1!, {r4-r11}
-	/* Write 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}
-
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1		/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]		/* Enable MPU. */
-	dsb					/* Force memory writes before continuing. */
-
-	/* Pop the registers that are not automatically saved on exception entry. */
-	ldmia r0!, {r3-r11, r14}
-	msr control, r3
-	/* Restore the task stack pointer. */
-	msr psp, r0
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-
-/*-----------------------------------------------------------*/
-
-vPortEnableVFP:
-	/* The FPU enable bits are in the CPACR. */
-	ldr.w r0, =0xE000ED88
-	ldr	r1, [r0]
-
-	/* Enable CP10 and CP11 coprocessors, then save back. */
-	orr	r1, r1, #( 0xf << 20 )
-	str r1, [r0]
-	bx	r14
-
-/*-----------------------------------------------------------*/
-
-xIsPrivileged:
-	mrs r0, control		/* r0 = CONTROL. */
-	tst r0, #1			/* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	ite ne
-	movne r0, #0		/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	moveq r0, #1		/* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	bx lr				/* Return. */
-/*-----------------------------------------------------------*/
-
-vResetPrivilege:
-	mrs r0, control		/* r0 = CONTROL. */
-	orr r0, r0, #1		/* r0 = r0 | 1. */
-	msr control, r0		/* CONTROL = r0. */
-	bx lr				/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM4_MPU/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM4_MPU/portmacro.h
deleted file mode 100644
index 3df7ae6..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM4_MPU/portmacro.h
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* MPU specific constants. */
-#define portUSING_MPU_WRAPPERS		1
-#define portPRIVILEGE_BIT			( 0x80000000UL )
-
-#define portMPU_REGION_READ_WRITE								( 0x03UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY						( 0x05UL << 24UL )
-#define portMPU_REGION_READ_ONLY								( 0x06UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE					( 0x01UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY	( 0x02UL << 24UL )
-#define portMPU_REGION_CACHEABLE_BUFFERABLE						( 0x03UL << 16UL )
-#define portMPU_REGION_EXECUTE_NEVER							( 0x01UL << 28UL )
-
-#define portUNPRIVILEGED_FLASH_REGION			( 0UL )
-#define portPRIVILEGED_FLASH_REGION				( 1UL )
-#define portPRIVILEGED_RAM_REGION				( 2UL )
-#define portGENERAL_PERIPHERALS_REGION			( 3UL )
-#define portSTACK_REGION						( 4UL )
-#define portFIRST_CONFIGURABLE_REGION			( 5UL )
-#define portLAST_CONFIGURABLE_REGION			( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS			( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS					( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-#define portSWITCH_TO_USER_MODE() __asm volatile ( " mrs r0, control \n orr r0, r0, #1 \n msr control, r0 " ::: "r0", "memory" )
-
-typedef struct MPU_REGION_REGISTERS
-{
-	uint32_t ulRegionBaseAddress;
-	uint32_t ulRegionAttribute;
-} xMPU_REGION_REGISTERS;
-
-/* Plus 1 to create space for the stack region. */
-typedef struct MPU_SETTINGS
-{
-	xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS ];
-} xMPU_SETTINGS;
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* SVC numbers for various services. */
-#define portSVC_START_SCHEDULER				0
-#define portSVC_YIELD						1
-#define portSVC_RAISE_PRIVILEGE				2
-
-/* Scheduler utilities. */
-
-#define portYIELD()				__asm volatile ( "	SVC	%0	\n" :: "i" (portSVC_YIELD) : "memory" )
-#define portYIELD_WITHIN_API()								\
-{															\
-	/* Set a PendSV to request a context switch. */			\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;			\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD_WITHIN_API()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 1 )
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ( uint32_t ) __CLZ( ( uxReadyPriorities ) ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()							\
-{															\
-	__set_BASEPRI( configMAX_SYSCALL_INTERRUPT_PRIORITY );	\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portENABLE_INTERRUPTS()					__set_BASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		__get_BASEPRI(); portDISABLE_INTERRUPTS()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	__set_BASEPRI( x )
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-
-/*-----------------------------------------------------------*/
-
-extern BaseType_t xIsPrivileged( void );
-extern void vResetPrivilege( void );
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-#define portIS_PRIVILEGED()			xIsPrivileged()
-
-/**
- * @brief Raise an SVC request to raise privilege.
-*/
-#define portRAISE_PRIVILEGE()		__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- */
-#define portRESET_PRIVILEGE()		vResetPrivilege()
-/*-----------------------------------------------------------*/
-
-#ifndef configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY
-	#warning "configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not defined. We recommend defining it to 1 in FreeRTOSConfig.h for better security. https://www.freertos.org/FreeRTOS-V10.3.x.html"
-	#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 0
-#endif
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
-the source code because to do so would cause other compilers to generate
-warnings. */
-#pragma diag_suppress=Pe191
-#pragma diag_suppress=Pa082
-#pragma diag_suppress=Be006
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7/ReadMe.txt b/osal/src/freertos/portable/IAR/ARM_CM7/ReadMe.txt
deleted file mode 100644
index 5ecbe81..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7/ReadMe.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-There are two options for running FreeRTOS on ARM Cortex-M7 microcontrollers.
-The best option depends on the revision of the ARM Cortex-M7 core in use.  The
-revision is specified by an 'r' number, and a 'p' number, so will look something
-like 'r0p1'.  Check the documentation for the microcontroller in use to find the 
-revision of the Cortex-M7 core used in that microcontroller.  If in doubt, use 
-the FreeRTOS port provided specifically for r0p1 revisions, as that can be used
-with all core revisions.
-
-The first option is to use the ARM Cortex-M4F port, and the second option is to
-use the Cortex-M7 r0p1 port - the latter containing a minor errata workaround.
-
-If the revision of the ARM Cortex-M7 core is not r0p1 then either option can be
-used, but it is recommended to use the FreeRTOS ARM Cortex-M4F port located in 
-the /FreeRTOS/Source/portable/IAR/ARM_CM4F directory.
-
-If the revision of the ARM Cortex-M7 core is r0p1 then use the FreeRTOS ARM
-Cortex-M7 r0p1 port located in the /FreeRTOS/Source/portable/IAR/ARM_CM7/r0p1
-directory.
\ No newline at end of file
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/port.c b/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/port.c
deleted file mode 100644
index f16eea5..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/port.c
+++ /dev/null
@@ -1,644 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __ARMVFP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#if( configMAX_SYSCALL_INTERRUPT_PRIORITY == 0 )
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS			( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000 )
-#define portINITIAL_EXC_RETURN				( 0xfffffffd )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortSysTickHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-extern void vPortStartFirstTask( void );
-
-/*
- * Turn the VFP on.
- */
-extern void vPortEnableVFP( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__disable_interrupt();
-		__DSB();
-		__ISB();
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above __disable_interrupt()
-			call above. */
-			__enable_interrupt();
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__DSB();
-				__WFI();
-				__ISB();
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__enable_interrupt();
-			__DSB();
-			__ISB();
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__disable_interrupt();
-			__DSB();
-			__ISB();
-			
-			/* Disable the SysTick clock without reading the 
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again, 
-			the time the SysTick is stopped for is accounted for as best it can 
-			be, but using the tickless mode will inevitably result in some tiny 
-			drift of the time maintained by the kernel with respect to calendar 
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__enable_interrupt();
-		}
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__weak void vPortSetupTimerInterrupt( void )
-{
-	/* Calculate the constants required to configure the tick interrupt. */
-	#if( configUSE_TICKLESS_IDLE == 1 )
-	{
-		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-	}
-	#endif /* configUSE_TICKLESS_IDLE */
-
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portasm.s
deleted file mode 100644
index a623b1d..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portasm.s
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#include <FreeRTOSConfig.h>
-
-	RSEG    CODE:CODE(2)
-	thumb
-
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-
-	PUBLIC xPortPendSVHandler
-	PUBLIC vPortSVCHandler
-	PUBLIC vPortStartFirstTask
-	PUBLIC vPortEnableVFP
-
-
-/*-----------------------------------------------------------*/
-
-xPortPendSVHandler:
-	mrs r0, psp
-	isb
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	/* Is the task using the FPU context?  If so, push high vfp registers. */
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	/* Save the core registers. */
-	stmdb r0!, {r4-r11, r14}
-
-	/* Save the new top of stack into the first member of the TCB. */
-	str r0, [r2]
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	cpsid i
-	msr basepri, r0
-	dsb
-	isb
-	cpsie i
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-
-	/* The first item in pxCurrentTCB is the task top of stack. */
-	ldr r1, [r3]
-	ldr r0, [r1]
-
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-
-	/* Is the task using the FPU context?  If so, pop the high vfp registers
-	too. */
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata */
-		#if WORKAROUND_PMU_CM001 == 1
-			push { r14 }
-			pop { pc }
-		#endif
-	#endif
-
-	bx r14
-
-
-/*-----------------------------------------------------------*/
-
-vPortSVCHandler:
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	ldr r0, [r1]
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-	msr psp, r0
-	isb
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-
-/*-----------------------------------------------------------*/
-
-vPortStartFirstTask
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	before the scheduler was started - which would otherwise result in the
-	unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	registers. */
-	mov r0, #0
-	msr control, r0
-	/* Call SVC to start the first task. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc 0
-
-/*-----------------------------------------------------------*/
-
-vPortEnableVFP:
-	/* The FPU enable bits are in the CPACR. */
-	ldr.w r0, =0xE000ED88
-	ldr	r1, [r0]
-
-	/* Enable CP10 and CP11 coprocessors, then save back. */
-	orr	r1, r1, #( 0xf << 20 )
-	str r1, [r0]
-	bx	r14
-
-
-
-	END
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portmacro.h
deleted file mode 100644
index 5820551..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7/r0p1/portmacro.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* Compiler directives. */
-#define portWEAK_SYMBOL				__attribute__( ( weak ) )
-
-/*-----------------------------------------------------------*/
-
-
-/* Scheduler utilities. */
-#define portYIELD()											\
-{															\
-	/* Set a PendSV to request a context switch. */			\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;			\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 1 )
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ( uint32_t ) __CLZ( ( uxReadyPriorities ) ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()							\
-{															\
-	 /* Errata work around. */								\
-	__disable_interrupt();									\
-	__set_BASEPRI( configMAX_SYSCALL_INTERRUPT_PRIORITY );	\
-	__DSB();												\
-	__ISB();												\
-	__enable_interrupt();									\
-}
-
-#define portENABLE_INTERRUPTS()					__set_BASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		__get_BASEPRI(); portDISABLE_INTERRUPTS()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	__set_BASEPRI( x )
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
-the source code because to do so would cause other compilers to generate
-warnings. */
-#pragma diag_suppress=Pe191
-#pragma diag_suppress=Pa082
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/ReadMe.txt b/osal/src/freertos/portable/IAR/ARM_CM7_MPU/ReadMe.txt
deleted file mode 100644
index e1dd275..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/ReadMe.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-There are two options for running FreeRTOS on ARM Cortex-M7 microcontrollers.
-The best option depends on the revision of the ARM Cortex-M7 core in use.  The
-revision is specified by an 'r' number, and a 'p' number, so will look something
-like 'r0p1'.  Check the documentation for the microcontroller in use to find the 
-revision of the Cortex-M7 core used in that microcontroller.  If in doubt, use 
-the FreeRTOS port provided specifically for r0p1 revisions, as that can be used
-with all core revisions.
-
-The first option is to use the ARM Cortex-M4F port, and the second option is to
-use the Cortex-M7 r0p1 port - the latter containing a minor errata workaround.
-
-If the revision of the ARM Cortex-M7 core is not r0p1 then either option can be
-used, but it is recommended to use the FreeRTOS ARM Cortex-M4F port located in 
-the /FreeRTOS/Source/portable/IAR/ARM_CM4F directory.
-
-If the revision of the ARM Cortex-M7 core is r0p1 then use the FreeRTOS ARM
-Cortex-M7 r0p1 port located in the /FreeRTOS/Source/portable/IAR/ARM_CM7_MPU/r0p1
-directory.
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/port.c b/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/port.c
deleted file mode 100644
index dee9abc..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/port.c
+++ /dev/null
@@ -1,738 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Portion Copyright  2020 STMicroelectronics International N.V. All rights reserved.
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM7 port.
- *----------------------------------------------------------*/
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers.  That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#ifndef __ARMVFP__
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#if( configMAX_SYSCALL_INTERRUPT_PRIORITY == 0 )
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG				( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG		( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG					( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSPRI1_REG					( * ( ( volatile uint32_t * ) 0xe000ed1c ) )
-#define portNVIC_SYS_CTRL_STATE_REG				( * ( ( volatile uint32_t * ) 0xe000ed24 ) )
-#define portNVIC_MEM_FAULT_ENABLE				( 1UL << 16UL )
-
-/* Constants required to access and manipulate the MPU. */
-#define portMPU_TYPE_REG						( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_REGION_BASE_ADDRESS_REG			( * ( ( volatile uint32_t * ) 0xe000ed9C ) )
-#define portMPU_REGION_ATTRIBUTE_REG			( * ( ( volatile uint32_t * ) 0xe000edA0 ) )
-#define portMPU_CTRL_REG						( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portEXPECTED_MPU_TYPE_VALUE				( 8UL << 8UL ) /* 8 regions, unified. */
-#define portMPU_ENABLE							( 0x01UL )
-#define portMPU_BACKGROUND_ENABLE				( 1UL << 2UL )
-#define portPRIVILEGED_EXECUTION_START_ADDRESS	( 0UL )
-#define portMPU_REGION_VALID					( 0x10UL )
-#define portMPU_REGION_ENABLE					( 0x01UL )
-#define portPERIPHERALS_START_ADDRESS			0x40000000UL
-#define portPERIPHERALS_END_ADDRESS				0x5FFFFFFFUL
-
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-#define portNVIC_SVC_PRI					( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR							( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS			( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR					( 0x01000000 )
-#define portINITIAL_EXC_RETURN				( 0xfffffffd )
-#define portINITIAL_CONTROL_IF_UNPRIVILEGED	( 0x03 )
-#define portINITIAL_CONTROL_IF_PRIVILEGED	( 0x02 )
-
-/* Offsets in the stack to the parameters when inside the SVC handler. */
-#define portOFFSET_TO_PC						( 6 )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Configure a number of standard MPU regions that are used by all tasks.
- */
-static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the smallest MPU region size that a given number of bytes will fit
- * into.  The region size is returned as the value that should be programmed
- * into the region attribute register for that region.
- */
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes ) PRIVILEGED_FUNCTION;
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortSysTickHandler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-extern void vPortStartFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Turn the VFP on.
- */
-extern void vPortEnableVFP( void );
-
-/*
- * The C portion of the SVC handler.
- */
-void vPortSVCHandler_C( uint32_t *pulParam );
-
-/*
- * Called from the SVC handler used to start the scheduler.
- */
-extern void vPortRestoreContextOfFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-extern BaseType_t xPortRaisePrivilege( void );
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-extern void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	 * of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) 0;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	 * own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	if( xRunPrivileged == pdTRUE )
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_PRIVILEGED;
-	}
-	else
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
-	}
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler_C( uint32_t *pulParam )
-{
-uint8_t ucSVCNumber;
-uint32_t ulPC;
-#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-	extern uint32_t __syscalls_flash_start__[];
-	extern uint32_t __syscalls_flash_end__[];
-#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-	/* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR. The first
-	 * argument (r0) is pulParam[ 0 ]. */
-	ulPC = pulParam[ portOFFSET_TO_PC ];
-	ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
-	switch( ucSVCNumber )
-	{
-		case portSVC_START_SCHEDULER	:	portNVIC_SYSPRI1_REG |= portNVIC_SVC_PRI;
-											vPortRestoreContextOfFirstTask();
-											break;
-
-		case portSVC_YIELD				:	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-											/* Barriers are normally not required
-											 * but do ensure the code is completely
-											 * within the specified behaviour for the
-											 * architecture. */
-											__asm volatile( "dsb" ::: "memory" );
-											__asm volatile( "isb" );
-
-											break;
-
-	#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-		case portSVC_RAISE_PRIVILEGE	:	/* Only raise the privilege, if the
-											 * svc was raised from any of the
-											 * system calls. */
-											if( ulPC >= ( uint32_t ) __syscalls_flash_start__ &&
-												ulPC <= ( uint32_t ) __syscalls_flash_end__ )
-											{
-												__asm volatile
-												(
-													"	mrs r1, control		\n" /* Obtain current control value. */
-													"	bic r1, r1, #1		\n" /* Set privilege bit. */
-													"	msr control, r1		\n" /* Write back new control value. */
-													::: "r1", "memory"
-												);
-											}
-											break;
-	#else
-		case portSVC_RAISE_PRIVILEGE	:	__asm volatile
-											(
-												"	mrs r1, control		\n" /* Obtain current control value. */
-												"	bic r1, r1, #1		\n" /* Set privilege bit. */
-												"	msr control, r1		\n" /* Write back new control value. */
-												::: "r1", "memory"
-											);
-											break;
-	#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-		default							:	/* Unknown SVC call. */
-											break;
-	}
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	 * See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		 * functions can be called.  ISR safe functions are those that end in
-		 * "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		 * ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		 * possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		 * of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		 * register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		 * value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Configure the regions in the MPU that are common to all tasks. */
-	prvSetupMPU();
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	 * here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
- BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	vPortResetPrivilege( xRunningPrivileged );
-
-	/* This is not the interrupt safe version of the enter critical function so
-	 * assert() if it is being called from an interrupt context.  Only API
-	 * functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	 * the critical nesting count is 1 to protect against recursive calls if the
-	 * assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	configASSERT( uxCriticalNesting );
-
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	 * executes all interrupts must be unmasked.  There is therefore no need to
-	 * save and then restore the interrupt mask value as its value is already
-	 * known. */
-	portDISABLE_INTERRUPTS();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			 * the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portENABLE_INTERRUPTS();
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__weak void vPortSetupTimerInterrupt( void )
-{
-	/* Stop and clear the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-}
-/*-----------------------------------------------------------*/
-
-static void prvSetupMPU( void )
-{
-extern uint32_t __privileged_functions_start__[];
-extern uint32_t __privileged_functions_end__[];
-extern uint32_t __FLASH_segment_start__[];
-extern uint32_t __FLASH_segment_end__[];
-extern uint32_t __privileged_data_start__[];
-extern uint32_t __privileged_data_end__[];
-
-	/* Check the expected MPU is present. */
-	if( ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )  || ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE << 1 ))
-	{
-		/* First setup the unprivileged flash for unprivileged read only access. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portUNPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged flash for privileged only access.  This is where
-		 * the kernel code is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_functions_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __privileged_functions_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged data RAM region.  This is where the kernel data
-		 * is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_RAM_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-										( portMPU_REGION_ENABLE );
-
-		/* By default allow everything to access the general peripherals.  The
-		 * system peripherals and registers are protected. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( portPERIPHERALS_START_ADDRESS ) |
-											( portMPU_REGION_VALID ) |
-											( portGENERAL_PERIPHERALS_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
-										( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Enable the memory fault exception. */
-		portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
-
-		/* Enable the MPU with the background region configured. */
-		portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes )
-{
-uint32_t ulRegionSize, ulReturnValue = 4;
-
-	/* 32 is the smallest region size, 31 is the largest valid value for
-	 * ulReturnValue. */
-	for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
-	{
-		if( ulActualSizeInBytes <= ulRegionSize )
-		{
-			break;
-		}
-		else
-		{
-			ulReturnValue++;
-		}
-	}
-
-	/* Shift the code by one before returning so it can be written directly
-	 * into the the correct bit position of the attribute register. */
-	return ( ulReturnValue << 1UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-{
-extern uint32_t __SRAM_segment_start__[];
-extern uint32_t __SRAM_segment_end__[];
-extern uint32_t __privileged_data_start__[];
-extern uint32_t __privileged_data_end__[];
-int32_t lIndex;
-uint32_t ul;
-
-	if( xRegions == NULL )
-	{
-		/* No MPU regions are specified so allow access to all RAM. */
-		xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-				( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION );
-
-		xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-				( portMPU_REGION_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Re-instate the privileged only RAM region as xRegion[ 0 ] will have
-		 * just removed the privileged only parameters. */
-		xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
-				( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION + 1 );
-
-		xMPUSettings->xRegion[ 1 ].ulRegionAttribute =
-				( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Invalidate all other regions. */
-		for( ul = 2; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-			xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-		}
-	}
-	else
-	{
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that the
-		 * stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-					( ( uint32_t ) pxBottomOfStack ) |
-					( portMPU_REGION_VALID ) |
-					( portSTACK_REGION ); /* Region number. */
-
-			xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-					( portMPU_REGION_READ_WRITE ) | /* Read and write. */
-					( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
-					( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-					( portMPU_REGION_ENABLE );
-		}
-
-		lIndex = 0;
-
-		for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
-			{
-				/* Translate the generic region definition contained in
-				 * xRegions into the CM3 specific MPU settings that are then
-				 * stored in xMPUSettings. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
-						( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) |
-						( portMPU_REGION_VALID ) |
-						( portSTACK_REGION + ul ); /* Region number. */
-
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute =
-						( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
-						( xRegions[ lIndex ].ulParameters ) |
-						( portMPU_REGION_ENABLE );
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			 * an interrupt that has been assigned a priority above
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			 * function.  ISR safe FreeRTOS API functions must *only* be called
-			 * from interrupts that have been assigned a priority at or below
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Numerically low interrupt priority numbers represent logically high
-			 * interrupt priorities, therefore the priority of the interrupt must
-			 * be set to a value equal to or numerically *higher* than
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Interrupts that	use the FreeRTOS API must not be left at their
-			 * default priority of	zero as that is the highest possible priority,
-			 * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			 * and	therefore also guaranteed to be invalid.
-
-			 * FreeRTOS maintains separate thread and ISR API functions to ensure
-			 * interrupt entry is as fast and simple as possible.
-
-			 * The following links provide detailed information:
-			 * http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			 * http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		 * that define each interrupt's priority to be split between bits that
-		 * define the interrupt's pre-emption priority bits and bits that define
-		 * the interrupt's sub-priority.  For simplicity all bits must be defined
-		 * to be pre-emption priority bits.  The following assertion will fail if
-		 * this is not the case (if some bits represent a sub-priority).
-
-		 * If the application only uses CMSIS libraries for interrupt
-		 * configuration then the correct setting can be achieved on all Cortex-M
-		 * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		 * scheduler.  Note however that some vendor specific peripheral libraries
-		 * assume a non-zero priority group setting, in which cases using a value
-		 * of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portasm.s b/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portasm.s
deleted file mode 100644
index ace44c9..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portasm.s
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-/* Including FreeRTOSConfig.h here will cause build errors if the header file
-contains code not understood by the assembler - for example the 'extern' keyword.
-To avoid errors place any such code inside a #ifdef __ICCARM__/#endif block so
-the code is included in C files but excluded by the preprocessor in assembly
-files (__ICCARM__ is defined by the IAR C compiler but not by the IAR assembler. */
-#include <FreeRTOSConfig.h>
-
-	RSEG    CODE:CODE(2)
-	thumb
-
-	EXTERN pxCurrentTCB
-	EXTERN vTaskSwitchContext
-	EXTERN vPortSVCHandler_C
-
-	PUBLIC xPortPendSVHandler
-	PUBLIC vPortSVCHandler
-	PUBLIC vPortStartFirstTask
-	PUBLIC vPortEnableVFP
-	PUBLIC vPortRestoreContextOfFirstTask
-	PUBLIC xIsPrivileged
-	PUBLIC vResetPrivilege
-
-/*-----------------------------------------------------------*/
-
-xPortPendSVHandler:
-	mrs r0, psp
-	isb
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	/* Is the task using the FPU context?  If so, push high vfp registers. */
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	/* Save the core registers. */
-	mrs r1, control
-	stmdb r0!, {r1, r4-r11, r14}
-
-	/* Save the new top of stack into the first member of the TCB. */
-	str r0, [r2]
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-    cpsid i
-	msr basepri, r0
-	dsb
-	isb
-    cpsie i
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-
-	/* The first item in pxCurrentTCB is the task top of stack. */
-	ldr r1, [r3]
-	ldr r0, [r1]
-	/* Move onto the second item in the TCB... */
-	add r1, r1, #4
-
-	dmb					/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1		/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]		/* Disable MPU. */
-
-	/* Region Base Address register. */
-	ldr r2, =0xe000ed9c
-	/* Read 4 sets of MPU registers. */
-	ldmia r1!, {r4-r11}
-	/* Write 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}
-
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1		/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]		/* Enable MPU. */
-	dsb					/* Force memory writes before continuing. */
-
-	/* Pop the registers that are not automatically saved on exception entry. */
-	ldmia r0!, {r3-r11, r14}
-	msr control, r3
-
-	/* Is the task using the FPU context?  If so, pop the high vfp registers
-	too. */
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-
-	bx r14
-
-
-/*-----------------------------------------------------------*/
-
-vPortSVCHandler:
-	#ifndef USE_PROCESS_STACK	/* Code should not be required if a main() is using the process stack. */
-		tst lr, #4
-		ite eq
-		mrseq r0, msp
-		mrsne r0, psp
-	#else
-		mrs r0, psp
-	#endif
-		b vPortSVCHandler_C
-
-/*-----------------------------------------------------------*/
-
-vPortStartFirstTask:
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	before the scheduler was started - which would otherwise result in the
-	unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	registers. */
-	mov r0, #0
-	msr control, r0
-	/* Call SVC to start the first task. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc 0
-
-/*-----------------------------------------------------------*/
-
-vPortRestoreContextOfFirstTask:
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Restore the context. */
-	ldr	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	/* The first item in the TCB is the task top of stack. */
-	ldr r0, [r1]
-	/* Move onto the second item in the TCB... */
-	add r1, r1, #4
-
-	dmb					/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1		/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]		/* Disable MPU. */
-
-	/* Region Base Address register. */
-	ldr r2, =0xe000ed9c
-	/* Read 4 sets of MPU registers. */
-	ldmia r1!, {r4-r11}
-	/* Write 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}
-
-	ldr r2, =0xe000ed94	/* MPU_CTRL register. */
-	ldr r3, [r2]		/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1		/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]		/* Enable MPU. */
-	dsb					/* Force memory writes before continuing. */
-
-	/* Pop the registers that are not automatically saved on exception entry. */
-	ldmia r0!, {r3-r11, r14}
-	msr control, r3
-	/* Restore the task stack pointer. */
-	msr psp, r0
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-
-/*-----------------------------------------------------------*/
-
-vPortEnableVFP:
-	/* The FPU enable bits are in the CPACR. */
-	ldr.w r0, =0xE000ED88
-	ldr	r1, [r0]
-
-	/* Enable CP10 and CP11 coprocessors, then save back. */
-	orr	r1, r1, #( 0xf << 20 )
-	str r1, [r0]
-	bx	r14
-
-/*-----------------------------------------------------------*/
-
-xIsPrivileged:
-	mrs r0, control		/* r0 = CONTROL. */
-	tst r0, #1			/* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	ite ne
-	movne r0, #0		/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	moveq r0, #1		/* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	bx lr				/* Return. */
-/*-----------------------------------------------------------*/
-
-vResetPrivilege:
-	mrs r0, control		/* r0 = CONTROL. */
-	orr r0, r0, #1		/* r0 = r0 | 1. */
-	msr control, r0		/* CONTROL = r0. */
-	bx lr				/* Return to the caller. */
-/*-----------------------------------------------------------*/
-
-	END
diff --git a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portmacro.h b/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portmacro.h
deleted file mode 100644
index 171a8a1..0000000
--- a/osal/src/freertos/portable/IAR/ARM_CM7_MPU/r0p1/portmacro.h
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Portion Copyright  2020 STMicroelectronics International N.V. All rights reserved.
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* IAR includes. */
-#include <intrinsics.h>
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* MPU specific constants. */
-#define portUSING_MPU_WRAPPERS		1
-#define portPRIVILEGE_BIT			( 0x80000000UL )
-
-#define portMPU_REGION_READ_WRITE								( 0x03UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY						( 0x05UL << 24UL )
-#define portMPU_REGION_READ_ONLY								( 0x06UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE					( 0x01UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY	( 0x02UL << 24UL )
-#define portMPU_REGION_CACHEABLE_BUFFERABLE						( 0x03UL << 16UL )
-#define portMPU_REGION_EXECUTE_NEVER							( 0x01UL << 28UL )
-
-#define portUNPRIVILEGED_FLASH_REGION			( 0UL )
-#define portPRIVILEGED_FLASH_REGION				( 1UL )
-#define portPRIVILEGED_RAM_REGION				( 2UL )
-#define portGENERAL_PERIPHERALS_REGION			( 3UL )
-#define portSTACK_REGION						( 4UL )
-#define portFIRST_CONFIGURABLE_REGION			( 5UL )
-#define portLAST_CONFIGURABLE_REGION			( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS			( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS					( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-#define portSWITCH_TO_USER_MODE() __asm volatile ( " mrs r0, control \n orr r0, r0, #1 \n msr control, r0 " ::: "r0", "memory" )
-
-typedef struct MPU_REGION_REGISTERS
-{
-	uint32_t ulRegionBaseAddress;
-	uint32_t ulRegionAttribute;
-} xMPU_REGION_REGISTERS;
-
-/* Plus 1 to create space for the stack region. */
-typedef struct MPU_SETTINGS
-{
-	xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS ];
-} xMPU_SETTINGS;
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-/* SVC numbers for various services. */
-#define portSVC_START_SCHEDULER				0
-#define portSVC_YIELD						1
-#define portSVC_RAISE_PRIVILEGE				2
-
-/* Scheduler utilities. */
-
-#define portYIELD()				__asm volatile ( "	SVC	%0	\n" :: "i" (portSVC_YIELD) : "memory" )
-#define portYIELD_WITHIN_API()								\
-{															\
-	/* Set a PendSV to request a context switch. */			\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;			\
-	__DSB();												\
-	__ISB();												\
-}
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD_WITHIN_API()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 1 )
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ( uint32_t ) __CLZ( ( uxReadyPriorities ) ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()							\
-{															\
-    __disable_interrupt();                                  \
-	__set_BASEPRI( configMAX_SYSCALL_INTERRUPT_PRIORITY );	\
-	__DSB();												\
-	__ISB();												\
-    __enable_interrupt();                                   \
-}
-
-#define portENABLE_INTERRUPTS()					__set_BASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		__get_BASEPRI(); portDISABLE_INTERRUPTS()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	__set_BASEPRI( x )
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE	__inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE inline __attribute__(( always_inline))
-#endif
-
-/*-----------------------------------------------------------*/
-
-portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-
-/*-----------------------------------------------------------*/
-
-extern BaseType_t xIsPrivileged( void );
-extern void vResetPrivilege( void );
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-#define portIS_PRIVILEGED()			xIsPrivileged()
-
-/**
- * @brief Raise an SVC request to raise privilege.
-*/
-#define portRAISE_PRIVILEGE()		__asm volatile ( "svc %0 \n" :: "i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- */
-#define portRESET_PRIVILEGE()		vResetPrivilege()
-/*-----------------------------------------------------------*/
-
-#ifndef configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY
-	#warning "configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not defined. We recommend defining it to 1 in FreeRTOSConfig.h for better security. https://www.freertos.org/FreeRTOS-V10.3.x.html"
-	#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 0
-#endif
-/*-----------------------------------------------------------*/
-
-/* Suppress warnings that are generated by the IAR tools, but cannot be fixed in
-the source code because to do so would cause other compilers to generate
-warnings. */
-#pragma diag_suppress=Pe191
-#pragma diag_suppress=Pa082
-#pragma diag_suppress=Be006
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/Keil/See-also-the-RVDS-directory.txt b/osal/src/freertos/portable/Keil/See-also-the-RVDS-directory.txt
deleted file mode 100644
index bd7fab7..0000000
--- a/osal/src/freertos/portable/Keil/See-also-the-RVDS-directory.txt
+++ /dev/null
@@ -1 +0,0 @@
-Nothing to see here.
\ No newline at end of file
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM0/port.c b/osal/src/freertos/portable/RVDS/ARM_CM0/port.c
deleted file mode 100644
index ad9e787..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM0/port.c
+++ /dev/null
@@ -1,530 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM0 port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* Constants required to manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_INT_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSTICK_CLK_BIT			( 1UL << 2UL )
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVSET_BIT				( 1UL << 28UL )
-#define portMIN_INTERRUPT_PRIORITY			( 255UL )
-#define portNVIC_PENDSV_PRI					( portMIN_INTERRUPT_PRIORITY << 16UL )
-#define portNVIC_SYSTICK_PRI				( portMIN_INTERRUPT_PRIORITY << 24UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR			( 0x01000000 )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER		( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
- occurred while the SysTick counter is stopped during tickless idle
- calculations. */
-#ifndef portMISSED_COUNTS_FACTOR
-	#define portMISSED_COUNTS_FACTOR	( 45UL )
-#endif
-
-/* Constants used with memory barrier intrinsics. */
-#define portSY_FULL_READ_WRITE		( 15 )
-
-/* Legacy macro for backward compatibility only.  This macro used to be used to
-replace the function that configures the clock used to generate the tick
-interrupt (prvSetupTimerInterrupt()), but now the function is declared weak so
-the application writer can override it by simply defining a function of the
-same name (vApplicationSetupTickInterrupt()). */
-#ifndef configOVERRIDE_DEFAULT_TICK_CONFIGURATION
-	#define configOVERRIDE_DEFAULT_TICK_CONFIGURATION 0
-#endif
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/* The number of SysTick increments that make up one tick period. */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/* The maximum number of tick periods that can be suppressed is limited by the
- 24 bit resolution of the SysTick timer. */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
- /* Compensate for the CPU cycles that pass while the SysTick is stopped (low
- power functionality only.
-*/
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void );
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvPortStartFirstTask( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-	pxTopOfStack -= 8; /* R11..R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-void vPortSVCHandler( void )
-{
-	/* This function is no longer used, but retained for backward
-	compatibility. */
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvPortStartFirstTask( void )
-{
-	extern pxCurrentTCB;
-
-	PRESERVE8
-
-	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
-	table offset register that can be used to locate the initial stack value.
-	Not all M0 parts have the application vector table at address 0. */
-
-	ldr	r3, =pxCurrentTCB	/* Obtain location of pxCurrentTCB. */
-	ldr r1, [r3]
-	ldr r0, [r1]			/* The first item in pxCurrentTCB is the task top of stack. */
-	adds r0, #32			/* Discard everything up to r0. */
-	msr psp, r0				/* This is now the new top of stack to use in the task. */
-	movs r0, #2				/* Switch to the psp stack. */
-	msr CONTROL, r0
-	isb
-	pop {r0-r5}				/* Pop the registers that are saved automatically. */
-	mov lr, r5				/* lr is now in r5. */
-	pop {r3}				/* The return address is now in r3. */
-	pop {r2}				/* Pop and discard the XPSR. */
-	cpsie i					/* The first task has its context and interrupts can be enabled. */
-	bx r3					/* Finally, jump to the user defined task code. */
-
-	ALIGN
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Start the first task. */
-	prvPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortYield( void )
-{
-	/* Set a PendSV to request a context switch. */
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-
-	/* Barriers are normally not required but do ensure the code is completely
-	within the specified behaviour for the architecture. */
-	__dsb( portSY_FULL_READ_WRITE );
-	__isb( portSY_FULL_READ_WRITE );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-    portDISABLE_INTERRUPTS();
-    uxCriticalNesting++;
-	__dsb( portSY_FULL_READ_WRITE );
-	__isb( portSY_FULL_READ_WRITE );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm uint32_t ulSetInterruptMaskFromISR( void )
-{
-	mrs r0, PRIMASK
-	cpsid i
-	bx lr
-}
-/*-----------------------------------------------------------*/
-
-__asm void vClearInterruptMaskFromISR( uint32_t ulMask )
-{
-	msr PRIMASK, r0
-	bx lr
-}
-/*-----------------------------------------------------------*/
-
-__asm void xPortPendSVHandler( void )
-{
-	extern vTaskSwitchContext
-	extern pxCurrentTCB
-
-	PRESERVE8
-
-	mrs r0, psp
-
-	ldr	r3, =pxCurrentTCB 	/* Get the location of the current TCB. */
-	ldr	r2, [r3]
-
-	subs r0, #32			/* Make space for the remaining low registers. */
-	str r0, [r2]			/* Save the new top of stack. */
-	stmia r0!, {r4-r7}		/* Store the low registers that are not saved automatically. */
-	mov r4, r8				/* Store the high registers. */
-	mov r5, r9
-	mov r6, r10
-	mov r7, r11
-	stmia r0!, {r4-r7}
-
-	push {r3, r14}
-	cpsid i
-	bl vTaskSwitchContext
-	cpsie i
-	pop {r2, r3}			/* lr goes in r3. r2 now holds tcb pointer. */
-
-	ldr r1, [r2]
-	ldr r0, [r1]			/* The first item in pxCurrentTCB is the task top of stack. */
-	adds r0, #16			/* Move to the high registers. */
-	ldmia r0!, {r4-r7}		/* Pop the high registers. */
-	mov r8, r4
-	mov r9, r5
-	mov r10, r6
-	mov r11, r7
-
-	msr psp, r0				/* Remember the new top of stack for the task. */
-
-	subs r0, #32			/* Go back for the low registers that are not automatically restored. */
-	ldmia r0!, {r4-r7}      /* Pop low registers.  */
-
-	bx r3
-	ALIGN
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulPreviousMask;
-
-	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-#if( configOVERRIDE_DEFAULT_TICK_CONFIGURATION == 0 )
-
-	__weak void vPortSetupTimerInterrupt( void )
-	{
-		/* Calculate the constants required to configure the tick interrupt. */
-		#if( configUSE_TICKLESS_IDLE == 1 )
-			ulTimerCountsForOneTick = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ );
-			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
-		#endif /* configUSE_TICKLESS_IDLE */
-
-		/* Stop and reset the SysTick. */
-		portNVIC_SYSTICK_CTRL_REG = 0UL;
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-		/* Configure SysTick to interrupt at the requested rate. */
-		portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-		portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
-	}
-
-#endif /* configOVERRIDE_DEFAULT_TICK_CONFIGURATION */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-{
-uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-TickType_t xModifiableIdleTime;
-
-	/* Make sure the SysTick reload value does not overflow the counter. */
-	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-	{
-		xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-	}
-
-	/* Stop the SysTick momentarily. The time the SysTick is stopped for
-	is accounted for as best it can be, but using the tickless mode will
-	inevitably result in some tiny drift of the time maintained by the
-	kernel with respect to calendar time. */
-	portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-	/* Calculate the reload value required to wait xExpectedIdleTime
-	tick periods.  -1 is used because this code will execute part way
-	through one of the tick periods. */
-	ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-	if( ulReloadValue > ulStoppedTimerCompensation )
-	{
-		ulReloadValue -= ulStoppedTimerCompensation;
-	}
-
-	/* Enter a critical section but don't use the taskENTER_CRITICAL()
-	method as that will mask interrupts that should exit sleep mode. */
-	__disable_irq();
-	__dsb( portSY_FULL_READ_WRITE );
-	__isb( portSY_FULL_READ_WRITE );
-
-	/* If a context switch is pending or a task is waiting for the scheduler
-	to be unsuspended then abandon the low power entry. */
-	if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-	{
-		/* Restart from whatever is left in the count register to complete
-		this tick period. */
-		portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-		/* Restart SysTick. */
-		portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Reset the reload register to the value required for normal tick
-		periods. */
-		portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-		/* Re-enable interrupts - see comments above __disable_irq() call
-		above. */
-		__enable_irq();
-	}
-	else
-	{
-		/* Set the new reload value. */
-		portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-		/* Clear the SysTick count flag and set the count value back to
-		zero. */
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-		/* Restart SysTick. */
-		portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Sleep until something happens. configPRE_SLEEP_PROCESSING() can
-		set its parameter to 0 to indicate that its implementation contains
-		its own wait for interrupt or wait for event instruction, and so wfi
-		should not be executed again. However, the original expected idle
-		time variable must remain unmodified, so a copy is taken. */
-		xModifiableIdleTime = xExpectedIdleTime;
-		configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-		if( xModifiableIdleTime > 0 )
-		{
-			__dsb( portSY_FULL_READ_WRITE );
-			__wfi();
-			__isb( portSY_FULL_READ_WRITE );
-		}
-		configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-		/* Re-enable interrupts to allow the interrupt that brought the MCU
-		out of sleep mode to execute immediately. see comments above
-		__disable_interrupt() call above. */
-		__enable_irq();
-		__dsb( portSY_FULL_READ_WRITE );
-		__isb( portSY_FULL_READ_WRITE );
-
-		/* Disable interrupts again because the clock is about to be stopped
-		and interrupts that execute while the clock is stopped will increase
-		any slippage between the time maintained by the RTOS and calendar
-		time. */
-		__disable_irq();
-		__dsb( portSY_FULL_READ_WRITE );
-		__isb( portSY_FULL_READ_WRITE );
-
-		/* Disable the SysTick clock without reading the
-		portNVIC_SYSTICK_CTRL_REG register to ensure the
-		portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-		the time the SysTick is stopped for is accounted for as best it can
-		be, but using the tickless mode will inevitably result in some tiny
-		drift of the time maintained by the kernel with respect to calendar
-		time*/
-		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-		/* Determine if the SysTick clock has already counted to zero and
-		been set back to the current reload value (the reload back being
-		correct for the entire expected idle time) or if the SysTick is yet
-		to count to zero (in which case an interrupt other than the SysTick
-		must have brought the system out of sleep mode). */
-		if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-		{
-			uint32_t ulCalculatedLoadValue;
-
-			/* The tick interrupt is already pending, and the SysTick count
-			reloaded with ulReloadValue.  Reset the
-			portNVIC_SYSTICK_LOAD with whatever remains of this tick
-			period. */
-			ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-			/* Don't allow a tiny value, or values that have somehow
-			underflowed because the post sleep hook did something
-			that took too long. */
-			if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-			{
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-			}
-
-			portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-			/* As the pending tick will be processed as soon as this
-			function exits, the tick value maintained by the tick is stepped
-			forward by one less than the time spent waiting. */
-			ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-		}
-		else
-		{
-			/* Something other than the tick interrupt ended the sleep.
-			Work out how long the sleep lasted rounded to complete tick
-			periods (not the ulReload value which accounted for part
-			ticks). */
-			ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* How many complete tick periods passed while the processor
-			was waiting? */
-			ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-			/* The reload value is set to whatever fraction of a single tick
-			period remains. */
-			portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-		}
-
-		/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD
-		again, then set portNVIC_SYSTICK_LOAD back to its standard
-		value. */
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-		portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-		vTaskStepTick( ulCompleteTickPeriods );
-		portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-		/* Exit with interrpts enabled. */
-		__enable_irq();
-	}
-}
-
-#endif /* #if configUSE_TICKLESS_IDLE */
-
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM0/portmacro.h b/osal/src/freertos/portable/RVDS/ARM_CM0/portmacro.h
deleted file mode 100644
index adaed4a..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM0/portmacro.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-
-/* Scheduler utilities. */
-extern void vPortYield( void );
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portYIELD()					vPortYield()
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-extern uint32_t ulSetInterruptMaskFromISR( void );
-extern void vClearInterruptMaskFromISR( uint32_t ulMask );
-
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulSetInterruptMaskFromISR()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vClearInterruptMaskFromISR( x )
-#define portDISABLE_INTERRUPTS()				__disable_irq()
-#define portENABLE_INTERRUPTS()					__enable_irq()
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-
-#define portNOP()
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM3/port.c b/osal/src/freertos/portable/RVDS/ARM_CM3/port.c
deleted file mode 100644
index d2137f0..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM3/port.c
+++ /dev/null
@@ -1,698 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM3 port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef configKERNEL_INTERRUPT_PRIORITY
-	#define configKERNEL_INTERRUPT_PRIORITY 255
-#endif
-
-#if configMAX_SYSCALL_INTERRUPT_PRIORITY == 0
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Legacy macro for backward compatibility only.  This macro used to be used to
-replace the function that configures the clock used to generate the tick
-interrupt (prvSetupTimerInterrupt()), but now the function is declared weak so
-the application writer can override it by simply defining a function of the
-same name (vApplicationSetupTickInterrupt()). */
-#ifndef configOVERRIDE_DEFAULT_TICK_CONFIGURATION
-	#define configOVERRIDE_DEFAULT_TICK_CONFIGURATION 0
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR			( 0x01000000 )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR			( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void );
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvStartFirstTask( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( uint8_t * ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortSVCHandler( void )
-{
-	PRESERVE8
-
-	ldr	r3, =pxCurrentTCB	/* Restore the context. */
-	ldr r1, [r3]			/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
-	ldr r0, [r1]			/* The first item in pxCurrentTCB is the task top of stack. */
-	ldmia r0!, {r4-r11}		/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
-	msr psp, r0				/* Restore the task stack pointer. */
-	isb
-	mov r0, #0
-	msr	basepri, r0
-	orr r14, #0xd
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvStartFirstTask( void )
-{
-	PRESERVE8
-
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Globally enable interrupts. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	/* Call SVC to start the first task. */
-	svc 0
-	nop
-	nop
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* The kernel interrupt priority should be set to the lowest
-		priority. */
-		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Start the first task. */
-	prvStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm void xPortPendSVHandler( void )
-{
-	extern uxCriticalNesting;
-	extern pxCurrentTCB;
-	extern vTaskSwitchContext;
-
-	PRESERVE8
-
-	mrs r0, psp
-	isb
-
-	ldr	r3, =pxCurrentTCB		/* Get the location of the current TCB. */
-	ldr	r2, [r3]
-
-	stmdb r0!, {r4-r11}			/* Save the remaining registers. */
-	str r0, [r2]				/* Save the new top of stack into the first member of the TCB. */
-
-	stmdb sp!, {r3, r14}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r3, r14}
-
-	ldr r1, [r3]
-	ldr r0, [r1]				/* The first item in pxCurrentTCB is the task top of stack. */
-	ldmia r0!, {r4-r11}			/* Pop the registers and the critical nesting count. */
-	msr psp, r0
-	isb
-	bx r14
-	nop
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
-	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
-	vPortRaiseBASEPRI();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	vPortClearBASEPRIFromISR();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__disable_irq();
-		__dsb( portSY_FULL_READ_WRITE );
-		__isb( portSY_FULL_READ_WRITE );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above __disable_irq() call
-			above. */
-			__enable_irq();
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__dsb( portSY_FULL_READ_WRITE );
-				__wfi();
-				__isb( portSY_FULL_READ_WRITE );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__enable_irq();
-			__dsb( portSY_FULL_READ_WRITE );
-			__isb( portSY_FULL_READ_WRITE );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__disable_irq();
-			__dsb( portSY_FULL_READ_WRITE );
-			__isb( portSY_FULL_READ_WRITE );
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__enable_irq();
-		}
-	}
-
-#endif /* #if configUSE_TICKLESS_IDLE */
-
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the SysTick timer to generate the tick interrupts at the required
- * frequency.
- */
-#if( configOVERRIDE_DEFAULT_TICK_CONFIGURATION == 0 )
-
-	__weak void vPortSetupTimerInterrupt( void )
-	{
-		/* Calculate the constants required to configure the tick interrupt. */
-		#if( configUSE_TICKLESS_IDLE == 1 )
-		{
-			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-		}
-		#endif /* configUSE_TICKLESS_IDLE */
-
-		/* Stop and clear the SysTick. */
-		portNVIC_SYSTICK_CTRL_REG = 0UL;
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-		/* Configure SysTick to interrupt at the requested rate. */
-		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-	}
-
-#endif /* configOVERRIDE_DEFAULT_TICK_CONFIGURATION */
-/*-----------------------------------------------------------*/
-
-__asm uint32_t vPortGetIPSR( void )
-{
-	PRESERVE8
-
-	mrs r0, ipsr
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		ulCurrentInterrupt = vPortGetIPSR();
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM3/portmacro.h b/osal/src/freertos/portable/RVDS/ARM_CM3/portmacro.h
deleted file mode 100644
index 2b07ff1..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM3/portmacro.h
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-
-/* Constants used with memory barrier intrinsics. */
-#define portSY_FULL_READ_WRITE		( 15 )
-
-/*-----------------------------------------------------------*/
-
-/* Scheduler utilities. */
-#define portYIELD()																\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__dsb( portSY_FULL_READ_WRITE );											\
-	__isb( portSY_FULL_READ_WRITE );											\
-}
-/*-----------------------------------------------------------*/
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Port specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
-
-#endif /* taskRECORD_READY_PRIORITY */
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE __inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE __forceinline
-#endif
-
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
-{
-	__asm
-	{
-		/* Barrier instructions are not used as this function is only used to
-		lower the BASEPRI value. */
-		msr basepri, ulBASEPRI
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
-{
-	__asm
-	{
-		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
-		used to lower the mask in an interrupt, so memory barriers are not 
-		used. */
-		msr basepri, #0
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		mrs ulReturn, basepri
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-	}
-
-	return ulReturn;
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm
-	{
-		mrs ulCurrentInterrupt, ipsr
-	}
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM4F/port.c b/osal/src/freertos/portable/RVDS/ARM_CM4F/port.c
deleted file mode 100644
index 6cd7542..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM4F/port.c
+++ /dev/null
@@ -1,788 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __TARGET_FPU_VFP
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#if configMAX_SYSCALL_INTERRUPT_PRIORITY == 0
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* Legacy macro for backward compatibility only.  This macro used to be used to
-replace the function that configures the clock used to generate the tick
-interrupt (prvSetupTimerInterrupt()), but now the function is declared weak so
-the application writer can override it by simply defining a function of the
-same name (vApplicationSetupTickInterrupt()). */
-#ifndef configOVERRIDE_DEFAULT_TICK_CONFIGURATION
-	#define configOVERRIDE_DEFAULT_TICK_CONFIGURATION 0
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-/* Constants used to detect a Cortex-M7 r0p1 core, which should use the ARM_CM7
-r0p1 port. */
-#define portCPUID							( * ( ( volatile uint32_t * ) 0xE000ed00 ) )
-#define portCORTEX_M7_r0p1_ID				( 0x410FC271UL )
-#define portCORTEX_M7_r0p0_ID				( 0x410FC270UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR					( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS	( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR			( 0x01000000 )
-#define portINITIAL_EXC_RETURN		( 0xfffffffd )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER		( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR	( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK		( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void );
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvStartFirstTask( void );
-
-/*
- * Functions defined in portasm.s to enable the VFP.
- */
-static void prvEnableVFP( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( uint8_t * ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortSVCHandler( void )
-{
-	PRESERVE8
-
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	ldr r0, [r1]
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-	msr psp, r0
-	isb
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvStartFirstTask( void )
-{
-	PRESERVE8
-
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	before the scheduler was started - which would otherwise result in the
-	unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	registers. */
-	mov r0, #0
-	msr control, r0
-	/* Globally enable interrupts. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	/* Call SVC to start the first task. */
-	svc 0
-	nop
-	nop
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvEnableVFP( void )
-{
-	PRESERVE8
-
-	/* The FPU enable bits are in the CPACR. */
-	ldr.w r0, =0xE000ED88
-	ldr	r1, [r0]
-
-	/* Enable CP10 and CP11 coprocessors, then save back. */
-	orr	r1, r1, #( 0xf << 20 )
-	str r1, [r0]
-	bx	r14
-	nop
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
-
-	/* This port can be used on all revisions of the Cortex-M7 core other than
-	the r0p1 parts.  r0p1 parts should use the port from the
-	/source/portable/GCC/ARM_CM7/r0p1 directory. */
-	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
-	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* The kernel interrupt priority should be set to the lowest
-		priority. */
-		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	prvEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	prvStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm void xPortPendSVHandler( void )
-{
-	extern uxCriticalNesting;
-	extern pxCurrentTCB;
-	extern vTaskSwitchContext;
-
-	PRESERVE8
-
-	mrs r0, psp
-	isb
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	/* Is the task using the FPU context?  If so, push high vfp registers. */
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	/* Save the core registers. */
-	stmdb r0!, {r4-r11, r14}
-
-	/* Save the new top of stack into the first member of the TCB. */
-	str r0, [r2]
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-
-	/* The first item in pxCurrentTCB is the task top of stack. */
-	ldr r1, [r3]
-	ldr r0, [r1]
-
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-
-	/* Is the task using the FPU context?  If so, pop the high vfp registers
-	too. */
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata */
-		#if WORKAROUND_PMU_CM001 == 1
-			push { r14 }
-			pop { pc }
-			nop
-		#endif
-	#endif
-
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
-	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
-	vPortRaiseBASEPRI();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	vPortClearBASEPRIFromISR();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__disable_irq();
-		__dsb( portSY_FULL_READ_WRITE );
-		__isb( portSY_FULL_READ_WRITE );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above __disable_irq() call
-			above. */
-			__enable_irq();
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__dsb( portSY_FULL_READ_WRITE );
-				__wfi();
-				__isb( portSY_FULL_READ_WRITE );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__enable_irq();
-			__dsb( portSY_FULL_READ_WRITE );
-			__isb( portSY_FULL_READ_WRITE );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__disable_irq();
-			__dsb( portSY_FULL_READ_WRITE );
-			__isb( portSY_FULL_READ_WRITE );
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__enable_irq();
-		}
-	}
-
-#endif /* #if configUSE_TICKLESS_IDLE */
-
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the SysTick timer to generate the tick interrupts at the required
- * frequency.
- */
-#if( configOVERRIDE_DEFAULT_TICK_CONFIGURATION == 0 )
-
-	__weak void vPortSetupTimerInterrupt( void )
-	{
-		/* Calculate the constants required to configure the tick interrupt. */
-		#if( configUSE_TICKLESS_IDLE == 1 )
-		{
-			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-		}
-		#endif /* configUSE_TICKLESS_IDLE */
-
-		/* Stop and clear the SysTick. */
-		portNVIC_SYSTICK_CTRL_REG = 0UL;
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-		/* Configure SysTick to interrupt at the requested rate. */
-		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-	}
-
-#endif /* configOVERRIDE_DEFAULT_TICK_CONFIGURATION */
-/*-----------------------------------------------------------*/
-
-__asm uint32_t vPortGetIPSR( void )
-{
-	PRESERVE8
-
-	mrs r0, ipsr
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		ulCurrentInterrupt = vPortGetIPSR();
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM4F/portmacro.h b/osal/src/freertos/portable/RVDS/ARM_CM4F/portmacro.h
deleted file mode 100644
index 2b07ff1..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM4F/portmacro.h
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-
-/* Constants used with memory barrier intrinsics. */
-#define portSY_FULL_READ_WRITE		( 15 )
-
-/*-----------------------------------------------------------*/
-
-/* Scheduler utilities. */
-#define portYIELD()																\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__dsb( portSY_FULL_READ_WRITE );											\
-	__isb( portSY_FULL_READ_WRITE );											\
-}
-/*-----------------------------------------------------------*/
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Port specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
-
-#endif /* taskRECORD_READY_PRIORITY */
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE __inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE __forceinline
-#endif
-
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
-{
-	__asm
-	{
-		/* Barrier instructions are not used as this function is only used to
-		lower the BASEPRI value. */
-		msr basepri, ulBASEPRI
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
-{
-	__asm
-	{
-		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
-		used to lower the mask in an interrupt, so memory barriers are not 
-		used. */
-		msr basepri, #0
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		mrs ulReturn, basepri
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-	}
-
-	return ulReturn;
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm
-	{
-		mrs ulCurrentInterrupt, ipsr
-	}
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM4_MPU/port.c b/osal/src/freertos/portable/RVDS/ARM_CM4_MPU/port.c
deleted file mode 100644
index e64961d..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM4_MPU/port.c
+++ /dev/null
@@ -1,916 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM3 port.
- *----------------------------------------------------------*/
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers.  That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __TARGET_FPU_VFP
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Constants required to access and manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG				( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG		( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG					( *	( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSPRI1_REG					( * ( ( volatile uint32_t * ) 0xe000ed1c ) )
-#define portNVIC_SYS_CTRL_STATE_REG				( * ( ( volatile uint32_t * ) 0xe000ed24 ) )
-#define portNVIC_MEM_FAULT_ENABLE				( 1UL << 16UL )
-
-/* Constants required to access and manipulate the MPU. */
-#define portMPU_TYPE_REG						( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_REGION_BASE_ADDRESS_REG			( * ( ( volatile uint32_t * ) 0xe000ed9C ) )
-#define portMPU_REGION_ATTRIBUTE_REG			( * ( ( volatile uint32_t * ) 0xe000edA0 ) )
-#define portMPU_CTRL_REG						( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portEXPECTED_MPU_TYPE_VALUE				( 8UL << 8UL ) /* 8 regions, unified. */
-#define portMPU_ENABLE							( 0x01UL )
-#define portMPU_BACKGROUND_ENABLE				( 1UL << 2UL )
-#define portPRIVILEGED_EXECUTION_START_ADDRESS	( 0UL )
-#define portMPU_REGION_VALID					( 0x10UL )
-#define portMPU_REGION_ENABLE					( 0x01UL )
-#define portPERIPHERALS_START_ADDRESS			0x40000000UL
-#define portPERIPHERALS_END_ADDRESS				0x5FFFFFFFUL
-
-/* Constants required to access and manipulate the SysTick. */
-#define portNVIC_SYSTICK_CLK					( 0x00000004UL )
-#define portNVIC_SYSTICK_INT					( 0x00000002UL )
-#define portNVIC_SYSTICK_ENABLE					( 0x00000001UL )
-#define portNVIC_PENDSV_PRI						( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-#define portNVIC_SVC_PRI						( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR								( ( volatile uint32_t * ) 0xe000ef34UL ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS				( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR						( 0x01000000UL )
-#define portINITIAL_EXC_RETURN					( 0xfffffffdUL )
-#define portINITIAL_CONTROL_IF_UNPRIVILEGED		( 0x03 )
-#define portINITIAL_CONTROL_IF_PRIVILEGED		( 0x02 )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Offsets in the stack to the parameters when inside the SVC handler. */
-#define portOFFSET_TO_PC						( 6 )
-
-/* For strict compliance with the Cortex-M spec the task start address should
- * have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/* Each task maintains its own interrupt status in the critical nesting
- * variable.  Note this is not saved as part of the task context as context
- * switches can only occur when uxCriticalNesting is zero. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * Setup the timer to generate the tick interrupts.
- */
-void vSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Configure a number of standard MPU regions that are used by all tasks.
- */
-static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvStartFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the smallest MPU region size that a given number of bytes will fit
- * into.  The region size is returned as the value that should be programmed
- * into the region attribute register for that region.
- */
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes ) PRIVILEGED_FUNCTION;
-
-/*
- * Standard FreeRTOS exception handlers.
- */
-void xPortPendSVHandler( void ) PRIVILEGED_FUNCTION;
-void xPortSysTickHandler( void ) PRIVILEGED_FUNCTION;
-void vPortSVCHandler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Starts the scheduler by restoring the context of the first task to run.
- */
-static void prvRestoreContextOfFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/*
- * C portion of the SVC handler.  The SVC handler is split between an asm entry
- * and a C wrapper for simplicity of coding and maintenance.
- */
-void prvSVCHandler( uint32_t *pulRegisters ) __attribute__((used)) PRIVILEGED_FUNCTION;
-
-/*
- * Function to enable the VFP.
- */
-static void vPortEnableVFP( void );
-
-/*
- * Utility function.
- */
-static uint32_t prvPortGetIPSR( void );
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const uint8_t * ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void );
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void );
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-extern BaseType_t xPortRaisePrivilege( void );
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-extern void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = 0;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	 * own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	if( xRunPrivileged == pdTRUE )
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_PRIVILEGED;
-	}
-	else
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
-	}
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-void prvSVCHandler( uint32_t *pulParam )
-{
-uint8_t ucSVCNumber;
-uint32_t ulReg, ulPC;
-#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-	extern uint32_t __syscalls_flash_start__;
-	extern uint32_t __syscalls_flash_end__;
-#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-	/* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR. The first
-	 * argument (r0) is pulParam[ 0 ]. */
-	ulPC = pulParam[ portOFFSET_TO_PC ];
-	ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
-	switch( ucSVCNumber )
-	{
-		case portSVC_START_SCHEDULER	:	portNVIC_SYSPRI1_REG |= portNVIC_SVC_PRI;
-											prvRestoreContextOfFirstTask();
-											break;
-
-		case portSVC_YIELD				:	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-											/* Barriers are normally not required
-											 * but do ensure the code is completely
-											 * within the specified behaviour for the
-											 * architecture. */
-											__asm volatile( "dsb" );
-											__asm volatile( "isb" );
-
-											break;
-
-	#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-		case portSVC_RAISE_PRIVILEGE	:	/* Only raise the privilege, if the
-											 * svc was raised from any of the
-											 * system calls. */
-											if( ( ulPC >= ( uint32_t ) __syscalls_flash_start__ ) &&
-												( ulPC <= ( uint32_t ) __syscalls_flash_end__ ) )
-											{
-												__asm
-												{
-													mrs ulReg, control	/* Obtain current control value. */
-													bic ulReg, #1		/* Set privilege bit. */
-													msr control, ulReg	/* Write back new control value. */
-												}
-											}
-											break;
-	#else
-		case portSVC_RAISE_PRIVILEGE	:	__asm
-											{
-												mrs ulReg, control	/* Obtain current control value. */
-												bic ulReg, #1		/* Set privilege bit. */
-												msr control, ulReg	/* Write back new control value. */
-											}
-											break;
-	#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-		default							:	/* Unknown SVC call. */
-											break;
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortSVCHandler( void )
-{
-	extern prvSVCHandler
-
-	PRESERVE8
-
-	/* Assumes psp was in use. */
-	#ifndef USE_PROCESS_STACK	/* Code should not be required if a main() is using the process stack. */
-		tst lr, #4
-		ite eq
-		mrseq r0, msp
-		mrsne r0, psp
-	#else
-		mrs r0, psp
-	#endif
-		b prvSVCHandler
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvRestoreContextOfFirstTask( void )
-{
-	PRESERVE8
-
-	ldr r0, =0xE000ED08				/* Use the NVIC offset register to locate the stack. */
-	ldr r0, [r0]
-	ldr r0, [r0]
-	msr msp, r0						/* Set the msp back to the start of the stack. */
-	ldr	r3, =pxCurrentTCB			/* Restore the context. */
-	ldr r1, [r3]
-	ldr r0, [r1]					/* The first item in the TCB is the task top of stack. */
-	add r1, r1, #4					/* Move onto the second item in the TCB... */
-
-	dmb								/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1					/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]					/* Disable MPU. */
-
-	ldr r2, =0xe000ed9c				/* Region Base Address register. */
-	ldmia r1!, {r4-r11}				/* Read 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}				/* Write 4 sets of MPU registers. */
-
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1					/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]					/* Enable MPU. */
-	dsb								/* Force memory writes before continuing. */
-
-	ldmia r0!, {r3-r11, r14}		/* Pop the registers that are not automatically saved on exception entry. */
-	msr control, r3
-	msr psp, r0						/* Restore the task stack pointer. */
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-	nop
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See
-	 * http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		 * functions can be called.  ISR safe functions are those that end in
-		 * "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		 * ensure interrupt entry is as fast and simple as possible.
-
-		 * Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		 * possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		 * of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		 * register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		 * value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the same priority as the kernel, and the SVC
-	 * handler higher priority so it can be used to exit a critical section (where
-	 * lower priorities are masked). */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Configure the regions in the MPU that are common to all tasks. */
-	prvSetupMPU();
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	 * here already. */
-	vSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	prvStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvStartFirstTask( void )
-{
-	PRESERVE8
-
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	 * before the scheduler was started - which would otherwise result in the
-	 * unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	 * registers. */
-	mov r0, #0
-	msr control, r0
-	/* Globally enable interrupts. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc portSVC_START_SCHEDULER	/* System call to start first task. */
-	nop
-	nop
-}
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-__asm void xPortPendSVHandler( void )
-{
-	extern uxCriticalNesting;
-	extern pxCurrentTCB;
-	extern vTaskSwitchContext;
-
-	PRESERVE8
-
-	mrs r0, psp
-
-	ldr r3, =pxCurrentTCB			/* Get the location of the current TCB. */
-	ldr r2, [r3]
-
-	tst r14, #0x10					/* Is the task using the FPU context?  If so, push high vfp registers. */
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	mrs r1, control
-	stmdb r0!, {r1, r4-r11, r14}	/* Save the remaining registers. */
-	str r0, [r2]					/* Save the new top of stack into the first member of the TCB. */
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-									/* Restore the context. */
-	ldr r1, [r3]
-	ldr r0, [r1]					/* The first item in the TCB is the task top of stack. */
-	add r1, r1, #4					/* Move onto the second item in the TCB... */
-
-	dmb								/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1					/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]					/* Disable MPU. */
-
-	ldr r2, =0xe000ed9c				/* Region Base Address register. */
-	ldmia r1!, {r4-r11}				/* Read 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}				/* Write 4 sets of MPU registers. */
-
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1					/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]					/* Enable MPU. */
-	dsb								/* Force memory writes before continuing. */
-
-	ldmia r0!, {r3-r11, r14}		/* Pop the registers that are not automatically saved on exception entry. */
-	msr control, r3
-
-	tst r14, #0x10					/* Is the task using the FPU context?  If so, pop the high vfp registers too. */
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	bx r14
-	nop
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulDummy;
-
-	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__weak void vSetupTimerInterrupt( void )
-{
-	/* Reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortSwitchToUserMode( void )
-{
-	PRESERVE8
-
-	mrs r0, control
-	orr r0, #1
-	msr control, r0
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortEnableVFP( void )
-{
-	PRESERVE8
-
-	ldr.w r0, =0xE000ED88		/* The FPU enable bits are in the CPACR. */
-	ldr r1, [r0]
-
-	orr r1, r1, #( 0xf << 20 )	/* Enable CP10 and CP11 coprocessors, then save back. */
-	str r1, [r0]
-	bx r14
-	nop
-	nop
-}
-/*-----------------------------------------------------------*/
-
-static void prvSetupMPU( void )
-{
-extern uint32_t __privileged_functions_end__;
-extern uint32_t __FLASH_segment_start__;
-extern uint32_t __FLASH_segment_end__;
-extern uint32_t __privileged_data_start__;
-extern uint32_t __privileged_data_end__;
-
-	/* Check the expected MPU is present. */
-	if( ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )  || ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE << 1 ))
-	{
-		/* First setup the entire flash for unprivileged read only access. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portUNPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the first 16K for privileged only access (even though less
-		 * than 10K is actually being used).  This is where the kernel code is
-		 * placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged data RAM region.  This is where the kernel data
-		 * is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_RAM_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-										( portMPU_REGION_ENABLE );
-
-		/* By default allow everything to access the general peripherals.  The
-		 * system peripherals and registers are protected. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( portPERIPHERALS_START_ADDRESS ) |
-											( portMPU_REGION_VALID ) |
-											( portGENERAL_PERIPHERALS_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
-										( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Enable the memory fault exception. */
-		portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
-
-		/* Enable the MPU with the background region configured. */
-		portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes )
-{
-uint32_t ulRegionSize, ulReturnValue = 4;
-
-	/* 32 is the smallest region size, 31 is the largest valid value for
-	 * ulReturnValue. */
-	for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
-	{
-		if( ulActualSizeInBytes <= ulRegionSize )
-		{
-			break;
-		}
-		else
-		{
-			ulReturnValue++;
-		}
-	}
-
-	/* Shift the code by one before returning so it can be written directly
-	 * into the the correct bit position of the attribute register. */
-	return ( ulReturnValue << 1UL );
-}
-/*-----------------------------------------------------------*/
-
-__asm BaseType_t xIsPrivileged( void )
-{
-	PRESERVE8
-
-	mrs r0, control		/* r0 = CONTROL. */
-	tst r0, #1			/* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	ite ne
-	movne r0, #0		/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	moveq r0, #1		/* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	bx lr				/* Return. */
-}
-/*-----------------------------------------------------------*/
-
-__asm void vResetPrivilege( void )
-{
-	PRESERVE8
-
-	mrs r0, control		/* r0 = CONTROL. */
-	orrs r0, #1			/* r0 = r0 | 1. */
-	msr control, r0		/* CONTROL = r0. */
-	bx lr				/* Return. */
-}
-/*-----------------------------------------------------------*/
-
-void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-{
-extern uint32_t __SRAM_segment_start__;
-extern uint32_t __SRAM_segment_end__;
-extern uint32_t __privileged_data_start__;
-extern uint32_t __privileged_data_end__;
-
-
-int32_t lIndex;
-uint32_t ul;
-
-	if( xRegions == NULL )
-	{
-		/* No MPU regions are specified so allow access to all RAM. */
-		xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-				( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION );
-
-		xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-				( portMPU_REGION_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Re-instate the privileged only RAM region as xRegion[ 0 ] will have
-		 * just removed the privileged only parameters. */
-		xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
-				( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION + 1 );
-
-		xMPUSettings->xRegion[ 1 ].ulRegionAttribute =
-				( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Invalidate all other regions. */
-		for( ul = 2; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-			xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-		}
-	}
-	else
-	{
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that the
-		 * stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-					( ( uint32_t ) pxBottomOfStack ) |
-					( portMPU_REGION_VALID ) |
-					( portSTACK_REGION ); /* Region number. */
-
-			xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-					( portMPU_REGION_READ_WRITE ) | /* Read and write. */
-					( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
-					( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-					( portMPU_REGION_ENABLE );
-		}
-
-		lIndex = 0;
-
-		for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
-			{
-				/* Translate the generic region definition contained in
-				 * xRegions into the CM3 specific MPU settings that are then
-				 * stored in xMPUSettings. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
-						( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) |
-						( portMPU_REGION_VALID ) |
-						( portSTACK_REGION + ul ); /* Region number. */
-
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute =
-						( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
-						( xRegions[ lIndex ].ulParameters ) |
-						( portMPU_REGION_ENABLE );
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm uint32_t prvPortGetIPSR( void )
-{
-	PRESERVE8
-
-	mrs r0, ipsr
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		ulCurrentInterrupt = prvPortGetIPSR();
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			 * an interrupt that has been assigned a priority above
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			 * function.  ISR safe FreeRTOS API functions must *only* be called
-			 * from interrupts that have been assigned a priority at or below
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Numerically low interrupt priority numbers represent logically high
-			 * interrupt priorities, therefore the priority of the interrupt must
-			 * be set to a value equal to or numerically *higher* than
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Interrupts that	use the FreeRTOS API must not be left at their
-			 * default priority of	zero as that is the highest possible priority,
-			 * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			 * and	therefore also guaranteed to be invalid.
-
-			 * FreeRTOS maintains separate thread and ISR API functions to ensure
-			 * interrupt entry is as fast and simple as possible.
-
-			 * The following links provide detailed information:
-			 * http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			 * http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		 * that define each interrupt's priority to be split between bits that
-		 * define the interrupt's pre-emption priority bits and bits that define
-		 * the interrupt's sub-priority.  For simplicity all bits must be defined
-		 * to be pre-emption priority bits.  The following assertion will fail if
-		 * this is not the case (if some bits represent a sub-priority).
-
-		 * If the application only uses CMSIS libraries for interrupt
-		 * configuration then the correct setting can be achieved on all Cortex-M
-		 * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		 * scheduler.  Note however that some vendor specific peripheral libraries
-		 * assume a non-zero priority group setting, in which cases using a value
-		 * of zero will result in unpredicable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM4_MPU/portmacro.h b/osal/src/freertos/portable/RVDS/ARM_CM4_MPU/portmacro.h
deleted file mode 100644
index 0cdf068..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM4_MPU/portmacro.h
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* MPU specific constants. */
-#define portUSING_MPU_WRAPPERS		1
-#define portPRIVILEGE_BIT			( 0x80000000UL )
-
-#define portMPU_REGION_READ_WRITE								( 0x03UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY						( 0x05UL << 24UL )
-#define portMPU_REGION_READ_ONLY								( 0x06UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE					( 0x01UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY	( 0x02UL << 24UL )
-#define portMPU_REGION_CACHEABLE_BUFFERABLE						( 0x03UL << 16UL )
-#define portMPU_REGION_EXECUTE_NEVER							( 0x01UL << 28UL )
-
-#define portUNPRIVILEGED_FLASH_REGION		( 0UL )
-#define portPRIVILEGED_FLASH_REGION			( 1UL )
-#define portPRIVILEGED_RAM_REGION			( 2UL )
-#define portGENERAL_PERIPHERALS_REGION		( 3UL )
-#define portSTACK_REGION					( 4UL )
-#define portFIRST_CONFIGURABLE_REGION		( 5UL )
-#define portLAST_CONFIGURABLE_REGION		( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS		( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS				( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-void vPortSwitchToUserMode( void );
-#define portSWITCH_TO_USER_MODE()	vPortSwitchToUserMode()
-
-typedef struct MPU_REGION_REGISTERS
-{
-	uint32_t ulRegionBaseAddress;
-	uint32_t ulRegionAttribute;
-} xMPU_REGION_REGISTERS;
-
-/* Plus 1 to create space for the stack region. */
-typedef struct MPU_SETTINGS
-{
-	xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS ];
-} xMPU_SETTINGS;
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-
-/* Constants used with memory barrier intrinsics. */
-#define portSY_FULL_READ_WRITE		( 15 )
-
-/*-----------------------------------------------------------*/
-
-/* SVC numbers for various services. */
-#define portSVC_START_SCHEDULER				0
-#define portSVC_YIELD						1
-#define portSVC_RAISE_PRIVILEGE				2
-
-/* Scheduler utilities. */
-
-#define portYIELD()				__asm{ SVC portSVC_YIELD }
-#define portYIELD_WITHIN_API() 													\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__dsb( portSY_FULL_READ_WRITE );											\
-	__isb( portSY_FULL_READ_WRITE );											\
-}
-/*-----------------------------------------------------------*/
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE __inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE __forceinline
-#endif
-/*-----------------------------------------------------------*/
-
-extern BaseType_t xIsPrivileged( void );
-extern void vResetPrivilege( void );
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-#define portIS_PRIVILEGED()			xIsPrivileged()
-
-/**
- * @brief Raise an SVC request to raise privilege.
- */
-#define portRAISE_PRIVILEGE()		__asm { svc portSVC_RAISE_PRIVILEGE }
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- */
-#define portRESET_PRIVILEGE()		vResetPrivilege()
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
-{
-	__asm
-	{
-		/* Barrier instructions are not used as this function is only used to
-		lower the BASEPRI value. */
-		msr basepri, ulBASEPRI
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
-{
-	__asm
-	{
-		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
-		used to lower the mask in an interrupt, so memory barriers are not
-		used. */
-		msr basepri, #0
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		mrs ulReturn, basepri
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-	}
-
-	return ulReturn;
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm
-	{
-		mrs ulCurrentInterrupt, ipsr
-	}
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-#ifndef configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY
-	#warning "configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not defined. We recommend defining it to 1 in FreeRTOSConfig.h for better security. https://www.freertos.org/FreeRTOS-V10.3.x.html"
-	#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 0
-#endif
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM7/ReadMe.txt b/osal/src/freertos/portable/RVDS/ARM_CM7/ReadMe.txt
deleted file mode 100644
index 0a2e7fd..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM7/ReadMe.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-There are two options for running FreeRTOS on ARM Cortex-M7 microcontrollers.
-The best option depends on the revision of the ARM Cortex-M7 core in use.  The
-revision is specified by an 'r' number, and a 'p' number, so will look something
-like 'r0p1'.  Check the documentation for the microcontroller in use to find the 
-revision of the Cortex-M7 core used in that microcontroller.  If in doubt, use 
-the FreeRTOS port provided specifically for r0p1 revisions, as that can be used
-with all core revisions.
-
-The first option is to use the ARM Cortex-M4F port, and the second option is to
-use the Cortex-M7 r0p1 port - the latter containing a minor errata workaround.
-
-If the revision of the ARM Cortex-M7 core is not r0p1 then either option can be
-used, but it is recommended to use the FreeRTOS ARM Cortex-M4F port located in 
-the /FreeRTOS/Source/portable/RVDS/ARM_CM4F directory.
-
-If the revision of the ARM Cortex-M7 core is r0p1 then use the FreeRTOS ARM
-Cortex-M7 r0p1 port located in the /FreeRTOS/Source/portable/RVDS/ARM_CM7/r0p1
-directory.
\ No newline at end of file
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/port.c b/osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/port.c
deleted file mode 100644
index ae5e9cf..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/port.c
+++ /dev/null
@@ -1,774 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __TARGET_FPU_VFP
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#if configMAX_SYSCALL_INTERRUPT_PRIORITY == 0
-	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
-#endif
-
-#ifndef configSYSTICK_CLOCK_HZ
-	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
-	/* Ensure the SysTick is clocked at the same frequency as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
-#else
-	/* The way the SysTick is clocked is not modified in case it is not the same
-	as the core. */
-	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
-#endif
-
-/* The __weak attribute does not work as you might expect with the Keil tools
-so the configOVERRIDE_DEFAULT_TICK_CONFIGURATION constant must be set to 1 if
-the application writer wants to provide their own implementation of
-vPortSetupTimerInterrupt().  Ensure configOVERRIDE_DEFAULT_TICK_CONFIGURATION
-is defined. */
-#ifndef configOVERRIDE_DEFAULT_TICK_CONFIGURATION
-	#define configOVERRIDE_DEFAULT_TICK_CONFIGURATION 0
-#endif
-
-/* Constants required to manipulate the core.  Registers first... */
-#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
-/* ...then bits in the registers. */
-#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
-#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
-#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
-#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
-#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
-
-#define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK					( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR					( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS	( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR			( 0x01000000 )
-#define portINITIAL_EXC_RETURN		( 0xfffffffd )
-
-/* The systick is a 24-bit counter. */
-#define portMAX_24_BIT_NUMBER		( 0xffffffUL )
-
-/* A fiddle factor to estimate the number of SysTick counts that would have
-occurred while the SysTick counter is stopped during tickless idle
-calculations. */
-#define portMISSED_COUNTS_FACTOR	( 45UL )
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK		( ( StackType_t ) 0xfffffffeUL )
-
-/*
- * Setup the timer to generate the tick interrupts.  The implementation in this
- * file is weak to allow application writers to change the timer used to
- * generate the tick interrupt.
- */
-void vPortSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void xPortPendSVHandler( void );
-void xPortSysTickHandler( void );
-void vPortSVCHandler( void );
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvStartFirstTask( void );
-
-/*
- * Functions defined in portasm.s to enable the VFP.
- */
-static void prvEnableVFP( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/*-----------------------------------------------------------*/
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * The number of SysTick increments that make up one tick period.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulTimerCountsForOneTick = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * The maximum number of tick periods that can be suppressed is limited by the
- * 24 bit resolution of the SysTick timer.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t xMaximumPossibleSuppressedTicks = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Compensate for the CPU cycles that pass while the SysTick is stopped (low
- * power functionality only.
- */
-#if( configUSE_TICKLESS_IDLE == 1 )
-	static uint32_t ulStoppedTimerCompensation = 0;
-#endif /* configUSE_TICKLESS_IDLE */
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( uint8_t * ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( uxCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortSVCHandler( void )
-{
-	PRESERVE8
-
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	ldr r0, [r1]
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-	msr psp, r0
-	isb
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvStartFirstTask( void )
-{
-	PRESERVE8
-
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	before the scheduler was started - which would otherwise result in the
-	unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	registers. */
-	mov r0, #0
-	msr control, r0
-	/* Globally enable interrupts. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	/* Call SVC to start the first task. */
-	svc 0
-	nop
-	nop
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvEnableVFP( void )
-{
-	PRESERVE8
-
-	/* The FPU enable bits are in the CPACR. */
-	ldr.w r0, =0xE000ED88
-	ldr	r1, [r0]
-
-	/* Enable CP10 and CP11 coprocessors, then save back. */
-	orr	r1, r1, #( 0xf << 20 )
-	str r1, [r0]
-	bx	r14
-	nop
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		functions can be called.  ISR safe functions are those that end in
-		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		ensure interrupt entry is as fast and simple as possible.
-
-		Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* The kernel interrupt priority should be set to the lowest
-		priority. */
-		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			priority bits matches the number of priority bits actually queried
-			from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	vPortSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	prvEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	prvStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( uxCriticalNesting == 1 )
-	{
-		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm void xPortPendSVHandler( void )
-{
-	extern uxCriticalNesting;
-	extern pxCurrentTCB;
-	extern vTaskSwitchContext;
-
-	PRESERVE8
-
-	mrs r0, psp
-	isb
-	/* Get the location of the current TCB. */
-	ldr	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	/* Is the task using the FPU context?  If so, push high vfp registers. */
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	/* Save the core registers. */
-	stmdb r0!, {r4-r11, r14}
-
-	/* Save the new top of stack into the first member of the TCB. */
-	str r0, [r2]
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	cpsid i
-	msr basepri, r0
-	dsb
-	isb
-	cpsie i
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-
-	/* The first item in pxCurrentTCB is the task top of stack. */
-	ldr r1, [r3]
-	ldr r0, [r1]
-
-	/* Pop the core registers. */
-	ldmia r0!, {r4-r11, r14}
-
-	/* Is the task using the FPU context?  If so, pop the high vfp registers
-	too. */
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata */
-		#if WORKAROUND_PMU_CM001 == 1
-			push { r14 }
-			pop { pc }
-			nop
-		#endif
-	#endif
-
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
-	executes all interrupts must be unmasked.  There is therefore no need to
-	save and then restore the interrupt mask value as its value is already
-	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
-	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
-	vPortRaiseBASEPRI();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* A context switch is required.  Context switching is performed in
-			the PendSV interrupt.  Pend the PendSV interrupt. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	vPortClearBASEPRIFromISR();
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE == 1 )
-
-	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
-	{
-	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
-	TickType_t xModifiableIdleTime;
-
-		/* Make sure the SysTick reload value does not overflow the counter. */
-		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
-		{
-			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
-		}
-
-		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
-		is accounted for as best it can be, but using the tickless mode will
-		inevitably result in some tiny drift of the time maintained by the
-		kernel with respect to calendar time. */
-		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
-
-		/* Calculate the reload value required to wait xExpectedIdleTime
-		tick periods.  -1 is used because this code will execute part way
-		through one of the tick periods. */
-		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
-		if( ulReloadValue > ulStoppedTimerCompensation )
-		{
-			ulReloadValue -= ulStoppedTimerCompensation;
-		}
-
-		/* Enter a critical section but don't use the taskENTER_CRITICAL()
-		method as that will mask interrupts that should exit sleep mode. */
-		__disable_irq();
-		__dsb( portSY_FULL_READ_WRITE );
-		__isb( portSY_FULL_READ_WRITE );
-
-		/* If a context switch is pending or a task is waiting for the scheduler
-		to be unsuspended then abandon the low power entry. */
-		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
-		{
-			/* Restart from whatever is left in the count register to complete
-			this tick period. */
-			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Reset the reload register to the value required for normal tick
-			periods. */
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Re-enable interrupts - see comments above __disable_irq() call
-			above. */
-			__enable_irq();
-		}
-		else
-		{
-			/* Set the new reload value. */
-			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
-
-			/* Clear the SysTick count flag and set the count value back to
-			zero. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-			/* Restart SysTick. */
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-
-			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
-			set its parameter to 0 to indicate that its implementation contains
-			its own wait for interrupt or wait for event instruction, and so wfi
-			should not be executed again.  However, the original expected idle
-			time variable must remain unmodified, so a copy is taken. */
-			xModifiableIdleTime = xExpectedIdleTime;
-			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
-			if( xModifiableIdleTime > 0 )
-			{
-				__dsb( portSY_FULL_READ_WRITE );
-				__wfi();
-				__isb( portSY_FULL_READ_WRITE );
-			}
-			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
-
-			/* Re-enable interrupts to allow the interrupt that brought the MCU
-			out of sleep mode to execute immediately.  see comments above
-			__disable_interrupt() call above. */
-			__enable_irq();
-			__dsb( portSY_FULL_READ_WRITE );
-			__isb( portSY_FULL_READ_WRITE );
-
-			/* Disable interrupts again because the clock is about to be stopped
-			and interrupts that execute while the clock is stopped will increase
-			any slippage between the time maintained by the RTOS and calendar
-			time. */
-			__disable_irq();
-			__dsb( portSY_FULL_READ_WRITE );
-			__isb( portSY_FULL_READ_WRITE );
-
-			/* Disable the SysTick clock without reading the
-			portNVIC_SYSTICK_CTRL_REG register to ensure the
-			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
-			the time the SysTick is stopped for is accounted for as best it can
-			be, but using the tickless mode will inevitably result in some tiny
-			drift of the time maintained by the kernel with respect to calendar
-			time*/
-			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
-
-			/* Determine if the SysTick clock has already counted to zero and
-			been set back to the current reload value (the reload back being
-			correct for the entire expected idle time) or if the SysTick is yet
-			to count to zero (in which case an interrupt other than the SysTick
-			must have brought the system out of sleep mode). */
-			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
-			{
-				uint32_t ulCalculatedLoadValue;
-
-				/* The tick interrupt is already pending, and the SysTick count
-				reloaded with ulReloadValue.  Reset the
-				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
-				period. */
-				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
-
-				/* Don't allow a tiny value, or values that have somehow
-				underflowed because the post sleep hook did something
-				that took too long. */
-				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
-				{
-					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
-				}
-
-				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
-
-				/* As the pending tick will be processed as soon as this
-				function exits, the tick value maintained by the tick is stepped
-				forward by one less than the time spent waiting. */
-				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
-			}
-			else
-			{
-				/* Something other than the tick interrupt ended the sleep.
-				Work out how long the sleep lasted rounded to complete tick
-				periods (not the ulReload value which accounted for part
-				ticks). */
-				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
-
-				/* How many complete tick periods passed while the processor
-				was waiting? */
-				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
-
-				/* The reload value is set to whatever fraction of a single tick
-				period remains. */
-				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
-			}
-
-			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
-			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
-			value. */
-			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
-			vTaskStepTick( ulCompleteTickPeriods );
-			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
-
-			/* Exit with interrupts enabled. */
-			__enable_irq();
-		}
-	}
-
-#endif /* #if configUSE_TICKLESS_IDLE */
-
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the SysTick timer to generate the tick interrupts at the required
- * frequency.
- */
-#if( configOVERRIDE_DEFAULT_TICK_CONFIGURATION == 0 )
-
-	__weak void vPortSetupTimerInterrupt( void )
-	{
-		/* Calculate the constants required to configure the tick interrupt. */
-		#if( configUSE_TICKLESS_IDLE == 1 )
-		{
-			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
-			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
-			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
-		}
-		#endif /* configUSE_TICKLESS_IDLE */
-
-		/* Stop and clear the SysTick. */
-		portNVIC_SYSTICK_CTRL_REG = 0UL;
-		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-		/* Configure SysTick to interrupt at the requested rate. */
-		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
-	}
-
-#endif /* configOVERRIDE_DEFAULT_TICK_CONFIGURATION */
-/*-----------------------------------------------------------*/
-
-__asm uint32_t vPortGetIPSR( void )
-{
-	PRESERVE8
-
-	mrs r0, ipsr
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		ulCurrentInterrupt = vPortGetIPSR();
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			an interrupt that has been assigned a priority above
-			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			function.  ISR safe FreeRTOS API functions must *only* be called
-			from interrupts that have been assigned a priority at or below
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Numerically low interrupt priority numbers represent logically high
-			interrupt priorities, therefore the priority of the interrupt must
-			be set to a value equal to or numerically *higher* than
-			configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			Interrupts that	use the FreeRTOS API must not be left at their
-			default priority of	zero as that is the highest possible priority,
-			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			and	therefore also guaranteed to be invalid.
-
-			FreeRTOS maintains separate thread and ISR API functions to ensure
-			interrupt entry is as fast and simple as possible.
-
-			The following links provide detailed information:
-			http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		that define each interrupt's priority to be split between bits that
-		define the interrupt's pre-emption priority bits and bits that define
-		the interrupt's sub-priority.  For simplicity all bits must be defined
-		to be pre-emption priority bits.  The following assertion will fail if
-		this is not the case (if some bits represent a sub-priority).
-
-		If the application only uses CMSIS libraries for interrupt
-		configuration then the correct setting can be achieved on all Cortex-M
-		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		scheduler.  Note however that some vendor specific peripheral libraries
-		assume a non-zero priority group setting, in which cases using a value
-		of zero will result in unpredictable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/portmacro.h b/osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/portmacro.h
deleted file mode 100644
index 3af1fbf..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM7/r0p1/portmacro.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-
-/* Constants used with memory barrier intrinsics. */
-#define portSY_FULL_READ_WRITE		( 15 )
-
-/*-----------------------------------------------------------*/
-
-/* Scheduler utilities. */
-#define portYIELD()																\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__dsb( portSY_FULL_READ_WRITE );											\
-	__isb( portSY_FULL_READ_WRITE );											\
-}
-/*-----------------------------------------------------------*/
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )	vPortSetBASEPRI( x )
-
-/*-----------------------------------------------------------*/
-
-/* Tickless idle/low power functionality. */
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
-#endif
-/*-----------------------------------------------------------*/
-
-/* Port specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
-
-#endif /* taskRECORD_READY_PRIORITY */
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE __inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE __forceinline
-#endif
-
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
-{
-	__asm
-	{
-		/* Barrier instructions are not used as this function is only used to
-		lower the BASEPRI value. */
-		msr basepri, ulBASEPRI
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		cpsid i
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-		cpsie i
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
-{
-	__asm
-	{
-		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
-		used to lower the mask in an interrupt, so memory barriers are not 
-		used. */
-		msr basepri, #0
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-		mrs ulReturn, basepri
-		cpsid i
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-		cpsie i
-	}
-
-	return ulReturn;
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm
-	{
-		mrs ulCurrentInterrupt, ipsr
-	}
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/ReadMe.txt b/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/ReadMe.txt
deleted file mode 100644
index 4e44c98..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/ReadMe.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-There are two options for running FreeRTOS on ARM Cortex-M7 microcontrollers.
-The best option depends on the revision of the ARM Cortex-M7 core in use.  The
-revision is specified by an 'r' number, and a 'p' number, so will look something
-like 'r0p1'.  Check the documentation for the microcontroller in use to find the 
-revision of the Cortex-M7 core used in that microcontroller.  If in doubt, use 
-the FreeRTOS port provided specifically for r0p1 revisions, as that can be used
-with all core revisions.
-
-The first option is to use the ARM Cortex-M4F port, and the second option is to
-use the Cortex-M7 r0p1 port - the latter containing a minor errata workaround.
-
-If the revision of the ARM Cortex-M7 core is not r0p1 then either option can be
-used, but it is recommended to use the FreeRTOS ARM Cortex-M4F port located in 
-the /FreeRTOS/Source/portable/RVDS/ARM_CM4F directory.
-
-If the revision of the ARM Cortex-M7 core is r0p1 then use the FreeRTOS ARM
-Cortex-M7 r0p1 port located in the /FreeRTOS/Source/portable/RVDS/ARM_CM7_MPU/r0p1
-directory.
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/port.c b/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/port.c
deleted file mode 100644
index bac42c4..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/port.c
+++ /dev/null
@@ -1,917 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Portion Copyright  2020 STMicroelectronics International N.V. All rights reserved.
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM7 port.
- *----------------------------------------------------------*/
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
- * all the API functions to use the MPU wrappers.  That should only be done when
- * task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-#ifndef __TARGET_FPU_VFP
-	#error This port can only be used when the project options are configured to enable hardware floating point support.
-#endif
-
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* Constants required to access and manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL_REG				( * ( ( volatile uint32_t * ) 0xe000e010 ) )
-#define portNVIC_SYSTICK_LOAD_REG				( * ( ( volatile uint32_t * ) 0xe000e014 ) )
-#define portNVIC_SYSTICK_CURRENT_VALUE_REG		( * ( ( volatile uint32_t * ) 0xe000e018 ) )
-#define portNVIC_SYSPRI2_REG					( *	( ( volatile uint32_t * ) 0xe000ed20 ) )
-#define portNVIC_SYSPRI1_REG					( * ( ( volatile uint32_t * ) 0xe000ed1c ) )
-#define portNVIC_SYS_CTRL_STATE_REG				( * ( ( volatile uint32_t * ) 0xe000ed24 ) )
-#define portNVIC_MEM_FAULT_ENABLE				( 1UL << 16UL )
-
-/* Constants required to access and manipulate the MPU. */
-#define portMPU_TYPE_REG						( * ( ( volatile uint32_t * ) 0xe000ed90 ) )
-#define portMPU_REGION_BASE_ADDRESS_REG			( * ( ( volatile uint32_t * ) 0xe000ed9C ) )
-#define portMPU_REGION_ATTRIBUTE_REG			( * ( ( volatile uint32_t * ) 0xe000edA0 ) )
-#define portMPU_CTRL_REG						( * ( ( volatile uint32_t * ) 0xe000ed94 ) )
-#define portEXPECTED_MPU_TYPE_VALUE				( 8UL << 8UL ) /* 8 regions, unified. */
-#define portMPU_ENABLE							( 0x01UL )
-#define portMPU_BACKGROUND_ENABLE				( 1UL << 2UL )
-#define portPRIVILEGED_EXECUTION_START_ADDRESS	( 0UL )
-#define portMPU_REGION_VALID					( 0x10UL )
-#define portMPU_REGION_ENABLE					( 0x01UL )
-#define portPERIPHERALS_START_ADDRESS			0x40000000UL
-#define portPERIPHERALS_END_ADDRESS				0x5FFFFFFFUL
-
-/* Constants required to access and manipulate the SysTick. */
-#define portNVIC_SYSTICK_CLK					( 0x00000004UL )
-#define portNVIC_SYSTICK_INT					( 0x00000002UL )
-#define portNVIC_SYSTICK_ENABLE					( 0x00000001UL )
-#define portNVIC_PENDSV_PRI						( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
-#define portNVIC_SYSTICK_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
-#define portNVIC_SVC_PRI						( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR								( ( volatile uint32_t * ) 0xe000ef34UL ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS				( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR						( 0x01000000UL )
-#define portINITIAL_EXC_RETURN					( 0xfffffffdUL )
-#define portINITIAL_CONTROL_IF_UNPRIVILEGED		( 0x03 )
-#define portINITIAL_CONTROL_IF_PRIVILEGED		( 0x02 )
-
-/* Constants required to check the validity of an interrupt priority. */
-#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
-#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
-#define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
-#define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
-#define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
-#define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
-#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
-#define portPRIGROUP_SHIFT					( 8UL )
-
-/* Offsets in the stack to the parameters when inside the SVC handler. */
-#define portOFFSET_TO_PC						( 6 )
-
-/* For strict compliance with the Cortex-M spec the task start address should
- * have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/* Each task maintains its own interrupt status in the critical nesting
- * variable.  Note this is not saved as part of the task context as context
- * switches can only occur when uxCriticalNesting is zero. */
-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
-
-/*
- * Setup the timer to generate the tick interrupts.
- */
-void vSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Configure a number of standard MPU regions that are used by all tasks.
- */
-static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Start first task is a separate function so it can be tested in isolation.
- */
-static void prvStartFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the smallest MPU region size that a given number of bytes will fit
- * into.  The region size is returned as the value that should be programmed
- * into the region attribute register for that region.
- */
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes ) PRIVILEGED_FUNCTION;
-
-/*
- * Standard FreeRTOS exception handlers.
- */
-void xPortPendSVHandler( void ) PRIVILEGED_FUNCTION;
-void xPortSysTickHandler( void ) PRIVILEGED_FUNCTION;
-void vPortSVCHandler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Starts the scheduler by restoring the context of the first task to run.
- */
-static void prvRestoreContextOfFirstTask( void ) PRIVILEGED_FUNCTION;
-
-/*
- * C portion of the SVC handler.  The SVC handler is split between an asm entry
- * and a C wrapper for simplicity of coding and maintenance.
- */
-void prvSVCHandler( uint32_t *pulRegisters ) __attribute__((used)) PRIVILEGED_FUNCTION;
-
-/*
- * Function to enable the VFP.
- */
-static void vPortEnableVFP( void );
-
-/*
- * Utility function.
- */
-static uint32_t prvPortGetIPSR( void );
-
-/*
- * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
- * FreeRTOS API functions are not called from interrupts that have been assigned
- * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
- */
-#if ( configASSERT_DEFINED == 1 )
-	 static uint8_t ucMaxSysCallPriority = 0;
-	 static uint32_t ulMaxPRIGROUPValue = 0;
-	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const uint8_t * ) portNVIC_IP_REGISTERS_OFFSET_16;
-#endif /* configASSERT_DEFINED */
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-BaseType_t xIsPrivileged( void );
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- *
- * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
- *  Bit[0] = 0 --> The processor is running privileged
- *  Bit[0] = 1 --> The processor is running unprivileged.
- */
-void vResetPrivilege( void );
-
-/**
- * @brief Calls the port specific code to raise the privilege.
- *
- * @return pdFALSE if privilege was raised, pdTRUE otherwise.
- */
-extern BaseType_t xPortRaisePrivilege( void );
-
-/**
- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific
- * code to reset the privilege, otherwise does nothing.
- */
-extern void vPortResetPrivilege( BaseType_t xRunningPrivileged );
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	 * interrupt. */
-	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = 0;	/* LR */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	 * own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	if( xRunPrivileged == pdTRUE )
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_PRIVILEGED;
-	}
-	else
-	{
-		*pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
-	}
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-void prvSVCHandler( uint32_t *pulParam )
-{
-uint8_t ucSVCNumber;
-uint32_t ulReg, ulPC;
-#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-	extern uint32_t __syscalls_flash_start__;
-	extern uint32_t __syscalls_flash_end__;
-#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-	/* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR. The first
-	 * argument (r0) is pulParam[ 0 ]. */
-	ulPC = pulParam[ portOFFSET_TO_PC ];
-	ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
-	switch( ucSVCNumber )
-	{
-		case portSVC_START_SCHEDULER	:	portNVIC_SYSPRI1_REG |= portNVIC_SVC_PRI;
-											prvRestoreContextOfFirstTask();
-											break;
-
-		case portSVC_YIELD				:	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-											/* Barriers are normally not required
-											 * but do ensure the code is completely
-											 * within the specified behaviour for the
-											 * architecture. */
-											__asm volatile( "dsb" );
-											__asm volatile( "isb" );
-
-											break;
-
-	#if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )
-		case portSVC_RAISE_PRIVILEGE	:	/* Only raise the privilege, if the
-											 * svc was raised from any of the
-											 * system calls. */
-											if( ( ulPC >= ( uint32_t ) __syscalls_flash_start__ ) &&
-												( ulPC <= ( uint32_t ) __syscalls_flash_end__ ) )
-											{
-												__asm
-												{
-													mrs ulReg, control	/* Obtain current control value. */
-													bic ulReg, #1		/* Set privilege bit. */
-													msr control, ulReg	/* Write back new control value. */
-												}
-											}
-											break;
-	#else
-		case portSVC_RAISE_PRIVILEGE	:	__asm
-											{
-												mrs ulReg, control	/* Obtain current control value. */
-												bic ulReg, #1		/* Set privilege bit. */
-												msr control, ulReg	/* Write back new control value. */
-											}
-											break;
-	#endif /* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) */
-
-		default							:	/* Unknown SVC call. */
-											break;
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortSVCHandler( void )
-{
-	extern prvSVCHandler
-
-	PRESERVE8
-
-	/* Assumes psp was in use. */
-	#ifndef USE_PROCESS_STACK	/* Code should not be required if a main() is using the process stack. */
-		tst lr, #4
-		ite eq
-		mrseq r0, msp
-		mrsne r0, psp
-	#else
-		mrs r0, psp
-	#endif
-		b prvSVCHandler
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvRestoreContextOfFirstTask( void )
-{
-	PRESERVE8
-
-	ldr r0, =0xE000ED08				/* Use the NVIC offset register to locate the stack. */
-	ldr r0, [r0]
-	ldr r0, [r0]
-	msr msp, r0						/* Set the msp back to the start of the stack. */
-	ldr	r3, =pxCurrentTCB			/* Restore the context. */
-	ldr r1, [r3]
-	ldr r0, [r1]					/* The first item in the TCB is the task top of stack. */
-	add r1, r1, #4					/* Move onto the second item in the TCB... */
-
-	dmb								/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1					/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]					/* Disable MPU. */
-
-	ldr r2, =0xe000ed9c				/* Region Base Address register. */
-	ldmia r1!, {r4-r11}				/* Read 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}				/* Write 4 sets of MPU registers. */
-
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1					/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]					/* Enable MPU. */
-	dsb								/* Force memory writes before continuing. */
-
-	ldmia r0!, {r3-r11, r14}		/* Pop the registers that are not automatically saved on exception entry. */
-	msr control, r3
-	msr psp, r0						/* Restore the task stack pointer. */
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-	nop
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See
-	 * http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
-
-	#if( configASSERT_DEFINED == 1 )
-	{
-		volatile uint32_t ulOriginalPriority;
-		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
-		volatile uint8_t ucMaxPriorityValue;
-
-		/* Determine the maximum priority from which ISR safe FreeRTOS API
-		 * functions can be called.  ISR safe functions are those that end in
-		 * "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
-		 * ensure interrupt entry is as fast and simple as possible.
-
-		 * Save the interrupt priority value that is about to be clobbered. */
-		ulOriginalPriority = *pucFirstUserPriorityRegister;
-
-		/* Determine the number of priority bits available.  First write to all
-		 * possible bits. */
-		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
-
-		/* Read the value back to see how many bits stuck. */
-		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
-
-		/* Use the same mask on the maximum system call priority. */
-		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
-
-		/* Calculate the maximum acceptable priority group value for the number
-		 * of bits read back. */
-		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
-		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
-		{
-			ulMaxPRIGROUPValue--;
-			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
-		}
-
-		#ifdef __NVIC_PRIO_BITS
-		{
-			/* Check the CMSIS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
-		}
-		#endif
-
-		#ifdef configPRIO_BITS
-		{
-			/* Check the FreeRTOS configuration that defines the number of
-			 * priority bits matches the number of priority bits actually queried
-			 * from the hardware. */
-			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
-		}
-		#endif
-
-		/* Shift the priority group value back to its position within the AIRCR
-		 * register. */
-		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
-		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
-
-		/* Restore the clobbered interrupt priority register to its original
-		 * value. */
-		*pucFirstUserPriorityRegister = ulOriginalPriority;
-	}
-	#endif /* conifgASSERT_DEFINED */
-
-	/* Make PendSV and SysTick the same priority as the kernel, and the SVC
-	 * handler higher priority so it can be used to exit a critical section (where
-	 * lower priorities are masked). */
-	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
-	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
-
-	/* Configure the regions in the MPU that are common to all tasks. */
-	prvSetupMPU();
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	 * here already. */
-	vSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	uxCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	prvStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-__asm void prvStartFirstTask( void )
-{
-	PRESERVE8
-
-	/* Use the NVIC offset register to locate the stack. */
-	ldr r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	/* Set the msp back to the start of the stack. */
-	msr msp, r0
-	/* Clear the bit that indicates the FPU is in use in case the FPU was used
-	 * before the scheduler was started - which would otherwise result in the
-	 * unnecessary leaving of space in the SVC stack for lazy saving of FPU
-	 * registers. */
-	mov r0, #0
-	msr control, r0
-	/* Globally enable interrupts. */
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc portSVC_START_SCHEDULER	/* System call to start first task. */
-	nop
-	nop
-}
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	 * Artificially force an assert. */
-	configASSERT( uxCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	portDISABLE_INTERRUPTS();
-	uxCriticalNesting++;
-
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-BaseType_t xRunningPrivileged = xPortRaisePrivilege();
-
-	configASSERT( uxCriticalNesting );
-	uxCriticalNesting--;
-	if( uxCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-	vPortResetPrivilege( xRunningPrivileged );
-}
-/*-----------------------------------------------------------*/
-
-__asm void xPortPendSVHandler( void )
-{
-	extern uxCriticalNesting;
-	extern pxCurrentTCB;
-	extern vTaskSwitchContext;
-
-	PRESERVE8
-
-	mrs r0, psp
-
-	ldr r3, =pxCurrentTCB			/* Get the location of the current TCB. */
-	ldr r2, [r3]
-
-	tst r14, #0x10					/* Is the task using the FPU context?  If so, push high vfp registers. */
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	mrs r1, control
-	stmdb r0!, {r1, r4-r11, r14}	/* Save the remaining registers. */
-	str r0, [r2]					/* Save the new top of stack into the first member of the TCB. */
-
-	stmdb sp!, {r0, r3}
-	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
-	msr basepri, r0
-	dsb
-	isb
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-									/* Restore the context. */
-	ldr r1, [r3]
-	ldr r0, [r1]					/* The first item in the TCB is the task top of stack. */
-	add r1, r1, #4					/* Move onto the second item in the TCB... */
-
-	dmb								/* Complete outstanding transfers before disabling MPU. */
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	bic r3, r3, #1					/* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. */
-	str r3, [r2]					/* Disable MPU. */
-
-	ldr r2, =0xe000ed9c				/* Region Base Address register. */
-	ldmia r1!, {r4-r11}				/* Read 4 sets of MPU registers. */
-	stmia r2!, {r4-r11}				/* Write 4 sets of MPU registers. */
-
-	ldr r2, =0xe000ed94				/* MPU_CTRL register. */
-	ldr r3, [r2]					/* Read the value of MPU_CTRL. */
-	orr r3, r3, #1					/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */
-	str r3, [r2]					/* Enable MPU. */
-	dsb								/* Force memory writes before continuing. */
-
-	ldmia r0!, {r3-r11, r14}		/* Pop the registers that are not automatically saved on exception entry. */
-	msr control, r3
-
-	tst r14, #0x10					/* Is the task using the FPU context?  If so, pop the high vfp registers too. */
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	bx r14
-	nop
-}
-/*-----------------------------------------------------------*/
-
-void xPortSysTickHandler( void )
-{
-uint32_t ulDummy;
-
-	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Increment the RTOS tick. */
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-__weak void vSetupTimerInterrupt( void )
-{
-	/* Reset the SysTick. */
-	portNVIC_SYSTICK_CTRL_REG = 0UL;
-	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
-
-	/* Configure SysTick to interrupt at the requested rate. */
-	portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortSwitchToUserMode( void )
-{
-	PRESERVE8
-
-	mrs r0, control
-	orr r0, #1
-	msr control, r0
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-__asm void vPortEnableVFP( void )
-{
-	PRESERVE8
-
-	ldr.w r0, =0xE000ED88		/* The FPU enable bits are in the CPACR. */
-	ldr r1, [r0]
-
-	orr r1, r1, #( 0xf << 20 )	/* Enable CP10 and CP11 coprocessors, then save back. */
-	str r1, [r0]
-	bx r14
-	nop
-	nop
-}
-/*-----------------------------------------------------------*/
-
-static void prvSetupMPU( void )
-{
-extern uint32_t __privileged_functions_end__;
-extern uint32_t __FLASH_segment_start__;
-extern uint32_t __FLASH_segment_end__;
-extern uint32_t __privileged_data_start__;
-extern uint32_t __privileged_data_end__;
-
-	/* Check the expected MPU is present. */
-	if( ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )  || ( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE << 1 ))
-	{
-		/* First setup the entire flash for unprivileged read only access. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portUNPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the first 16K for privileged only access (even though less
-		 * than 10K is actually being used).  This is where the kernel code is
-		 * placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_FLASH_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Setup the privileged data RAM region.  This is where the kernel data
-		 * is placed. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-											( portMPU_REGION_VALID ) |
-											( portPRIVILEGED_RAM_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-										( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-										prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-										( portMPU_REGION_ENABLE );
-
-		/* By default allow everything to access the general peripherals.  The
-		 * system peripherals and registers are protected. */
-		portMPU_REGION_BASE_ADDRESS_REG =	( portPERIPHERALS_START_ADDRESS ) |
-											( portMPU_REGION_VALID ) |
-											( portGENERAL_PERIPHERALS_REGION );
-
-		portMPU_REGION_ATTRIBUTE_REG =	( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
-										( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
-										( portMPU_REGION_ENABLE );
-
-		/* Enable the memory fault exception. */
-		portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
-
-		/* Enable the MPU with the background region configured. */
-		portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
-	}
-}
-/*-----------------------------------------------------------*/
-
-static uint32_t prvGetMPURegionSizeSetting( uint32_t ulActualSizeInBytes )
-{
-uint32_t ulRegionSize, ulReturnValue = 4;
-
-	/* 32 is the smallest region size, 31 is the largest valid value for
-	 * ulReturnValue. */
-	for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
-	{
-		if( ulActualSizeInBytes <= ulRegionSize )
-		{
-			break;
-		}
-		else
-		{
-			ulReturnValue++;
-		}
-	}
-
-	/* Shift the code by one before returning so it can be written directly
-	 * into the the correct bit position of the attribute register. */
-	return ( ulReturnValue << 1UL );
-}
-/*-----------------------------------------------------------*/
-
-__asm BaseType_t xIsPrivileged( void )
-{
-	PRESERVE8
-
-	mrs r0, control		/* r0 = CONTROL. */
-	tst r0, #1			/* Perform r0 & 1 (bitwise AND) and update the conditions flag. */
-	ite ne
-	movne r0, #0		/* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. */
-	moveq r0, #1		/* CONTROL[0]==0. Return true to indicate that the processor is privileged. */
-	bx lr				/* Return. */
-}
-/*-----------------------------------------------------------*/
-
-__asm void vResetPrivilege( void )
-{
-	PRESERVE8
-
-	mrs r0, control		/* r0 = CONTROL. */
-	orrs r0, #1			/* r0 = r0 | 1. */
-	msr control, r0		/* CONTROL = r0. */
-	bx lr				/* Return. */
-}
-/*-----------------------------------------------------------*/
-
-void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth )
-{
-extern uint32_t __SRAM_segment_start__;
-extern uint32_t __SRAM_segment_end__;
-extern uint32_t __privileged_data_start__;
-extern uint32_t __privileged_data_end__;
-
-
-int32_t lIndex;
-uint32_t ul;
-
-	if( xRegions == NULL )
-	{
-		/* No MPU regions are specified so allow access to all RAM. */
-		xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-				( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION );
-
-		xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-				( portMPU_REGION_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Re-instate the privileged only RAM region as xRegion[ 0 ] will have
-		 * just removed the privileged only parameters. */
-		xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
-				( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
-				( portMPU_REGION_VALID ) |
-				( portSTACK_REGION + 1 );
-
-		xMPUSettings->xRegion[ 1 ].ulRegionAttribute =
-				( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
-				( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-				prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
-				( portMPU_REGION_ENABLE );
-
-		/* Invalidate all other regions. */
-		for( ul = 2; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-			xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-		}
-	}
-	else
-	{
-		/* This function is called automatically when the task is created - in
-		 * which case the stack region parameters will be valid.  At all other
-		 * times the stack parameters will not be valid and it is assumed that the
-		 * stack region has already been configured. */
-		if( ulStackDepth > 0 )
-		{
-			/* Define the region that allows access to the stack. */
-			xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
-					( ( uint32_t ) pxBottomOfStack ) |
-					( portMPU_REGION_VALID ) |
-					( portSTACK_REGION ); /* Region number. */
-
-			xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
-					( portMPU_REGION_READ_WRITE ) | /* Read and write. */
-					( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
-					( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
-					( portMPU_REGION_ENABLE );
-		}
-
-		lIndex = 0;
-
-		for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
-		{
-			if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
-			{
-				/* Translate the generic region definition contained in
-				 * xRegions into the CM3 specific MPU settings that are then
-				 * stored in xMPUSettings. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
-						( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) |
-						( portMPU_REGION_VALID ) |
-						( portSTACK_REGION + ul ); /* Region number. */
-
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute =
-						( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
-						( xRegions[ lIndex ].ulParameters ) |
-						( portMPU_REGION_ENABLE );
-			}
-			else
-			{
-				/* Invalidate the region. */
-				xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
-				xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
-			}
-
-			lIndex++;
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-__asm uint32_t prvPortGetIPSR( void )
-{
-	PRESERVE8
-
-	mrs r0, ipsr
-	bx r14
-}
-/*-----------------------------------------------------------*/
-
-#if( configASSERT_DEFINED == 1 )
-
-	void vPortValidateInterruptPriority( void )
-	{
-	uint32_t ulCurrentInterrupt;
-	uint8_t ucCurrentPriority;
-
-		/* Obtain the number of the currently executing interrupt. */
-		ulCurrentInterrupt = prvPortGetIPSR();
-
-		/* Is the interrupt number a user defined interrupt? */
-		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
-		{
-			/* Look up the interrupt's priority. */
-			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
-
-			/* The following assertion will fail if a service routine (ISR) for
-			 * an interrupt that has been assigned a priority above
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
-			 * function.  ISR safe FreeRTOS API functions must *only* be called
-			 * from interrupts that have been assigned a priority at or below
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Numerically low interrupt priority numbers represent logically high
-			 * interrupt priorities, therefore the priority of the interrupt must
-			 * be set to a value equal to or numerically *higher* than
-			 * configMAX_SYSCALL_INTERRUPT_PRIORITY.
-
-			 * Interrupts that	use the FreeRTOS API must not be left at their
-			 * default priority of	zero as that is the highest possible priority,
-			 * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
-			 * and	therefore also guaranteed to be invalid.
-
-			 * FreeRTOS maintains separate thread and ISR API functions to ensure
-			 * interrupt entry is as fast and simple as possible.
-
-			 * The following links provide detailed information:
-			 * http://www.freertos.org/RTOS-Cortex-M3-M4.html
-			 * http://www.freertos.org/FAQHelp.html */
-			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
-		}
-
-		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
-		 * that define each interrupt's priority to be split between bits that
-		 * define the interrupt's pre-emption priority bits and bits that define
-		 * the interrupt's sub-priority.  For simplicity all bits must be defined
-		 * to be pre-emption priority bits.  The following assertion will fail if
-		 * this is not the case (if some bits represent a sub-priority).
-
-		 * If the application only uses CMSIS libraries for interrupt
-		 * configuration then the correct setting can be achieved on all Cortex-M
-		 * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
-		 * scheduler.  Note however that some vendor specific peripheral libraries
-		 * assume a non-zero priority group setting, in which cases using a value
-		 * of zero will result in unpredicable behaviour. */
-		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
-	}
-
-#endif /* configASSERT_DEFINED */
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/portmacro.h b/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/portmacro.h
deleted file mode 100644
index e7f6c64..0000000
--- a/osal/src/freertos/portable/RVDS/ARM_CM7_MPU/r0p1/portmacro.h
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Portion Copyright  2020 STMicroelectronics International N.V. All rights reserved.
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* MPU specific constants. */
-#define portUSING_MPU_WRAPPERS		1
-#define portPRIVILEGE_BIT			( 0x80000000UL )
-
-#define portMPU_REGION_READ_WRITE								( 0x03UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_ONLY						( 0x05UL << 24UL )
-#define portMPU_REGION_READ_ONLY								( 0x06UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE					( 0x01UL << 24UL )
-#define portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY	( 0x02UL << 24UL )
-#define portMPU_REGION_CACHEABLE_BUFFERABLE						( 0x03UL << 16UL )
-#define portMPU_REGION_EXECUTE_NEVER							( 0x01UL << 28UL )
-
-#define portUNPRIVILEGED_FLASH_REGION		( 0UL )
-#define portPRIVILEGED_FLASH_REGION			( 1UL )
-#define portPRIVILEGED_RAM_REGION			( 2UL )
-#define portGENERAL_PERIPHERALS_REGION		( 3UL )
-#define portSTACK_REGION					( 4UL )
-#define portFIRST_CONFIGURABLE_REGION		( 5UL )
-#define portLAST_CONFIGURABLE_REGION		( 7UL )
-#define portNUM_CONFIGURABLE_REGIONS		( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )
-#define portTOTAL_NUM_REGIONS				( portNUM_CONFIGURABLE_REGIONS + 1 ) /* Plus one to make space for the stack region. */
-
-void vPortSwitchToUserMode( void );
-#define portSWITCH_TO_USER_MODE()	vPortSwitchToUserMode()
-
-typedef struct MPU_REGION_REGISTERS
-{
-	uint32_t ulRegionBaseAddress;
-	uint32_t ulRegionAttribute;
-} xMPU_REGION_REGISTERS;
-
-/* Plus 1 to create space for the stack region. */
-typedef struct MPU_SETTINGS
-{
-	xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS ];
-} xMPU_SETTINGS;
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-
-/* Constants used with memory barrier intrinsics. */
-#define portSY_FULL_READ_WRITE		( 15 )
-
-/*-----------------------------------------------------------*/
-
-/* SVC numbers for various services. */
-#define portSVC_START_SCHEDULER				0
-#define portSVC_YIELD						1
-#define portSVC_RAISE_PRIVILEGE				2
-
-/* Scheduler utilities. */
-
-#define portYIELD()				__asm{ SVC portSVC_YIELD }
-#define portYIELD_WITHIN_API() 													\
-{																				\
-	/* Set a PendSV to request a context switch. */								\
-	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
-																				\
-	/* Barriers are normally not required but do ensure the code is completely	\
-	within the specified behaviour for the architecture. */						\
-	__dsb( portSY_FULL_READ_WRITE );											\
-	__isb( portSY_FULL_READ_WRITE );											\
-}
-/*-----------------------------------------------------------*/
-
-#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
-#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-/* Critical section management. */
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
-#define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
-#define portENTER_CRITICAL()					vPortEnterCritical()
-#define portEXIT_CRITICAL()						vPortExitCritical()
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
-
-/*-----------------------------------------------------------*/
-
-/* Architecture specific optimisations. */
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site.  These are
-not necessary for to use this port.  They are defined so the common demo files
-(which build with all the ports) will build. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-/*-----------------------------------------------------------*/
-
-#ifdef configASSERT
-	void vPortValidateInterruptPriority( void );
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
-#endif
-
-/* portNOP() is not required by this port. */
-#define portNOP()
-
-#define portINLINE __inline
-
-#ifndef portFORCE_INLINE
-	#define portFORCE_INLINE __forceinline
-#endif
-/*-----------------------------------------------------------*/
-
-extern BaseType_t xIsPrivileged( void );
-extern void vResetPrivilege( void );
-
-/**
- * @brief Checks whether or not the processor is privileged.
- *
- * @return 1 if the processor is already privileged, 0 otherwise.
- */
-#define portIS_PRIVILEGED()			xIsPrivileged()
-
-/**
- * @brief Raise an SVC request to raise privilege.
- */
-#define portRAISE_PRIVILEGE()		__asm { svc portSVC_RAISE_PRIVILEGE }
-
-/**
- * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
- * register.
- */
-#define portRESET_PRIVILEGE()		vResetPrivilege()
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
-{
-	__asm
-	{
-		/* Barrier instructions are not used as this function is only used to
-		lower the BASEPRI value. */
-		msr basepri, ulBASEPRI
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortRaiseBASEPRI( void )
-{
-uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-    cpsid i
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-    cpsie i
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
-{
-	__asm
-	{
-		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
-		used to lower the mask in an interrupt, so memory barriers are not
-		used. */
-		msr basepri, #0
-	}
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
-{
-uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-	__asm
-	{
-		/* Set BASEPRI to the max syscall priority to effect a critical
-		section. */
-    cpsid i
-		mrs ulReturn, basepri
-		msr basepri, ulNewBASEPRI
-		dsb
-		isb
-    cpsie i
-	}
-
-	return ulReturn;
-}
-/*-----------------------------------------------------------*/
-
-static portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
-{
-uint32_t ulCurrentInterrupt;
-BaseType_t xReturn;
-
-	/* Obtain the number of the currently executing interrupt. */
-	__asm
-	{
-		mrs ulCurrentInterrupt, ipsr
-	}
-
-	if( ulCurrentInterrupt == 0 )
-	{
-		xReturn = pdFALSE;
-	}
-	else
-	{
-		xReturn = pdTRUE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-#ifndef configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY
-	#warning "configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not defined. We recommend defining it to 1 in FreeRTOSConfig.h for better security. https://www.freertos.org/FreeRTOS-V10.3.x.html"
-	#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 0
-#endif
-/*-----------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/Tasking/ARM_CM4F/port.c b/osal/src/freertos/portable/Tasking/ARM_CM4F/port.c
deleted file mode 100644
index 340058d..0000000
--- a/osal/src/freertos/portable/Tasking/ARM_CM4F/port.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Implementation of functions defined in portable.h for the ARM CM4F port.
- *----------------------------------------------------------*/
-
-/* Scheduler includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-
-/* Constants required to manipulate the NVIC. */
-#define portNVIC_SYSTICK_CTRL		( ( volatile uint32_t * ) 0xe000e010 )
-#define portNVIC_SYSTICK_LOAD		( ( volatile uint32_t * ) 0xe000e014 )
-#define portNVIC_SYSPRI2			( ( volatile uint32_t * ) 0xe000ed20 )
-#define portNVIC_SYSTICK_CLK		0x00000004
-#define portNVIC_SYSTICK_INT		0x00000002
-#define portNVIC_SYSTICK_ENABLE		0x00000001
-#define portNVIC_PENDSV_PRI			( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16 )
-#define portNVIC_SYSTICK_PRI		( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24 )
-
-/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
-#define portVECTACTIVE_MASK			( 0xFFUL )
-
-/* Constants required to manipulate the VFP. */
-#define portFPCCR					( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control register. */
-#define portASPEN_AND_LSPEN_BITS	( 0x3UL << 30UL )
-
-/* Constants required to set up the initial stack. */
-#define portINITIAL_XPSR			( 0x01000000 )
-#define portINITIAL_EXC_RETURN		( 0xfffffffd )
-
-/* Let the user override the pre-loading of the initial LR with the address of
-prvTaskExitError() in case it messes up unwinding of the stack in the
-debugger. */
-#ifdef configTASK_RETURN_ADDRESS
-	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
-#else
-	#define portTASK_RETURN_ADDRESS	prvTaskExitError
-#endif
-
-/* For strict compliance with the Cortex-M spec the task start address should
-have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
-#define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
-
-/* The priority used by the kernel is assigned to a variable to make access
-from inline assembler easier. */
-const uint32_t ulKernelPriority = configKERNEL_INTERRUPT_PRIORITY;
-
-/* Each task maintains its own interrupt status in the critical nesting
-variable. */
-static uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
-
-/*
- * Setup the timer to generate the tick interrupts.
- */
-static void prvSetupTimerInterrupt( void );
-
-/*
- * Exception handlers.
- */
-void SysTick_Handler( void );
-
-/*
- * Functions defined in port_asm.asm.
- */
-extern void vPortEnableVFP( void );
-extern void vPortStartFirstTask( void );
-
-/*
- * Used to catch tasks that attempt to return from their implementing function.
- */
-static void prvTaskExitError( void );
-
-/* This exists purely to allow the const to be used from within the
-port_asm.asm assembly file. */
-const uint32_t ulMaxSyscallInterruptPriorityConst = configMAX_SYSCALL_INTERRUPT_PRIORITY;
-
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
-{
-	/* Simulate the stack frame as it would be created by a context switch
-	interrupt. */
-
-	/* Offset added to account for the way the MCU uses the stack on entry/exit
-	of interrupts, and to ensure alignment. */
-	pxTopOfStack--;
-
-	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
-	pxTopOfStack--;
-	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
-	pxTopOfStack--;
-	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
-
-	/* Save code space by skipping register initialisation. */
-	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
-	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
-
-	/* A save method is being used that requires each task to maintain its
-	own exec return value. */
-	pxTopOfStack--;
-	*pxTopOfStack = portINITIAL_EXC_RETURN;
-
-	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
-
-	return pxTopOfStack;
-}
-/*-----------------------------------------------------------*/
-
-static void prvTaskExitError( void )
-{
-	/* A function that implements a task must not exit or attempt to return to
-	its caller as there is nothing to return to.  If a task wants to exit it
-	should instead call vTaskDelete( NULL ).
-
-	Artificially force an assert() to be triggered if configASSERT() is
-	defined, then stop here so application writers can catch the error. */
-	configASSERT( ulCriticalNesting == ~0UL );
-	portDISABLE_INTERRUPTS();
-	for( ;; );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * See header file for description.
- */
-BaseType_t xPortStartScheduler( void )
-{
-	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
-	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
-	configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
-
-	/* Make PendSV and SysTick the lowest priority interrupts. */
-	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
-	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
-
-	/* Start the timer that generates the tick ISR.  Interrupts are disabled
-	here already. */
-	prvSetupTimerInterrupt();
-
-	/* Initialise the critical nesting count ready for the first task. */
-	ulCriticalNesting = 0;
-
-	/* Ensure the VFP is enabled - it should be anyway. */
-	vPortEnableVFP();
-
-	/* Lazy save always. */
-	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
-
-	/* Start the first task. */
-	vPortStartFirstTask();
-
-	/* Should not get here! */
-	return 0;
-}
-/*-----------------------------------------------------------*/
-
-void vPortEndScheduler( void )
-{
-	/* Not implemented in ports where there is nothing to return to.
-	Artificially force an assert. */
-	configASSERT( ulCriticalNesting == 1000UL );
-}
-/*-----------------------------------------------------------*/
-
-void vPortYield( void )
-{
-	/* Set a PendSV to request a context switch. */
-	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
-
-	/* Barriers are normally not required but do ensure the code is completely
-	within the specified behaviour for the architecture. */
-	__DSB();
-	__ISB();
-}
-/*-----------------------------------------------------------*/
-
-void vPortEnterCritical( void )
-{
-	portDISABLE_INTERRUPTS();
-	ulCriticalNesting++;
-	__DSB();
-	__ISB();
-
-	/* This is not the interrupt safe version of the enter critical function so
-	assert() if it is being called from an interrupt context.  Only API
-	functions that end in "FromISR" can be used in an interrupt.  Only assert if
-	the critical nesting count is 1 to protect against recursive calls if the
-	assert function also uses a critical section. */
-	if( ulCriticalNesting == 1 )
-	{
-		configASSERT( ( ( *(portNVIC_INT_CTRL) ) & portVECTACTIVE_MASK ) == 0 );
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vPortExitCritical( void )
-{
-	configASSERT( ulCriticalNesting );
-	ulCriticalNesting--;
-	if( ulCriticalNesting == 0 )
-	{
-		portENABLE_INTERRUPTS();
-	}
-}
-/*-----------------------------------------------------------*/
-
-void SysTick_Handler( void )
-{
-uint32_t ulDummy;
-
-	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		if( xTaskIncrementTick() != pdFALSE )
-		{
-			/* Pend a context switch. */
-			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
-}
-/*-----------------------------------------------------------*/
-
-/*
- * Setup the systick timer to generate the tick interrupts at the required
- * frequency.
- */
-void prvSetupTimerInterrupt( void )
-{
-	/* Configure SysTick to interrupt at the requested rate. */
-	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
-	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
-}
-/*-----------------------------------------------------------*/
-
diff --git a/osal/src/freertos/portable/Tasking/ARM_CM4F/port_asm.asm b/osal/src/freertos/portable/Tasking/ARM_CM4F/port_asm.asm
deleted file mode 100644
index 5cdd731..0000000
--- a/osal/src/freertos/portable/Tasking/ARM_CM4F/port_asm.asm
+++ /dev/null
@@ -1,236 +0,0 @@
-;/*
-; * FreeRTOS Kernel V10.3.1
-; * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
-; *
-; * Permission is hereby granted, free of charge, to any person obtaining a copy of
-; * this software and associated documentation files (the "Software"), to deal in
-; * the Software without restriction, including without limitation the rights to
-; * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-; * the Software, and to permit persons to whom the Software is furnished to do so,
-; * subject to the following conditions:
-; *
-; * The above copyright notice and this permission notice shall be included in all
-; * copies or substantial portions of the Software.
-; *
-; * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-; * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-; * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-; * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-; * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-; *
-; * http://www.FreeRTOS.org
-; * http://aws.amazon.com/freertos
-; *
-; * 1 tab == 4 spaces!
-; */
-
-
-	.extern pxCurrentTCB
-	.extern vTaskSwitchContext
-	.extern ulMaxSyscallInterruptPriorityConst
-
-	.global _vector_14
-	.global _lc_ref__vector_pp_14
-	.global SVC_Handler
-	.global vPortStartFirstTask
-	.global vPortEnableVFP
-	.global ulPortSetInterruptMask
-	.global vPortClearInterruptMask
-
-;-----------------------------------------------------------
-
-	.section .text
-	.thumb
-	.align 4
-_vector_14: .type func
-
-	mrs r0, psp
-	isb
-
-	;Get the location of the current TCB.
-	ldr.w	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	;Is the task using the FPU context?  If so, push high vfp registers.
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	;Save the core registers.
-	stmdb r0!, {r4-r11, r14}
-
-	;Save the new top of stack into the first member of the TCB.
-	str r0, [r2]
-
-	stmdb sp!, {r0, r3}
-	ldr.w r0, =ulMaxSyscallInterruptPriorityConst
-	ldr r0, [r0]
-	msr basepri, r0
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r0, r3}
-
-	;The first item in pxCurrentTCB is the task top of stack.
-	ldr r1, [r3]
-	ldr r0, [r1]
-
-	;Pop the core registers.
-	ldmia r0!, {r4-r11, r14}
-
-	;Is the task using the FPU context?  If so, pop the high vfp registers too.
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-	bx r14
-
-	.size	_vector_14, $-_vector_14
-	.endsec
-
-;-----------------------------------------------------------
-
-; This function is an XMC4000 silicon errata workaround.  It will get used when
-; the SILICON_BUG_PMC_CM_001 linker macro is defined.
-	.section .text
-	.thumb
-	.align 4
-_lc_ref__vector_pp_14: .type func
-
-	mrs r0, psp
-	isb
-
-	;Get the location of the current TCB.
-	ldr.w	r3, =pxCurrentTCB
-	ldr	r2, [r3]
-
-	;Is the task using the FPU context?  If so, push high vfp registers.
-	tst r14, #0x10
-	it eq
-	vstmdbeq r0!, {s16-s31}
-
-	;Save the core registers.
-	stmdb r0!, {r4-r11, r14}
-
-	;Save the new top of stack into the first member of the TCB.
-	str r0, [r2]
-
-	stmdb sp!, {r3}
-	ldr.w r0, =ulMaxSyscallInterruptPriorityConst
-	ldr r0, [r0]
-	msr basepri, r0
-	bl vTaskSwitchContext
-	mov r0, #0
-	msr basepri, r0
-	ldmia sp!, {r3}
-
-	;The first item in pxCurrentTCB is the task top of stack.
-	ldr r1, [r3]
-	ldr r0, [r1]
-
-	;Pop the core registers.
-	ldmia r0!, {r4-r11, r14}
-
-	;Is the task using the FPU context?  If so, pop the high vfp registers too.
-	tst r14, #0x10
-	it eq
-	vldmiaeq r0!, {s16-s31}
-
-	msr psp, r0
-	isb
-	push { lr }
-	pop { pc } ; XMC4000 specific errata workaround.  Do not used "bx lr" here.
-
-	.size	_lc_ref__vector_pp_14, $-_lc_ref__vector_pp_14
-	.endsec
-
-;-----------------------------------------------------------
-
-	.section .text
-	.thumb
-	.align 4
-SVC_Handler: .type func
-	;Get the location of the current TCB.
-	ldr.w	r3, =pxCurrentTCB
-	ldr r1, [r3]
-	ldr r0, [r1]
-	;Pop the core registers.
-	ldmia r0!, {r4-r11, r14}
-	msr psp, r0
-	isb
-	mov r0, #0
-	msr	basepri, r0
-	bx r14
-	.size	SVC_Handler, $-SVC_Handler
-	.endsec
-
-;-----------------------------------------------------------
-
-	.section .text
-	.thumb
-	.align 4
-vPortStartFirstTask .type func
-	;Use the NVIC offset register to locate the stack.
-	ldr.w r0, =0xE000ED08
-	ldr r0, [r0]
-	ldr r0, [r0]
-	;Set the msp back to the start of the stack.
-	msr msp, r0
-	;Call SVC to start the first task.
-	cpsie i
-	cpsie f
-	dsb
-	isb
-	svc 0
-	.size	vPortStartFirstTask, $-vPortStartFirstTask
-	.endsec
-
-;-----------------------------------------------------------
-
-	.section .text
-	.thumb
-	.align 4
-vPortEnableVFP .type func
-	;The FPU enable bits are in the CPACR.
-	ldr.w r0, =0xE000ED88
-	ldr	r1, [r0]
-
-	;Enable CP10 and CP11 coprocessors, then save back.
-	orr	r1, r1, #( 0xf << 20 )
-	str r1, [r0]
-	bx	r14
-	.size	vPortEnableVFP, $-vPortEnableVFP
-	.endsec
-
-;-----------------------------------------------------------
-
-	.section .text
-	.thumb
-	.align 4
-ulPortSetInterruptMask:
-	mrs r0, basepri
-	ldr.w r1, =ulMaxSyscallInterruptPriorityConst
-	ldr r1, [r1]
-	msr basepri, r1
-	bx r14
-	.size	ulPortSetInterruptMask, $-ulPortSetInterruptMask
-	.endsec
-
-;-----------------------------------------------------------
-
-	.section .text
-	.thumb
-	.align 4
-vPortClearInterruptMask:
-	msr basepri, r0
-	bx r14
-	.size	vPortClearInterruptMask, $-vPortClearInterruptMask
-	.endsec
-
-;-----------------------------------------------------------
-
-	.end
-
diff --git a/osal/src/freertos/portable/Tasking/ARM_CM4F/portmacro.h b/osal/src/freertos/portable/Tasking/ARM_CM4F/portmacro.h
deleted file mode 100644
index 5f3de47..0000000
--- a/osal/src/freertos/portable/Tasking/ARM_CM4F/portmacro.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef PORTMACRO_H
-#define PORTMACRO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR		char
-#define portFLOAT		float
-#define portDOUBLE		double
-#define portLONG		long
-#define portSHORT		short
-#define portSTACK_TYPE	uint32_t
-#define portBASE_TYPE	long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	typedef uint16_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffff
-#else
-	typedef uint32_t TickType_t;
-	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-/*-----------------------------------------------------------*/
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH			( -1 )
-#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
-#define portBYTE_ALIGNMENT			8
-/*-----------------------------------------------------------*/
-
-
-/* Scheduler utilities. */
-extern void vPortYield( void );
-#define portNVIC_INT_CTRL			( ( volatile uint32_t * ) 0xe000ed04 )
-#define portNVIC_PENDSVSET			0x10000000
-#define portYIELD()					vPortYield()
-
-#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) *(portNVIC_INT_CTRL) = portNVIC_PENDSVSET
-#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
-/*-----------------------------------------------------------*/
-
-
-/* Critical section management. */
-
-/*
- * Set basepri to portMAX_SYSCALL_INTERRUPT_PRIORITY without effecting other
- * registers.  r0 is clobbered.
- */
-#define portSET_INTERRUPT_MASK() __set_BASEPRI( configMAX_SYSCALL_INTERRUPT_PRIORITY )
-
-/*
- * Set basepri back to 0 without effective other registers.
- * r0 is clobbered.  FAQ:  Setting BASEPRI to 0 is not a bug.  Please see
- * http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html before disagreeing.
- */
-#define portCLEAR_INTERRUPT_MASK() __set_BASEPRI( 0 )
-
-extern uint32_t ulPortSetInterruptMask( void );
-extern void vPortClearInterruptMask( uint32_t ulNewMask );
-#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortSetInterruptMask()
-#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortClearInterruptMask( x )
-
-
-extern void vPortEnterCritical( void );
-extern void vPortExitCritical( void );
-
-#define portDISABLE_INTERRUPTS()	portSET_INTERRUPT_MASK()
-#define portENABLE_INTERRUPTS()		portCLEAR_INTERRUPT_MASK()
-#define portENTER_CRITICAL()		vPortEnterCritical()
-#define portEXIT_CRITICAL()			vPortExitCritical()
-
-/*-----------------------------------------------------------*/
-
-/* Task function macros as described on the FreeRTOS.org WEB site. */
-#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
-#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
-
-#define portNOP()
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTMACRO_H */
-
diff --git a/osal/src/freertos/portable/readme.txt b/osal/src/freertos/portable/readme.txt
deleted file mode 100644
index b68d2d5..0000000
--- a/osal/src/freertos/portable/readme.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-Each real time kernel port consists of three files that contain the core kernel
-components and are common to every port, and one or more files that are
-specific to a particular microcontroller and/or compiler.
-
-
-+ The FreeRTOS/Source/Portable/MemMang directory contains the five sample
-memory allocators as described on the http://www.FreeRTOS.org WEB site.
-
-+ The other directories each contain files specific to a particular
-microcontroller or compiler, where the directory name denotes the compiler
-specific files the directory contains.
-
-
-
-For example, if you are interested in the [compiler] port for the [architecture]
-microcontroller, then the port specific files are contained in
-FreeRTOS/Source/Portable/[compiler]/[architecture] directory.  If this is the
-only port you are interested in then all the other directories can be
-ignored.
-
diff --git a/osal/src/freertos/queue.c b/osal/src/freertos/queue.c
deleted file mode 100644
index b3203b8..0000000
--- a/osal/src/freertos/queue.c
+++ /dev/null
@@ -1,2945 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#include <stdlib.h>
-#include <string.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#include "FreeRTOS.h"
-#include "task.h"
-#include "queue.h"
-
-#if ( configUSE_CO_ROUTINES == 1 )
-	#include "croutine.h"
-#endif
-
-/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
-because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
-for the header files above, but not in this file, in order to generate the
-correct privileged Vs unprivileged linkage and placement. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
-
-
-/* Constants used with the cRxLock and cTxLock structure members. */
-#define queueUNLOCKED					( ( int8_t ) -1 )
-#define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
-
-/* When the Queue_t structure is used to represent a base queue its pcHead and
-pcTail members are used as pointers into the queue storage area.  When the
-Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
-not necessary, and the pcHead pointer is set to NULL to indicate that the
-structure instead holds a pointer to the mutex holder (if any).  Map alternative
-names to the pcHead and structure member to ensure the readability of the code
-is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
-a union as their usage is mutually exclusive dependent on what the queue is
-being used for. */
-#define uxQueueType						pcHead
-#define queueQUEUE_IS_MUTEX				NULL
-
-typedef struct QueuePointers
-{
-	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
-	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
-} QueuePointers_t;
-
-typedef struct SemaphoreData
-{
-	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
-	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
-} SemaphoreData_t;
-
-/* Semaphores do not actually store or copy data, so have an item size of
-zero. */
-#define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
-#define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
-
-#if( configUSE_PREEMPTION == 0 )
-	/* If the cooperative scheduler is being used then a yield should not be
-	performed just because a higher priority task has been woken. */
-	#define queueYIELD_IF_USING_PREEMPTION()
-#else
-	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
-#endif
-
-/*
- * Definition of the queue used by the scheduler.
- * Items are queued by copy, not reference.  See the following link for the
- * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
- */
-typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aware debuggers. */
-{
-	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
-	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
-
-	union
-	{
-		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
-		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */
-	} u;
-
-	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
-	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
-
-	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
-	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
-	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
-
-	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
-	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
-
-	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
-	#endif
-
-	#if ( configUSE_QUEUE_SETS == 1 )
-		struct QueueDefinition *pxQueueSetContainer;
-	#endif
-
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxQueueNumber;
-		uint8_t ucQueueType;
-	#endif
-
-} xQUEUE;
-
-/* The old xQUEUE name is maintained above then typedefed to the new Queue_t
-name below to enable the use of older kernel aware debuggers. */
-typedef xQUEUE Queue_t;
-
-/*-----------------------------------------------------------*/
-
-/*
- * The queue registry is just a means for kernel aware debuggers to locate
- * queue structures.  It has no other purpose so is an optional component.
- */
-#if ( configQUEUE_REGISTRY_SIZE > 0 )
-
-	/* The type stored within the queue registry array.  This allows a name
-	to be assigned to each queue making kernel aware debugging a little
-	more user friendly. */
-	typedef struct QUEUE_REGISTRY_ITEM
-	{
-		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-		QueueHandle_t xHandle;
-	} xQueueRegistryItem;
-
-	/* The old xQueueRegistryItem name is maintained above then typedefed to the
-	new xQueueRegistryItem name below to enable the use of older kernel aware
-	debuggers. */
-	typedef xQueueRegistryItem QueueRegistryItem_t;
-
-	/* The queue registry is simply an array of QueueRegistryItem_t structures.
-	The pcQueueName member of a structure being NULL is indicative of the
-	array position being vacant. */
-	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
-
-#endif /* configQUEUE_REGISTRY_SIZE */
-
-/*
- * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
- * prevent an ISR from adding or removing items to the queue, but does prevent
- * an ISR from removing tasks from the queue event lists.  If an ISR finds a
- * queue is locked it will instead increment the appropriate queue lock count
- * to indicate that a task may require unblocking.  When the queue in unlocked
- * these lock counts are inspected, and the appropriate action taken.
- */
-static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
-
-/*
- * Uses a critical section to determine if there is any data in a queue.
- *
- * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
- */
-static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
-
-/*
- * Uses a critical section to determine if there is any space in a queue.
- *
- * @return pdTRUE if there is no space, otherwise pdFALSE;
- */
-static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
-
-/*
- * Copies an item into the queue, either at the front of the queue or the
- * back of the queue.
- */
-static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
-
-/*
- * Copies an item out of a queue.
- */
-static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
-
-#if ( configUSE_QUEUE_SETS == 1 )
-	/*
-	 * Checks to see if a queue is a member of a queue set, and if so, notifies
-	 * the queue set that the queue contains data.
-	 */
-	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
-#endif
-
-/*
- * Called after a Queue_t structure has been allocated either statically or
- * dynamically to fill in the structure's members.
- */
-static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
-
-/*
- * Mutexes are a special type of queue.  When a mutex is created, first the
- * queue is created, then prvInitialiseMutex() is called to configure the queue
- * as a mutex.
- */
-#if( configUSE_MUTEXES == 1 )
-	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
-#endif
-
-#if( configUSE_MUTEXES == 1 )
-	/*
-	 * If a task waiting for a mutex causes the mutex holder to inherit a
-	 * priority, but the waiting task times out, then the holder should
-	 * disinherit the priority - but only down to the highest priority of any
-	 * other tasks that are waiting for the same mutex.  This function returns
-	 * that priority.
-	 */
-	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
-#endif
-/*-----------------------------------------------------------*/
-
-/*
- * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
- * accessing the queue event lists.
- */
-#define prvLockQueue( pxQueue )								\
-	taskENTER_CRITICAL();									\
-	{														\
-		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
-		{													\
-			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
-		}													\
-		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
-		{													\
-			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
-		}													\
-	}														\
-	taskEXIT_CRITICAL()
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
-{
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-
-	taskENTER_CRITICAL();
-	{
-		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
-		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
-		pxQueue->pcWriteTo = pxQueue->pcHead;
-		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
-		pxQueue->cRxLock = queueUNLOCKED;
-		pxQueue->cTxLock = queueUNLOCKED;
-
-		if( xNewQueue == pdFALSE )
-		{
-			/* If there are tasks blocked waiting to read from the queue, then
-			the tasks will remain blocked as after this function exits the queue
-			will still be empty.  If there are tasks blocked waiting to write to
-			the queue, then one should be unblocked as after this function exits
-			it will be possible to write to it. */
-			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
-			{
-				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
-				{
-					queueYIELD_IF_USING_PREEMPTION();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			/* Ensure the event queues start in the correct state. */
-			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
-			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	/* A value is returned for calling semantic consistency with previous
-	versions. */
-	return pdPASS;
-}
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
-	{
-	Queue_t *pxNewQueue;
-
-		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
-
-		/* The StaticQueue_t structure and the queue storage area must be
-		supplied. */
-		configASSERT( pxStaticQueue != NULL );
-
-		/* A queue storage area should be provided if the item size is not 0, and
-		should not be provided if the item size is 0. */
-		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
-		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
-
-		#if( configASSERT_DEFINED == 1 )
-		{
-			/* Sanity check that the size of the structure used to declare a
-			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
-			the real queue and semaphore structures. */
-			volatile size_t xSize = sizeof( StaticQueue_t );
-			configASSERT( xSize == sizeof( Queue_t ) );
-			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
-		}
-		#endif /* configASSERT_DEFINED */
-
-		/* The address of a statically allocated queue was passed in, use it.
-		The address of a statically allocated storage area was also passed in
-		but is already set. */
-		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
-
-		if( pxNewQueue != NULL )
-		{
-			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-			{
-				/* Queues can be allocated wither statically or dynamically, so
-				note this queue was allocated statically in case the queue is
-				later deleted. */
-				pxNewQueue->ucStaticallyAllocated = pdTRUE;
-			}
-			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-
-			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
-		}
-		else
-		{
-			traceQUEUE_CREATE_FAILED( ucQueueType );
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return pxNewQueue;
-	}
-
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-
-	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
-	{
-	Queue_t *pxNewQueue;
-	size_t xQueueSizeInBytes;
-	uint8_t *pucQueueStorage;
-
-		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
-
-		/* Allocate enough space to hold the maximum number of items that
-		can be in the queue at any time.  It is valid for uxItemSize to be
-		zero in the case the queue is used as a semaphore. */
-		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-
-		/* Allocate the queue and storage area.  Justification for MISRA
-		deviation as follows:  pvPortMalloc() always ensures returned memory
-		blocks are aligned per the requirements of the MCU stack.  In this case
-		pvPortMalloc() must return a pointer that is guaranteed to meet the
-		alignment requirements of the Queue_t structure - which in this case
-		is an int8_t *.  Therefore, whenever the stack alignment requirements
-		are greater than or equal to the pointer to char requirements the cast
-		is safe.  In other cases alignment requirements are not strict (one or
-		two bytes). */
-		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
-
-		if( pxNewQueue != NULL )
-		{
-			/* Jump past the queue structure to find the location of the queue
-			storage area. */
-			pucQueueStorage = ( uint8_t * ) pxNewQueue;
-			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
-
-			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-			{
-				/* Queues can be created either statically or dynamically, so
-				note this task was created dynamically in case it is later
-				deleted. */
-				pxNewQueue->ucStaticallyAllocated = pdFALSE;
-			}
-			#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
-		}
-		else
-		{
-			traceQUEUE_CREATE_FAILED( ucQueueType );
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return pxNewQueue;
-	}
-
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
-{
-	/* Remove compiler warnings about unused parameters should
-	configUSE_TRACE_FACILITY not be set to 1. */
-	( void ) ucQueueType;
-
-	if( uxItemSize == ( UBaseType_t ) 0 )
-	{
-		/* No RAM was allocated for the queue storage area, but PC head cannot
-		be set to NULL because NULL is used as a key to say the queue is used as
-		a mutex.  Therefore just set pcHead to point to the queue as a benign
-		value that is known to be within the memory map. */
-		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
-	}
-	else
-	{
-		/* Set the head to the start of the queue storage area. */
-		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
-	}
-
-	/* Initialise the queue members as described where the queue type is
-	defined. */
-	pxNewQueue->uxLength = uxQueueLength;
-	pxNewQueue->uxItemSize = uxItemSize;
-	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
-
-	#if ( configUSE_TRACE_FACILITY == 1 )
-	{
-		pxNewQueue->ucQueueType = ucQueueType;
-	}
-	#endif /* configUSE_TRACE_FACILITY */
-
-	#if( configUSE_QUEUE_SETS == 1 )
-	{
-		pxNewQueue->pxQueueSetContainer = NULL;
-	}
-	#endif /* configUSE_QUEUE_SETS */
-
-	traceQUEUE_CREATE( pxNewQueue );
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_MUTEXES == 1 )
-
-	static void prvInitialiseMutex( Queue_t *pxNewQueue )
-	{
-		if( pxNewQueue != NULL )
-		{
-			/* The queue create function will set all the queue structure members
-			correctly for a generic queue, but this function is creating a
-			mutex.  Overwrite those members that need to be set differently -
-			in particular the information required for priority inheritance. */
-			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
-			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
-
-			/* In case this is a recursive mutex. */
-			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
-
-			traceCREATE_MUTEX( pxNewQueue );
-
-			/* Start with the semaphore in the expected state. */
-			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
-		}
-		else
-		{
-			traceCREATE_MUTEX_FAILED();
-		}
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-
-	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
-	{
-	QueueHandle_t xNewQueue;
-	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
-
-		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
-		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
-
-		return xNewQueue;
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-
-	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
-	{
-	QueueHandle_t xNewQueue;
-	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
-
-		/* Prevent compiler warnings about unused parameters if
-		configUSE_TRACE_FACILITY does not equal 1. */
-		( void ) ucQueueType;
-
-		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
-		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
-
-		return xNewQueue;
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
-
-	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
-	{
-	TaskHandle_t pxReturn;
-	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
-
-		/* This function is called by xSemaphoreGetMutexHolder(), and should not
-		be called directly.  Note:  This is a good way of determining if the
-		calling task is the mutex holder, but not a good way of determining the
-		identity of the mutex holder, as the holder may change between the
-		following critical section exiting and the function returning. */
-		taskENTER_CRITICAL();
-		{
-			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
-			{
-				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
-			}
-			else
-			{
-				pxReturn = NULL;
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		return pxReturn;
-	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
-
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
-
-	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
-	{
-	TaskHandle_t pxReturn;
-
-		configASSERT( xSemaphore );
-
-		/* Mutexes cannot be used in interrupt service routines, so the mutex
-		holder should not change in an ISR, and therefore a critical section is
-		not required here. */
-		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
-		{
-			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
-		}
-		else
-		{
-			pxReturn = NULL;
-		}
-
-		return pxReturn;
-	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
-
-#endif
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_RECURSIVE_MUTEXES == 1 )
-
-	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
-	{
-	BaseType_t xReturn;
-	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
-
-		configASSERT( pxMutex );
-
-		/* If this is the task that holds the mutex then xMutexHolder will not
-		change outside of this task.  If this task does not hold the mutex then
-		pxMutexHolder can never coincidentally equal the tasks handle, and as
-		this is the only condition we are interested in it does not matter if
-		pxMutexHolder is accessed simultaneously by another task.  Therefore no
-		mutual exclusion is required to test the pxMutexHolder variable. */
-		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
-		{
-			traceGIVE_MUTEX_RECURSIVE( pxMutex );
-
-			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
-			the task handle, therefore no underflow check is required.  Also,
-			uxRecursiveCallCount is only modified by the mutex holder, and as
-			there can only be one, no mutual exclusion is required to modify the
-			uxRecursiveCallCount member. */
-			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
-
-			/* Has the recursive call count unwound to 0? */
-			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
-			{
-				/* Return the mutex.  This will automatically unblock any other
-				task that might be waiting to access the mutex. */
-				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			xReturn = pdPASS;
-		}
-		else
-		{
-			/* The mutex cannot be given because the calling task is not the
-			holder. */
-			xReturn = pdFAIL;
-
-			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_RECURSIVE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_RECURSIVE_MUTEXES == 1 )
-
-	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
-	{
-	BaseType_t xReturn;
-	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
-
-		configASSERT( pxMutex );
-
-		/* Comments regarding mutual exclusion as per those within
-		xQueueGiveMutexRecursive(). */
-
-		traceTAKE_MUTEX_RECURSIVE( pxMutex );
-
-		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
-		{
-			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
-			xReturn = pdPASS;
-		}
-		else
-		{
-			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
-
-			/* pdPASS will only be returned if the mutex was successfully
-			obtained.  The calling task may have entered the Blocked state
-			before reaching here. */
-			if( xReturn != pdFAIL )
-			{
-				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
-			}
-			else
-			{
-				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
-			}
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_RECURSIVE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-
-	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
-	{
-	QueueHandle_t xHandle;
-
-		configASSERT( uxMaxCount != 0 );
-		configASSERT( uxInitialCount <= uxMaxCount );
-
-		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
-
-		if( xHandle != NULL )
-		{
-			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
-
-			traceCREATE_COUNTING_SEMAPHORE();
-		}
-		else
-		{
-			traceCREATE_COUNTING_SEMAPHORE_FAILED();
-		}
-
-		return xHandle;
-	}
-
-#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-
-	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
-	{
-	QueueHandle_t xHandle;
-
-		configASSERT( uxMaxCount != 0 );
-		configASSERT( uxInitialCount <= uxMaxCount );
-
-		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
-
-		if( xHandle != NULL )
-		{
-			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
-
-			traceCREATE_COUNTING_SEMAPHORE();
-		}
-		else
-		{
-			traceCREATE_COUNTING_SEMAPHORE_FAILED();
-		}
-
-		return xHandle;
-	}
-
-#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
-{
-BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
-TimeOut_t xTimeOut;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
-	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
-	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
-	{
-		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
-	}
-	#endif
-
-
-	/*lint -save -e904 This function relaxes the coding standard somewhat to
-	allow return statements within the function itself.  This is done in the
-	interest of execution time efficiency. */
-	for( ;; )
-	{
-		taskENTER_CRITICAL();
-		{
-			/* Is there room on the queue now?  The running task must be the
-			highest priority task wanting to access the queue.  If the head item
-			in the queue is to be overwritten then it does not matter if the
-			queue is full. */
-			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
-			{
-				traceQUEUE_SEND( pxQueue );
-
-				#if ( configUSE_QUEUE_SETS == 1 )
-				{
-				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
-
-					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
-
-					if( pxQueue->pxQueueSetContainer != NULL )
-					{
-						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
-						{
-							/* Do not notify the queue set as an existing item
-							was overwritten in the queue so the number of items
-							in the queue has not changed. */
-							mtCOVERAGE_TEST_MARKER();
-						}
-						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
-						{
-							/* The queue is a member of a queue set, and posting
-							to the queue set caused a higher priority task to
-							unblock. A context switch is required. */
-							queueYIELD_IF_USING_PREEMPTION();
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						/* If there was a task waiting for data to arrive on the
-						queue then unblock it now. */
-						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-						{
-							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-							{
-								/* The unblocked task has a priority higher than
-								our own so yield immediately.  Yes it is ok to
-								do this from within the critical section - the
-								kernel takes care of that. */
-								queueYIELD_IF_USING_PREEMPTION();
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-						}
-						else if( xYieldRequired != pdFALSE )
-						{
-							/* This path is a special case that will only get
-							executed if the task was holding multiple mutexes
-							and the mutexes were given back in an order that is
-							different to that in which they were taken. */
-							queueYIELD_IF_USING_PREEMPTION();
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-				}
-				#else /* configUSE_QUEUE_SETS */
-				{
-					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
-
-					/* If there was a task waiting for data to arrive on the
-					queue then unblock it now. */
-					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-					{
-						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-						{
-							/* The unblocked task has a priority higher than
-							our own so yield immediately.  Yes it is ok to do
-							this from within the critical section - the kernel
-							takes care of that. */
-							queueYIELD_IF_USING_PREEMPTION();
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else if( xYieldRequired != pdFALSE )
-					{
-						/* This path is a special case that will only get
-						executed if the task was holding multiple mutexes and
-						the mutexes were given back in an order that is
-						different to that in which they were taken. */
-						queueYIELD_IF_USING_PREEMPTION();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				#endif /* configUSE_QUEUE_SETS */
-
-				taskEXIT_CRITICAL();
-				return pdPASS;
-			}
-			else
-			{
-				if( xTicksToWait == ( TickType_t ) 0 )
-				{
-					/* The queue was full and no block time is specified (or
-					the block time has expired) so leave now. */
-					taskEXIT_CRITICAL();
-
-					/* Return to the original privilege level before exiting
-					the function. */
-					traceQUEUE_SEND_FAILED( pxQueue );
-					return errQUEUE_FULL;
-				}
-				else if( xEntryTimeSet == pdFALSE )
-				{
-					/* The queue was full and a block time was specified so
-					configure the timeout structure. */
-					vTaskInternalSetTimeOutState( &xTimeOut );
-					xEntryTimeSet = pdTRUE;
-				}
-				else
-				{
-					/* Entry time was already set. */
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		/* Interrupts and other tasks can send to and receive from the queue
-		now the critical section has been exited. */
-
-		vTaskSuspendAll();
-		prvLockQueue( pxQueue );
-
-		/* Update the timeout state to see if it has expired yet. */
-		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
-		{
-			if( prvIsQueueFull( pxQueue ) != pdFALSE )
-			{
-				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
-				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
-
-				/* Unlocking the queue means queue events can effect the
-				event list.  It is possible that interrupts occurring now
-				remove this task from the event list again - but as the
-				scheduler is suspended the task will go onto the pending
-				ready last instead of the actual ready list. */
-				prvUnlockQueue( pxQueue );
-
-				/* Resuming the scheduler will move tasks from the pending
-				ready list into the ready list - so it is feasible that this
-				task is already in a ready list before it yields - in which
-				case the yield will not cause a context switch unless there
-				is also a higher priority task in the pending ready list. */
-				if( xTaskResumeAll() == pdFALSE )
-				{
-					portYIELD_WITHIN_API();
-				}
-			}
-			else
-			{
-				/* Try again. */
-				prvUnlockQueue( pxQueue );
-				( void ) xTaskResumeAll();
-			}
-		}
-		else
-		{
-			/* The timeout has expired. */
-			prvUnlockQueue( pxQueue );
-			( void ) xTaskResumeAll();
-
-			traceQUEUE_SEND_FAILED( pxQueue );
-			return errQUEUE_FULL;
-		}
-	} /*lint -restore */
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
-{
-BaseType_t xReturn;
-UBaseType_t uxSavedInterruptStatus;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
-	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
-
-	/* RTOS ports that support interrupt nesting have the concept of a maximum
-	system call (or maximum API call) interrupt priority.  Interrupts that are
-	above the maximum system call priority are kept permanently enabled, even
-	when the RTOS kernel is in a critical section, but cannot make any calls to
-	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
-	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-	failure if a FreeRTOS API function is called from an interrupt that has been
-	assigned a priority above the configured maximum system call priority.
-	Only FreeRTOS functions that end in FromISR can be called from interrupts
-	that have been assigned a priority at or (logically) below the maximum
-	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
-	safe API to ensure interrupt entry is as fast and as simple as possible.
-	More information (albeit Cortex-M specific) is provided on the following
-	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
-	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-	/* Similar to xQueueGenericSend, except without blocking if there is no room
-	in the queue.  Also don't directly wake a task that was blocked on a queue
-	read, instead return a flag to say whether a context switch is required or
-	not (i.e. has a task with a higher priority than us been woken by this
-	post). */
-	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
-		{
-			const int8_t cTxLock = pxQueue->cTxLock;
-			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
-
-			traceQUEUE_SEND_FROM_ISR( pxQueue );
-
-			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
-			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
-			in a task disinheriting a priority and prvCopyDataToQueue() can be
-			called here even though the disinherit function does not check if
-			the scheduler is suspended before accessing the ready lists. */
-			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
-
-			/* The event list is not altered if the queue is locked.  This will
-			be done when the queue is unlocked later. */
-			if( cTxLock == queueUNLOCKED )
-			{
-				#if ( configUSE_QUEUE_SETS == 1 )
-				{
-					if( pxQueue->pxQueueSetContainer != NULL )
-					{
-						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
-						{
-							/* Do not notify the queue set as an existing item
-							was overwritten in the queue so the number of items
-							in the queue has not changed. */
-							mtCOVERAGE_TEST_MARKER();
-						}
-						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
-						{
-							/* The queue is a member of a queue set, and posting
-							to the queue set caused a higher priority task to
-							unblock.  A context switch is required. */
-							if( pxHigherPriorityTaskWoken != NULL )
-							{
-								*pxHigherPriorityTaskWoken = pdTRUE;
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-						{
-							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-							{
-								/* The task waiting has a higher priority so
-								record that a context switch is required. */
-								if( pxHigherPriorityTaskWoken != NULL )
-								{
-									*pxHigherPriorityTaskWoken = pdTRUE;
-								}
-								else
-								{
-									mtCOVERAGE_TEST_MARKER();
-								}
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-				}
-				#else /* configUSE_QUEUE_SETS */
-				{
-					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-					{
-						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-						{
-							/* The task waiting has a higher priority so record that a
-							context	switch is required. */
-							if( pxHigherPriorityTaskWoken != NULL )
-							{
-								*pxHigherPriorityTaskWoken = pdTRUE;
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-					
-					/* Not used in this path. */
-					( void ) uxPreviousMessagesWaiting;
-				}
-				#endif /* configUSE_QUEUE_SETS */
-			}
-			else
-			{
-				/* Increment the lock count so the task that unlocks the queue
-				knows that data was posted while it was locked. */
-				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
-			}
-
-			xReturn = pdPASS;
-		}
-		else
-		{
-			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
-			xReturn = errQUEUE_FULL;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
-{
-BaseType_t xReturn;
-UBaseType_t uxSavedInterruptStatus;
-Queue_t * const pxQueue = xQueue;
-
-	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
-	item size is 0.  Don't directly wake a task that was blocked on a queue
-	read, instead return a flag to say whether a context switch is required or
-	not (i.e. has a task with a higher priority than us been woken by this
-	post). */
-
-	configASSERT( pxQueue );
-
-	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
-	if the item size is not 0. */
-	configASSERT( pxQueue->uxItemSize == 0 );
-
-	/* Normally a mutex would not be given from an interrupt, especially if
-	there is a mutex holder, as priority inheritance makes no sense for an
-	interrupts, only tasks. */
-	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
-
-	/* RTOS ports that support interrupt nesting have the concept of a maximum
-	system call (or maximum API call) interrupt priority.  Interrupts that are
-	above the maximum system call priority are kept permanently enabled, even
-	when the RTOS kernel is in a critical section, but cannot make any calls to
-	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
-	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-	failure if a FreeRTOS API function is called from an interrupt that has been
-	assigned a priority above the configured maximum system call priority.
-	Only FreeRTOS functions that end in FromISR can be called from interrupts
-	that have been assigned a priority at or (logically) below the maximum
-	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
-	safe API to ensure interrupt entry is as fast and as simple as possible.
-	More information (albeit Cortex-M specific) is provided on the following
-	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
-	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
-
-		/* When the queue is used to implement a semaphore no data is ever
-		moved through the queue but it is still valid to see if the queue 'has
-		space'. */
-		if( uxMessagesWaiting < pxQueue->uxLength )
-		{
-			const int8_t cTxLock = pxQueue->cTxLock;
-
-			traceQUEUE_SEND_FROM_ISR( pxQueue );
-
-			/* A task can only have an inherited priority if it is a mutex
-			holder - and if there is a mutex holder then the mutex cannot be
-			given from an ISR.  As this is the ISR version of the function it
-			can be assumed there is no mutex holder and no need to determine if
-			priority disinheritance is needed.  Simply increase the count of
-			messages (semaphores) available. */
-			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
-
-			/* The event list is not altered if the queue is locked.  This will
-			be done when the queue is unlocked later. */
-			if( cTxLock == queueUNLOCKED )
-			{
-				#if ( configUSE_QUEUE_SETS == 1 )
-				{
-					if( pxQueue->pxQueueSetContainer != NULL )
-					{
-						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
-						{
-							/* The semaphore is a member of a queue set, and
-							posting	to the queue set caused a higher priority
-							task to	unblock.  A context switch is required. */
-							if( pxHigherPriorityTaskWoken != NULL )
-							{
-								*pxHigherPriorityTaskWoken = pdTRUE;
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-						{
-							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-							{
-								/* The task waiting has a higher priority so
-								record that a context switch is required. */
-								if( pxHigherPriorityTaskWoken != NULL )
-								{
-									*pxHigherPriorityTaskWoken = pdTRUE;
-								}
-								else
-								{
-									mtCOVERAGE_TEST_MARKER();
-								}
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-				}
-				#else /* configUSE_QUEUE_SETS */
-				{
-					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-					{
-						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-						{
-							/* The task waiting has a higher priority so record that a
-							context	switch is required. */
-							if( pxHigherPriorityTaskWoken != NULL )
-							{
-								*pxHigherPriorityTaskWoken = pdTRUE;
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				#endif /* configUSE_QUEUE_SETS */
-			}
-			else
-			{
-				/* Increment the lock count so the task that unlocks the queue
-				knows that data was posted while it was locked. */
-				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
-			}
-
-			xReturn = pdPASS;
-		}
-		else
-		{
-			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
-			xReturn = errQUEUE_FULL;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
-{
-BaseType_t xEntryTimeSet = pdFALSE;
-TimeOut_t xTimeOut;
-Queue_t * const pxQueue = xQueue;
-
-	/* Check the pointer is not NULL. */
-	configASSERT( ( pxQueue ) );
-
-	/* The buffer into which data is received can only be NULL if the data size
-	is zero (so no data is copied into the buffer. */
-	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
-
-	/* Cannot block if the scheduler is suspended. */
-	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
-	{
-		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
-	}
-	#endif
-
-
-	/*lint -save -e904  This function relaxes the coding standard somewhat to
-	allow return statements within the function itself.  This is done in the
-	interest of execution time efficiency. */
-	for( ;; )
-	{
-		taskENTER_CRITICAL();
-		{
-			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
-
-			/* Is there data in the queue now?  To be running the calling task
-			must be the highest priority task wanting to access the queue. */
-			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
-			{
-				/* Data available, remove one item. */
-				prvCopyDataFromQueue( pxQueue, pvBuffer );
-				traceQUEUE_RECEIVE( pxQueue );
-				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
-
-				/* There is now space in the queue, were any tasks waiting to
-				post to the queue?  If so, unblock the highest priority waiting
-				task. */
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
-				{
-					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
-					{
-						queueYIELD_IF_USING_PREEMPTION();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				taskEXIT_CRITICAL();
-				return pdPASS;
-			}
-			else
-			{
-				if( xTicksToWait == ( TickType_t ) 0 )
-				{
-					/* The queue was empty and no block time is specified (or
-					the block time has expired) so leave now. */
-					taskEXIT_CRITICAL();
-					traceQUEUE_RECEIVE_FAILED( pxQueue );
-					return errQUEUE_EMPTY;
-				}
-				else if( xEntryTimeSet == pdFALSE )
-				{
-					/* The queue was empty and a block time was specified so
-					configure the timeout structure. */
-					vTaskInternalSetTimeOutState( &xTimeOut );
-					xEntryTimeSet = pdTRUE;
-				}
-				else
-				{
-					/* Entry time was already set. */
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		/* Interrupts and other tasks can send to and receive from the queue
-		now the critical section has been exited. */
-
-		vTaskSuspendAll();
-		prvLockQueue( pxQueue );
-
-		/* Update the timeout state to see if it has expired yet. */
-		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
-		{
-			/* The timeout has not expired.  If the queue is still empty place
-			the task on the list of tasks waiting to receive from the queue. */
-			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
-			{
-				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
-				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
-				prvUnlockQueue( pxQueue );
-				if( xTaskResumeAll() == pdFALSE )
-				{
-					portYIELD_WITHIN_API();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				/* The queue contains data again.  Loop back to try and read the
-				data. */
-				prvUnlockQueue( pxQueue );
-				( void ) xTaskResumeAll();
-			}
-		}
-		else
-		{
-			/* Timed out.  If there is no data in the queue exit, otherwise loop
-			back and attempt to read the data. */
-			prvUnlockQueue( pxQueue );
-			( void ) xTaskResumeAll();
-
-			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
-			{
-				traceQUEUE_RECEIVE_FAILED( pxQueue );
-				return errQUEUE_EMPTY;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-	} /*lint -restore */
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
-{
-BaseType_t xEntryTimeSet = pdFALSE;
-TimeOut_t xTimeOut;
-Queue_t * const pxQueue = xQueue;
-
-#if( configUSE_MUTEXES == 1 )
-	BaseType_t xInheritanceOccurred = pdFALSE;
-#endif
-
-	/* Check the queue pointer is not NULL. */
-	configASSERT( ( pxQueue ) );
-
-	/* Check this really is a semaphore, in which case the item size will be
-	0. */
-	configASSERT( pxQueue->uxItemSize == 0 );
-
-	/* Cannot block if the scheduler is suspended. */
-	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
-	{
-		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
-	}
-	#endif
-
-
-	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
-	statements within the function itself.  This is done in the interest
-	of execution time efficiency. */
-	for( ;; )
-	{
-		taskENTER_CRITICAL();
-		{
-			/* Semaphores are queues with an item size of 0, and where the
-			number of messages in the queue is the semaphore's count value. */
-			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
-
-			/* Is there data in the queue now?  To be running the calling task
-			must be the highest priority task wanting to access the queue. */
-			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
-			{
-				traceQUEUE_RECEIVE( pxQueue );
-
-				/* Semaphores are queues with a data size of zero and where the
-				messages waiting is the semaphore's count.  Reduce the count. */
-				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
-
-				#if ( configUSE_MUTEXES == 1 )
-				{
-					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
-					{
-						/* Record the information required to implement
-						priority inheritance should it become necessary. */
-						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				#endif /* configUSE_MUTEXES */
-
-				/* Check to see if other tasks are blocked waiting to give the
-				semaphore, and if so, unblock the highest priority such task. */
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
-				{
-					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
-					{
-						queueYIELD_IF_USING_PREEMPTION();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				taskEXIT_CRITICAL();
-				return pdPASS;
-			}
-			else
-			{
-				if( xTicksToWait == ( TickType_t ) 0 )
-				{
-					/* For inheritance to have occurred there must have been an
-					initial timeout, and an adjusted timeout cannot become 0, as
-					if it were 0 the function would have exited. */
-					#if( configUSE_MUTEXES == 1 )
-					{
-						configASSERT( xInheritanceOccurred == pdFALSE );
-					}
-					#endif /* configUSE_MUTEXES */
-
-					/* The semaphore count was 0 and no block time is specified
-					(or the block time has expired) so exit now. */
-					taskEXIT_CRITICAL();
-					traceQUEUE_RECEIVE_FAILED( pxQueue );
-					return errQUEUE_EMPTY;
-				}
-				else if( xEntryTimeSet == pdFALSE )
-				{
-					/* The semaphore count was 0 and a block time was specified
-					so configure the timeout structure ready to block. */
-					vTaskInternalSetTimeOutState( &xTimeOut );
-					xEntryTimeSet = pdTRUE;
-				}
-				else
-				{
-					/* Entry time was already set. */
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		/* Interrupts and other tasks can give to and take from the semaphore
-		now the critical section has been exited. */
-
-		vTaskSuspendAll();
-		prvLockQueue( pxQueue );
-
-		/* Update the timeout state to see if it has expired yet. */
-		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
-		{
-			/* A block time is specified and not expired.  If the semaphore
-			count is 0 then enter the Blocked state to wait for a semaphore to
-			become available.  As semaphores are implemented with queues the
-			queue being empty is equivalent to the semaphore count being 0. */
-			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
-			{
-				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
-
-				#if ( configUSE_MUTEXES == 1 )
-				{
-					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
-					{
-						taskENTER_CRITICAL();
-						{
-							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
-						}
-						taskEXIT_CRITICAL();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				#endif
-
-				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
-				prvUnlockQueue( pxQueue );
-				if( xTaskResumeAll() == pdFALSE )
-				{
-					portYIELD_WITHIN_API();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				/* There was no timeout and the semaphore count was not 0, so
-				attempt to take the semaphore again. */
-				prvUnlockQueue( pxQueue );
-				( void ) xTaskResumeAll();
-			}
-		}
-		else
-		{
-			/* Timed out. */
-			prvUnlockQueue( pxQueue );
-			( void ) xTaskResumeAll();
-
-			/* If the semaphore count is 0 exit now as the timeout has
-			expired.  Otherwise return to attempt to take the semaphore that is
-			known to be available.  As semaphores are implemented by queues the
-			queue being empty is equivalent to the semaphore count being 0. */
-			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
-			{
-				#if ( configUSE_MUTEXES == 1 )
-				{
-					/* xInheritanceOccurred could only have be set if
-					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
-					test the mutex type again to check it is actually a mutex. */
-					if( xInheritanceOccurred != pdFALSE )
-					{
-						taskENTER_CRITICAL();
-						{
-							UBaseType_t uxHighestWaitingPriority;
-
-							/* This task blocking on the mutex caused another
-							task to inherit this task's priority.  Now this task
-							has timed out the priority should be disinherited
-							again, but only as low as the next highest priority
-							task that is waiting for the same mutex. */
-							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
-							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
-						}
-						taskEXIT_CRITICAL();
-					}
-				}
-				#endif /* configUSE_MUTEXES */
-
-				traceQUEUE_RECEIVE_FAILED( pxQueue );
-				return errQUEUE_EMPTY;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-	} /*lint -restore */
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
-{
-BaseType_t xEntryTimeSet = pdFALSE;
-TimeOut_t xTimeOut;
-int8_t *pcOriginalReadPosition;
-Queue_t * const pxQueue = xQueue;
-
-	/* Check the pointer is not NULL. */
-	configASSERT( ( pxQueue ) );
-
-	/* The buffer into which data is received can only be NULL if the data size
-	is zero (so no data is copied into the buffer. */
-	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
-
-	/* Cannot block if the scheduler is suspended. */
-	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
-	{
-		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
-	}
-	#endif
-
-
-	/*lint -save -e904  This function relaxes the coding standard somewhat to
-	allow return statements within the function itself.  This is done in the
-	interest of execution time efficiency. */
-	for( ;; )
-	{
-		taskENTER_CRITICAL();
-		{
-			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
-
-			/* Is there data in the queue now?  To be running the calling task
-			must be the highest priority task wanting to access the queue. */
-			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
-			{
-				/* Remember the read position so it can be reset after the data
-				is read from the queue as this function is only peeking the
-				data, not removing it. */
-				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
-
-				prvCopyDataFromQueue( pxQueue, pvBuffer );
-				traceQUEUE_PEEK( pxQueue );
-
-				/* The data is not being removed, so reset the read pointer. */
-				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
-
-				/* The data is being left in the queue, so see if there are
-				any other tasks waiting for the data. */
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-				{
-					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-					{
-						/* The task waiting has a higher priority than this task. */
-						queueYIELD_IF_USING_PREEMPTION();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				taskEXIT_CRITICAL();
-				return pdPASS;
-			}
-			else
-			{
-				if( xTicksToWait == ( TickType_t ) 0 )
-				{
-					/* The queue was empty and no block time is specified (or
-					the block time has expired) so leave now. */
-					taskEXIT_CRITICAL();
-					traceQUEUE_PEEK_FAILED( pxQueue );
-					return errQUEUE_EMPTY;
-				}
-				else if( xEntryTimeSet == pdFALSE )
-				{
-					/* The queue was empty and a block time was specified so
-					configure the timeout structure ready to enter the blocked
-					state. */
-					vTaskInternalSetTimeOutState( &xTimeOut );
-					xEntryTimeSet = pdTRUE;
-				}
-				else
-				{
-					/* Entry time was already set. */
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		/* Interrupts and other tasks can send to and receive from the queue
-		now the critical section has been exited. */
-
-		vTaskSuspendAll();
-		prvLockQueue( pxQueue );
-
-		/* Update the timeout state to see if it has expired yet. */
-		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
-		{
-			/* Timeout has not expired yet, check to see if there is data in the
-			queue now, and if not enter the Blocked state to wait for data. */
-			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
-			{
-				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
-				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
-				prvUnlockQueue( pxQueue );
-				if( xTaskResumeAll() == pdFALSE )
-				{
-					portYIELD_WITHIN_API();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				/* There is data in the queue now, so don't enter the blocked
-				state, instead return to try and obtain the data. */
-				prvUnlockQueue( pxQueue );
-				( void ) xTaskResumeAll();
-			}
-		}
-		else
-		{
-			/* The timeout has expired.  If there is still no data in the queue
-			exit, otherwise go back and try to read the data again. */
-			prvUnlockQueue( pxQueue );
-			( void ) xTaskResumeAll();
-
-			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
-			{
-				traceQUEUE_PEEK_FAILED( pxQueue );
-				return errQUEUE_EMPTY;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-	} /*lint -restore */
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
-{
-BaseType_t xReturn;
-UBaseType_t uxSavedInterruptStatus;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
-
-	/* RTOS ports that support interrupt nesting have the concept of a maximum
-	system call (or maximum API call) interrupt priority.  Interrupts that are
-	above the maximum system call priority are kept permanently enabled, even
-	when the RTOS kernel is in a critical section, but cannot make any calls to
-	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
-	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-	failure if a FreeRTOS API function is called from an interrupt that has been
-	assigned a priority above the configured maximum system call priority.
-	Only FreeRTOS functions that end in FromISR can be called from interrupts
-	that have been assigned a priority at or (logically) below the maximum
-	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
-	safe API to ensure interrupt entry is as fast and as simple as possible.
-	More information (albeit Cortex-M specific) is provided on the following
-	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
-	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
-
-		/* Cannot block in an ISR, so check there is data available. */
-		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
-		{
-			const int8_t cRxLock = pxQueue->cRxLock;
-
-			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
-
-			prvCopyDataFromQueue( pxQueue, pvBuffer );
-			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
-
-			/* If the queue is locked the event list will not be modified.
-			Instead update the lock count so the task that unlocks the queue
-			will know that an ISR has removed data while the queue was
-			locked. */
-			if( cRxLock == queueUNLOCKED )
-			{
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
-				{
-					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
-					{
-						/* The task waiting has a higher priority than us so
-						force a context switch. */
-						if( pxHigherPriorityTaskWoken != NULL )
-						{
-							*pxHigherPriorityTaskWoken = pdTRUE;
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				/* Increment the lock count so the task that unlocks the queue
-				knows that data was removed while it was locked. */
-				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
-			}
-
-			xReturn = pdPASS;
-		}
-		else
-		{
-			xReturn = pdFAIL;
-			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
-{
-BaseType_t xReturn;
-UBaseType_t uxSavedInterruptStatus;
-int8_t *pcOriginalReadPosition;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
-	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
-
-	/* RTOS ports that support interrupt nesting have the concept of a maximum
-	system call (or maximum API call) interrupt priority.  Interrupts that are
-	above the maximum system call priority are kept permanently enabled, even
-	when the RTOS kernel is in a critical section, but cannot make any calls to
-	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
-	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-	failure if a FreeRTOS API function is called from an interrupt that has been
-	assigned a priority above the configured maximum system call priority.
-	Only FreeRTOS functions that end in FromISR can be called from interrupts
-	that have been assigned a priority at or (logically) below the maximum
-	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
-	safe API to ensure interrupt entry is as fast and as simple as possible.
-	More information (albeit Cortex-M specific) is provided on the following
-	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
-	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		/* Cannot block in an ISR, so check there is data available. */
-		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
-		{
-			traceQUEUE_PEEK_FROM_ISR( pxQueue );
-
-			/* Remember the read position so it can be reset as nothing is
-			actually being removed from the queue. */
-			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
-			prvCopyDataFromQueue( pxQueue, pvBuffer );
-			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
-
-			xReturn = pdPASS;
-		}
-		else
-		{
-			xReturn = pdFAIL;
-			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
-{
-UBaseType_t uxReturn;
-
-	configASSERT( xQueue );
-
-	taskENTER_CRITICAL();
-	{
-		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
-	}
-	taskEXIT_CRITICAL();
-
-	return uxReturn;
-} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
-/*-----------------------------------------------------------*/
-
-UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
-{
-UBaseType_t uxReturn;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-
-	taskENTER_CRITICAL();
-	{
-		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
-	}
-	taskEXIT_CRITICAL();
-
-	return uxReturn;
-} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
-/*-----------------------------------------------------------*/
-
-UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
-{
-UBaseType_t uxReturn;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	uxReturn = pxQueue->uxMessagesWaiting;
-
-	return uxReturn;
-} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
-/*-----------------------------------------------------------*/
-
-void vQueueDelete( QueueHandle_t xQueue )
-{
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	traceQUEUE_DELETE( pxQueue );
-
-	#if ( configQUEUE_REGISTRY_SIZE > 0 )
-	{
-		vQueueUnregisterQueue( pxQueue );
-	}
-	#endif
-
-	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
-	{
-		/* The queue can only have been allocated dynamically - free it
-		again. */
-		vPortFree( pxQueue );
-	}
-	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-	{
-		/* The queue could have been allocated statically or dynamically, so
-		check before attempting to free the memory. */
-		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
-		{
-			vPortFree( pxQueue );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#else
-	{
-		/* The queue must have been statically allocated, so is not going to be
-		deleted.  Avoid compiler warnings about the unused parameter. */
-		( void ) pxQueue;
-	}
-	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-}
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
-	{
-		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
-	{
-		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
-	{
-		return ( ( Queue_t * ) xQueue )->ucQueueType;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_MUTEXES == 1 )
-
-	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
-	{
-	UBaseType_t uxHighestPriorityOfWaitingTasks;
-
-		/* If a task waiting for a mutex causes the mutex holder to inherit a
-		priority, but the waiting task times out, then the holder should
-		disinherit the priority - but only down to the highest priority of any
-		other tasks that are waiting for the same mutex.  For this purpose,
-		return the priority of the highest priority task that is waiting for the
-		mutex. */
-		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
-		{
-			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
-		}
-		else
-		{
-			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
-		}
-
-		return uxHighestPriorityOfWaitingTasks;
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
-{
-BaseType_t xReturn = pdFALSE;
-UBaseType_t uxMessagesWaiting;
-
-	/* This function is called from a critical section. */
-
-	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
-
-	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
-	{
-		#if ( configUSE_MUTEXES == 1 )
-		{
-			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
-			{
-				/* The mutex is no longer being held. */
-				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
-				pxQueue->u.xSemaphore.xMutexHolder = NULL;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* configUSE_MUTEXES */
-	}
-	else if( xPosition == queueSEND_TO_BACK )
-	{
-		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
-		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
-		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
-		{
-			pxQueue->pcWriteTo = pxQueue->pcHead;
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
-		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
-		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
-		{
-			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		if( xPosition == queueOVERWRITE )
-		{
-			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
-			{
-				/* An item is not being added but overwritten, so subtract
-				one from the recorded number of items in the queue so when
-				one is added again below the number of recorded items remains
-				correct. */
-				--uxMessagesWaiting;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
-{
-	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
-	{
-		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
-		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
-		{
-			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvUnlockQueue( Queue_t * const pxQueue )
-{
-	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
-
-	/* The lock counts contains the number of extra data items placed or
-	removed from the queue while the queue was locked.  When a queue is
-	locked items can be added or removed, but the event lists cannot be
-	updated. */
-	taskENTER_CRITICAL();
-	{
-		int8_t cTxLock = pxQueue->cTxLock;
-
-		/* See if data was added to the queue while it was locked. */
-		while( cTxLock > queueLOCKED_UNMODIFIED )
-		{
-			/* Data was posted while the queue was locked.  Are any tasks
-			blocked waiting for data to become available? */
-			#if ( configUSE_QUEUE_SETS == 1 )
-			{
-				if( pxQueue->pxQueueSetContainer != NULL )
-				{
-					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
-					{
-						/* The queue is a member of a queue set, and posting to
-						the queue set caused a higher priority task to unblock.
-						A context switch is required. */
-						vTaskMissedYield();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					/* Tasks that are removed from the event list will get
-					added to the pending ready list as the scheduler is still
-					suspended. */
-					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-					{
-						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-						{
-							/* The task waiting has a higher priority so record that a
-							context	switch is required. */
-							vTaskMissedYield();
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						break;
-					}
-				}
-			}
-			#else /* configUSE_QUEUE_SETS */
-			{
-				/* Tasks that are removed from the event list will get added to
-				the pending ready list as the scheduler is still suspended. */
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-				{
-					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-					{
-						/* The task waiting has a higher priority so record that
-						a context switch is required. */
-						vTaskMissedYield();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					break;
-				}
-			}
-			#endif /* configUSE_QUEUE_SETS */
-
-			--cTxLock;
-		}
-
-		pxQueue->cTxLock = queueUNLOCKED;
-	}
-	taskEXIT_CRITICAL();
-
-	/* Do the same for the Rx lock. */
-	taskENTER_CRITICAL();
-	{
-		int8_t cRxLock = pxQueue->cRxLock;
-
-		while( cRxLock > queueLOCKED_UNMODIFIED )
-		{
-			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
-			{
-				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
-				{
-					vTaskMissedYield();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				--cRxLock;
-			}
-			else
-			{
-				break;
-			}
-		}
-
-		pxQueue->cRxLock = queueUNLOCKED;
-	}
-	taskEXIT_CRITICAL();
-}
-/*-----------------------------------------------------------*/
-
-static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
-{
-BaseType_t xReturn;
-
-	taskENTER_CRITICAL();
-	{
-		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
-		{
-			xReturn = pdTRUE;
-		}
-		else
-		{
-			xReturn = pdFALSE;
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
-{
-BaseType_t xReturn;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
-	{
-		xReturn = pdTRUE;
-	}
-	else
-	{
-		xReturn = pdFALSE;
-	}
-
-	return xReturn;
-} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
-/*-----------------------------------------------------------*/
-
-static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
-{
-BaseType_t xReturn;
-
-	taskENTER_CRITICAL();
-	{
-		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
-		{
-			xReturn = pdTRUE;
-		}
-		else
-		{
-			xReturn = pdFALSE;
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
-{
-BaseType_t xReturn;
-Queue_t * const pxQueue = xQueue;
-
-	configASSERT( pxQueue );
-	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
-	{
-		xReturn = pdTRUE;
-	}
-	else
-	{
-		xReturn = pdFALSE;
-	}
-
-	return xReturn;
-} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_CO_ROUTINES == 1 )
-
-	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
-	{
-	BaseType_t xReturn;
-	Queue_t * const pxQueue = xQueue;
-
-		/* If the queue is already full we may have to block.  A critical section
-		is required to prevent an interrupt removing something from the queue
-		between the check to see if the queue is full and blocking on the queue. */
-		portDISABLE_INTERRUPTS();
-		{
-			if( prvIsQueueFull( pxQueue ) != pdFALSE )
-			{
-				/* The queue is full - do we want to block or just leave without
-				posting? */
-				if( xTicksToWait > ( TickType_t ) 0 )
-				{
-					/* As this is called from a coroutine we cannot block directly, but
-					return indicating that we need to block. */
-					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
-					portENABLE_INTERRUPTS();
-					return errQUEUE_BLOCKED;
-				}
-				else
-				{
-					portENABLE_INTERRUPTS();
-					return errQUEUE_FULL;
-				}
-			}
-		}
-		portENABLE_INTERRUPTS();
-
-		portDISABLE_INTERRUPTS();
-		{
-			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
-			{
-				/* There is room in the queue, copy the data into the queue. */
-				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
-				xReturn = pdPASS;
-
-				/* Were any co-routines waiting for data to become available? */
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-				{
-					/* In this instance the co-routine could be placed directly
-					into the ready list as we are within a critical section.
-					Instead the same pending ready list mechanism is used as if
-					the event were caused from within an interrupt. */
-					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-					{
-						/* The co-routine waiting has a higher priority so record
-						that a yield might be appropriate. */
-						xReturn = errQUEUE_YIELD;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				xReturn = errQUEUE_FULL;
-			}
-		}
-		portENABLE_INTERRUPTS();
-
-		return xReturn;
-	}
-
-#endif /* configUSE_CO_ROUTINES */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_CO_ROUTINES == 1 )
-
-	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
-	{
-	BaseType_t xReturn;
-	Queue_t * const pxQueue = xQueue;
-
-		/* If the queue is already empty we may have to block.  A critical section
-		is required to prevent an interrupt adding something to the queue
-		between the check to see if the queue is empty and blocking on the queue. */
-		portDISABLE_INTERRUPTS();
-		{
-			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
-			{
-				/* There are no messages in the queue, do we want to block or just
-				leave with nothing? */
-				if( xTicksToWait > ( TickType_t ) 0 )
-				{
-					/* As this is a co-routine we cannot block directly, but return
-					indicating that we need to block. */
-					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
-					portENABLE_INTERRUPTS();
-					return errQUEUE_BLOCKED;
-				}
-				else
-				{
-					portENABLE_INTERRUPTS();
-					return errQUEUE_FULL;
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		portENABLE_INTERRUPTS();
-
-		portDISABLE_INTERRUPTS();
-		{
-			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
-			{
-				/* Data is available from the queue. */
-				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
-				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
-				{
-					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-				--( pxQueue->uxMessagesWaiting );
-				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
-
-				xReturn = pdPASS;
-
-				/* Were any co-routines waiting for space to become available? */
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
-				{
-					/* In this instance the co-routine could be placed directly
-					into the ready list as we are within a critical section.
-					Instead the same pending ready list mechanism is used as if
-					the event were caused from within an interrupt. */
-					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
-					{
-						xReturn = errQUEUE_YIELD;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				xReturn = pdFAIL;
-			}
-		}
-		portENABLE_INTERRUPTS();
-
-		return xReturn;
-	}
-
-#endif /* configUSE_CO_ROUTINES */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_CO_ROUTINES == 1 )
-
-	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
-	{
-	Queue_t * const pxQueue = xQueue;
-
-		/* Cannot block within an ISR so if there is no space on the queue then
-		exit without doing anything. */
-		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
-		{
-			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
-
-			/* We only want to wake one co-routine per ISR, so check that a
-			co-routine has not already been woken. */
-			if( xCoRoutinePreviouslyWoken == pdFALSE )
-			{
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
-				{
-					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
-					{
-						return pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return xCoRoutinePreviouslyWoken;
-	}
-
-#endif /* configUSE_CO_ROUTINES */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_CO_ROUTINES == 1 )
-
-	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
-	{
-	BaseType_t xReturn;
-	Queue_t * const pxQueue = xQueue;
-
-		/* We cannot block from an ISR, so check there is data available. If
-		not then just leave without doing anything. */
-		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
-		{
-			/* Copy the data from the queue. */
-			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
-			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
-			{
-				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-			--( pxQueue->uxMessagesWaiting );
-			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
-
-			if( ( *pxCoRoutineWoken ) == pdFALSE )
-			{
-				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
-				{
-					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
-					{
-						*pxCoRoutineWoken = pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			xReturn = pdPASS;
-		}
-		else
-		{
-			xReturn = pdFAIL;
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_CO_ROUTINES */
-/*-----------------------------------------------------------*/
-
-#if ( configQUEUE_REGISTRY_SIZE > 0 )
-
-	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	{
-	UBaseType_t ux;
-
-		/* See if there is an empty space in the registry.  A NULL name denotes
-		a free slot. */
-		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
-		{
-			if( xQueueRegistry[ ux ].pcQueueName == NULL )
-			{
-				/* Store the information on this queue. */
-				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
-				xQueueRegistry[ ux ].xHandle = xQueue;
-
-				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
-				break;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-	}
-
-#endif /* configQUEUE_REGISTRY_SIZE */
-/*-----------------------------------------------------------*/
-
-#if ( configQUEUE_REGISTRY_SIZE > 0 )
-
-	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	{
-	UBaseType_t ux;
-	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-		/* Note there is nothing here to protect against another task adding or
-		removing entries from the registry while it is being searched. */
-		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
-		{
-			if( xQueueRegistry[ ux ].xHandle == xQueue )
-			{
-				pcReturn = xQueueRegistry[ ux ].pcQueueName;
-				break;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-
-		return pcReturn;
-	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
-
-#endif /* configQUEUE_REGISTRY_SIZE */
-/*-----------------------------------------------------------*/
-
-#if ( configQUEUE_REGISTRY_SIZE > 0 )
-
-	void vQueueUnregisterQueue( QueueHandle_t xQueue )
-	{
-	UBaseType_t ux;
-
-		/* See if the handle of the queue being unregistered in actually in the
-		registry. */
-		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
-		{
-			if( xQueueRegistry[ ux ].xHandle == xQueue )
-			{
-				/* Set the name to NULL to show that this slot if free again. */
-				xQueueRegistry[ ux ].pcQueueName = NULL;
-
-				/* Set the handle to NULL to ensure the same queue handle cannot
-				appear in the registry twice if it is added, removed, then
-				added again. */
-				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
-				break;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-
-	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
-
-#endif /* configQUEUE_REGISTRY_SIZE */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TIMERS == 1 )
-
-	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
-	{
-	Queue_t * const pxQueue = xQueue;
-
-		/* This function should not be called by application code hence the
-		'Restricted' in its name.  It is not part of the public API.  It is
-		designed for use by kernel code, and has special calling requirements.
-		It can result in vListInsert() being called on a list that can only
-		possibly ever have one item in it, so the list will be fast, but even
-		so it should be called with the scheduler locked and not from a critical
-		section. */
-
-		/* Only do anything if there are no messages in the queue.  This function
-		will not actually cause the task to block, just place it on a blocked
-		list.  It will not block until the scheduler is unlocked - at which
-		time a yield will be performed.  If an item is added to the queue while
-		the queue is locked, and the calling task blocks on the queue, then the
-		calling task will be immediately unblocked when the queue is unlocked. */
-		prvLockQueue( pxQueue );
-		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
-		{
-			/* There is nothing in the queue, block for the specified period. */
-			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-		prvUnlockQueue( pxQueue );
-	}
-
-#endif /* configUSE_TIMERS */
-/*-----------------------------------------------------------*/
-
-#if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-
-	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
-	{
-	QueueSetHandle_t pxQueue;
-
-		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
-
-		return pxQueue;
-	}
-
-#endif /* configUSE_QUEUE_SETS */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-
-	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
-	{
-	BaseType_t xReturn;
-
-		taskENTER_CRITICAL();
-		{
-			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
-			{
-				/* Cannot add a queue/semaphore to more than one queue set. */
-				xReturn = pdFAIL;
-			}
-			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
-			{
-				/* Cannot add a queue/semaphore to a queue set if there are already
-				items in the queue/semaphore. */
-				xReturn = pdFAIL;
-			}
-			else
-			{
-				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
-				xReturn = pdPASS;
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		return xReturn;
-	}
-
-#endif /* configUSE_QUEUE_SETS */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-
-	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
-	{
-	BaseType_t xReturn;
-	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
-
-		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
-		{
-			/* The queue was not a member of the set. */
-			xReturn = pdFAIL;
-		}
-		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
-		{
-			/* It is dangerous to remove a queue from a set when the queue is
-			not empty because the queue set will still hold pending events for
-			the queue. */
-			xReturn = pdFAIL;
-		}
-		else
-		{
-			taskENTER_CRITICAL();
-			{
-				/* The queue is no longer contained in the set. */
-				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
-			}
-			taskEXIT_CRITICAL();
-			xReturn = pdPASS;
-		}
-
-		return xReturn;
-	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
-
-#endif /* configUSE_QUEUE_SETS */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-
-	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
-	{
-	QueueSetMemberHandle_t xReturn = NULL;
-
-		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
-		return xReturn;
-	}
-
-#endif /* configUSE_QUEUE_SETS */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-
-	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
-	{
-	QueueSetMemberHandle_t xReturn = NULL;
-
-		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
-		return xReturn;
-	}
-
-#endif /* configUSE_QUEUE_SETS */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_QUEUE_SETS == 1 )
-
-	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
-	{
-	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
-	BaseType_t xReturn = pdFALSE;
-
-		/* This function must be called form a critical section. */
-
-		configASSERT( pxQueueSetContainer );
-		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
-
-		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
-		{
-			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
-
-			traceQUEUE_SEND( pxQueueSetContainer );
-
-			/* The data copied is the handle of the queue that contains data. */
-			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
-
-			if( cTxLock == queueUNLOCKED )
-			{
-				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
-				{
-					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
-					{
-						/* The task waiting has a higher priority. */
-						xReturn = pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_QUEUE_SETS */
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/osal/src/freertos/stream_buffer.c b/osal/src/freertos/stream_buffer.c
deleted file mode 100644
index 7ad5d54..0000000
--- a/osal/src/freertos/stream_buffer.c
+++ /dev/null
@@ -1,1263 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdint.h>
-#include <string.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* FreeRTOS includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-#include "stream_buffer.h"
-
-#if( configUSE_TASK_NOTIFICATIONS != 1 )
-	#error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
-#endif
-
-/* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified
-because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
-for the header files above, but not in this file, in order to generate the
-correct privileged Vs unprivileged linkage and placement. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
-
-/* If the user has not provided application specific Rx notification macros,
-or #defined the notification macros away, them provide default implementations
-that uses task notifications. */
-/*lint -save -e9026 Function like macros allowed and needed here so they can be overidden. */
-#ifndef sbRECEIVE_COMPLETED
-	#define sbRECEIVE_COMPLETED( pxStreamBuffer )										\
-		vTaskSuspendAll();																\
-		{																				\
-			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
-			{																			\
-				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend,			\
-									  ( uint32_t ) 0,									\
-									  eNoAction );										\
-				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
-			}																			\
-		}																				\
-		( void ) xTaskResumeAll();
-#endif /* sbRECEIVE_COMPLETED */
-
-#ifndef sbRECEIVE_COMPLETED_FROM_ISR
-	#define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,								\
-										  pxHigherPriorityTaskWoken )					\
-	{																					\
-	UBaseType_t uxSavedInterruptStatus;													\
-																						\
-		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
-		{																				\
-			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
-			{																			\
-				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,	\
-											 ( uint32_t ) 0,							\
-											 eNoAction,									\
-											 pxHigherPriorityTaskWoken );				\
-				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
-			}																			\
-		}																				\
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
-	}
-#endif /* sbRECEIVE_COMPLETED_FROM_ISR */
-
-/* If the user has not provided an application specific Tx notification macro,
-or #defined the notification macro away, them provide a default implementation
-that uses task notifications. */
-#ifndef sbSEND_COMPLETED
-	#define sbSEND_COMPLETED( pxStreamBuffer )											\
-		vTaskSuspendAll();																\
-		{																				\
-			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
-			{																			\
-				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive,		\
-									  ( uint32_t ) 0,									\
-									  eNoAction );										\
-				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
-			}																			\
-		}																				\
-		( void ) xTaskResumeAll();
-#endif /* sbSEND_COMPLETED */
-
-#ifndef sbSEND_COMPLETE_FROM_ISR
-	#define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )		\
-	{																					\
-	UBaseType_t uxSavedInterruptStatus;													\
-																						\
-		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
-		{																				\
-			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
-			{																			\
-				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,	\
-											 ( uint32_t ) 0,							\
-											 eNoAction,									\
-											 pxHigherPriorityTaskWoken );				\
-				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
-			}																			\
-		}																				\
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
-	}
-#endif /* sbSEND_COMPLETE_FROM_ISR */
-/*lint -restore (9026) */
-
-/* The number of bytes used to hold the length of a message in the buffer. */
-#define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )
-
-/* Bits stored in the ucFlags field of the stream buffer. */
-#define sbFLAGS_IS_MESSAGE_BUFFER		( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */
-#define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */
-
-/*-----------------------------------------------------------*/
-
-/* Structure that hold state information on the buffer. */
-typedef struct StreamBufferDef_t /*lint !e9058 Style convention uses tag. */
-{
-	volatile size_t xTail;				/* Index to the next item to read within the buffer. */
-	volatile size_t xHead;				/* Index to the next item to write within the buffer. */
-	size_t xLength;						/* The length of the buffer pointed to by pucBuffer. */
-	size_t xTriggerLevelBytes;			/* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */
-	volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */
-	volatile TaskHandle_t xTaskWaitingToSend;	/* Holds the handle of a task waiting to send data to a message buffer that is full. */
-	uint8_t *pucBuffer;					/* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */
-	uint8_t ucFlags;
-
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxStreamBufferNumber;		/* Used for tracing purposes. */
-	#endif
-} StreamBuffer_t;
-
-/*
- * The number of bytes available to be read from the buffer.
- */
-static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
-
-/*
- * Add xCount bytes from pucData into the pxStreamBuffer message buffer.
- * Returns the number of bytes written, which will either equal xCount in the
- * success case, or 0 if there was not enough space in the buffer (in which case
- * no data is written into the buffer).
- */
-static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount ) PRIVILEGED_FUNCTION;
-
-/*
- * If the stream buffer is being used as a message buffer, then reads an entire
- * message out of the buffer.  If the stream buffer is being used as a stream
- * buffer then read as many bytes as possible from the buffer.
- * prvReadBytesFromBuffer() is called to actually extract the bytes from the
- * buffer's data storage area.
- */
-static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
-										void *pvRxData,
-										size_t xBufferLengthBytes,
-										size_t xBytesAvailable,
-										size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
-
-/*
- * If the stream buffer is being used as a message buffer, then writes an entire
- * message to the buffer.  If the stream buffer is being used as a stream
- * buffer then write as many bytes as possible to the buffer.
- * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's
- * data storage area.
- */
-static size_t prvWriteMessageToBuffer(  StreamBuffer_t * const pxStreamBuffer,
-										const void * pvTxData,
-										size_t xDataLengthBytes,
-										size_t xSpace,
-										size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
-
-/*
- * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them
- * to pucData.
- */
-static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer,
-									  uint8_t *pucData,
-									  size_t xMaxCount,
-									  size_t xBytesAvailable ) PRIVILEGED_FUNCTION;
-
-/*
- * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to
- * initialise the members of the newly created stream buffer structure.
- */
-static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
-										  uint8_t * const pucBuffer,
-										  size_t xBufferSizeBytes,
-										  size_t xTriggerLevelBytes,
-										  uint8_t ucFlags ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-
-	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
-	{
-	uint8_t *pucAllocatedMemory;
-	uint8_t ucFlags;
-
-		/* In case the stream buffer is going to be used as a message buffer
-		(that is, it will hold discrete messages with a little meta data that
-		says how big the next message is) check the buffer will be large enough
-		to hold at least one message. */
-		if( xIsMessageBuffer == pdTRUE )
-		{
-			/* Is a message buffer but not statically allocated. */
-			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
-			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
-		}
-		else
-		{
-			/* Not a message buffer and not statically allocated. */
-			ucFlags = 0;
-			configASSERT( xBufferSizeBytes > 0 );
-		}
-		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
-
-		/* A trigger level of 0 would cause a waiting task to unblock even when
-		the buffer was empty. */
-		if( xTriggerLevelBytes == ( size_t ) 0 )
-		{
-			xTriggerLevelBytes = ( size_t ) 1;
-		}
-
-		/* A stream buffer requires a StreamBuffer_t structure and a buffer.
-		Both are allocated in a single call to pvPortMalloc().  The
-		StreamBuffer_t structure is placed at the start of the allocated memory
-		and the buffer follows immediately after.  The requested size is
-		incremented so the free space is returned as the user would expect -
-		this is a quirk of the implementation that means otherwise the free
-		space would be reported as one byte smaller than would be logically
-		expected. */
-		xBufferSizeBytes++;
-		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
-
-		if( pucAllocatedMemory != NULL )
-		{
-			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
-										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
-										   xBufferSizeBytes,
-										   xTriggerLevelBytes,
-										   ucFlags );
-
-			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
-		}
-		else
-		{
-			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
-		}
-
-		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
-	}
-
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-	StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
-														   size_t xTriggerLevelBytes,
-														   BaseType_t xIsMessageBuffer,
-														   uint8_t * const pucStreamBufferStorageArea,
-														   StaticStreamBuffer_t * const pxStaticStreamBuffer )
-	{
-	StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
-	StreamBufferHandle_t xReturn;
-	uint8_t ucFlags;
-
-		configASSERT( pucStreamBufferStorageArea );
-		configASSERT( pxStaticStreamBuffer );
-		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
-
-		/* A trigger level of 0 would cause a waiting task to unblock even when
-		the buffer was empty. */
-		if( xTriggerLevelBytes == ( size_t ) 0 )
-		{
-			xTriggerLevelBytes = ( size_t ) 1;
-		}
-
-		if( xIsMessageBuffer != pdFALSE )
-		{
-			/* Statically allocated message buffer. */
-			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
-		}
-		else
-		{
-			/* Statically allocated stream buffer. */
-			ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;
-		}
-
-		/* In case the stream buffer is going to be used as a message buffer
-		(that is, it will hold discrete messages with a little meta data that
-		says how big the next message is) check the buffer will be large enough
-		to hold at least one message. */
-		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
-
-		#if( configASSERT_DEFINED == 1 )
-		{
-			/* Sanity check that the size of the structure used to declare a
-			variable of type StaticStreamBuffer_t equals the size of the real
-			message buffer structure. */
-			volatile size_t xSize = sizeof( StaticStreamBuffer_t );
-			configASSERT( xSize == sizeof( StreamBuffer_t ) );
-		} /*lint !e529 xSize is referenced is configASSERT() is defined. */
-		#endif /* configASSERT_DEFINED */
-
-		if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
-		{
-			prvInitialiseNewStreamBuffer( pxStreamBuffer,
-										  pucStreamBufferStorageArea,
-										  xBufferSizeBytes,
-										  xTriggerLevelBytes,
-										  ucFlags );
-
-			/* Remember this was statically allocated in case it is ever deleted
-			again. */
-			pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
-
-			traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
-
-			xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */
-		}
-		else
-		{
-			xReturn = NULL;
-			traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
-		}
-
-		return xReturn;
-	}
-
-#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
-/*-----------------------------------------------------------*/
-
-void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
-{
-StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
-
-	configASSERT( pxStreamBuffer );
-
-	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
-
-	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
-	{
-		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-		{
-			/* Both the structure and the buffer were allocated using a single call
-			to pvPortMalloc(), hence only one call to vPortFree() is required. */
-			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
-		}
-		#else
-		{
-			/* Should not be possible to get here, ucFlags must be corrupt.
-			Force an assert. */
-			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
-		}
-		#endif
-	}
-	else
-	{
-		/* The structure and buffer were not allocated dynamically and cannot be
-		freed - just scrub the structure so future use will assert. */
-		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
-	}
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-BaseType_t xReturn = pdFAIL;
-
-#if( configUSE_TRACE_FACILITY == 1 )
-	UBaseType_t uxStreamBufferNumber;
-#endif
-
-	configASSERT( pxStreamBuffer );
-
-	#if( configUSE_TRACE_FACILITY == 1 )
-	{
-		/* Store the stream buffer number so it can be restored after the
-		reset. */
-		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
-	}
-	#endif
-
-	/* Can only reset a message buffer if there are no tasks blocked on it. */
-	taskENTER_CRITICAL();
-	{
-		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
-		{
-			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
-			{
-				prvInitialiseNewStreamBuffer( pxStreamBuffer,
-											  pxStreamBuffer->pucBuffer,
-											  pxStreamBuffer->xLength,
-											  pxStreamBuffer->xTriggerLevelBytes,
-											  pxStreamBuffer->ucFlags );
-				xReturn = pdPASS;
-
-				#if( configUSE_TRACE_FACILITY == 1 )
-				{
-					pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
-				}
-				#endif
-
-				traceSTREAM_BUFFER_RESET( xStreamBuffer );
-			}
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-BaseType_t xReturn;
-
-	configASSERT( pxStreamBuffer );
-
-	/* It is not valid for the trigger level to be 0. */
-	if( xTriggerLevel == ( size_t ) 0 )
-	{
-		xTriggerLevel = ( size_t ) 1;
-	}
-
-	/* The trigger level is the number of bytes that must be in the stream
-	buffer before a task that is waiting for data is unblocked. */
-	if( xTriggerLevel <= pxStreamBuffer->xLength )
-	{
-		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
-		xReturn = pdPASS;
-	}
-	else
-	{
-		xReturn = pdFALSE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
-{
-const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-size_t xSpace;
-
-	configASSERT( pxStreamBuffer );
-
-	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
-	xSpace -= pxStreamBuffer->xHead;
-	xSpace -= ( size_t ) 1;
-
-	if( xSpace >= pxStreamBuffer->xLength )
-	{
-		xSpace -= pxStreamBuffer->xLength;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	return xSpace;
-}
-/*-----------------------------------------------------------*/
-
-size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
-{
-const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-size_t xReturn;
-
-	configASSERT( pxStreamBuffer );
-
-	xReturn = prvBytesInBuffer( pxStreamBuffer );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
-						  const void *pvTxData,
-						  size_t xDataLengthBytes,
-						  TickType_t xTicksToWait )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-size_t xReturn, xSpace = 0;
-size_t xRequiredSpace = xDataLengthBytes;
-TimeOut_t xTimeOut;
-
-	configASSERT( pvTxData );
-	configASSERT( pxStreamBuffer );
-
-	/* This send function is used to write to both message buffers and stream
-	buffers.  If this is a message buffer then the space needed must be
-	increased by the amount of bytes needed to store the length of the
-	message. */
-	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
-	{
-		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
-
-		/* Overflow? */
-		configASSERT( xRequiredSpace > xDataLengthBytes );
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	if( xTicksToWait != ( TickType_t ) 0 )
-	{
-		vTaskSetTimeOutState( &xTimeOut );
-
-		do
-		{
-			/* Wait until the required number of bytes are free in the message
-			buffer. */
-			taskENTER_CRITICAL();
-			{
-				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
-
-				if( xSpace < xRequiredSpace )
-				{
-					/* Clear notification state as going to wait for space. */
-					( void ) xTaskNotifyStateClear( NULL );
-
-					/* Should only be one writer. */
-					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
-					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
-				}
-				else
-				{
-					taskEXIT_CRITICAL();
-					break;
-				}
-			}
-			taskEXIT_CRITICAL();
-
-			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
-			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
-			pxStreamBuffer->xTaskWaitingToSend = NULL;
-
-		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	if( xSpace == ( size_t ) 0 )
-	{
-		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
-
-	if( xReturn > ( size_t ) 0 )
-	{
-		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
-
-		/* Was a task waiting for the data? */
-		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
-		{
-			sbSEND_COMPLETED( pxStreamBuffer );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
-								 const void *pvTxData,
-								 size_t xDataLengthBytes,
-								 BaseType_t * const pxHigherPriorityTaskWoken )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-size_t xReturn, xSpace;
-size_t xRequiredSpace = xDataLengthBytes;
-
-	configASSERT( pvTxData );
-	configASSERT( pxStreamBuffer );
-
-	/* This send function is used to write to both message buffers and stream
-	buffers.  If this is a message buffer then the space needed must be
-	increased by the amount of bytes needed to store the length of the
-	message. */
-	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
-	{
-		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
-	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
-
-	if( xReturn > ( size_t ) 0 )
-	{
-		/* Was a task waiting for the data? */
-		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
-		{
-			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
-									   const void * pvTxData,
-									   size_t xDataLengthBytes,
-									   size_t xSpace,
-									   size_t xRequiredSpace )
-{
-	BaseType_t xShouldWrite;
-	size_t xReturn;
-
-	if( xSpace == ( size_t ) 0 )
-	{
-		/* Doesn't matter if this is a stream buffer or a message buffer, there
-		is no space to write. */
-		xShouldWrite = pdFALSE;
-	}
-	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
-	{
-		/* This is a stream buffer, as opposed to a message buffer, so writing a
-		stream of bytes rather than discrete messages.  Write as many bytes as
-		possible. */
-		xShouldWrite = pdTRUE;
-		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
-	}
-	else if( xSpace >= xRequiredSpace )
-	{
-		/* This is a message buffer, as opposed to a stream buffer, and there
-		is enough space to write both the message length and the message itself
-		into the buffer.  Start by writing the length of the data, the data
-		itself will be written later in this function. */
-		xShouldWrite = pdTRUE;
-		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
-	}
-	else
-	{
-		/* There is space available, but not enough space. */
-		xShouldWrite = pdFALSE;
-	}
-
-	if( xShouldWrite != pdFALSE )
-	{
-		/* Writes the data itself. */
-		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
-	}
-	else
-	{
-		xReturn = 0;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
-							 void *pvRxData,
-							 size_t xBufferLengthBytes,
-							 TickType_t xTicksToWait )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
-
-	configASSERT( pvRxData );
-	configASSERT( pxStreamBuffer );
-
-	/* This receive function is used by both message buffers, which store
-	discrete messages, and stream buffers, which store a continuous stream of
-	bytes.  Discrete messages include an additional
-	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
-	message. */
-	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
-	{
-		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
-	}
-	else
-	{
-		xBytesToStoreMessageLength = 0;
-	}
-
-	if( xTicksToWait != ( TickType_t ) 0 )
-	{
-		/* Checking if there is data and clearing the notification state must be
-		performed atomically. */
-		taskENTER_CRITICAL();
-		{
-			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
-
-			/* If this function was invoked by a message buffer read then
-			xBytesToStoreMessageLength holds the number of bytes used to hold
-			the length of the next discrete message.  If this function was
-			invoked by a stream buffer read then xBytesToStoreMessageLength will
-			be 0. */
-			if( xBytesAvailable <= xBytesToStoreMessageLength )
-			{
-				/* Clear notification state as going to wait for data. */
-				( void ) xTaskNotifyStateClear( NULL );
-
-				/* Should only be one reader. */
-				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
-				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		if( xBytesAvailable <= xBytesToStoreMessageLength )
-		{
-			/* Wait for data to be available. */
-			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
-			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
-			pxStreamBuffer->xTaskWaitingToReceive = NULL;
-
-			/* Recheck the data available after blocking. */
-			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
-	}
-
-	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
-	holds the number of bytes used to store the message length) or a stream of
-	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
-	available must be greater than xBytesToStoreMessageLength to be able to
-	read bytes from the buffer. */
-	if( xBytesAvailable > xBytesToStoreMessageLength )
-	{
-		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
-
-		/* Was a task waiting for space in the buffer? */
-		if( xReceivedLength != ( size_t ) 0 )
-		{
-			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
-			sbRECEIVE_COMPLETED( pxStreamBuffer );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	return xReceivedLength;
-}
-/*-----------------------------------------------------------*/
-
-size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-size_t xReturn, xBytesAvailable, xOriginalTail;
-configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;
-
-	configASSERT( pxStreamBuffer );
-
-	/* Ensure the stream buffer is being used as a message buffer. */
-	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
-	{
-		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
-		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
-		{
-			/* The number of bytes available is greater than the number of bytes
-			required to hold the length of the next message, so another message
-			is available.  Return its length without removing the length bytes
-			from the buffer.  A copy of the tail is stored so the buffer can be
-			returned to its prior state as the message is not actually being
-			removed from the buffer. */
-			xOriginalTail = pxStreamBuffer->xTail;
-			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
-			xReturn = ( size_t ) xTempReturn;
-			pxStreamBuffer->xTail = xOriginalTail;
-		}
-		else
-		{
-			/* The minimum amount of bytes in a message buffer is
-			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
-			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
-			value is 0. */
-			configASSERT( xBytesAvailable == 0 );
-			xReturn = 0;
-		}
-	}
-	else
-	{
-		xReturn = 0;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
-									void *pvRxData,
-									size_t xBufferLengthBytes,
-									BaseType_t * const pxHigherPriorityTaskWoken )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
-
-	configASSERT( pvRxData );
-	configASSERT( pxStreamBuffer );
-
-	/* This receive function is used by both message buffers, which store
-	discrete messages, and stream buffers, which store a continuous stream of
-	bytes.  Discrete messages include an additional
-	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
-	message. */
-	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
-	{
-		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
-	}
-	else
-	{
-		xBytesToStoreMessageLength = 0;
-	}
-
-	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
-
-	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
-	holds the number of bytes used to store the message length) or a stream of
-	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
-	available must be greater than xBytesToStoreMessageLength to be able to
-	read bytes from the buffer. */
-	if( xBytesAvailable > xBytesToStoreMessageLength )
-	{
-		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
-
-		/* Was a task waiting for space in the buffer? */
-		if( xReceivedLength != ( size_t ) 0 )
-		{
-			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
-
-	return xReceivedLength;
-}
-/*-----------------------------------------------------------*/
-
-static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
-										void *pvRxData,
-										size_t xBufferLengthBytes,
-										size_t xBytesAvailable,
-										size_t xBytesToStoreMessageLength )
-{
-size_t xOriginalTail, xReceivedLength, xNextMessageLength;
-configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
-
-	if( xBytesToStoreMessageLength != ( size_t ) 0 )
-	{
-		/* A discrete message is being received.  First receive the length
-		of the message.  A copy of the tail is stored so the buffer can be
-		returned to its prior state if the length of the message is too
-		large for the provided buffer. */
-		xOriginalTail = pxStreamBuffer->xTail;
-		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
-		xNextMessageLength = ( size_t ) xTempNextMessageLength;
-
-		/* Reduce the number of bytes available by the number of bytes just
-		read out. */
-		xBytesAvailable -= xBytesToStoreMessageLength;
-
-		/* Check there is enough space in the buffer provided by the
-		user. */
-		if( xNextMessageLength > xBufferLengthBytes )
-		{
-			/* The user has provided insufficient space to read the message
-			so return the buffer to its previous state (so the length of
-			the message is in the buffer again). */
-			pxStreamBuffer->xTail = xOriginalTail;
-			xNextMessageLength = 0;
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		/* A stream of bytes is being received (as opposed to a discrete
-		message), so read as many bytes as possible. */
-		xNextMessageLength = xBufferLengthBytes;
-	}
-
-	/* Read the actual data. */
-	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
-
-	return xReceivedLength;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
-{
-const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-BaseType_t xReturn;
-size_t xTail;
-
-	configASSERT( pxStreamBuffer );
-
-	/* True if no bytes are available. */
-	xTail = pxStreamBuffer->xTail;
-	if( pxStreamBuffer->xHead == xTail )
-	{
-		xReturn = pdTRUE;
-	}
-	else
-	{
-		xReturn = pdFALSE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
-{
-BaseType_t xReturn;
-size_t xBytesToStoreMessageLength;
-const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-
-	configASSERT( pxStreamBuffer );
-
-	/* This generic version of the receive function is used by both message
-	buffers, which store discrete messages, and stream buffers, which store a
-	continuous stream of bytes.  Discrete messages include an additional
-	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
-	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
-	{
-		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
-	}
-	else
-	{
-		xBytesToStoreMessageLength = 0;
-	}
-
-	/* True if the available space equals zero. */
-	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
-	{
-		xReturn = pdTRUE;
-	}
-	else
-	{
-		xReturn = pdFALSE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-BaseType_t xReturn;
-UBaseType_t uxSavedInterruptStatus;
-
-	configASSERT( pxStreamBuffer );
-
-	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
-		{
-			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
-										 ( uint32_t ) 0,
-										 eNoAction,
-										 pxHigherPriorityTaskWoken );
-			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
-			xReturn = pdTRUE;
-		}
-		else
-		{
-			xReturn = pdFALSE;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
-{
-StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
-BaseType_t xReturn;
-UBaseType_t uxSavedInterruptStatus;
-
-	configASSERT( pxStreamBuffer );
-
-	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
-	{
-		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
-		{
-			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
-										 ( uint32_t ) 0,
-										 eNoAction,
-										 pxHigherPriorityTaskWoken );
-			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
-			xReturn = pdTRUE;
-		}
-		else
-		{
-			xReturn = pdFALSE;
-		}
-	}
-	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
-{
-size_t xNextHead, xFirstLength;
-
-	configASSERT( xCount > ( size_t ) 0 );
-
-	xNextHead = pxStreamBuffer->xHead;
-
-	/* Calculate the number of bytes that can be added in the first write -
-	which may be less than the total number of bytes that need to be added if
-	the buffer will wrap back to the beginning. */
-	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
-
-	/* Write as many bytes as can be written in the first write. */
-	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
-	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
-
-	/* If the number of bytes written was less than the number that could be
-	written in the first write... */
-	if( xCount > xFirstLength )
-	{
-		/* ...then write the remaining bytes to the start of the buffer. */
-		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
-		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	xNextHead += xCount;
-	if( xNextHead >= pxStreamBuffer->xLength )
-	{
-		xNextHead -= pxStreamBuffer->xLength;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	pxStreamBuffer->xHead = xNextHead;
-
-	return xCount;
-}
-/*-----------------------------------------------------------*/
-
-static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
-{
-size_t xCount, xFirstLength, xNextTail;
-
-	/* Use the minimum of the wanted bytes and the available bytes. */
-	xCount = configMIN( xBytesAvailable, xMaxCount );
-
-	if( xCount > ( size_t ) 0 )
-	{
-		xNextTail = pxStreamBuffer->xTail;
-
-		/* Calculate the number of bytes that can be read - which may be
-		less than the number wanted if the data wraps around to the start of
-		the buffer. */
-		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
-
-		/* Obtain the number of bytes it is possible to obtain in the first
-		read.  Asserts check bounds of read and write. */
-		configASSERT( xFirstLength <= xMaxCount );
-		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
-		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
-
-		/* If the total number of wanted bytes is greater than the number
-		that could be read in the first read... */
-		if( xCount > xFirstLength )
-		{
-			/*...then read the remaining bytes from the start of the buffer. */
-			configASSERT( xCount <= xMaxCount );
-			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		/* Move the tail pointer to effectively remove the data read from
-		the buffer. */
-		xNextTail += xCount;
-
-		if( xNextTail >= pxStreamBuffer->xLength )
-		{
-			xNextTail -= pxStreamBuffer->xLength;
-		}
-
-		pxStreamBuffer->xTail = xNextTail;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	return xCount;
-}
-/*-----------------------------------------------------------*/
-
-static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
-{
-/* Returns the distance between xTail and xHead. */
-size_t xCount;
-
-	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
-	xCount -= pxStreamBuffer->xTail;
-	if ( xCount >= pxStreamBuffer->xLength )
-	{
-		xCount -= pxStreamBuffer->xLength;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	return xCount;
-}
-/*-----------------------------------------------------------*/
-
-static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
-										  uint8_t * const pucBuffer,
-										  size_t xBufferSizeBytes,
-										  size_t xTriggerLevelBytes,
-										  uint8_t ucFlags )
-{
-	/* Assert here is deliberately writing to the entire buffer to ensure it can
-	be written to without generating exceptions, and is setting the buffer to a
-	known value to assist in development/debugging. */
-	#if( configASSERT_DEFINED == 1 )
-	{
-		/* The value written just has to be identifiable when looking at the
-		memory.  Don't use 0xA5 as that is the stack fill value and could
-		result in confusion as to what is actually being observed. */
-		const BaseType_t xWriteValue = 0x55;
-		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
-	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
-	#endif
-
-	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
-	pxStreamBuffer->pucBuffer = pucBuffer;
-	pxStreamBuffer->xLength = xBufferSizeBytes;
-	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
-	pxStreamBuffer->ucFlags = ucFlags;
-}
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
-	{
-		return xStreamBuffer->uxStreamBufferNumber;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
-	{
-		xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
-	{
-		return ( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
diff --git a/osal/src/freertos/tasks.c b/osal/src/freertos/tasks.c
deleted file mode 100644
index f6a6a9b..0000000
--- a/osal/src/freertos/tasks.c
+++ /dev/null
@@ -1,5310 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdlib.h>
-#include <string.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-/* FreeRTOS includes. */
-#include "FreeRTOS.h"
-#include "task.h"
-#include "timers.h"
-#include "stack_macros.h"
-
-/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
-because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
-for the header files above, but not in this file, in order to generate the
-correct privileged Vs unprivileged linkage and placement. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
-
-/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
-functions but without including stdio.h here. */
-#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
-	/* At the bottom of this file are two optional functions that can be used
-	to generate human readable text from the raw data generated by the
-	uxTaskGetSystemState() function.  Note the formatting functions are provided
-	for convenience only, and are NOT considered part of the kernel. */
-	#include <stdio.h>
-#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
-
-#if( configUSE_PREEMPTION == 0 )
-	/* If the cooperative scheduler is being used then a yield should not be
-	performed just because a higher priority task has been woken. */
-	#define taskYIELD_IF_USING_PREEMPTION()
-#else
-	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
-#endif
-
-/* Values that can be assigned to the ucNotifyState member of the TCB. */
-#define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
-#define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
-#define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
-
-/*
- * The value used to fill the stack of a task when the task is created.  This
- * is used purely for checking the high water mark for tasks.
- */
-#define tskSTACK_FILL_BYTE	( 0xa5U )
-
-/* Bits used to recored how a task's stack and TCB were allocated. */
-#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
-#define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
-#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
-
-/* If any of the following are set then task stacks are filled with a known
-value so the high water mark can be determined.  If none of the following are
-set then don't fill the stack so there is no unnecessary dependency on memset. */
-#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
-	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
-#else
-	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
-#endif
-
-/*
- * Macros used by vListTask to indicate which state a task is in.
- */
-#define tskRUNNING_CHAR		( 'X' )
-#define tskBLOCKED_CHAR		( 'B' )
-#define tskREADY_CHAR		( 'R' )
-#define tskDELETED_CHAR		( 'D' )
-#define tskSUSPENDED_CHAR	( 'S' )
-
-/*
- * Some kernel aware debuggers require the data the debugger needs access to be
- * global, rather than file scope.
- */
-#ifdef portREMOVE_STATIC_QUALIFIER
-	#define static
-#endif
-
-/* The name allocated to the Idle task.  This can be overridden by defining
-configIDLE_TASK_NAME in FreeRTOSConfig.h. */
-#ifndef configIDLE_TASK_NAME
-	#define configIDLE_TASK_NAME "IDLE"
-#endif
-
-#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
-
-	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
-	performed in a generic way that is not optimised to any particular
-	microcontroller architecture. */
-
-	/* uxTopReadyPriority holds the priority of the highest priority ready
-	state task. */
-	#define taskRECORD_READY_PRIORITY( uxPriority )														\
-	{																									\
-		if( ( uxPriority ) > uxTopReadyPriority )														\
-		{																								\
-			uxTopReadyPriority = ( uxPriority );														\
-		}																								\
-	} /* taskRECORD_READY_PRIORITY */
-
-	/*-----------------------------------------------------------*/
-
-	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
-	{																									\
-	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
-																										\
-		/* Find the highest priority queue that contains ready tasks. */								\
-		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
-		{																								\
-			configASSERT( uxTopPriority );																\
-			--uxTopPriority;																			\
-		}																								\
-																										\
-		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
-		the	same priority get an equal share of the processor time. */									\
-		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
-		uxTopReadyPriority = uxTopPriority;																\
-	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
-
-	/*-----------------------------------------------------------*/
-
-	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
-	they are only required when a port optimised method of task selection is
-	being used. */
-	#define taskRESET_READY_PRIORITY( uxPriority )
-	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
-
-#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
-	performed in a way that is tailored to the particular microcontroller
-	architecture being used. */
-
-	/* A port optimised version is provided.  Call the port defined macros. */
-	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
-
-	/*-----------------------------------------------------------*/
-
-	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
-	{																								\
-	UBaseType_t uxTopPriority;																		\
-																									\
-		/* Find the highest priority list that contains ready tasks. */								\
-		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
-		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
-		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
-	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
-
-	/*-----------------------------------------------------------*/
-
-	/* A port optimised version is provided, call it only if the TCB being reset
-	is being referenced from a ready list.  If it is referenced from a delayed
-	or suspended list then it won't be in a ready list. */
-	#define taskRESET_READY_PRIORITY( uxPriority )														\
-	{																									\
-		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
-		{																								\
-			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
-		}																								\
-	}
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-/*-----------------------------------------------------------*/
-
-/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
-count overflows. */
-#define taskSWITCH_DELAYED_LISTS()																	\
-{																									\
-	List_t *pxTemp;																					\
-																									\
-	/* The delayed tasks list should be empty when the lists are switched. */						\
-	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
-																									\
-	pxTemp = pxDelayedTaskList;																		\
-	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
-	pxOverflowDelayedTaskList = pxTemp;																\
-	xNumOfOverflows++;																				\
-	prvResetNextTaskUnblockTime();																	\
-}
-
-/*-----------------------------------------------------------*/
-
-/*
- * Place the task represented by pxTCB into the appropriate ready list for
- * the task.  It is inserted at the end of the list.
- */
-#define prvAddTaskToReadyList( pxTCB )																\
-	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
-	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
-	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
-	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
-/*-----------------------------------------------------------*/
-
-/*
- * Several functions take an TaskHandle_t parameter that can optionally be NULL,
- * where NULL is used to indicate that the handle of the currently executing
- * task should be used in place of the parameter.  This macro simply checks to
- * see if the parameter is NULL and returns a pointer to the appropriate TCB.
- */
-#define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
-
-/* The item value of the event list item is normally used to hold the priority
-of the task to which it belongs (coded to allow it to be held in reverse
-priority order).  However, it is occasionally borrowed for other purposes.  It
-is important its value is not updated due to a task priority change while it is
-being used for another purpose.  The following bit definition is used to inform
-the scheduler that the value should not be changed - in which case it is the
-responsibility of whichever module is using the value to ensure it gets set back
-to its original value when it is released. */
-#if( configUSE_16_BIT_TICKS == 1 )
-	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
-#else
-	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
-#endif
-
-/*
- * Task control block.  A task control block (TCB) is allocated for each task,
- * and stores task state information, including a pointer to the task's context
- * (the task's run time environment, including register values)
- */
-typedef struct tskTaskControlBlock 			/* The old naming convention is used to prevent breaking kernel aware debuggers. */
-{
-	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
-
-	#if ( portUSING_MPU_WRAPPERS == 1 )
-		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
-	#endif
-
-	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
-	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
-	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
-	StackType_t			*pxStack;			/*< Points to the start of the stack. */
-	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
-		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
-	#endif
-
-	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
-		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
-	#endif
-
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
-		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
-	#endif
-
-	#if ( configUSE_MUTEXES == 1 )
-		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
-		UBaseType_t		uxMutexesHeld;
-	#endif
-
-	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-		TaskHookFunction_t pxTaskTag;
-	#endif
-
-	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
-		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
-	#endif
-
-	#if( configGENERATE_RUN_TIME_STATS == 1 )
-		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
-	#endif
-
-	#if ( configUSE_NEWLIB_REENTRANT == 1 )
-		/* Allocate a Newlib reent structure that is specific to this task.
-		Note Newlib support has been included by popular demand, but is not
-		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
-		responsible for resulting newlib operation.  User must be familiar with
-		newlib and must provide system-wide implementations of the necessary
-		stubs. Be warned that (at the time of writing) the current newlib design
-		implements a system-wide malloc() that must be provided with locks.
-
-		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
-		for additional information. */
-		struct	_reent xNewLib_reent;
-	#endif
-
-	#if( configUSE_TASK_NOTIFICATIONS == 1 )
-		volatile uint32_t ulNotifiedValue;
-		volatile uint8_t ucNotifyState;
-	#endif
-
-	/* See the comments in FreeRTOS.h with the definition of
-	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
-	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
-		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
-	#endif
-
-	#if( INCLUDE_xTaskAbortDelay == 1 )
-		uint8_t ucDelayAborted;
-	#endif
-
-	#if( configUSE_POSIX_ERRNO == 1 )
-		int iTaskErrno;
-	#endif
-
-} tskTCB;
-
-/* The old tskTCB name is maintained above then typedefed to the new TCB_t name
-below to enable the use of older kernel aware debuggers. */
-typedef tskTCB TCB_t;
-
-/*lint -save -e956 A manual analysis and inspection has been used to determine
-which static variables must be declared volatile. */
-PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
-
-/* Lists for ready and blocked tasks. --------------------
-xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
-doing so breaks some kernel aware debuggers and debuggers that rely on removing
-the static qualifier. */
-PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
-PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
-PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
-PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
-PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
-PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
-
-#if( INCLUDE_vTaskDelete == 1 )
-
-	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
-	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
-
-#endif
-
-#if ( INCLUDE_vTaskSuspend == 1 )
-
-	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
-
-#endif
-
-/* Global POSIX errno. Its value is changed upon context switching to match
-the errno of the currently running task. */
-#if ( configUSE_POSIX_ERRNO == 1 )
-	int FreeRTOS_errno = 0;
-#endif
-
-/* Other file private variables. --------------------------------*/
-PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
-PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
-PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
-PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
-PRIVILEGED_DATA static volatile TickType_t xPendedTicks 			= ( TickType_t ) 0U;
-PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
-PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
-PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
-PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
-PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
-
-/* Context switches are held pending while the scheduler is suspended.  Also,
-interrupts must not manipulate the xStateListItem of a TCB, or any of the
-lists the xStateListItem can be referenced from, if the scheduler is suspended.
-If an interrupt needs to unblock a task while the scheduler is suspended then it
-moves the task's event list item into the xPendingReadyList, ready for the
-kernel to move the task from the pending ready list into the real ready list
-when the scheduler is unsuspended.  The pending ready list itself can only be
-accessed from a critical section. */
-PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
-
-#if ( configGENERATE_RUN_TIME_STATS == 1 )
-
-	/* Do not move these variables to function scope as doing so prevents the
-	code working with debuggers that need to remove the static qualifier. */
-	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
-	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
-
-#endif
-
-/*lint -restore */
-
-/*-----------------------------------------------------------*/
-
-/* Callback function prototypes. --------------------------*/
-#if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
-
-	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
-
-#endif
-
-#if( configUSE_TICK_HOOK > 0 )
-
-	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application callback. */
-
-#endif
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize ); /*lint !e526 Symbol not defined as it is an application callback. */
-
-#endif
-
-/* File private functions. --------------------------------*/
-
-/**
- * Utility task that simply returns pdTRUE if the task referenced by xTask is
- * currently in the Suspended state, or pdFALSE if the task referenced by xTask
- * is in any other state.
- */
-#if ( INCLUDE_vTaskSuspend == 1 )
-
-	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-#endif /* INCLUDE_vTaskSuspend */
-
-/*
- * Utility to ready all the lists used by the scheduler.  This is called
- * automatically upon the creation of the first task.
- */
-static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
-
-/*
- * The idle task, which as all tasks is implemented as a never ending loop.
- * The idle task is automatically created and added to the ready lists upon
- * creation of the first user task.
- *
- * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
- * language extensions.  The equivalent prototype for this function is:
- *
- * void prvIdleTask( void *pvParameters );
- *
- */
-static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
-
-/*
- * Utility to free all memory allocated by the scheduler to hold a TCB,
- * including the stack pointed to by the TCB.
- *
- * This does not free memory allocated by the task itself (i.e. memory
- * allocated by calls to pvPortMalloc from within the tasks application code).
- */
-#if ( INCLUDE_vTaskDelete == 1 )
-
-	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/*
- * Used only by the idle task.  This checks to see if anything has been placed
- * in the list of tasks waiting to be deleted.  If so the task is cleaned up
- * and its TCB deleted.
- */
-static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
-
-/*
- * The currently executing task is entering the Blocked state.  Add the task to
- * either the current or the overflow delayed task list.
- */
-static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
-
-/*
- * Fills an TaskStatus_t structure with information on each task that is
- * referenced from the pxList list (which may be a ready list, a delayed list,
- * a suspended list, etc.).
- *
- * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
- * NORMAL APPLICATION CODE.
- */
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/*
- * Searches pxList for a task with name pcNameToQuery - returning a handle to
- * the task if it is found, or NULL if the task is not found.
- */
-#if ( INCLUDE_xTaskGetHandle == 1 )
-
-	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/*
- * When a task is created, the stack of the task is filled with a known value.
- * This function determines the 'high water mark' of the task stack by
- * determining how much of the stack remains at the original preset value.
- */
-#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
-
-	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/*
- * Return the amount of time, in ticks, that will pass before the kernel will
- * next move a task from the Blocked state to the Running state.
- *
- * This conditional compilation should use inequality to 0, not equality to 1.
- * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
- * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
- * set to a value other than 1.
- */
-#if ( configUSE_TICKLESS_IDLE != 0 )
-
-	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/*
- * Set xNextTaskUnblockTime to the time at which the next Blocked state task
- * will exit the Blocked state.
- */
-static void prvResetNextTaskUnblockTime( void );
-
-#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
-
-	/*
-	 * Helper function used to pad task names with spaces when printing out
-	 * human readable tables of task information.
-	 */
-	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/*
- * Called after a Task_t structure has been allocated either statically or
- * dynamically to fill in the structure's members.
- */
-static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
-									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-									const uint32_t ulStackDepth,
-									void * const pvParameters,
-									UBaseType_t uxPriority,
-									TaskHandle_t * const pxCreatedTask,
-									TCB_t *pxNewTCB,
-									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
-
-/*
- * Called after a new task has been created and initialised to place the task
- * under the control of the scheduler.
- */
-static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
-
-/*
- * freertos_tasks_c_additions_init() should only be called if the user definable
- * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
- * called by the function.
- */
-#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
-
-	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
-									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-									const uint32_t ulStackDepth,
-									void * const pvParameters,
-									UBaseType_t uxPriority,
-									StackType_t * const puxStackBuffer,
-									StaticTask_t * const pxTaskBuffer )
-	{
-	TCB_t *pxNewTCB;
-	TaskHandle_t xReturn;
-
-		configASSERT( puxStackBuffer != NULL );
-		configASSERT( pxTaskBuffer != NULL );
-
-		#if( configASSERT_DEFINED == 1 )
-		{
-			/* Sanity check that the size of the structure used to declare a
-			variable of type StaticTask_t equals the size of the real task
-			structure. */
-			volatile size_t xSize = sizeof( StaticTask_t );
-			configASSERT( xSize == sizeof( TCB_t ) );
-			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
-		}
-		#endif /* configASSERT_DEFINED */
-
-
-		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
-		{
-			/* The memory used for the task's TCB and stack are passed into this
-			function - use them. */
-			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
-			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
-
-			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
-			{
-				/* Tasks can be created statically or dynamically, so note this
-				task was created statically in case the task is later deleted. */
-				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
-			}
-			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
-
-			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
-			prvAddNewTaskToReadyList( pxNewTCB );
-		}
-		else
-		{
-			xReturn = NULL;
-		}
-
-		return xReturn;
-	}
-
-#endif /* SUPPORT_STATIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-
-	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
-	{
-	TCB_t *pxNewTCB;
-	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
-
-		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
-		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
-
-		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
-		{
-			/* Allocate space for the TCB.  Where the memory comes from depends
-			on the implementation of the port malloc function and whether or
-			not static allocation is being used. */
-			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
-
-			/* Store the stack location in the TCB. */
-			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
-
-			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
-			{
-				/* Tasks can be created statically or dynamically, so note this
-				task was created statically in case the task is later deleted. */
-				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
-			}
-			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
-
-			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
-									pxTaskDefinition->pcName,
-									( uint32_t ) pxTaskDefinition->usStackDepth,
-									pxTaskDefinition->pvParameters,
-									pxTaskDefinition->uxPriority,
-									pxCreatedTask, pxNewTCB,
-									pxTaskDefinition->xRegions );
-
-			prvAddNewTaskToReadyList( pxNewTCB );
-			xReturn = pdPASS;
-		}
-
-		return xReturn;
-	}
-
-#endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
-/*-----------------------------------------------------------*/
-
-#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-
-	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
-	{
-	TCB_t *pxNewTCB;
-	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
-
-		configASSERT( pxTaskDefinition->puxStackBuffer );
-
-		if( pxTaskDefinition->puxStackBuffer != NULL )
-		{
-			/* Allocate space for the TCB.  Where the memory comes from depends
-			on the implementation of the port malloc function and whether or
-			not static allocation is being used. */
-			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
-
-			if( pxNewTCB != NULL )
-			{
-				/* Store the stack location in the TCB. */
-				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
-
-				#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
-				{
-					/* Tasks can be created statically or dynamically, so note
-					this task had a statically allocated stack in case it is
-					later deleted.  The TCB was allocated dynamically. */
-					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
-				}
-				#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
-
-				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
-										pxTaskDefinition->pcName,
-										( uint32_t ) pxTaskDefinition->usStackDepth,
-										pxTaskDefinition->pvParameters,
-										pxTaskDefinition->uxPriority,
-										pxCreatedTask, pxNewTCB,
-										pxTaskDefinition->xRegions );
-
-				prvAddNewTaskToReadyList( pxNewTCB );
-				xReturn = pdPASS;
-			}
-		}
-
-		return xReturn;
-	}
-
-#endif /* portUSING_MPU_WRAPPERS */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-
-	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
-							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-							const configSTACK_DEPTH_TYPE usStackDepth,
-							void * const pvParameters,
-							UBaseType_t uxPriority,
-							TaskHandle_t * const pxCreatedTask )
-	{
-	TCB_t *pxNewTCB;
-	BaseType_t xReturn;
-
-		/* If the stack grows down then allocate the stack then the TCB so the stack
-		does not grow into the TCB.  Likewise if the stack grows up then allocate
-		the TCB then the stack. */
-		#if( portSTACK_GROWTH > 0 )
-		{
-			/* Allocate space for the TCB.  Where the memory comes from depends on
-			the implementation of the port malloc function and whether or not static
-			allocation is being used. */
-			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
-
-			if( pxNewTCB != NULL )
-			{
-				/* Allocate space for the stack used by the task being created.
-				The base of the stack memory stored in the TCB so the task can
-				be deleted later if required. */
-				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-
-				if( pxNewTCB->pxStack == NULL )
-				{
-					/* Could not allocate the stack.  Delete the allocated TCB. */
-					vPortFree( pxNewTCB );
-					pxNewTCB = NULL;
-				}
-			}
-		}
-		#else /* portSTACK_GROWTH */
-		{
-		StackType_t *pxStack;
-
-			/* Allocate space for the stack used by the task being created. */
-			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
-
-			if( pxStack != NULL )
-			{
-				/* Allocate space for the TCB. */
-				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
-
-				if( pxNewTCB != NULL )
-				{
-					/* Store the stack location in the TCB. */
-					pxNewTCB->pxStack = pxStack;
-				}
-				else
-				{
-					/* The stack cannot be used as the TCB was not created.  Free
-					it again. */
-					vPortFree( pxStack );
-				}
-			}
-			else
-			{
-				pxNewTCB = NULL;
-			}
-		}
-		#endif /* portSTACK_GROWTH */
-
-		if( pxNewTCB != NULL )
-		{
-			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
-			{
-				/* Tasks can be created statically or dynamically, so note this
-				task was created dynamically in case it is later deleted. */
-				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
-			}
-			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
-
-			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
-			prvAddNewTaskToReadyList( pxNewTCB );
-			xReturn = pdPASS;
-		}
-		else
-		{
-			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
-		}
-
-		return xReturn;
-	}
-
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
-									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-									const uint32_t ulStackDepth,
-									void * const pvParameters,
-									UBaseType_t uxPriority,
-									TaskHandle_t * const pxCreatedTask,
-									TCB_t *pxNewTCB,
-									const MemoryRegion_t * const xRegions )
-{
-StackType_t *pxTopOfStack;
-UBaseType_t x;
-
-	#if( portUSING_MPU_WRAPPERS == 1 )
-		/* Should the task be created in privileged mode? */
-		BaseType_t xRunPrivileged;
-		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
-		{
-			xRunPrivileged = pdTRUE;
-		}
-		else
-		{
-			xRunPrivileged = pdFALSE;
-		}
-		uxPriority &= ~portPRIVILEGE_BIT;
-	#endif /* portUSING_MPU_WRAPPERS == 1 */
-
-	/* Avoid dependency on memset() if it is not required. */
-	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
-	{
-		/* Fill the stack with a known value to assist debugging. */
-		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
-	}
-	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
-
-	/* Calculate the top of stack address.  This depends on whether the stack
-	grows from high memory to low (as per the 80x86) or vice versa.
-	portSTACK_GROWTH is used to make the result positive or negative as required
-	by the port. */
-	#if( portSTACK_GROWTH < 0 )
-	{
-		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
-		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
-
-		/* Check the alignment of the calculated top of stack is correct. */
-		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
-
-		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
-		{
-			/* Also record the stack's high address, which may assist
-			debugging. */
-			pxNewTCB->pxEndOfStack = pxTopOfStack;
-		}
-		#endif /* configRECORD_STACK_HIGH_ADDRESS */
-	}
-	#else /* portSTACK_GROWTH */
-	{
-		pxTopOfStack = pxNewTCB->pxStack;
-
-		/* Check the alignment of the stack buffer is correct. */
-		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
-
-		/* The other extreme of the stack space is required if stack checking is
-		performed. */
-		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
-	}
-	#endif /* portSTACK_GROWTH */
-
-	/* Store the task name in the TCB. */
-	if( pcName != NULL )
-	{
-		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
-		{
-			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
-
-			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
-			configMAX_TASK_NAME_LEN characters just in case the memory after the
-			string is not accessible (extremely unlikely). */
-			if( pcName[ x ] == ( char ) 0x00 )
-			{
-				break;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-
-		/* Ensure the name string is terminated in the case that the string length
-		was greater or equal to configMAX_TASK_NAME_LEN. */
-		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
-	}
-	else
-	{
-		/* The task has not been given a name, so just ensure there is a NULL
-		terminator when it is read out. */
-		pxNewTCB->pcTaskName[ 0 ] = 0x00;
-	}
-
-	/* This is used as an array index so must ensure it's not too large.  First
-	remove the privilege bit if one is present. */
-	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
-	{
-		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	pxNewTCB->uxPriority = uxPriority;
-	#if ( configUSE_MUTEXES == 1 )
-	{
-		pxNewTCB->uxBasePriority = uxPriority;
-		pxNewTCB->uxMutexesHeld = 0;
-	}
-	#endif /* configUSE_MUTEXES */
-
-	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
-	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
-
-	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
-	back to	the containing TCB from a generic item in a list. */
-	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
-
-	/* Event lists are always in priority order. */
-	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
-
-	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
-	{
-		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
-	}
-	#endif /* portCRITICAL_NESTING_IN_TCB */
-
-	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-	{
-		pxNewTCB->pxTaskTag = NULL;
-	}
-	#endif /* configUSE_APPLICATION_TASK_TAG */
-
-	#if ( configGENERATE_RUN_TIME_STATS == 1 )
-	{
-		pxNewTCB->ulRunTimeCounter = 0UL;
-	}
-	#endif /* configGENERATE_RUN_TIME_STATS */
-
-	#if ( portUSING_MPU_WRAPPERS == 1 )
-	{
-		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
-	}
-	#else
-	{
-		/* Avoid compiler warning about unreferenced parameter. */
-		( void ) xRegions;
-	}
-	#endif
-
-	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
-	{
-		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
-		{
-			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
-		}
-	}
-	#endif
-
-	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
-	{
-		pxNewTCB->ulNotifiedValue = 0;
-		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
-	}
-	#endif
-
-	#if ( configUSE_NEWLIB_REENTRANT == 1 )
-	{
-		/* Initialise this task's Newlib reent structure.
-		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
-		for additional information. */
-		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
-	}
-	#endif
-
-	#if( INCLUDE_xTaskAbortDelay == 1 )
-	{
-		pxNewTCB->ucDelayAborted = pdFALSE;
-	}
-	#endif
-
-	/* Initialize the TCB stack to look as if the task was already running,
-	but had been interrupted by the scheduler.  The return address is set
-	to the start of the task function. Once the stack has been initialised
-	the top of stack variable is updated. */
-	#if( portUSING_MPU_WRAPPERS == 1 )
-	{
-		/* If the port has capability to detect stack overflow,
-		pass the stack end address to the stack initialization
-		function as well. */
-		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
-		{
-			#if( portSTACK_GROWTH < 0 )
-			{
-				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged );
-			}
-			#else /* portSTACK_GROWTH */
-			{
-				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );
-			}
-			#endif /* portSTACK_GROWTH */
-		}
-		#else /* portHAS_STACK_OVERFLOW_CHECKING */
-		{
-			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
-		}
-		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
-	}
-	#else /* portUSING_MPU_WRAPPERS */
-	{
-		/* If the port has capability to detect stack overflow,
-		pass the stack end address to the stack initialization
-		function as well. */
-		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
-		{
-			#if( portSTACK_GROWTH < 0 )
-			{
-				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
-			}
-			#else /* portSTACK_GROWTH */
-			{
-				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters );
-			}
-			#endif /* portSTACK_GROWTH */
-		}
-		#else /* portHAS_STACK_OVERFLOW_CHECKING */
-		{
-			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
-		}
-		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
-	}
-	#endif /* portUSING_MPU_WRAPPERS */
-
-	if( pxCreatedTask != NULL )
-	{
-		/* Pass the handle out in an anonymous way.  The handle can be used to
-		change the created task's priority, delete the created task, etc.*/
-		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
-{
-	/* Ensure interrupts don't access the task lists while the lists are being
-	updated. */
-	taskENTER_CRITICAL();
-	{
-		uxCurrentNumberOfTasks++;
-		if( pxCurrentTCB == NULL )
-		{
-			/* There are no other tasks, or all the other tasks are in
-			the suspended state - make this the current task. */
-			pxCurrentTCB = pxNewTCB;
-
-			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
-			{
-				/* This is the first task to be created so do the preliminary
-				initialisation required.  We will not recover if this call
-				fails, but we will report the failure. */
-				prvInitialiseTaskLists();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			/* If the scheduler is not already running, make this task the
-			current task if it is the highest priority task to be created
-			so far. */
-			if( xSchedulerRunning == pdFALSE )
-			{
-				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
-				{
-					pxCurrentTCB = pxNewTCB;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-
-		uxTaskNumber++;
-
-		#if ( configUSE_TRACE_FACILITY == 1 )
-		{
-			/* Add a counter into the TCB for tracing only. */
-			pxNewTCB->uxTCBNumber = uxTaskNumber;
-		}
-		#endif /* configUSE_TRACE_FACILITY */
-		traceTASK_CREATE( pxNewTCB );
-
-		prvAddTaskToReadyList( pxNewTCB );
-
-		portSETUP_TCB( pxNewTCB );
-	}
-	taskEXIT_CRITICAL();
-
-	if( xSchedulerRunning != pdFALSE )
-	{
-		/* If the created task is of a higher priority than the current task
-		then it should run now. */
-		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
-		{
-			taskYIELD_IF_USING_PREEMPTION();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskDelete == 1 )
-
-	void vTaskDelete( TaskHandle_t xTaskToDelete )
-	{
-	TCB_t *pxTCB;
-
-		taskENTER_CRITICAL();
-		{
-			/* If null is passed in here then it is the calling task that is
-			being deleted. */
-			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
-
-			/* Remove task from the ready/delayed list. */
-			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
-			{
-				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			/* Is the task waiting on an event also? */
-			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
-			{
-				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			/* Increment the uxTaskNumber also so kernel aware debuggers can
-			detect that the task lists need re-generating.  This is done before
-			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
-			not return. */
-			uxTaskNumber++;
-
-			if( pxTCB == pxCurrentTCB )
-			{
-				/* A task is deleting itself.  This cannot complete within the
-				task itself, as a context switch to another task is required.
-				Place the task in the termination list.  The idle task will
-				check the termination list and free up any memory allocated by
-				the scheduler for the TCB and stack of the deleted task. */
-				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
-
-				/* Increment the ucTasksDeleted variable so the idle task knows
-				there is a task that has been deleted and that it should therefore
-				check the xTasksWaitingTermination list. */
-				++uxDeletedTasksWaitingCleanUp;
-
-				/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
-				portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
-				traceTASK_DELETE( pxTCB );
-
-				/* The pre-delete hook is primarily for the Windows simulator,
-				in which Windows specific clean up operations are performed,
-				after which it is not possible to yield away from this task -
-				hence xYieldPending is used to latch that a context switch is
-				required. */
-				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
-			}
-			else
-			{
-				--uxCurrentNumberOfTasks;
-				traceTASK_DELETE( pxTCB );
-				prvDeleteTCB( pxTCB );
-
-				/* Reset the next expected unblock time in case it referred to
-				the task that has just been deleted. */
-				prvResetNextTaskUnblockTime();
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		/* Force a reschedule if it is the currently running task that has just
-		been deleted. */
-		if( xSchedulerRunning != pdFALSE )
-		{
-			if( pxTCB == pxCurrentTCB )
-			{
-				configASSERT( uxSchedulerSuspended == 0 );
-				portYIELD_WITHIN_API();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-	}
-
-#endif /* INCLUDE_vTaskDelete */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskDelayUntil == 1 )
-
-	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
-	{
-	TickType_t xTimeToWake;
-	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
-
-		configASSERT( pxPreviousWakeTime );
-		configASSERT( ( xTimeIncrement > 0U ) );
-		configASSERT( uxSchedulerSuspended == 0 );
-
-		vTaskSuspendAll();
-		{
-			/* Minor optimisation.  The tick count cannot change in this
-			block. */
-			const TickType_t xConstTickCount = xTickCount;
-
-			/* Generate the tick time at which the task wants to wake. */
-			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
-
-			if( xConstTickCount < *pxPreviousWakeTime )
-			{
-				/* The tick count has overflowed since this function was
-				lasted called.  In this case the only time we should ever
-				actually delay is if the wake time has also	overflowed,
-				and the wake time is greater than the tick time.  When this
-				is the case it is as if neither time had overflowed. */
-				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
-				{
-					xShouldDelay = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				/* The tick time has not overflowed.  In this case we will
-				delay if either the wake time has overflowed, and/or the
-				tick time is less than the wake time. */
-				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
-				{
-					xShouldDelay = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-
-			/* Update the wake time ready for the next call. */
-			*pxPreviousWakeTime = xTimeToWake;
-
-			if( xShouldDelay != pdFALSE )
-			{
-				traceTASK_DELAY_UNTIL( xTimeToWake );
-
-				/* prvAddCurrentTaskToDelayedList() needs the block time, not
-				the time to wake, so subtract the current tick count. */
-				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		xAlreadyYielded = xTaskResumeAll();
-
-		/* Force a reschedule if xTaskResumeAll has not already done so, we may
-		have put ourselves to sleep. */
-		if( xAlreadyYielded == pdFALSE )
-		{
-			portYIELD_WITHIN_API();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* INCLUDE_vTaskDelayUntil */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskDelay == 1 )
-
-	void vTaskDelay( const TickType_t xTicksToDelay )
-	{
-	BaseType_t xAlreadyYielded = pdFALSE;
-
-		/* A delay time of zero just forces a reschedule. */
-		if( xTicksToDelay > ( TickType_t ) 0U )
-		{
-			configASSERT( uxSchedulerSuspended == 0 );
-			vTaskSuspendAll();
-			{
-				traceTASK_DELAY();
-
-				/* A task that is removed from the event list while the
-				scheduler is suspended will not get placed in the ready
-				list or removed from the blocked list until the scheduler
-				is resumed.
-
-				This task cannot be in an event list as it is the currently
-				executing task. */
-				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
-			}
-			xAlreadyYielded = xTaskResumeAll();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		/* Force a reschedule if xTaskResumeAll has not already done so, we may
-		have put ourselves to sleep. */
-		if( xAlreadyYielded == pdFALSE )
-		{
-			portYIELD_WITHIN_API();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* INCLUDE_vTaskDelay */
-/*-----------------------------------------------------------*/
-
-#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )
-
-	eTaskState eTaskGetState( TaskHandle_t xTask )
-	{
-	eTaskState eReturn;
-	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
-	const TCB_t * const pxTCB = xTask;
-
-		configASSERT( pxTCB );
-
-		if( pxTCB == pxCurrentTCB )
-		{
-			/* The task calling this function is querying its own state. */
-			eReturn = eRunning;
-		}
-		else
-		{
-			taskENTER_CRITICAL();
-			{
-				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
-				pxDelayedList = pxDelayedTaskList;
-				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
-			}
-			taskEXIT_CRITICAL();
-
-			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
-			{
-				/* The task being queried is referenced from one of the Blocked
-				lists. */
-				eReturn = eBlocked;
-			}
-
-			#if ( INCLUDE_vTaskSuspend == 1 )
-				else if( pxStateList == &xSuspendedTaskList )
-				{
-					/* The task being queried is referenced from the suspended
-					list.  Is it genuinely suspended or is it blocked
-					indefinitely? */
-					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
-					{
-						#if( configUSE_TASK_NOTIFICATIONS == 1 )
-						{
-							/* The task does not appear on the event list item of
-							and of the RTOS objects, but could still be in the
-							blocked state if it is waiting on its notification
-							rather than waiting on an object. */
-							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
-							{
-								eReturn = eBlocked;
-							}
-							else
-							{
-								eReturn = eSuspended;
-							}
-						}
-						#else
-						{
-							eReturn = eSuspended;
-						}
-						#endif
-					}
-					else
-					{
-						eReturn = eBlocked;
-					}
-				}
-			#endif
-
-			#if ( INCLUDE_vTaskDelete == 1 )
-				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
-				{
-					/* The task being queried is referenced from the deleted
-					tasks list, or it is not referenced from any lists at
-					all. */
-					eReturn = eDeleted;
-				}
-			#endif
-
-			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
-			{
-				/* If the task is not in any other state, it must be in the
-				Ready (including pending ready) state. */
-				eReturn = eReady;
-			}
-		}
-
-		return eReturn;
-	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
-
-#endif /* INCLUDE_eTaskGetState */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_uxTaskPriorityGet == 1 )
-
-	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
-	{
-	TCB_t const *pxTCB;
-	UBaseType_t uxReturn;
-
-		taskENTER_CRITICAL();
-		{
-			/* If null is passed in here then it is the priority of the task
-			that called uxTaskPriorityGet() that is being queried. */
-			pxTCB = prvGetTCBFromHandle( xTask );
-			uxReturn = pxTCB->uxPriority;
-		}
-		taskEXIT_CRITICAL();
-
-		return uxReturn;
-	}
-
-#endif /* INCLUDE_uxTaskPriorityGet */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_uxTaskPriorityGet == 1 )
-
-	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
-	{
-	TCB_t const *pxTCB;
-	UBaseType_t uxReturn, uxSavedInterruptState;
-
-		/* RTOS ports that support interrupt nesting have the concept of a
-		maximum	system call (or maximum API call) interrupt priority.
-		Interrupts that are	above the maximum system call priority are keep
-		permanently enabled, even when the RTOS kernel is in a critical section,
-		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
-		is defined in FreeRTOSConfig.h then
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-		failure if a FreeRTOS API function is called from an interrupt that has
-		been assigned a priority above the configured maximum system call
-		priority.  Only FreeRTOS functions that end in FromISR can be called
-		from interrupts	that have been assigned a priority at or (logically)
-		below the maximum system call interrupt priority.  FreeRTOS maintains a
-		separate interrupt safe API to ensure interrupt entry is as fast and as
-		simple as possible.  More information (albeit Cortex-M specific) is
-		provided on the following link:
-		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
-		{
-			/* If null is passed in here then it is the priority of the calling
-			task that is being queried. */
-			pxTCB = prvGetTCBFromHandle( xTask );
-			uxReturn = pxTCB->uxPriority;
-		}
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
-
-		return uxReturn;
-	}
-
-#endif /* INCLUDE_uxTaskPriorityGet */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskPrioritySet == 1 )
-
-	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
-	{
-	TCB_t *pxTCB;
-	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
-	BaseType_t xYieldRequired = pdFALSE;
-
-		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
-
-		/* Ensure the new priority is valid. */
-		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
-		{
-			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		taskENTER_CRITICAL();
-		{
-			/* If null is passed in here then it is the priority of the calling
-			task that is being changed. */
-			pxTCB = prvGetTCBFromHandle( xTask );
-
-			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
-
-			#if ( configUSE_MUTEXES == 1 )
-			{
-				uxCurrentBasePriority = pxTCB->uxBasePriority;
-			}
-			#else
-			{
-				uxCurrentBasePriority = pxTCB->uxPriority;
-			}
-			#endif
-
-			if( uxCurrentBasePriority != uxNewPriority )
-			{
-				/* The priority change may have readied a task of higher
-				priority than the calling task. */
-				if( uxNewPriority > uxCurrentBasePriority )
-				{
-					if( pxTCB != pxCurrentTCB )
-					{
-						/* The priority of a task other than the currently
-						running task is being raised.  Is the priority being
-						raised above that of the running task? */
-						if( uxNewPriority >= pxCurrentTCB->uxPriority )
-						{
-							xYieldRequired = pdTRUE;
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						/* The priority of the running task is being raised,
-						but the running task must already be the highest
-						priority task able to run so no yield is required. */
-					}
-				}
-				else if( pxTCB == pxCurrentTCB )
-				{
-					/* Setting the priority of the running task down means
-					there may now be another task of higher priority that
-					is ready to execute. */
-					xYieldRequired = pdTRUE;
-				}
-				else
-				{
-					/* Setting the priority of any other task down does not
-					require a yield as the running task must be above the
-					new priority of the task being modified. */
-				}
-
-				/* Remember the ready list the task might be referenced from
-				before its uxPriority member is changed so the
-				taskRESET_READY_PRIORITY() macro can function correctly. */
-				uxPriorityUsedOnEntry = pxTCB->uxPriority;
-
-				#if ( configUSE_MUTEXES == 1 )
-				{
-					/* Only change the priority being used if the task is not
-					currently using an inherited priority. */
-					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
-					{
-						pxTCB->uxPriority = uxNewPriority;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* The base priority gets set whatever. */
-					pxTCB->uxBasePriority = uxNewPriority;
-				}
-				#else
-				{
-					pxTCB->uxPriority = uxNewPriority;
-				}
-				#endif
-
-				/* Only reset the event list item value if the value is not
-				being used for anything else. */
-				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
-				{
-					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* If the task is in the blocked or suspended list we need do
-				nothing more than change its priority variable. However, if
-				the task is in a ready list it needs to be removed and placed
-				in the list appropriate to its new priority. */
-				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
-				{
-					/* The task is currently in its ready list - remove before
-					adding it to it's new ready list.  As we are in a critical
-					section we can do this even if the scheduler is suspended. */
-					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
-					{
-						/* It is known that the task is in its ready list so
-						there is no need to check again and the port level
-						reset macro can be called directly. */
-						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-					prvAddTaskToReadyList( pxTCB );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				if( xYieldRequired != pdFALSE )
-				{
-					taskYIELD_IF_USING_PREEMPTION();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* Remove compiler warning about unused variables when the port
-				optimised task selection is not being used. */
-				( void ) uxPriorityUsedOnEntry;
-			}
-		}
-		taskEXIT_CRITICAL();
-	}
-
-#endif /* INCLUDE_vTaskPrioritySet */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskSuspend == 1 )
-
-	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
-	{
-	TCB_t *pxTCB;
-
-		taskENTER_CRITICAL();
-		{
-			/* If null is passed in here then it is the running task that is
-			being suspended. */
-			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
-
-			traceTASK_SUSPEND( pxTCB );
-
-			/* Remove task from the ready/delayed list and place in the
-			suspended list. */
-			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
-			{
-				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			/* Is the task waiting on an event also? */
-			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
-			{
-				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
-
-			#if( configUSE_TASK_NOTIFICATIONS == 1 )
-			{
-				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
-				{
-					/* The task was blocked to wait for a notification, but is
-					now suspended, so no notification was received. */
-					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
-				}
-			}
-			#endif
-		}
-		taskEXIT_CRITICAL();
-
-		if( xSchedulerRunning != pdFALSE )
-		{
-			/* Reset the next expected unblock time in case it referred to the
-			task that is now in the Suspended state. */
-			taskENTER_CRITICAL();
-			{
-				prvResetNextTaskUnblockTime();
-			}
-			taskEXIT_CRITICAL();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		if( pxTCB == pxCurrentTCB )
-		{
-			if( xSchedulerRunning != pdFALSE )
-			{
-				/* The current task has just been suspended. */
-				configASSERT( uxSchedulerSuspended == 0 );
-				portYIELD_WITHIN_API();
-			}
-			else
-			{
-				/* The scheduler is not running, but the task that was pointed
-				to by pxCurrentTCB has just been suspended and pxCurrentTCB
-				must be adjusted to point to a different task. */
-				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
-				{
-					/* No other tasks are ready, so set pxCurrentTCB back to
-					NULL so when the next task is created pxCurrentTCB will
-					be set to point to it no matter what its relative priority
-					is. */
-					pxCurrentTCB = NULL;
-				}
-				else
-				{
-					vTaskSwitchContext();
-				}
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* INCLUDE_vTaskSuspend */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskSuspend == 1 )
-
-	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
-	{
-	BaseType_t xReturn = pdFALSE;
-	const TCB_t * const pxTCB = xTask;
-
-		/* Accesses xPendingReadyList so must be called from a critical
-		section. */
-
-		/* It does not make sense to check if the calling task is suspended. */
-		configASSERT( xTask );
-
-		/* Is the task being resumed actually in the suspended list? */
-		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
-		{
-			/* Has the task already been resumed from within an ISR? */
-			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
-			{
-				/* Is it in the suspended list because it is in the	Suspended
-				state, or because is is blocked with no timeout? */
-				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
-				{
-					xReturn = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return xReturn;
-	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
-
-#endif /* INCLUDE_vTaskSuspend */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskSuspend == 1 )
-
-	void vTaskResume( TaskHandle_t xTaskToResume )
-	{
-	TCB_t * const pxTCB = xTaskToResume;
-
-		/* It does not make sense to resume the calling task. */
-		configASSERT( xTaskToResume );
-
-		/* The parameter cannot be NULL as it is impossible to resume the
-		currently executing task. */
-		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
-		{
-			taskENTER_CRITICAL();
-			{
-				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
-				{
-					traceTASK_RESUME( pxTCB );
-
-					/* The ready list can be accessed even if the scheduler is
-					suspended because this is inside a critical section. */
-					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
-					prvAddTaskToReadyList( pxTCB );
-
-					/* A higher priority task may have just been resumed. */
-					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
-					{
-						/* This yield may not cause the task just resumed to run,
-						but will leave the lists in the correct state for the
-						next yield. */
-						taskYIELD_IF_USING_PREEMPTION();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			taskEXIT_CRITICAL();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* INCLUDE_vTaskSuspend */
-
-/*-----------------------------------------------------------*/
-
-#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
-
-	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
-	{
-	BaseType_t xYieldRequired = pdFALSE;
-	TCB_t * const pxTCB = xTaskToResume;
-	UBaseType_t uxSavedInterruptStatus;
-
-		configASSERT( xTaskToResume );
-
-		/* RTOS ports that support interrupt nesting have the concept of a
-		maximum	system call (or maximum API call) interrupt priority.
-		Interrupts that are	above the maximum system call priority are keep
-		permanently enabled, even when the RTOS kernel is in a critical section,
-		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
-		is defined in FreeRTOSConfig.h then
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-		failure if a FreeRTOS API function is called from an interrupt that has
-		been assigned a priority above the configured maximum system call
-		priority.  Only FreeRTOS functions that end in FromISR can be called
-		from interrupts	that have been assigned a priority at or (logically)
-		below the maximum system call interrupt priority.  FreeRTOS maintains a
-		separate interrupt safe API to ensure interrupt entry is as fast and as
-		simple as possible.  More information (albeit Cortex-M specific) is
-		provided on the following link:
-		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-		{
-			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
-			{
-				traceTASK_RESUME_FROM_ISR( pxTCB );
-
-				/* Check the ready lists can be accessed. */
-				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
-				{
-					/* Ready lists can be accessed so move the task from the
-					suspended list to the ready list directly. */
-					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
-					{
-						xYieldRequired = pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-					prvAddTaskToReadyList( pxTCB );
-				}
-				else
-				{
-					/* The delayed or ready lists cannot be accessed so the task
-					is held in the pending ready list until the scheduler is
-					unsuspended. */
-					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-		return xYieldRequired;
-	}
-
-#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
-/*-----------------------------------------------------------*/
-
-void vTaskStartScheduler( void )
-{
-BaseType_t xReturn;
-
-	/* Add the idle task at the lowest priority. */
-	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	{
-		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
-		StackType_t *pxIdleTaskStackBuffer = NULL;
-		uint32_t ulIdleTaskStackSize;
-
-		/* The Idle task is created using user provided RAM - obtain the
-		address of the RAM then create the idle task. */
-		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
-		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
-												configIDLE_TASK_NAME,
-												ulIdleTaskStackSize,
-												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
-												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
-												pxIdleTaskStackBuffer,
-												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
-
-		if( xIdleTaskHandle != NULL )
-		{
-			xReturn = pdPASS;
-		}
-		else
-		{
-			xReturn = pdFAIL;
-		}
-	}
-	#else
-	{
-		/* The Idle task is being created using dynamically allocated RAM. */
-		xReturn = xTaskCreate(	prvIdleTask,
-								configIDLE_TASK_NAME,
-								configMINIMAL_STACK_SIZE,
-								( void * ) NULL,
-								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
-								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
-	}
-	#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-	#if ( configUSE_TIMERS == 1 )
-	{
-		if( xReturn == pdPASS )
-		{
-			xReturn = xTimerCreateTimerTask();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	#endif /* configUSE_TIMERS */
-
-	if( xReturn == pdPASS )
-	{
-		/* freertos_tasks_c_additions_init() should only be called if the user
-		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
-		the only macro called by the function. */
-		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
-		{
-			freertos_tasks_c_additions_init();
-		}
-		#endif
-
-		/* Interrupts are turned off here, to ensure a tick does not occur
-		before or during the call to xPortStartScheduler().  The stacks of
-		the created tasks contain a status word with interrupts switched on
-		so interrupts will automatically get re-enabled when the first task
-		starts to run. */
-		portDISABLE_INTERRUPTS();
-
-		#if ( configUSE_NEWLIB_REENTRANT == 1 )
-		{
-			/* Switch Newlib's _impure_ptr variable to point to the _reent
-			structure specific to the task that will run first.
-			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
-			for additional information. */
-			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
-		}
-		#endif /* configUSE_NEWLIB_REENTRANT */
-
-		xNextTaskUnblockTime = portMAX_DELAY;
-		xSchedulerRunning = pdTRUE;
-		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
-
-		/* If configGENERATE_RUN_TIME_STATS is defined then the following
-		macro must be defined to configure the timer/counter used to generate
-		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
-		is set to 0 and the following line fails to build then ensure you do not
-		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
-		FreeRTOSConfig.h file. */
-		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
-
-		traceTASK_SWITCHED_IN();
-
-		/* Setting up the timer tick is hardware specific and thus in the
-		portable interface. */
-		if( xPortStartScheduler() != pdFALSE )
-		{
-			/* Should not reach here as if the scheduler is running the
-			function will not return. */
-		}
-		else
-		{
-			/* Should only reach here if a task calls xTaskEndScheduler(). */
-		}
-	}
-	else
-	{
-		/* This line will only be reached if the kernel could not be started,
-		because there was not enough FreeRTOS heap to create the idle task
-		or the timer task. */
-		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
-	}
-
-	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
-	meaning xIdleTaskHandle is not used anywhere else. */
-	( void ) xIdleTaskHandle;
-}
-/*-----------------------------------------------------------*/
-
-void vTaskEndScheduler( void )
-{
-	/* Stop the scheduler interrupts and call the portable scheduler end
-	routine so the original ISRs can be restored if necessary.  The port
-	layer must ensure interrupts enable	bit is left in the correct state. */
-	portDISABLE_INTERRUPTS();
-	xSchedulerRunning = pdFALSE;
-	vPortEndScheduler();
-}
-/*----------------------------------------------------------*/
-
-void vTaskSuspendAll( void )
-{
-	/* A critical section is not required as the variable is of type
-	BaseType_t.  Please read Richard Barry's reply in the following link to a
-	post in the FreeRTOS support forum before reporting this as a bug! -
-	http://goo.gl/wu4acr */
-
-	/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
-	do not otherwise exhibit real time behaviour. */
-	portSOFTWARE_BARRIER();
-
-	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
-	is used to allow calls to vTaskSuspendAll() to nest. */
-	++uxSchedulerSuspended;
-
-	/* Enforces ordering for ports and optimised compilers that may otherwise place
-	the above increment elsewhere. */
-	portMEMORY_BARRIER();
-}
-/*----------------------------------------------------------*/
-
-#if ( configUSE_TICKLESS_IDLE != 0 )
-
-	static TickType_t prvGetExpectedIdleTime( void )
-	{
-	TickType_t xReturn;
-	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
-
-		/* uxHigherPriorityReadyTasks takes care of the case where
-		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
-		task that are in the Ready state, even though the idle task is
-		running. */
-		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
-		{
-			if( uxTopReadyPriority > tskIDLE_PRIORITY )
-			{
-				uxHigherPriorityReadyTasks = pdTRUE;
-			}
-		}
-		#else
-		{
-			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
-
-			/* When port optimised task selection is used the uxTopReadyPriority
-			variable is used as a bit map.  If bits other than the least
-			significant bit are set then there are tasks that have a priority
-			above the idle priority that are in the Ready state.  This takes
-			care of the case where the co-operative scheduler is in use. */
-			if( uxTopReadyPriority > uxLeastSignificantBit )
-			{
-				uxHigherPriorityReadyTasks = pdTRUE;
-			}
-		}
-		#endif
-
-		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
-		{
-			xReturn = 0;
-		}
-		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
-		{
-			/* There are other idle priority tasks in the ready state.  If
-			time slicing is used then the very next tick interrupt must be
-			processed. */
-			xReturn = 0;
-		}
-		else if( uxHigherPriorityReadyTasks != pdFALSE )
-		{
-			/* There are tasks in the Ready state that have a priority above the
-			idle priority.  This path can only be reached if
-			configUSE_PREEMPTION is 0. */
-			xReturn = 0;
-		}
-		else
-		{
-			xReturn = xNextTaskUnblockTime - xTickCount;
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
-/*----------------------------------------------------------*/
-
-BaseType_t xTaskResumeAll( void )
-{
-TCB_t *pxTCB = NULL;
-BaseType_t xAlreadyYielded = pdFALSE;
-
-	/* If uxSchedulerSuspended is zero then this function does not match a
-	previous call to vTaskSuspendAll(). */
-	configASSERT( uxSchedulerSuspended );
-
-	/* It is possible that an ISR caused a task to be removed from an event
-	list while the scheduler was suspended.  If this was the case then the
-	removed task will have been added to the xPendingReadyList.  Once the
-	scheduler has been resumed it is safe to move all the pending ready
-	tasks from this list into their appropriate ready list. */
-	taskENTER_CRITICAL();
-	{
-		--uxSchedulerSuspended;
-
-		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
-		{
-			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
-			{
-				/* Move any readied tasks from the pending list into the
-				appropriate ready list. */
-				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
-				{
-					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
-					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-					prvAddTaskToReadyList( pxTCB );
-
-					/* If the moved task has a priority higher than the current
-					task then a yield must be performed. */
-					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
-					{
-						xYieldPending = pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-
-				if( pxTCB != NULL )
-				{
-					/* A task was unblocked while the scheduler was suspended,
-					which may have prevented the next unblock time from being
-					re-calculated, in which case re-calculate it now.  Mainly
-					important for low power tickless implementations, where
-					this can prevent an unnecessary exit from low power
-					state. */
-					prvResetNextTaskUnblockTime();
-				}
-
-				/* If any ticks occurred while the scheduler was suspended then
-				they should be processed now.  This ensures the tick count does
-				not	slip, and that any delayed tasks are resumed at the correct
-				time. */
-				{
-					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
-
-					if( xPendedCounts > ( TickType_t ) 0U )
-					{
-						do
-						{
-							if( xTaskIncrementTick() != pdFALSE )
-							{
-								xYieldPending = pdTRUE;
-							}
-							else
-							{
-								mtCOVERAGE_TEST_MARKER();
-							}
-							--xPendedCounts;
-						} while( xPendedCounts > ( TickType_t ) 0U );
-
-						xPendedTicks = 0;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-
-				if( xYieldPending != pdFALSE )
-				{
-					#if( configUSE_PREEMPTION != 0 )
-					{
-						xAlreadyYielded = pdTRUE;
-					}
-					#endif
-					taskYIELD_IF_USING_PREEMPTION();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	return xAlreadyYielded;
-}
-/*-----------------------------------------------------------*/
-
-TickType_t xTaskGetTickCount( void )
-{
-TickType_t xTicks;
-
-	/* Critical section required if running on a 16 bit processor. */
-	portTICK_TYPE_ENTER_CRITICAL();
-	{
-		xTicks = xTickCount;
-	}
-	portTICK_TYPE_EXIT_CRITICAL();
-
-	return xTicks;
-}
-/*-----------------------------------------------------------*/
-
-TickType_t xTaskGetTickCountFromISR( void )
-{
-TickType_t xReturn;
-UBaseType_t uxSavedInterruptStatus;
-
-	/* RTOS ports that support interrupt nesting have the concept of a maximum
-	system call (or maximum API call) interrupt priority.  Interrupts that are
-	above the maximum system call priority are kept permanently enabled, even
-	when the RTOS kernel is in a critical section, but cannot make any calls to
-	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
-	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-	failure if a FreeRTOS API function is called from an interrupt that has been
-	assigned a priority above the configured maximum system call priority.
-	Only FreeRTOS functions that end in FromISR can be called from interrupts
-	that have been assigned a priority at or (logically) below the maximum
-	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
-	safe API to ensure interrupt entry is as fast and as simple as possible.
-	More information (albeit Cortex-M specific) is provided on the following
-	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
-	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
-	{
-		xReturn = xTickCount;
-	}
-	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-UBaseType_t uxTaskGetNumberOfTasks( void )
-{
-	/* A critical section is not required because the variables are of type
-	BaseType_t. */
-	return uxCurrentNumberOfTasks;
-}
-/*-----------------------------------------------------------*/
-
-char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-{
-TCB_t *pxTCB;
-
-	/* If null is passed in here then the name of the calling task is being
-	queried. */
-	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
-	configASSERT( pxTCB );
-	return &( pxTCB->pcTaskName[ 0 ] );
-}
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskGetHandle == 1 )
-
-	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
-	{
-	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
-	UBaseType_t x;
-	char cNextChar;
-	BaseType_t xBreakLoop;
-
-		/* This function is called with the scheduler suspended. */
-
-		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
-		{
-			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-
-			do
-			{
-				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-
-				/* Check each character in the name looking for a match or
-				mismatch. */
-				xBreakLoop = pdFALSE;
-				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
-				{
-					cNextChar = pxNextTCB->pcTaskName[ x ];
-
-					if( cNextChar != pcNameToQuery[ x ] )
-					{
-						/* Characters didn't match. */
-						xBreakLoop = pdTRUE;
-					}
-					else if( cNextChar == ( char ) 0x00 )
-					{
-						/* Both strings terminated, a match must have been
-						found. */
-						pxReturn = pxNextTCB;
-						xBreakLoop = pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					if( xBreakLoop != pdFALSE )
-					{
-						break;
-					}
-				}
-
-				if( pxReturn != NULL )
-				{
-					/* The handle has been found. */
-					break;
-				}
-
-			} while( pxNextTCB != pxFirstTCB );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return pxReturn;
-	}
-
-#endif /* INCLUDE_xTaskGetHandle */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskGetHandle == 1 )
-
-	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	{
-	UBaseType_t uxQueue = configMAX_PRIORITIES;
-	TCB_t* pxTCB;
-
-		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
-		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
-
-		vTaskSuspendAll();
-		{
-			/* Search the ready lists. */
-			do
-			{
-				uxQueue--;
-				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
-
-				if( pxTCB != NULL )
-				{
-					/* Found the handle. */
-					break;
-				}
-
-			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-
-			/* Search the delayed lists. */
-			if( pxTCB == NULL )
-			{
-				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
-			}
-
-			if( pxTCB == NULL )
-			{
-				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
-			}
-
-			#if ( INCLUDE_vTaskSuspend == 1 )
-			{
-				if( pxTCB == NULL )
-				{
-					/* Search the suspended list. */
-					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
-				}
-			}
-			#endif
-
-			#if( INCLUDE_vTaskDelete == 1 )
-			{
-				if( pxTCB == NULL )
-				{
-					/* Search the deleted list. */
-					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
-				}
-			}
-			#endif
-		}
-		( void ) xTaskResumeAll();
-
-		return pxTCB;
-	}
-
-#endif /* INCLUDE_xTaskGetHandle */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
-	{
-	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
-
-		vTaskSuspendAll();
-		{
-			/* Is there a space in the array for each task in the system? */
-			if( uxArraySize >= uxCurrentNumberOfTasks )
-			{
-				/* Fill in an TaskStatus_t structure with information on each
-				task in the Ready state. */
-				do
-				{
-					uxQueue--;
-					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
-
-				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-
-				/* Fill in an TaskStatus_t structure with information on each
-				task in the Blocked state. */
-				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
-				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
-
-				#if( INCLUDE_vTaskDelete == 1 )
-				{
-					/* Fill in an TaskStatus_t structure with information on
-					each task that has been deleted but not yet cleaned up. */
-					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
-				}
-				#endif
-
-				#if ( INCLUDE_vTaskSuspend == 1 )
-				{
-					/* Fill in an TaskStatus_t structure with information on
-					each task in the Suspended state. */
-					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
-				}
-				#endif
-
-				#if ( configGENERATE_RUN_TIME_STATS == 1)
-				{
-					if( pulTotalRunTime != NULL )
-					{
-						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
-							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
-						#else
-							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
-						#endif
-					}
-				}
-				#else
-				{
-					if( pulTotalRunTime != NULL )
-					{
-						*pulTotalRunTime = 0;
-					}
-				}
-				#endif
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		( void ) xTaskResumeAll();
-
-		return uxTask;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
-
-	TaskHandle_t xTaskGetIdleTaskHandle( void )
-	{
-		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
-		started, then xIdleTaskHandle will be NULL. */
-		configASSERT( ( xIdleTaskHandle != NULL ) );
-		return xIdleTaskHandle;
-	}
-
-#endif /* INCLUDE_xTaskGetIdleTaskHandle */
-/*----------------------------------------------------------*/
-
-/* This conditional compilation should use inequality to 0, not equality to 1.
-This is to ensure vTaskStepTick() is available when user defined low power mode
-implementations require configUSE_TICKLESS_IDLE to be set to a value other than
-1. */
-#if ( configUSE_TICKLESS_IDLE != 0 )
-
-	void vTaskStepTick( const TickType_t xTicksToJump )
-	{
-		/* Correct the tick count value after a period during which the tick
-		was suppressed.  Note this does *not* call the tick hook function for
-		each stepped tick. */
-		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
-		xTickCount += xTicksToJump;
-		traceINCREASE_TICK_COUNT( xTicksToJump );
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
-/*----------------------------------------------------------*/
-
-BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
-{
-BaseType_t xYieldRequired = pdFALSE;
-
-	/* Must not be called with the scheduler suspended as the implementation
-	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
-	configASSERT( uxSchedulerSuspended == 0 );
-
-	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
-	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
-	vTaskSuspendAll();
-	xPendedTicks += xTicksToCatchUp;
-	xYieldRequired = xTaskResumeAll();
-
-	return xYieldRequired;
-}
-/*----------------------------------------------------------*/
-
-#if ( INCLUDE_xTaskAbortDelay == 1 )
-
-	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
-	{
-	TCB_t *pxTCB = xTask;
-	BaseType_t xReturn;
-
-		configASSERT( pxTCB );
-
-		vTaskSuspendAll();
-		{
-			/* A task can only be prematurely removed from the Blocked state if
-			it is actually in the Blocked state. */
-			if( eTaskGetState( xTask ) == eBlocked )
-			{
-				xReturn = pdPASS;
-
-				/* Remove the reference to the task from the blocked list.  An
-				interrupt won't touch the xStateListItem because the
-				scheduler is suspended. */
-				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-
-				/* Is the task waiting on an event also?  If so remove it from
-				the event list too.  Interrupts can touch the event list item,
-				even though the scheduler is suspended, so a critical section
-				is used. */
-				taskENTER_CRITICAL();
-				{
-					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
-					{
-						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
-
-						/* This lets the task know it was forcibly removed from the
-						blocked state so it should not re-evaluate its block time and
-						then block again. */
-						pxTCB->ucDelayAborted = pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				taskEXIT_CRITICAL();
-
-				/* Place the unblocked task into the appropriate ready list. */
-				prvAddTaskToReadyList( pxTCB );
-
-				/* A task being unblocked cannot cause an immediate context
-				switch if preemption is turned off. */
-				#if (  configUSE_PREEMPTION == 1 )
-				{
-					/* Preemption is on, but a context switch should only be
-					performed if the unblocked task has a priority that is
-					equal to or higher than the currently executing task. */
-					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
-					{
-						/* Pend the yield to be performed when the scheduler
-						is unsuspended. */
-						xYieldPending = pdTRUE;
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				#endif /* configUSE_PREEMPTION */
-			}
-			else
-			{
-				xReturn = pdFAIL;
-			}
-		}
-		( void ) xTaskResumeAll();
-
-		return xReturn;
-	}
-
-#endif /* INCLUDE_xTaskAbortDelay */
-/*----------------------------------------------------------*/
-
-BaseType_t xTaskIncrementTick( void )
-{
-TCB_t * pxTCB;
-TickType_t xItemValue;
-BaseType_t xSwitchRequired = pdFALSE;
-
-	/* Called by the portable layer each time a tick interrupt occurs.
-	Increments the tick then checks to see if the new tick value will cause any
-	tasks to be unblocked. */
-	traceTASK_INCREMENT_TICK( xTickCount );
-	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
-	{
-		/* Minor optimisation.  The tick count cannot change in this
-		block. */
-		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
-
-		/* Increment the RTOS tick, switching the delayed and overflowed
-		delayed lists if it wraps to 0. */
-		xTickCount = xConstTickCount;
-
-		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
-		{
-			taskSWITCH_DELAYED_LISTS();
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		/* See if this tick has made a timeout expire.  Tasks are stored in
-		the	queue in the order of their wake time - meaning once one task
-		has been found whose block time has not expired there is no need to
-		look any further down the list. */
-		if( xConstTickCount >= xNextTaskUnblockTime )
-		{
-			for( ;; )
-			{
-				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
-				{
-					/* The delayed list is empty.  Set xNextTaskUnblockTime
-					to the maximum possible value so it is extremely
-					unlikely that the
-					if( xTickCount >= xNextTaskUnblockTime ) test will pass
-					next time through. */
-					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-					break;
-				}
-				else
-				{
-					/* The delayed list is not empty, get the value of the
-					item at the head of the delayed list.  This is the time
-					at which the task at the head of the delayed list must
-					be removed from the Blocked state. */
-					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
-
-					if( xConstTickCount < xItemValue )
-					{
-						/* It is not time to unblock this item yet, but the
-						item value is the time at which the task at the head
-						of the blocked list must be removed from the Blocked
-						state -	so record the item value in
-						xNextTaskUnblockTime. */
-						xNextTaskUnblockTime = xItemValue;
-						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* It is time to remove the item from the Blocked state. */
-					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-
-					/* Is the task waiting on an event also?  If so remove
-					it from the event list. */
-					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
-					{
-						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* Place the unblocked task into the appropriate ready
-					list. */
-					prvAddTaskToReadyList( pxTCB );
-
-					/* A task being unblocked cannot cause an immediate
-					context switch if preemption is turned off. */
-					#if (  configUSE_PREEMPTION == 1 )
-					{
-						/* Preemption is on, but a context switch should
-						only be performed if the unblocked task has a
-						priority that is equal to or higher than the
-						currently executing task. */
-						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
-						{
-							xSwitchRequired = pdTRUE;
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					#endif /* configUSE_PREEMPTION */
-				}
-			}
-		}
-
-		/* Tasks of equal priority to the currently running task will share
-		processing time (time slice) if preemption is on, and the application
-		writer has not explicitly turned time slicing off. */
-		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
-		{
-			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
-			{
-				xSwitchRequired = pdTRUE;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
-
-		#if ( configUSE_TICK_HOOK == 1 )
-		{
-			/* Guard against the tick hook being called when the pended tick
-			count is being unwound (when the scheduler is being unlocked). */
-			if( xPendedTicks == ( TickType_t ) 0 )
-			{
-				vApplicationTickHook();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* configUSE_TICK_HOOK */
-
-		#if ( configUSE_PREEMPTION == 1 )
-		{
-			if( xYieldPending != pdFALSE )
-			{
-				xSwitchRequired = pdTRUE;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* configUSE_PREEMPTION */
-	}
-	else
-	{
-		++xPendedTicks;
-
-		/* The tick hook gets called at regular intervals, even if the
-		scheduler is locked. */
-		#if ( configUSE_TICK_HOOK == 1 )
-		{
-			vApplicationTickHook();
-		}
-		#endif
-	}
-
-	return xSwitchRequired;
-}
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-
-	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
-	{
-	TCB_t *xTCB;
-
-		/* If xTask is NULL then it is the task hook of the calling task that is
-		getting set. */
-		if( xTask == NULL )
-		{
-			xTCB = ( TCB_t * ) pxCurrentTCB;
-		}
-		else
-		{
-			xTCB = xTask;
-		}
-
-		/* Save the hook function in the TCB.  A critical section is required as
-		the value can be accessed from an interrupt. */
-		taskENTER_CRITICAL();
-		{
-			xTCB->pxTaskTag = pxHookFunction;
-		}
-		taskEXIT_CRITICAL();
-	}
-
-#endif /* configUSE_APPLICATION_TASK_TAG */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-
-	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
-	{
-	TCB_t *pxTCB;
-	TaskHookFunction_t xReturn;
-
-		/* If xTask is NULL then set the calling task's hook. */
-		pxTCB = prvGetTCBFromHandle( xTask );
-
-		/* Save the hook function in the TCB.  A critical section is required as
-		the value can be accessed from an interrupt. */
-		taskENTER_CRITICAL();
-		{
-			xReturn = pxTCB->pxTaskTag;
-		}
-		taskEXIT_CRITICAL();
-
-		return xReturn;
-	}
-
-#endif /* configUSE_APPLICATION_TASK_TAG */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-
-	TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
-	{
-	TCB_t *pxTCB;
-	TaskHookFunction_t xReturn;
-	UBaseType_t uxSavedInterruptStatus;
-
-		/* If xTask is NULL then set the calling task's hook. */
-		pxTCB = prvGetTCBFromHandle( xTask );
-
-		/* Save the hook function in the TCB.  A critical section is required as
-		the value can be accessed from an interrupt. */
-		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-		{
-			xReturn = pxTCB->pxTaskTag;
-		}
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-		return xReturn;
-	}
-
-#endif /* configUSE_APPLICATION_TASK_TAG */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-
-	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
-	{
-	TCB_t *xTCB;
-	BaseType_t xReturn;
-
-		/* If xTask is NULL then we are calling our own task hook. */
-		if( xTask == NULL )
-		{
-			xTCB = pxCurrentTCB;
-		}
-		else
-		{
-			xTCB = xTask;
-		}
-
-		if( xTCB->pxTaskTag != NULL )
-		{
-			xReturn = xTCB->pxTaskTag( pvParameter );
-		}
-		else
-		{
-			xReturn = pdFAIL;
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_APPLICATION_TASK_TAG */
-/*-----------------------------------------------------------*/
-
-void vTaskSwitchContext( void )
-{
-	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
-	{
-		/* The scheduler is currently suspended - do not allow a context
-		switch. */
-		xYieldPending = pdTRUE;
-	}
-	else
-	{
-		xYieldPending = pdFALSE;
-		traceTASK_SWITCHED_OUT();
-
-		#if ( configGENERATE_RUN_TIME_STATS == 1 )
-		{
-			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
-				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
-			#else
-				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
-			#endif
-
-			/* Add the amount of time the task has been running to the
-			accumulated time so far.  The time the task started running was
-			stored in ulTaskSwitchedInTime.  Note that there is no overflow
-			protection here so count values are only valid until the timer
-			overflows.  The guard against negative values is to protect
-			against suspect run time stat counter implementations - which
-			are provided by the application, not the kernel. */
-			if( ulTotalRunTime > ulTaskSwitchedInTime )
-			{
-				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-			ulTaskSwitchedInTime = ulTotalRunTime;
-		}
-		#endif /* configGENERATE_RUN_TIME_STATS */
-
-		/* Check for stack overflow, if configured. */
-		taskCHECK_FOR_STACK_OVERFLOW();
-
-		/* Before the currently running task is switched out, save its errno. */
-		#if( configUSE_POSIX_ERRNO == 1 )
-		{
-			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
-		}
-		#endif
-
-		/* Select a new task to run using either the generic C or port
-		optimised asm code. */
-		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-		traceTASK_SWITCHED_IN();
-
-		/* After the new task is switched in, update the global errno. */
-		#if( configUSE_POSIX_ERRNO == 1 )
-		{
-			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
-		}
-		#endif
-
-		#if ( configUSE_NEWLIB_REENTRANT == 1 )
-		{
-			/* Switch Newlib's _impure_ptr variable to point to the _reent
-			structure specific to this task.
-			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
-			for additional information. */
-			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
-		}
-		#endif /* configUSE_NEWLIB_REENTRANT */
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
-{
-	configASSERT( pxEventList );
-
-	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
-	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
-
-	/* Place the event list item of the TCB in the appropriate event list.
-	This is placed in the list in priority order so the highest priority task
-	is the first to be woken by the event.  The queue that contains the event
-	list is locked, preventing simultaneous access from interrupts. */
-	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
-
-	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
-}
-/*-----------------------------------------------------------*/
-
-void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
-{
-	configASSERT( pxEventList );
-
-	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
-	the event groups implementation. */
-	configASSERT( uxSchedulerSuspended != 0 );
-
-	/* Store the item value in the event list item.  It is safe to access the
-	event list item here as interrupts won't access the event list item of a
-	task that is not in the Blocked state. */
-	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
-
-	/* Place the event list item of the TCB at the end of the appropriate event
-	list.  It is safe to access the event list here because it is part of an
-	event group implementation - and interrupts don't access event groups
-	directly (instead they access them indirectly by pending function calls to
-	the task level). */
-	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
-
-	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TIMERS == 1 )
-
-	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
-	{
-		configASSERT( pxEventList );
-
-		/* This function should not be called by application code hence the
-		'Restricted' in its name.  It is not part of the public API.  It is
-		designed for use by kernel code, and has special calling requirements -
-		it should be called with the scheduler suspended. */
-
-
-		/* Place the event list item of the TCB in the appropriate event list.
-		In this case it is assume that this is the only task that is going to
-		be waiting on this event list, so the faster vListInsertEnd() function
-		can be used in place of vListInsert. */
-		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
-
-		/* If the task should block indefinitely then set the block time to a
-		value that will be recognised as an indefinite delay inside the
-		prvAddCurrentTaskToDelayedList() function. */
-		if( xWaitIndefinitely != pdFALSE )
-		{
-			xTicksToWait = portMAX_DELAY;
-		}
-
-		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
-		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
-	}
-
-#endif /* configUSE_TIMERS */
-/*-----------------------------------------------------------*/
-
-BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
-{
-TCB_t *pxUnblockedTCB;
-BaseType_t xReturn;
-
-	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
-	called from a critical section within an ISR. */
-
-	/* The event list is sorted in priority order, so the first in the list can
-	be removed as it is known to be the highest priority.  Remove the TCB from
-	the delayed list, and add it to the ready list.
-
-	If an event is for a queue that is locked then this function will never
-	get called - the lock count on the queue will get modified instead.  This
-	means exclusive access to the event list is guaranteed here.
-
-	This function assumes that a check has already been made to ensure that
-	pxEventList is not empty. */
-	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-	configASSERT( pxUnblockedTCB );
-	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
-
-	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
-	{
-		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
-		prvAddTaskToReadyList( pxUnblockedTCB );
-
-		#if( configUSE_TICKLESS_IDLE != 0 )
-		{
-			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
-			might be set to the blocked task's time out time.  If the task is
-			unblocked for a reason other than a timeout xNextTaskUnblockTime is
-			normally left unchanged, because it is automatically reset to a new
-			value when the tick count equals xNextTaskUnblockTime.  However if
-			tickless idling is used it might be more important to enter sleep mode
-			at the earliest possible time - so reset xNextTaskUnblockTime here to
-			ensure it is updated at the earliest possible time. */
-			prvResetNextTaskUnblockTime();
-		}
-		#endif
-	}
-	else
-	{
-		/* The delayed and ready lists cannot be accessed, so hold this task
-		pending until the scheduler is resumed. */
-		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
-	}
-
-	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
-	{
-		/* Return true if the task removed from the event list has a higher
-		priority than the calling task.  This allows the calling task to know if
-		it should force a context switch now. */
-		xReturn = pdTRUE;
-
-		/* Mark that a yield is pending in case the user is not using the
-		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
-		xYieldPending = pdTRUE;
-	}
-	else
-	{
-		xReturn = pdFALSE;
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
-{
-TCB_t *pxUnblockedTCB;
-
-	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
-	the event flags implementation. */
-	configASSERT( uxSchedulerSuspended != pdFALSE );
-
-	/* Store the new item value in the event list. */
-	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
-
-	/* Remove the event list form the event flag.  Interrupts do not access
-	event flags. */
-	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-	configASSERT( pxUnblockedTCB );
-	( void ) uxListRemove( pxEventListItem );
-
-	#if( configUSE_TICKLESS_IDLE != 0 )
-	{
-		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
-		might be set to the blocked task's time out time.  If the task is
-		unblocked for a reason other than a timeout xNextTaskUnblockTime is
-		normally left unchanged, because it is automatically reset to a new
-		value when the tick count equals xNextTaskUnblockTime.  However if
-		tickless idling is used it might be more important to enter sleep mode
-		at the earliest possible time - so reset xNextTaskUnblockTime here to
-		ensure it is updated at the earliest possible time. */
-		prvResetNextTaskUnblockTime();
-	}
-	#endif
-
-	/* Remove the task from the delayed list and add it to the ready list.  The
-	scheduler is suspended so interrupts will not be accessing the ready
-	lists. */
-	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
-	prvAddTaskToReadyList( pxUnblockedTCB );
-
-	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
-	{
-		/* The unblocked task has a priority above that of the calling task, so
-		a context switch is required.  This function is called with the
-		scheduler suspended so xYieldPending is set so the context switch
-		occurs immediately that the scheduler is resumed (unsuspended). */
-		xYieldPending = pdTRUE;
-	}
-}
-/*-----------------------------------------------------------*/
-
-void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
-{
-	configASSERT( pxTimeOut );
-	taskENTER_CRITICAL();
-	{
-		pxTimeOut->xOverflowCount = xNumOfOverflows;
-		pxTimeOut->xTimeOnEntering = xTickCount;
-	}
-	taskEXIT_CRITICAL();
-}
-/*-----------------------------------------------------------*/
-
-void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
-{
-	/* For internal use only as it does not use a critical section. */
-	pxTimeOut->xOverflowCount = xNumOfOverflows;
-	pxTimeOut->xTimeOnEntering = xTickCount;
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
-{
-BaseType_t xReturn;
-
-	configASSERT( pxTimeOut );
-	configASSERT( pxTicksToWait );
-
-	taskENTER_CRITICAL();
-	{
-		/* Minor optimisation.  The tick count cannot change in this block. */
-		const TickType_t xConstTickCount = xTickCount;
-		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
-
-		#if( INCLUDE_xTaskAbortDelay == 1 )
-			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
-			{
-				/* The delay was aborted, which is not the same as a time out,
-				but has the same result. */
-				pxCurrentTCB->ucDelayAborted = pdFALSE;
-				xReturn = pdTRUE;
-			}
-			else
-		#endif
-
-		#if ( INCLUDE_vTaskSuspend == 1 )
-			if( *pxTicksToWait == portMAX_DELAY )
-			{
-				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
-				specified is the maximum block time then the task should block
-				indefinitely, and therefore never time out. */
-				xReturn = pdFALSE;
-			}
-			else
-		#endif
-
-		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
-		{
-			/* The tick count is greater than the time at which
-			vTaskSetTimeout() was called, but has also overflowed since
-			vTaskSetTimeOut() was called.  It must have wrapped all the way
-			around and gone past again. This passed since vTaskSetTimeout()
-			was called. */
-			xReturn = pdTRUE;
-		}
-		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
-		{
-			/* Not a genuine timeout. Adjust parameters for time remaining. */
-			*pxTicksToWait -= xElapsedTime;
-			vTaskInternalSetTimeOutState( pxTimeOut );
-			xReturn = pdFALSE;
-		}
-		else
-		{
-			*pxTicksToWait = 0;
-			xReturn = pdTRUE;
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vTaskMissedYield( void )
-{
-	xYieldPending = pdTRUE;
-}
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
-	{
-	UBaseType_t uxReturn;
-	TCB_t const *pxTCB;
-
-		if( xTask != NULL )
-		{
-			pxTCB = xTask;
-			uxReturn = pxTCB->uxTaskNumber;
-		}
-		else
-		{
-			uxReturn = 0U;
-		}
-
-		return uxReturn;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
-	{
-	TCB_t * pxTCB;
-
-		if( xTask != NULL )
-		{
-			pxTCB = xTask;
-			pxTCB->uxTaskNumber = uxHandle;
-		}
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-
-/*
- * -----------------------------------------------------------
- * The Idle task.
- * ----------------------------------------------------------
- *
- * The portTASK_FUNCTION() macro is used to allow port/compiler specific
- * language extensions.  The equivalent prototype for this function is:
- *
- * void prvIdleTask( void *pvParameters );
- *
- */
-static portTASK_FUNCTION( prvIdleTask, pvParameters )
-{
-	/* Stop warnings. */
-	( void ) pvParameters;
-
-	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
-	SCHEDULER IS STARTED. **/
-
-	/* In case a task that has a secure context deletes itself, in which case
-	the idle task is responsible for deleting the task's secure context, if
-	any. */
-	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
-
-	for( ;; )
-	{
-		/* See if any tasks have deleted themselves - if so then the idle task
-		is responsible for freeing the deleted task's TCB and stack. */
-		prvCheckTasksWaitingTermination();
-
-		#if ( configUSE_PREEMPTION == 0 )
-		{
-			/* If we are not using preemption we keep forcing a task switch to
-			see if any other task has become available.  If we are using
-			preemption we don't need to do this as any task becoming available
-			will automatically get the processor anyway. */
-			taskYIELD();
-		}
-		#endif /* configUSE_PREEMPTION */
-
-		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
-		{
-			/* When using preemption tasks of equal priority will be
-			timesliced.  If a task that is sharing the idle priority is ready
-			to run then the idle task should yield before the end of the
-			timeslice.
-
-			A critical region is not required here as we are just reading from
-			the list, and an occasional incorrect value will not matter.  If
-			the ready list at the idle priority contains more than one task
-			then a task other than the idle task is ready to execute. */
-			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
-			{
-				taskYIELD();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
-
-		#if ( configUSE_IDLE_HOOK == 1 )
-		{
-			extern void vApplicationIdleHook( void );
-
-			/* Call the user defined function from within the idle task.  This
-			allows the application designer to add background functionality
-			without the overhead of a separate task.
-			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
-			CALL A FUNCTION THAT MIGHT BLOCK. */
-			vApplicationIdleHook();
-		}
-		#endif /* configUSE_IDLE_HOOK */
-
-		/* This conditional compilation should use inequality to 0, not equality
-		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
-		user defined low power mode	implementations require
-		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
-		#if ( configUSE_TICKLESS_IDLE != 0 )
-		{
-		TickType_t xExpectedIdleTime;
-
-			/* It is not desirable to suspend then resume the scheduler on
-			each iteration of the idle task.  Therefore, a preliminary
-			test of the expected idle time is performed without the
-			scheduler suspended.  The result here is not necessarily
-			valid. */
-			xExpectedIdleTime = prvGetExpectedIdleTime();
-
-			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
-			{
-				vTaskSuspendAll();
-				{
-					/* Now the scheduler is suspended, the expected idle
-					time can be sampled again, and this time its value can
-					be used. */
-					configASSERT( xNextTaskUnblockTime >= xTickCount );
-					xExpectedIdleTime = prvGetExpectedIdleTime();
-
-					/* Define the following macro to set xExpectedIdleTime to 0
-					if the application does not want
-					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
-					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
-
-					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
-					{
-						traceLOW_POWER_IDLE_BEGIN();
-						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
-						traceLOW_POWER_IDLE_END();
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				( void ) xTaskResumeAll();
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* configUSE_TICKLESS_IDLE */
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TICKLESS_IDLE != 0 )
-
-	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
-	{
-	/* The idle task exists in addition to the application tasks. */
-	const UBaseType_t uxNonApplicationTasks = 1;
-	eSleepModeStatus eReturn = eStandardSleep;
-
-		/* This function must be called from a critical section. */
-
-		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
-		{
-			/* A task was made ready while the scheduler was suspended. */
-			eReturn = eAbortSleep;
-		}
-		else if( xYieldPending != pdFALSE )
-		{
-			/* A yield was pended while the scheduler was suspended. */
-			eReturn = eAbortSleep;
-		}
-		else
-		{
-			/* If all the tasks are in the suspended list (which might mean they
-			have an infinite block time rather than actually being suspended)
-			then it is safe to turn all clocks off and just wait for external
-			interrupts. */
-			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
-			{
-				eReturn = eNoTasksWaitingTimeout;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-
-		return eReturn;
-	}
-
-#endif /* configUSE_TICKLESS_IDLE */
-/*-----------------------------------------------------------*/
-
-#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
-
-	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
-	{
-	TCB_t *pxTCB;
-
-		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
-		{
-			pxTCB = prvGetTCBFromHandle( xTaskToSet );
-			configASSERT( pxTCB != NULL );
-			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
-		}
-	}
-
-#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
-/*-----------------------------------------------------------*/
-
-#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
-
-	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
-	{
-	void *pvReturn = NULL;
-	TCB_t *pxTCB;
-
-		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
-		{
-			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
-			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
-		}
-		else
-		{
-			pvReturn = NULL;
-		}
-
-		return pvReturn;
-	}
-
-#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
-/*-----------------------------------------------------------*/
-
-#if ( portUSING_MPU_WRAPPERS == 1 )
-
-	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
-	{
-	TCB_t *pxTCB;
-
-		/* If null is passed in here then we are modifying the MPU settings of
-		the calling task. */
-		pxTCB = prvGetTCBFromHandle( xTaskToModify );
-
-		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
-	}
-
-#endif /* portUSING_MPU_WRAPPERS */
-/*-----------------------------------------------------------*/
-
-static void prvInitialiseTaskLists( void )
-{
-UBaseType_t uxPriority;
-
-	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
-	{
-		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
-	}
-
-	vListInitialise( &xDelayedTaskList1 );
-	vListInitialise( &xDelayedTaskList2 );
-	vListInitialise( &xPendingReadyList );
-
-	#if ( INCLUDE_vTaskDelete == 1 )
-	{
-		vListInitialise( &xTasksWaitingTermination );
-	}
-	#endif /* INCLUDE_vTaskDelete */
-
-	#if ( INCLUDE_vTaskSuspend == 1 )
-	{
-		vListInitialise( &xSuspendedTaskList );
-	}
-	#endif /* INCLUDE_vTaskSuspend */
-
-	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
-	using list2. */
-	pxDelayedTaskList = &xDelayedTaskList1;
-	pxOverflowDelayedTaskList = &xDelayedTaskList2;
-}
-/*-----------------------------------------------------------*/
-
-static void prvCheckTasksWaitingTermination( void )
-{
-
-	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
-
-	#if ( INCLUDE_vTaskDelete == 1 )
-	{
-		TCB_t *pxTCB;
-
-		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
-		being called too often in the idle task. */
-		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
-		{
-			taskENTER_CRITICAL();
-			{
-				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-				--uxCurrentNumberOfTasks;
-				--uxDeletedTasksWaitingCleanUp;
-			}
-			taskEXIT_CRITICAL();
-
-			prvDeleteTCB( pxTCB );
-		}
-	}
-	#endif /* INCLUDE_vTaskDelete */
-}
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TRACE_FACILITY == 1 )
-
-	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
-	{
-	TCB_t *pxTCB;
-
-		/* xTask is NULL then get the state of the calling task. */
-		pxTCB = prvGetTCBFromHandle( xTask );
-
-		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
-		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
-		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
-		pxTaskStatus->pxStackBase = pxTCB->pxStack;
-		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
-
-		#if ( configUSE_MUTEXES == 1 )
-		{
-			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
-		}
-		#else
-		{
-			pxTaskStatus->uxBasePriority = 0;
-		}
-		#endif
-
-		#if ( configGENERATE_RUN_TIME_STATS == 1 )
-		{
-			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
-		}
-		#else
-		{
-			pxTaskStatus->ulRunTimeCounter = 0;
-		}
-		#endif
-
-		/* Obtaining the task state is a little fiddly, so is only done if the
-		value of eState passed into this function is eInvalid - otherwise the
-		state is just set to whatever is passed in. */
-		if( eState != eInvalid )
-		{
-			if( pxTCB == pxCurrentTCB )
-			{
-				pxTaskStatus->eCurrentState = eRunning;
-			}
-			else
-			{
-				pxTaskStatus->eCurrentState = eState;
-
-				#if ( INCLUDE_vTaskSuspend == 1 )
-				{
-					/* If the task is in the suspended list then there is a
-					chance it is actually just blocked indefinitely - so really
-					it should be reported as being in the Blocked state. */
-					if( eState == eSuspended )
-					{
-						vTaskSuspendAll();
-						{
-							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
-							{
-								pxTaskStatus->eCurrentState = eBlocked;
-							}
-						}
-						( void ) xTaskResumeAll();
-					}
-				}
-				#endif /* INCLUDE_vTaskSuspend */
-			}
-		}
-		else
-		{
-			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
-		}
-
-		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
-		parameter is provided to allow it to be skipped. */
-		if( xGetFreeStackSpace != pdFALSE )
-		{
-			#if ( portSTACK_GROWTH > 0 )
-			{
-				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
-			}
-			#else
-			{
-				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
-			}
-			#endif
-		}
-		else
-		{
-			pxTaskStatus->usStackHighWaterMark = 0;
-		}
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
-	{
-	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
-	UBaseType_t uxTask = 0;
-
-		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
-		{
-			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-
-			/* Populate an TaskStatus_t structure within the
-			pxTaskStatusArray array for each task that is referenced from
-			pxList.  See the definition of TaskStatus_t in task.h for the
-			meaning of each TaskStatus_t structure member. */
-			do
-			{
-				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
-				uxTask++;
-			} while( pxNextTCB != pxFirstTCB );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return uxTask;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
-
-	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
-	{
-	uint32_t ulCount = 0U;
-
-		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
-		{
-			pucStackByte -= portSTACK_GROWTH;
-			ulCount++;
-		}
-
-		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
-
-		return ( configSTACK_DEPTH_TYPE ) ulCount;
-	}
-
-#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
-
-	/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
-	same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
-	user to determine the return type.  It gets around the problem of the value
-	overflowing on 8-bit types without breaking backward compatibility for
-	applications that expect an 8-bit return type. */
-	configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
-	{
-	TCB_t *pxTCB;
-	uint8_t *pucEndOfStack;
-	configSTACK_DEPTH_TYPE uxReturn;
-
-		/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
-		the same except for their return type.  Using configSTACK_DEPTH_TYPE
-		allows the user to determine the return type.  It gets around the
-		problem of the value overflowing on 8-bit types without breaking
-		backward compatibility for applications that expect an 8-bit return
-		type. */
-
-		pxTCB = prvGetTCBFromHandle( xTask );
-
-		#if portSTACK_GROWTH < 0
-		{
-			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
-		}
-		#else
-		{
-			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
-		}
-		#endif
-
-		uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
-
-		return uxReturn;
-	}
-
-#endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
-
-	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
-	{
-	TCB_t *pxTCB;
-	uint8_t *pucEndOfStack;
-	UBaseType_t uxReturn;
-
-		pxTCB = prvGetTCBFromHandle( xTask );
-
-		#if portSTACK_GROWTH < 0
-		{
-			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
-		}
-		#else
-		{
-			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
-		}
-		#endif
-
-		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
-
-		return uxReturn;
-	}
-
-#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
-/*-----------------------------------------------------------*/
-
-#if ( INCLUDE_vTaskDelete == 1 )
-
-	static void prvDeleteTCB( TCB_t *pxTCB )
-	{
-		/* This call is required specifically for the TriCore port.  It must be
-		above the vPortFree() calls.  The call is also used by ports/demos that
-		want to allocate and clean RAM statically. */
-		portCLEAN_UP_TCB( pxTCB );
-
-		/* Free up the memory allocated by the scheduler for the task.  It is up
-		to the task to free any memory allocated at the application level.
-		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
-		for additional information. */
-		#if ( configUSE_NEWLIB_REENTRANT == 1 )
-		{
-			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
-		}
-		#endif /* configUSE_NEWLIB_REENTRANT */
-
-		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
-		{
-			/* The task can only have been allocated dynamically - free both
-			the stack and TCB. */
-			vPortFree( pxTCB->pxStack );
-			vPortFree( pxTCB );
-		}
-		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
-		{
-			/* The task could have been allocated statically or dynamically, so
-			check what was statically allocated before trying to free the
-			memory. */
-			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
-			{
-				/* Both the stack and TCB were allocated dynamically, so both
-				must be freed. */
-				vPortFree( pxTCB->pxStack );
-				vPortFree( pxTCB );
-			}
-			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
-			{
-				/* Only the stack was statically allocated, so the TCB is the
-				only memory that must be freed. */
-				vPortFree( pxTCB );
-			}
-			else
-			{
-				/* Neither the stack nor the TCB were allocated dynamically, so
-				nothing needs to be freed. */
-				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-	}
-
-#endif /* INCLUDE_vTaskDelete */
-/*-----------------------------------------------------------*/
-
-static void prvResetNextTaskUnblockTime( void )
-{
-TCB_t *pxTCB;
-
-	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
-	{
-		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
-		the maximum possible value so it is	extremely unlikely that the
-		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
-		there is an item in the delayed list. */
-		xNextTaskUnblockTime = portMAX_DELAY;
-	}
-	else
-	{
-		/* The new current delayed list is not empty, get the value of
-		the item at the head of the delayed list.  This is the time at
-		which the task at the head of the delayed list should be removed
-		from the Blocked state. */
-		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
-	}
-}
-/*-----------------------------------------------------------*/
-
-#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
-
-	TaskHandle_t xTaskGetCurrentTaskHandle( void )
-	{
-	TaskHandle_t xReturn;
-
-		/* A critical section is not required as this is not called from
-		an interrupt and the current TCB will always be the same for any
-		individual execution thread. */
-		xReturn = pxCurrentTCB;
-
-		return xReturn;
-	}
-
-#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
-/*-----------------------------------------------------------*/
-
-#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
-
-	BaseType_t xTaskGetSchedulerState( void )
-	{
-	BaseType_t xReturn;
-
-		if( xSchedulerRunning == pdFALSE )
-		{
-			xReturn = taskSCHEDULER_NOT_STARTED;
-		}
-		else
-		{
-			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
-			{
-				xReturn = taskSCHEDULER_RUNNING;
-			}
-			else
-			{
-				xReturn = taskSCHEDULER_SUSPENDED;
-			}
-		}
-
-		return xReturn;
-	}
-
-#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_MUTEXES == 1 )
-
-	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
-	{
-	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
-	BaseType_t xReturn = pdFALSE;
-
-		/* If the mutex was given back by an interrupt while the queue was
-		locked then the mutex holder might now be NULL.  _RB_ Is this still
-		needed as interrupts can no longer use mutexes? */
-		if( pxMutexHolder != NULL )
-		{
-			/* If the holder of the mutex has a priority below the priority of
-			the task attempting to obtain the mutex then it will temporarily
-			inherit the priority of the task attempting to obtain the mutex. */
-			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
-			{
-				/* Adjust the mutex holder state to account for its new
-				priority.  Only reset the event list item value if the value is
-				not being used for anything else. */
-				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
-				{
-					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-
-				/* If the task being modified is in the ready state it will need
-				to be moved into a new list. */
-				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
-				{
-					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
-					{
-						/* It is known that the task is in its ready list so
-						there is no need to check again and the port level
-						reset macro can be called directly. */
-						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* Inherit the priority before being moved into the new list. */
-					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
-					prvAddTaskToReadyList( pxMutexHolderTCB );
-				}
-				else
-				{
-					/* Just inherit the priority. */
-					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
-				}
-
-				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
-
-				/* Inheritance occurred. */
-				xReturn = pdTRUE;
-			}
-			else
-			{
-				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
-				{
-					/* The base priority of the mutex holder is lower than the
-					priority of the task attempting to take the mutex, but the
-					current priority of the mutex holder is not lower than the
-					priority of the task attempting to take the mutex.
-					Therefore the mutex holder must have already inherited a
-					priority, but inheritance would have occurred if that had
-					not been the case. */
-					xReturn = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_MUTEXES == 1 )
-
-	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
-	{
-	TCB_t * const pxTCB = pxMutexHolder;
-	BaseType_t xReturn = pdFALSE;
-
-		if( pxMutexHolder != NULL )
-		{
-			/* A task can only have an inherited priority if it holds the mutex.
-			If the mutex is held by a task then it cannot be given from an
-			interrupt, and if a mutex is given by the holding task then it must
-			be the running state task. */
-			configASSERT( pxTCB == pxCurrentTCB );
-			configASSERT( pxTCB->uxMutexesHeld );
-			( pxTCB->uxMutexesHeld )--;
-
-			/* Has the holder of the mutex inherited the priority of another
-			task? */
-			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
-			{
-				/* Only disinherit if no other mutexes are held. */
-				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
-				{
-					/* A task can only have an inherited priority if it holds
-					the mutex.  If the mutex is held by a task then it cannot be
-					given from an interrupt, and if a mutex is given by the
-					holding task then it must be the running state task.  Remove
-					the holding task from the ready/delayed list. */
-					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
-					{
-						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* Disinherit the priority before adding the task into the
-					new	ready list. */
-					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
-					pxTCB->uxPriority = pxTCB->uxBasePriority;
-
-					/* Reset the event list item value.  It cannot be in use for
-					any other purpose if this task is running, and it must be
-					running to give back the mutex. */
-					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-					prvAddTaskToReadyList( pxTCB );
-
-					/* Return true to indicate that a context switch is required.
-					This is only actually required in the corner case whereby
-					multiple mutexes were held and the mutexes were given back
-					in an order different to that in which they were taken.
-					If a context switch did not occur when the first mutex was
-					returned, even if a task was waiting on it, then a context
-					switch should occur when the last mutex is returned whether
-					a task is waiting on it or not. */
-					xReturn = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-
-		return xReturn;
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_MUTEXES == 1 )
-
-	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
-	{
-	TCB_t * const pxTCB = pxMutexHolder;
-	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
-	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
-
-		if( pxMutexHolder != NULL )
-		{
-			/* If pxMutexHolder is not NULL then the holder must hold at least
-			one mutex. */
-			configASSERT( pxTCB->uxMutexesHeld );
-
-			/* Determine the priority to which the priority of the task that
-			holds the mutex should be set.  This will be the greater of the
-			holding task's base priority and the priority of the highest
-			priority task that is waiting to obtain the mutex. */
-			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
-			{
-				uxPriorityToUse = uxHighestPriorityWaitingTask;
-			}
-			else
-			{
-				uxPriorityToUse = pxTCB->uxBasePriority;
-			}
-
-			/* Does the priority need to change? */
-			if( pxTCB->uxPriority != uxPriorityToUse )
-			{
-				/* Only disinherit if no other mutexes are held.  This is a
-				simplification in the priority inheritance implementation.  If
-				the task that holds the mutex is also holding other mutexes then
-				the other mutexes may have caused the priority inheritance. */
-				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
-				{
-					/* If a task has timed out because it already holds the
-					mutex it was trying to obtain then it cannot of inherited
-					its own priority. */
-					configASSERT( pxTCB != pxCurrentTCB );
-
-					/* Disinherit the priority, remembering the previous
-					priority to facilitate determining the subject task's
-					state. */
-					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
-					uxPriorityUsedOnEntry = pxTCB->uxPriority;
-					pxTCB->uxPriority = uxPriorityToUse;
-
-					/* Only reset the event list item value if the value is not
-					being used for anything else. */
-					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
-					{
-						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-
-					/* If the running task is not the task that holds the mutex
-					then the task that holds the mutex could be in either the
-					Ready, Blocked or Suspended states.  Only remove the task
-					from its current state list if it is in the Ready state as
-					the task's priority is going to change and there is one
-					Ready list per priority. */
-					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
-					{
-						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
-						{
-							/* It is known that the task is in its ready list so
-							there is no need to check again and the port level
-							reset macro can be called directly. */
-							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-
-						prvAddTaskToReadyList( pxTCB );
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if ( portCRITICAL_NESTING_IN_TCB == 1 )
-
-	void vTaskEnterCritical( void )
-	{
-		portDISABLE_INTERRUPTS();
-
-		if( xSchedulerRunning != pdFALSE )
-		{
-			( pxCurrentTCB->uxCriticalNesting )++;
-
-			/* This is not the interrupt safe version of the enter critical
-			function so	assert() if it is being called from an interrupt
-			context.  Only API functions that end in "FromISR" can be used in an
-			interrupt.  Only assert if the critical nesting count is 1 to
-			protect against recursive calls if the assert function also uses a
-			critical section. */
-			if( pxCurrentTCB->uxCriticalNesting == 1 )
-			{
-				portASSERT_IF_IN_ISR();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* portCRITICAL_NESTING_IN_TCB */
-/*-----------------------------------------------------------*/
-
-#if ( portCRITICAL_NESTING_IN_TCB == 1 )
-
-	void vTaskExitCritical( void )
-	{
-		if( xSchedulerRunning != pdFALSE )
-		{
-			if( pxCurrentTCB->uxCriticalNesting > 0U )
-			{
-				( pxCurrentTCB->uxCriticalNesting )--;
-
-				if( pxCurrentTCB->uxCriticalNesting == 0U )
-				{
-					portENABLE_INTERRUPTS();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* portCRITICAL_NESTING_IN_TCB */
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
-
-	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
-	{
-	size_t x;
-
-		/* Start by copying the entire string. */
-		strcpy( pcBuffer, pcTaskName );
-
-		/* Pad the end of the string with spaces to ensure columns line up when
-		printed out. */
-		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
-		{
-			pcBuffer[ x ] = ' ';
-		}
-
-		/* Terminate. */
-		pcBuffer[ x ] = ( char ) 0x00;
-
-		/* Return the new end of string. */
-		return &( pcBuffer[ x ] );
-	}
-
-#endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
-/*-----------------------------------------------------------*/
-
-#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-
-	void vTaskList( char * pcWriteBuffer )
-	{
-	TaskStatus_t *pxTaskStatusArray;
-	UBaseType_t uxArraySize, x;
-	char cStatus;
-
-		/*
-		 * PLEASE NOTE:
-		 *
-		 * This function is provided for convenience only, and is used by many
-		 * of the demo applications.  Do not consider it to be part of the
-		 * scheduler.
-		 *
-		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
-		 * uxTaskGetSystemState() output into a human readable table that
-		 * displays task names, states and stack usage.
-		 *
-		 * vTaskList() has a dependency on the sprintf() C library function that
-		 * might bloat the code size, use a lot of stack, and provide different
-		 * results on different platforms.  An alternative, tiny, third party,
-		 * and limited functionality implementation of sprintf() is provided in
-		 * many of the FreeRTOS/Demo sub-directories in a file called
-		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
-		 * snprintf() implementation!).
-		 *
-		 * It is recommended that production systems call uxTaskGetSystemState()
-		 * directly to get access to raw stats data, rather than indirectly
-		 * through a call to vTaskList().
-		 */
-
-
-		/* Make sure the write buffer does not contain a string. */
-		*pcWriteBuffer = ( char ) 0x00;
-
-		/* Take a snapshot of the number of tasks in case it changes while this
-		function is executing. */
-		uxArraySize = uxCurrentNumberOfTasks;
-
-		/* Allocate an array index for each task.  NOTE!  if
-		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
-		equate to NULL. */
-		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
-
-		if( pxTaskStatusArray != NULL )
-		{
-			/* Generate the (binary) data. */
-			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
-
-			/* Create a human readable table from the binary data. */
-			for( x = 0; x < uxArraySize; x++ )
-			{
-				switch( pxTaskStatusArray[ x ].eCurrentState )
-				{
-					case eRunning:		cStatus = tskRUNNING_CHAR;
-										break;
-
-					case eReady:		cStatus = tskREADY_CHAR;
-										break;
-
-					case eBlocked:		cStatus = tskBLOCKED_CHAR;
-										break;
-
-					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
-										break;
-
-					case eDeleted:		cStatus = tskDELETED_CHAR;
-										break;
-
-					case eInvalid:		/* Fall through. */
-					default:			/* Should not get here, but it is included
-										to prevent static checking errors. */
-										cStatus = ( char ) 0x00;
-										break;
-				}
-
-				/* Write the task name to the string, padding with spaces so it
-				can be printed in tabular form more easily. */
-				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
-
-				/* Write the rest of the string. */
-				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
-				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
-			}
-
-			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
-			is 0 then vPortFree() will be #defined to nothing. */
-			vPortFree( pxTaskStatusArray );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
-/*----------------------------------------------------------*/
-
-#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-
-	void vTaskGetRunTimeStats( char *pcWriteBuffer )
-	{
-	TaskStatus_t *pxTaskStatusArray;
-	UBaseType_t uxArraySize, x;
-	uint32_t ulTotalTime, ulStatsAsPercentage;
-
-		#if( configUSE_TRACE_FACILITY != 1 )
-		{
-			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
-		}
-		#endif
-
-		/*
-		 * PLEASE NOTE:
-		 *
-		 * This function is provided for convenience only, and is used by many
-		 * of the demo applications.  Do not consider it to be part of the
-		 * scheduler.
-		 *
-		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
-		 * of the uxTaskGetSystemState() output into a human readable table that
-		 * displays the amount of time each task has spent in the Running state
-		 * in both absolute and percentage terms.
-		 *
-		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
-		 * function that might bloat the code size, use a lot of stack, and
-		 * provide different results on different platforms.  An alternative,
-		 * tiny, third party, and limited functionality implementation of
-		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
-		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
-		 * a full snprintf() implementation!).
-		 *
-		 * It is recommended that production systems call uxTaskGetSystemState()
-		 * directly to get access to raw stats data, rather than indirectly
-		 * through a call to vTaskGetRunTimeStats().
-		 */
-
-		/* Make sure the write buffer does not contain a string. */
-		*pcWriteBuffer = ( char ) 0x00;
-
-		/* Take a snapshot of the number of tasks in case it changes while this
-		function is executing. */
-		uxArraySize = uxCurrentNumberOfTasks;
-
-		/* Allocate an array index for each task.  NOTE!  If
-		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
-		equate to NULL. */
-		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
-
-		if( pxTaskStatusArray != NULL )
-		{
-			/* Generate the (binary) data. */
-			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
-
-			/* For percentage calculations. */
-			ulTotalTime /= 100UL;
-
-			/* Avoid divide by zero errors. */
-			if( ulTotalTime > 0UL )
-			{
-				/* Create a human readable table from the binary data. */
-				for( x = 0; x < uxArraySize; x++ )
-				{
-					/* What percentage of the total run time has the task used?
-					This will always be rounded down to the nearest integer.
-					ulTotalRunTimeDiv100 has already been divided by 100. */
-					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
-
-					/* Write the task name to the string, padding with
-					spaces so it can be printed in tabular form more
-					easily. */
-					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
-
-					if( ulStatsAsPercentage > 0UL )
-					{
-						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
-						{
-							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
-						}
-						#else
-						{
-							/* sizeof( int ) == sizeof( long ) so a smaller
-							printf() library can be used. */
-							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
-						}
-						#endif
-					}
-					else
-					{
-						/* If the percentage is zero here then the task has
-						consumed less than 1% of the total run time. */
-						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
-						{
-							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
-						}
-						#else
-						{
-							/* sizeof( int ) == sizeof( long ) so a smaller
-							printf() library can be used. */
-							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
-						}
-						#endif
-					}
-
-					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
-			is 0 then vPortFree() will be #defined to nothing. */
-			vPortFree( pxTaskStatusArray );
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
-/*-----------------------------------------------------------*/
-
-TickType_t uxTaskResetEventItemValue( void )
-{
-TickType_t uxReturn;
-
-	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
-
-	/* Reset the event list item to its normal value - so it can be used with
-	queues and semaphores. */
-	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_MUTEXES == 1 )
-
-	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
-	{
-		/* If xSemaphoreCreateMutex() is called before any tasks have been created
-		then pxCurrentTCB will be NULL. */
-		if( pxCurrentTCB != NULL )
-		{
-			( pxCurrentTCB->uxMutexesHeld )++;
-		}
-
-		return pxCurrentTCB;
-	}
-
-#endif /* configUSE_MUTEXES */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-
-	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
-	{
-	uint32_t ulReturn;
-
-		taskENTER_CRITICAL();
-		{
-			/* Only block if the notification count is not already non-zero. */
-			if( pxCurrentTCB->ulNotifiedValue == 0UL )
-			{
-				/* Mark this task as waiting for a notification. */
-				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
-
-				if( xTicksToWait > ( TickType_t ) 0 )
-				{
-					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
-					traceTASK_NOTIFY_TAKE_BLOCK();
-
-					/* All ports are written to allow a yield in a critical
-					section (some will yield immediately, others wait until the
-					critical section exits) - but it is not something that
-					application code should ever do. */
-					portYIELD_WITHIN_API();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		taskENTER_CRITICAL();
-		{
-			traceTASK_NOTIFY_TAKE();
-			ulReturn = pxCurrentTCB->ulNotifiedValue;
-
-			if( ulReturn != 0UL )
-			{
-				if( xClearCountOnExit != pdFALSE )
-				{
-					pxCurrentTCB->ulNotifiedValue = 0UL;
-				}
-				else
-				{
-					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
-		}
-		taskEXIT_CRITICAL();
-
-		return ulReturn;
-	}
-
-#endif /* configUSE_TASK_NOTIFICATIONS */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-
-	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
-	{
-	BaseType_t xReturn;
-
-		taskENTER_CRITICAL();
-		{
-			/* Only block if a notification is not already pending. */
-			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
-			{
-				/* Clear bits in the task's notification value as bits may get
-				set	by the notifying task or interrupt.  This can be used to
-				clear the value to zero. */
-				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
-
-				/* Mark this task as waiting for a notification. */
-				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
-
-				if( xTicksToWait > ( TickType_t ) 0 )
-				{
-					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
-					traceTASK_NOTIFY_WAIT_BLOCK();
-
-					/* All ports are written to allow a yield in a critical
-					section (some will yield immediately, others wait until the
-					critical section exits) - but it is not something that
-					application code should ever do. */
-					portYIELD_WITHIN_API();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		taskENTER_CRITICAL();
-		{
-			traceTASK_NOTIFY_WAIT();
-
-			if( pulNotificationValue != NULL )
-			{
-				/* Output the current notification value, which may or may not
-				have changed. */
-				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
-			}
-
-			/* If ucNotifyValue is set then either the task never entered the
-			blocked state (because a notification was already pending) or the
-			task unblocked because of a notification.  Otherwise the task
-			unblocked because of a timeout. */
-			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
-			{
-				/* A notification was not received. */
-				xReturn = pdFALSE;
-			}
-			else
-			{
-				/* A notification was already pending or a notification was
-				received while the task was waiting. */
-				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
-				xReturn = pdTRUE;
-			}
-
-			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
-		}
-		taskEXIT_CRITICAL();
-
-		return xReturn;
-	}
-
-#endif /* configUSE_TASK_NOTIFICATIONS */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-
-	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
-	{
-	TCB_t * pxTCB;
-	BaseType_t xReturn = pdPASS;
-	uint8_t ucOriginalNotifyState;
-
-		configASSERT( xTaskToNotify );
-		pxTCB = xTaskToNotify;
-
-		taskENTER_CRITICAL();
-		{
-			if( pulPreviousNotificationValue != NULL )
-			{
-				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
-			}
-
-			ucOriginalNotifyState = pxTCB->ucNotifyState;
-
-			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
-
-			switch( eAction )
-			{
-				case eSetBits	:
-					pxTCB->ulNotifiedValue |= ulValue;
-					break;
-
-				case eIncrement	:
-					( pxTCB->ulNotifiedValue )++;
-					break;
-
-				case eSetValueWithOverwrite	:
-					pxTCB->ulNotifiedValue = ulValue;
-					break;
-
-				case eSetValueWithoutOverwrite :
-					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
-					{
-						pxTCB->ulNotifiedValue = ulValue;
-					}
-					else
-					{
-						/* The value could not be written to the task. */
-						xReturn = pdFAIL;
-					}
-					break;
-
-				case eNoAction:
-					/* The task is being notified without its notify value being
-					updated. */
-					break;
-
-				default:
-					/* Should not get here if all enums are handled.
-					Artificially force an assert by testing a value the
-					compiler can't assume is const. */
-					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
-
-					break;
-			}
-
-			traceTASK_NOTIFY();
-
-			/* If the task is in the blocked state specifically to wait for a
-			notification then unblock it now. */
-			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
-			{
-				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-				prvAddTaskToReadyList( pxTCB );
-
-				/* The task should not have been on an event list. */
-				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
-
-				#if( configUSE_TICKLESS_IDLE != 0 )
-				{
-					/* If a task is blocked waiting for a notification then
-					xNextTaskUnblockTime might be set to the blocked task's time
-					out time.  If the task is unblocked for a reason other than
-					a timeout xNextTaskUnblockTime is normally left unchanged,
-					because it will automatically get reset to a new value when
-					the tick count equals xNextTaskUnblockTime.  However if
-					tickless idling is used it might be more important to enter
-					sleep mode at the earliest possible time - so reset
-					xNextTaskUnblockTime here to ensure it is updated at the
-					earliest possible time. */
-					prvResetNextTaskUnblockTime();
-				}
-				#endif
-
-				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
-				{
-					/* The notified task has a priority above the currently
-					executing task so a yield is required. */
-					taskYIELD_IF_USING_PREEMPTION();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		return xReturn;
-	}
-
-#endif /* configUSE_TASK_NOTIFICATIONS */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-
-	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
-	{
-	TCB_t * pxTCB;
-	uint8_t ucOriginalNotifyState;
-	BaseType_t xReturn = pdPASS;
-	UBaseType_t uxSavedInterruptStatus;
-
-		configASSERT( xTaskToNotify );
-
-		/* RTOS ports that support interrupt nesting have the concept of a
-		maximum	system call (or maximum API call) interrupt priority.
-		Interrupts that are	above the maximum system call priority are keep
-		permanently enabled, even when the RTOS kernel is in a critical section,
-		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
-		is defined in FreeRTOSConfig.h then
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-		failure if a FreeRTOS API function is called from an interrupt that has
-		been assigned a priority above the configured maximum system call
-		priority.  Only FreeRTOS functions that end in FromISR can be called
-		from interrupts	that have been assigned a priority at or (logically)
-		below the maximum system call interrupt priority.  FreeRTOS maintains a
-		separate interrupt safe API to ensure interrupt entry is as fast and as
-		simple as possible.  More information (albeit Cortex-M specific) is
-		provided on the following link:
-		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-		pxTCB = xTaskToNotify;
-
-		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-		{
-			if( pulPreviousNotificationValue != NULL )
-			{
-				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
-			}
-
-			ucOriginalNotifyState = pxTCB->ucNotifyState;
-			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
-
-			switch( eAction )
-			{
-				case eSetBits	:
-					pxTCB->ulNotifiedValue |= ulValue;
-					break;
-
-				case eIncrement	:
-					( pxTCB->ulNotifiedValue )++;
-					break;
-
-				case eSetValueWithOverwrite	:
-					pxTCB->ulNotifiedValue = ulValue;
-					break;
-
-				case eSetValueWithoutOverwrite :
-					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
-					{
-						pxTCB->ulNotifiedValue = ulValue;
-					}
-					else
-					{
-						/* The value could not be written to the task. */
-						xReturn = pdFAIL;
-					}
-					break;
-
-				case eNoAction :
-					/* The task is being notified without its notify value being
-					updated. */
-					break;
-
-				default:
-					/* Should not get here if all enums are handled.
-					Artificially force an assert by testing a value the
-					compiler can't assume is const. */
-					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
-					break;
-			}
-
-			traceTASK_NOTIFY_FROM_ISR();
-
-			/* If the task is in the blocked state specifically to wait for a
-			notification then unblock it now. */
-			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
-			{
-				/* The task should not have been on an event list. */
-				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
-
-				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
-				{
-					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-					prvAddTaskToReadyList( pxTCB );
-				}
-				else
-				{
-					/* The delayed and ready lists cannot be accessed, so hold
-					this task pending until the scheduler is resumed. */
-					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
-				}
-
-				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
-				{
-					/* The notified task has a priority above the currently
-					executing task so a yield is required. */
-					if( pxHigherPriorityTaskWoken != NULL )
-					{
-						*pxHigherPriorityTaskWoken = pdTRUE;
-					}
-
-					/* Mark that a yield is pending in case the user is not
-					using the "xHigherPriorityTaskWoken" parameter to an ISR
-					safe FreeRTOS function. */
-					xYieldPending = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-
-		return xReturn;
-	}
-
-#endif /* configUSE_TASK_NOTIFICATIONS */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-
-	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
-	{
-	TCB_t * pxTCB;
-	uint8_t ucOriginalNotifyState;
-	UBaseType_t uxSavedInterruptStatus;
-
-		configASSERT( xTaskToNotify );
-
-		/* RTOS ports that support interrupt nesting have the concept of a
-		maximum	system call (or maximum API call) interrupt priority.
-		Interrupts that are	above the maximum system call priority are keep
-		permanently enabled, even when the RTOS kernel is in a critical section,
-		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
-		is defined in FreeRTOSConfig.h then
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
-		failure if a FreeRTOS API function is called from an interrupt that has
-		been assigned a priority above the configured maximum system call
-		priority.  Only FreeRTOS functions that end in FromISR can be called
-		from interrupts	that have been assigned a priority at or (logically)
-		below the maximum system call interrupt priority.  FreeRTOS maintains a
-		separate interrupt safe API to ensure interrupt entry is as fast and as
-		simple as possible.  More information (albeit Cortex-M specific) is
-		provided on the following link:
-		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
-		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
-
-		pxTCB = xTaskToNotify;
-
-		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
-		{
-			ucOriginalNotifyState = pxTCB->ucNotifyState;
-			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
-
-			/* 'Giving' is equivalent to incrementing a count in a counting
-			semaphore. */
-			( pxTCB->ulNotifiedValue )++;
-
-			traceTASK_NOTIFY_GIVE_FROM_ISR();
-
-			/* If the task is in the blocked state specifically to wait for a
-			notification then unblock it now. */
-			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
-			{
-				/* The task should not have been on an event list. */
-				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
-
-				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
-				{
-					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
-					prvAddTaskToReadyList( pxTCB );
-				}
-				else
-				{
-					/* The delayed and ready lists cannot be accessed, so hold
-					this task pending until the scheduler is resumed. */
-					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
-				}
-
-				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
-				{
-					/* The notified task has a priority above the currently
-					executing task so a yield is required. */
-					if( pxHigherPriorityTaskWoken != NULL )
-					{
-						*pxHigherPriorityTaskWoken = pdTRUE;
-					}
-
-					/* Mark that a yield is pending in case the user is not
-					using the "xHigherPriorityTaskWoken" parameter in an ISR
-					safe FreeRTOS function. */
-					xYieldPending = pdTRUE;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
-	}
-
-#endif /* configUSE_TASK_NOTIFICATIONS */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-
-	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
-	{
-	TCB_t *pxTCB;
-	BaseType_t xReturn;
-
-		/* If null is passed in here then it is the calling task that is having
-		its notification state cleared. */
-		pxTCB = prvGetTCBFromHandle( xTask );
-
-		taskENTER_CRITICAL();
-		{
-			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
-			{
-				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
-				xReturn = pdPASS;
-			}
-			else
-			{
-				xReturn = pdFAIL;
-			}
-		}
-		taskEXIT_CRITICAL();
-
-		return xReturn;
-	}
-
-#endif /* configUSE_TASK_NOTIFICATIONS */
-/*-----------------------------------------------------------*/
-
-#if( configUSE_TASK_NOTIFICATIONS == 1 )
-
-	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
-	{
-	TCB_t *pxTCB;
-	uint32_t ulReturn;
-
-		/* If null is passed in here then it is the calling task that is having
-		its notification state cleared. */
-		pxTCB = prvGetTCBFromHandle( xTask );
-
-		taskENTER_CRITICAL();
-		{
-			/* Return the notification as it was before the bits were cleared,
-			then clear the bit mask. */
-			ulReturn = pxCurrentTCB->ulNotifiedValue;
-			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
-		}
-		taskEXIT_CRITICAL();
-
-		return ulReturn;
-	}
-
-#endif /* configUSE_TASK_NOTIFICATIONS */
-/*-----------------------------------------------------------*/
-
-#if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
-
-	uint32_t ulTaskGetIdleRunTimeCounter( void )
-	{
-		return xIdleTaskHandle->ulRunTimeCounter;
-	}
-
-#endif
-/*-----------------------------------------------------------*/
-
-static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
-{
-TickType_t xTimeToWake;
-const TickType_t xConstTickCount = xTickCount;
-
-	#if( INCLUDE_xTaskAbortDelay == 1 )
-	{
-		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
-		reset to pdFALSE so it can be detected as having been set to pdTRUE
-		when the task leaves the Blocked state. */
-		pxCurrentTCB->ucDelayAborted = pdFALSE;
-	}
-	#endif
-
-	/* Remove the task from the ready list before adding it to the blocked list
-	as the same list item is used for both lists. */
-	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
-	{
-		/* The current task must be in a ready list, so there is no need to
-		check, and the port reset macro can be called directly. */
-		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	#if ( INCLUDE_vTaskSuspend == 1 )
-	{
-		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
-		{
-			/* Add the task to the suspended task list instead of a delayed task
-			list to ensure it is not woken by a timing event.  It will block
-			indefinitely. */
-			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
-		}
-		else
-		{
-			/* Calculate the time at which the task should be woken if the event
-			does not occur.  This may overflow but this doesn't matter, the
-			kernel will manage it correctly. */
-			xTimeToWake = xConstTickCount + xTicksToWait;
-
-			/* The list item will be inserted in wake time order. */
-			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
-
-			if( xTimeToWake < xConstTickCount )
-			{
-				/* Wake time has overflowed.  Place this item in the overflow
-				list. */
-				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
-			}
-			else
-			{
-				/* The wake time has not overflowed, so the current block list
-				is used. */
-				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
-
-				/* If the task entering the blocked state was placed at the
-				head of the list of blocked tasks then xNextTaskUnblockTime
-				needs to be updated too. */
-				if( xTimeToWake < xNextTaskUnblockTime )
-				{
-					xNextTaskUnblockTime = xTimeToWake;
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-	}
-	#else /* INCLUDE_vTaskSuspend */
-	{
-		/* Calculate the time at which the task should be woken if the event
-		does not occur.  This may overflow but this doesn't matter, the kernel
-		will manage it correctly. */
-		xTimeToWake = xConstTickCount + xTicksToWait;
-
-		/* The list item will be inserted in wake time order. */
-		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
-
-		if( xTimeToWake < xConstTickCount )
-		{
-			/* Wake time has overflowed.  Place this item in the overflow list. */
-			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
-		}
-		else
-		{
-			/* The wake time has not overflowed, so the current block list is used. */
-			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
-
-			/* If the task entering the blocked state was placed at the head of the
-			list of blocked tasks then xNextTaskUnblockTime needs to be updated
-			too. */
-			if( xTimeToWake < xNextTaskUnblockTime )
-			{
-				xNextTaskUnblockTime = xTimeToWake;
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-
-		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
-		( void ) xCanBlockIndefinitely;
-	}
-	#endif /* INCLUDE_vTaskSuspend */
-}
-
-/* Code below here allows additional code to be inserted into this source file,
-especially where access to file scope functions and data is needed (for example
-when performing module tests). */
-
-#ifdef FREERTOS_MODULE_TEST
-	#include "tasks_test_access_functions.h"
-#endif
-
-
-#if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
-
-	#include "freertos_tasks_c_additions.h"
-
-	#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
-		static void freertos_tasks_c_additions_init( void )
-		{
-			FREERTOS_TASKS_C_ADDITIONS_INIT();
-		}
-	#endif
-
-#endif
-
-
diff --git a/osal/src/freertos/timers.c b/osal/src/freertos/timers.c
deleted file mode 100644
index 00200b8..0000000
--- a/osal/src/freertos/timers.c
+++ /dev/null
@@ -1,1127 +0,0 @@
-/*
- * FreeRTOS Kernel V10.3.1
- * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/* Standard includes. */
-#include <stdlib.h>
-
-/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
-all the API functions to use the MPU wrappers.  That should only be done when
-task.h is included from an application file. */
-#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-#include "FreeRTOS.h"
-#include "task.h"
-#include "queue.h"
-#include "timers.h"
-
-#if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
-	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
-#endif
-
-/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
-because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
-for the header files above, but not in this file, in order to generate the
-correct privileged Vs unprivileged linkage and placement. */
-#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e9021 !e961 !e750. */
-
-
-/* This entire source file will be skipped if the application is not configured
-to include software timer functionality.  This #if is closed at the very bottom
-of this file.  If you want to include software timer functionality then ensure
-configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
-#if ( configUSE_TIMERS == 1 )
-
-/* Misc definitions. */
-#define tmrNO_DELAY		( TickType_t ) 0U
-
-/* The name assigned to the timer service task.  This can be overridden by
-defining trmTIMER_SERVICE_TASK_NAME in FreeRTOSConfig.h. */
-#ifndef configTIMER_SERVICE_TASK_NAME
-	#define configTIMER_SERVICE_TASK_NAME "Tmr Svc"
-#endif
-
-/* Bit definitions used in the ucStatus member of a timer structure. */
-#define tmrSTATUS_IS_ACTIVE					( ( uint8_t ) 0x01 )
-#define tmrSTATUS_IS_STATICALLY_ALLOCATED	( ( uint8_t ) 0x02 )
-#define tmrSTATUS_IS_AUTORELOAD				( ( uint8_t ) 0x04 )
-
-/* The definition of the timers themselves. */
-typedef struct tmrTimerControl /* The old naming convention is used to prevent breaking kernel aware debuggers. */
-{
-	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
-	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
-	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
-	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
-	#if( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
-	#endif
-	uint8_t 				ucStatus;			/*<< Holds bits to say if the timer was statically allocated or not, and if it is active or not. */
-} xTIMER;
-
-/* The old xTIMER name is maintained above then typedefed to the new Timer_t
-name below to enable the use of older kernel aware debuggers. */
-typedef xTIMER Timer_t;
-
-/* The definition of messages that can be sent and received on the timer queue.
-Two types of message can be queued - messages that manipulate a software timer,
-and messages that request the execution of a non-timer related callback.  The
-two message types are defined in two separate structures, xTimerParametersType
-and xCallbackParametersType respectively. */
-typedef struct tmrTimerParameters
-{
-	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
-	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
-} TimerParameter_t;
-
-
-typedef struct tmrCallbackParameters
-{
-	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
-	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
-	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
-} CallbackParameters_t;
-
-/* The structure that contains the two message types, along with an identifier
-that is used to determine which message type is valid. */
-typedef struct tmrTimerQueueMessage
-{
-	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
-	union
-	{
-		TimerParameter_t xTimerParameters;
-
-		/* Don't include xCallbackParameters if it is not going to be used as
-		it makes the structure (and therefore the timer queue) larger. */
-		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
-			CallbackParameters_t xCallbackParameters;
-		#endif /* INCLUDE_xTimerPendFunctionCall */
-	} u;
-} DaemonTaskMessage_t;
-
-/*lint -save -e956 A manual analysis and inspection has been used to determine
-which static variables must be declared volatile. */
-
-/* The list in which active timers are stored.  Timers are referenced in expire
-time order, with the nearest expiry time at the front of the list.  Only the
-timer service task is allowed to access these lists.
-xActiveTimerList1 and xActiveTimerList2 could be at function scope but that
-breaks some kernel aware debuggers, and debuggers that reply on removing the
-static qualifier. */
-PRIVILEGED_DATA static List_t xActiveTimerList1;
-PRIVILEGED_DATA static List_t xActiveTimerList2;
-PRIVILEGED_DATA static List_t *pxCurrentTimerList;
-PRIVILEGED_DATA static List_t *pxOverflowTimerList;
-
-/* A queue that is used to send commands to the timer service task. */
-PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
-PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
-
-/*lint -restore */
-
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-	/* If static allocation is supported then the application must provide the
-	following callback function - which enables the application to optionally
-	provide the memory that will be used by the timer task as the task's stack
-	and TCB. */
-	extern void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize );
-
-#endif
-
-/*
- * Initialise the infrastructure used by the timer service task if it has not
- * been initialised already.
- */
-static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
-
-/*
- * The timer service task (daemon).  Timer functionality is controlled by this
- * task.  Other tasks communicate with the timer service task using the
- * xTimerQueue queue.
- */
-static portTASK_FUNCTION_PROTO( prvTimerTask, pvParameters ) PRIVILEGED_FUNCTION;
-
-/*
- * Called by the timer service task to interpret and process a command it
- * received on the timer queue.
- */
-static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
- * depending on if the expire time causes a timer counter overflow.
- */
-static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
-
-/*
- * An active timer has reached its expire time.  Reload the timer if it is an
- * auto-reload timer, then call its callback.
- */
-static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
-
-/*
- * The tick count has overflowed.  Switch the timer lists after ensuring the
- * current timer list does not still reference some timers.
- */
-static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
- * if a tick count overflow occurred since prvSampleTimeNow() was last called.
- */
-static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
-
-/*
- * If the timer list contains any active timers then return the expire time of
- * the timer that will expire first and set *pxListWasEmpty to false.  If the
- * timer list does not contain any timers then return 0 and set *pxListWasEmpty
- * to pdTRUE.
- */
-static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
-
-/*
- * If a timer has expired, process it.  Otherwise, block the timer service task
- * until either a timer does expire or a command is received.
- */
-static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
-
-/*
- * Called after a Timer_t structure has been allocated either statically or
- * dynamically to fill in the structure's members.
- */
-static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-									const TickType_t xTimerPeriodInTicks,
-									const UBaseType_t uxAutoReload,
-									void * const pvTimerID,
-									TimerCallbackFunction_t pxCallbackFunction,
-									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
-/*-----------------------------------------------------------*/
-
-BaseType_t xTimerCreateTimerTask( void )
-{
-BaseType_t xReturn = pdFAIL;
-
-	/* This function is called when the scheduler is started if
-	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
-	timer service task has been created/initialised.  If timers have already
-	been created then the initialisation will already have been performed. */
-	prvCheckForValidListAndQueue();
-
-	if( xTimerQueue != NULL )
-	{
-		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-		{
-			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
-			StackType_t *pxTimerTaskStackBuffer = NULL;
-			uint32_t ulTimerTaskStackSize;
-
-			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
-			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
-													configTIMER_SERVICE_TASK_NAME,
-													ulTimerTaskStackSize,
-													NULL,
-													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
-													pxTimerTaskStackBuffer,
-													pxTimerTaskTCBBuffer );
-
-			if( xTimerTaskHandle != NULL )
-			{
-				xReturn = pdPASS;
-			}
-		}
-		#else
-		{
-			xReturn = xTaskCreate(	prvTimerTask,
-									configTIMER_SERVICE_TASK_NAME,
-									configTIMER_TASK_STACK_DEPTH,
-									NULL,
-									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
-									&xTimerTaskHandle );
-		}
-		#endif /* configSUPPORT_STATIC_ALLOCATION */
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	configASSERT( xReturn );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-
-	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-								const TickType_t xTimerPeriodInTicks,
-								const UBaseType_t uxAutoReload,
-								void * const pvTimerID,
-								TimerCallbackFunction_t pxCallbackFunction )
-	{
-	Timer_t *pxNewTimer;
-
-		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
-
-		if( pxNewTimer != NULL )
-		{
-			/* Status is thus far zero as the timer is not created statically
-			and has not been started.  The auto-reload bit may get set in
-			prvInitialiseNewTimer. */
-			pxNewTimer->ucStatus = 0x00;
-			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
-		}
-
-		return pxNewTimer;
-	}
-
-#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-										const TickType_t xTimerPeriodInTicks,
-										const UBaseType_t uxAutoReload,
-										void * const pvTimerID,
-										TimerCallbackFunction_t pxCallbackFunction,
-										StaticTimer_t *pxTimerBuffer )
-	{
-	Timer_t *pxNewTimer;
-
-		#if( configASSERT_DEFINED == 1 )
-		{
-			/* Sanity check that the size of the structure used to declare a
-			variable of type StaticTimer_t equals the size of the real timer
-			structure. */
-			volatile size_t xSize = sizeof( StaticTimer_t );
-			configASSERT( xSize == sizeof( Timer_t ) );
-			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
-		}
-		#endif /* configASSERT_DEFINED */
-
-		/* A pointer to a StaticTimer_t structure MUST be provided, use it. */
-		configASSERT( pxTimerBuffer );
-		pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 !e9087 StaticTimer_t is a pointer to a Timer_t, so guaranteed to be aligned and sized correctly (checked by an assert()), so this is safe. */
-
-		if( pxNewTimer != NULL )
-		{
-			/* Timers can be created statically or dynamically so note this
-			timer was created statically in case it is later deleted.  The
-			auto-reload bit may get set in prvInitialiseNewTimer(). */
-			pxNewTimer->ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;
-
-			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
-		}
-
-		return pxNewTimer;
-	}
-
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-/*-----------------------------------------------------------*/
-
-static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-									const TickType_t xTimerPeriodInTicks,
-									const UBaseType_t uxAutoReload,
-									void * const pvTimerID,
-									TimerCallbackFunction_t pxCallbackFunction,
-									Timer_t *pxNewTimer )
-{
-	/* 0 is not a valid value for xTimerPeriodInTicks. */
-	configASSERT( ( xTimerPeriodInTicks > 0 ) );
-
-	if( pxNewTimer != NULL )
-	{
-		/* Ensure the infrastructure used by the timer service task has been
-		created/initialised. */
-		prvCheckForValidListAndQueue();
-
-		/* Initialise the timer structure members using the function
-		parameters. */
-		pxNewTimer->pcTimerName = pcTimerName;
-		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
-		pxNewTimer->pvTimerID = pvTimerID;
-		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
-		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
-		if( uxAutoReload != pdFALSE )
-		{
-			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
-		}
-		traceTIMER_CREATE( pxNewTimer );
-	}
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
-{
-BaseType_t xReturn = pdFAIL;
-DaemonTaskMessage_t xMessage;
-
-	configASSERT( xTimer );
-
-	/* Send a message to the timer service task to perform a particular action
-	on a particular timer definition. */
-	if( xTimerQueue != NULL )
-	{
-		/* Send a command to the timer service task to start the xTimer timer. */
-		xMessage.xMessageID = xCommandID;
-		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
-		xMessage.u.xTimerParameters.pxTimer = xTimer;
-
-		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
-		{
-			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
-			{
-				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
-			}
-			else
-			{
-				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
-			}
-		}
-		else
-		{
-			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
-		}
-
-		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
-	}
-	else
-	{
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
-{
-	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
-	started, then xTimerTaskHandle will be NULL. */
-	configASSERT( ( xTimerTaskHandle != NULL ) );
-	return xTimerTaskHandle;
-}
-/*-----------------------------------------------------------*/
-
-TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
-{
-Timer_t *pxTimer = xTimer;
-
-	configASSERT( xTimer );
-	return pxTimer->xTimerPeriodInTicks;
-}
-/*-----------------------------------------------------------*/
-
-void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
-{
-Timer_t * pxTimer =  xTimer;
-
-	configASSERT( xTimer );
-	taskENTER_CRITICAL();
-	{
-		if( uxAutoReload != pdFALSE )
-		{
-			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
-		}
-		else
-		{
-			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
-		}
-	}
-	taskEXIT_CRITICAL();
-}
-/*-----------------------------------------------------------*/
-
-UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
-{
-Timer_t * pxTimer =  xTimer;
-UBaseType_t uxReturn;
-
-	configASSERT( xTimer );
-	taskENTER_CRITICAL();
-	{
-		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
-		{
-			/* Not an auto-reload timer. */
-			uxReturn = ( UBaseType_t ) pdFALSE;
-		}
-		else
-		{
-			/* Is an auto-reload timer. */
-			uxReturn = ( UBaseType_t ) pdTRUE;
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	return uxReturn;
-}
-/*-----------------------------------------------------------*/
-
-TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
-{
-Timer_t * pxTimer =  xTimer;
-TickType_t xReturn;
-
-	configASSERT( xTimer );
-	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
-	return xReturn;
-}
-/*-----------------------------------------------------------*/
-
-const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-{
-Timer_t *pxTimer = xTimer;
-
-	configASSERT( xTimer );
-	return pxTimer->pcTimerName;
-}
-/*-----------------------------------------------------------*/
-
-static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
-{
-BaseType_t xResult;
-Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-
-	/* Remove the timer from the list of active timers.  A check has already
-	been performed to ensure the list is not empty. */
-	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
-	traceTIMER_EXPIRED( pxTimer );
-
-	/* If the timer is an auto-reload timer then calculate the next
-	expiry time and re-insert the timer in the list of active timers. */
-	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
-	{
-		/* The timer is inserted into a list using a time relative to anything
-		other than the current time.  It will therefore be inserted into the
-		correct list relative to the time this task thinks it is now. */
-		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
-		{
-			/* The timer expired before it was added to the active timer
-			list.  Reload it now.  */
-			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
-			configASSERT( xResult );
-			( void ) xResult;
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	else
-	{
-		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
-		mtCOVERAGE_TEST_MARKER();
-	}
-
-	/* Call the timer callback. */
-	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
-}
-/*-----------------------------------------------------------*/
-
-static portTASK_FUNCTION( prvTimerTask, pvParameters )
-{
-TickType_t xNextExpireTime;
-BaseType_t xListWasEmpty;
-
-	/* Just to avoid compiler warnings. */
-	( void ) pvParameters;
-
-	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
-	{
-		extern void vApplicationDaemonTaskStartupHook( void );
-
-		/* Allow the application writer to execute some code in the context of
-		this task at the point the task starts executing.  This is useful if the
-		application includes initialisation code that would benefit from
-		executing after the scheduler has been started. */
-		vApplicationDaemonTaskStartupHook();
-	}
-	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
-
-	for( ;; )
-	{
-		/* Query the timers list to see if it contains any timers, and if so,
-		obtain the time at which the next timer will expire. */
-		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
-
-		/* If a timer has expired, process it.  Otherwise, block this task
-		until either a timer does expire, or a command is received. */
-		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
-
-		/* Empty the command queue. */
-		prvProcessReceivedCommands();
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
-{
-TickType_t xTimeNow;
-BaseType_t xTimerListsWereSwitched;
-
-	vTaskSuspendAll();
-	{
-		/* Obtain the time now to make an assessment as to whether the timer
-		has expired or not.  If obtaining the time causes the lists to switch
-		then don't process this timer as any timers that remained in the list
-		when the lists were switched will have been processed within the
-		prvSampleTimeNow() function. */
-		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
-		if( xTimerListsWereSwitched == pdFALSE )
-		{
-			/* The tick count has not overflowed, has the timer expired? */
-			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
-			{
-				( void ) xTaskResumeAll();
-				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
-			}
-			else
-			{
-				/* The tick count has not overflowed, and the next expire
-				time has not been reached yet.  This task should therefore
-				block to wait for the next expire time or a command to be
-				received - whichever comes first.  The following line cannot
-				be reached unless xNextExpireTime > xTimeNow, except in the
-				case when the current timer list is empty. */
-				if( xListWasEmpty != pdFALSE )
-				{
-					/* The current timer list is empty - is the overflow list
-					also empty? */
-					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
-				}
-
-				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
-
-				if( xTaskResumeAll() == pdFALSE )
-				{
-					/* Yield to wait for either a command to arrive, or the
-					block time to expire.  If a command arrived between the
-					critical section being exited and this yield then the yield
-					will not cause the task to block. */
-					portYIELD_WITHIN_API();
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-		}
-		else
-		{
-			( void ) xTaskResumeAll();
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
-{
-TickType_t xNextExpireTime;
-
-	/* Timers are listed in expiry time order, with the head of the list
-	referencing the task that will expire first.  Obtain the time at which
-	the timer with the nearest expiry time will expire.  If there are no
-	active timers then just set the next expire time to 0.  That will cause
-	this task to unblock when the tick count overflows, at which point the
-	timer lists will be switched and the next expiry time can be
-	re-assessed.  */
-	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
-	if( *pxListWasEmpty == pdFALSE )
-	{
-		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
-	}
-	else
-	{
-		/* Ensure the task unblocks when the tick count rolls over. */
-		xNextExpireTime = ( TickType_t ) 0U;
-	}
-
-	return xNextExpireTime;
-}
-/*-----------------------------------------------------------*/
-
-static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
-{
-TickType_t xTimeNow;
-PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
-
-	xTimeNow = xTaskGetTickCount();
-
-	if( xTimeNow < xLastTime )
-	{
-		prvSwitchTimerLists();
-		*pxTimerListsWereSwitched = pdTRUE;
-	}
-	else
-	{
-		*pxTimerListsWereSwitched = pdFALSE;
-	}
-
-	xLastTime = xTimeNow;
-
-	return xTimeNow;
-}
-/*-----------------------------------------------------------*/
-
-static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
-{
-BaseType_t xProcessTimerNow = pdFALSE;
-
-	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
-	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
-
-	if( xNextExpiryTime <= xTimeNow )
-	{
-		/* Has the expiry time elapsed between the command to start/reset a
-		timer was issued, and the time the command was processed? */
-		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-		{
-			/* The time between a command being issued and the command being
-			processed actually exceeds the timers period.  */
-			xProcessTimerNow = pdTRUE;
-		}
-		else
-		{
-			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
-		}
-	}
-	else
-	{
-		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
-		{
-			/* If, since the command was issued, the tick count has overflowed
-			but the expiry time has not, then the timer must have already passed
-			its expiry time and should be processed immediately. */
-			xProcessTimerNow = pdTRUE;
-		}
-		else
-		{
-			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
-		}
-	}
-
-	return xProcessTimerNow;
-}
-/*-----------------------------------------------------------*/
-
-static void	prvProcessReceivedCommands( void )
-{
-DaemonTaskMessage_t xMessage;
-Timer_t *pxTimer;
-BaseType_t xTimerListsWereSwitched, xResult;
-TickType_t xTimeNow;
-
-	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
-	{
-		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
-		{
-			/* Negative commands are pended function calls rather than timer
-			commands. */
-			if( xMessage.xMessageID < ( BaseType_t ) 0 )
-			{
-				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
-
-				/* The timer uses the xCallbackParameters member to request a
-				callback be executed.  Check the callback is not NULL. */
-				configASSERT( pxCallback );
-
-				/* Call the function. */
-				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-		}
-		#endif /* INCLUDE_xTimerPendFunctionCall */
-
-		/* Commands that are positive are timer commands rather than pended
-		function calls. */
-		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
-		{
-			/* The messages uses the xTimerParameters member to work on a
-			software timer. */
-			pxTimer = xMessage.u.xTimerParameters.pxTimer;
-
-			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
-			{
-				/* The timer is in a list, remove it. */
-				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
-			}
-			else
-			{
-				mtCOVERAGE_TEST_MARKER();
-			}
-
-			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
-
-			/* In this case the xTimerListsWereSwitched parameter is not used, but
-			it must be present in the function call.  prvSampleTimeNow() must be
-			called after the message is received from xTimerQueue so there is no
-			possibility of a higher priority task adding a message to the message
-			queue with a time that is ahead of the timer daemon task (because it
-			pre-empted the timer daemon task after the xTimeNow value was set). */
-			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
-
-			switch( xMessage.xMessageID )
-			{
-				case tmrCOMMAND_START :
-				case tmrCOMMAND_START_FROM_ISR :
-				case tmrCOMMAND_RESET :
-				case tmrCOMMAND_RESET_FROM_ISR :
-				case tmrCOMMAND_START_DONT_TRACE :
-					/* Start or restart a timer. */
-					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
-					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
-					{
-						/* The timer expired before it was added to the active
-						timer list.  Process it now. */
-						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
-						traceTIMER_EXPIRED( pxTimer );
-
-						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
-						{
-							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
-							configASSERT( xResult );
-							( void ) xResult;
-						}
-						else
-						{
-							mtCOVERAGE_TEST_MARKER();
-						}
-					}
-					else
-					{
-						mtCOVERAGE_TEST_MARKER();
-					}
-					break;
-
-				case tmrCOMMAND_STOP :
-				case tmrCOMMAND_STOP_FROM_ISR :
-					/* The timer has already been removed from the active list. */
-					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
-					break;
-
-				case tmrCOMMAND_CHANGE_PERIOD :
-				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
-					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
-					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
-					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
-
-					/* The new period does not really have a reference, and can
-					be longer or shorter than the old one.  The command time is
-					therefore set to the current time, and as the period cannot
-					be zero the next expiry time can only be in the future,
-					meaning (unlike for the xTimerStart() case above) there is
-					no fail case that needs to be handled here. */
-					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
-					break;
-
-				case tmrCOMMAND_DELETE :
-					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-					{
-						/* The timer has already been removed from the active list,
-						just free up the memory if the memory was dynamically
-						allocated. */
-						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
-						{
-							vPortFree( pxTimer );
-						}
-						else
-						{
-							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
-						}
-					}
-					#else
-					{
-						/* If dynamic allocation is not enabled, the memory
-						could not have been dynamically allocated. So there is
-						no need to free the memory - just mark the timer as
-						"not active". */
-						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
-					}
-					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
-					break;
-
-				default	:
-					/* Don't expect to get here. */
-					break;
-			}
-		}
-	}
-}
-/*-----------------------------------------------------------*/
-
-static void prvSwitchTimerLists( void )
-{
-TickType_t xNextExpireTime, xReloadTime;
-List_t *pxTemp;
-Timer_t *pxTimer;
-BaseType_t xResult;
-
-	/* The tick count has overflowed.  The timer lists must be switched.
-	If there are any timers still referenced from the current timer list
-	then they must have expired and should be processed before the lists
-	are switched. */
-	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
-	{
-		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
-
-		/* Remove the timer from the list. */
-		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
-		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
-		traceTIMER_EXPIRED( pxTimer );
-
-		/* Execute its callback, then send a command to restart the timer if
-		it is an auto-reload timer.  It cannot be restarted here as the lists
-		have not yet been switched. */
-		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
-
-		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
-		{
-			/* Calculate the reload value, and if the reload value results in
-			the timer going into the same timer list then it has already expired
-			and the timer should be re-inserted into the current list so it is
-			processed again within this loop.  Otherwise a command should be sent
-			to restart the timer to ensure it is only inserted into a list after
-			the lists have been swapped. */
-			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
-			if( xReloadTime > xNextExpireTime )
-			{
-				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
-				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
-				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
-			}
-			else
-			{
-				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
-				configASSERT( xResult );
-				( void ) xResult;
-			}
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-
-	pxTemp = pxCurrentTimerList;
-	pxCurrentTimerList = pxOverflowTimerList;
-	pxOverflowTimerList = pxTemp;
-}
-/*-----------------------------------------------------------*/
-
-static void prvCheckForValidListAndQueue( void )
-{
-	/* Check that the list from which active timers are referenced, and the
-	queue used to communicate with the timer service, have been
-	initialised. */
-	taskENTER_CRITICAL();
-	{
-		if( xTimerQueue == NULL )
-		{
-			vListInitialise( &xActiveTimerList1 );
-			vListInitialise( &xActiveTimerList2 );
-			pxCurrentTimerList = &xActiveTimerList1;
-			pxOverflowTimerList = &xActiveTimerList2;
-
-			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-			{
-				/* The timer queue is allocated statically in case
-				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
-				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
-				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
-
-				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
-			}
-			#else
-			{
-				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
-			}
-			#endif
-
-			#if ( configQUEUE_REGISTRY_SIZE > 0 )
-			{
-				if( xTimerQueue != NULL )
-				{
-					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
-				}
-				else
-				{
-					mtCOVERAGE_TEST_MARKER();
-				}
-			}
-			#endif /* configQUEUE_REGISTRY_SIZE */
-		}
-		else
-		{
-			mtCOVERAGE_TEST_MARKER();
-		}
-	}
-	taskEXIT_CRITICAL();
-}
-/*-----------------------------------------------------------*/
-
-BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
-{
-BaseType_t xReturn;
-Timer_t *pxTimer = xTimer;
-
-	configASSERT( xTimer );
-
-	/* Is the timer in the list of active timers? */
-	taskENTER_CRITICAL();
-	{
-		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
-		{
-			xReturn = pdFALSE;
-		}
-		else
-		{
-			xReturn = pdTRUE;
-		}
-	}
-	taskEXIT_CRITICAL();
-
-	return xReturn;
-} /*lint !e818 Can't be pointer to const due to the typedef. */
-/*-----------------------------------------------------------*/
-
-void *pvTimerGetTimerID( const TimerHandle_t xTimer )
-{
-Timer_t * const pxTimer = xTimer;
-void *pvReturn;
-
-	configASSERT( xTimer );
-
-	taskENTER_CRITICAL();
-	{
-		pvReturn = pxTimer->pvTimerID;
-	}
-	taskEXIT_CRITICAL();
-
-	return pvReturn;
-}
-/*-----------------------------------------------------------*/
-
-void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
-{
-Timer_t * const pxTimer = xTimer;
-
-	configASSERT( xTimer );
-
-	taskENTER_CRITICAL();
-	{
-		pxTimer->pvTimerID = pvNewID;
-	}
-	taskEXIT_CRITICAL();
-}
-/*-----------------------------------------------------------*/
-
-#if( INCLUDE_xTimerPendFunctionCall == 1 )
-
-	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
-	{
-	DaemonTaskMessage_t xMessage;
-	BaseType_t xReturn;
-
-		/* Complete the message with the function parameters and post it to the
-		daemon task. */
-		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
-		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
-		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
-		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
-
-		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
-
-		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
-
-		return xReturn;
-	}
-
-#endif /* INCLUDE_xTimerPendFunctionCall */
-/*-----------------------------------------------------------*/
-
-#if( INCLUDE_xTimerPendFunctionCall == 1 )
-
-	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
-	{
-	DaemonTaskMessage_t xMessage;
-	BaseType_t xReturn;
-
-		/* This function can only be called after a timer has been created or
-		after the scheduler has been started because, until then, the timer
-		queue does not exist. */
-		configASSERT( xTimerQueue );
-
-		/* Complete the message with the function parameters and post it to the
-		daemon task. */
-		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
-		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
-		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
-		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
-
-		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
-
-		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
-
-		return xReturn;
-	}
-
-#endif /* INCLUDE_xTimerPendFunctionCall */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
-	{
-		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-#if ( configUSE_TRACE_FACILITY == 1 )
-
-	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
-	{
-		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
-	}
-
-#endif /* configUSE_TRACE_FACILITY */
-/*-----------------------------------------------------------*/
-
-/* This entire source file will be skipped if the application is not configured
-to include software timer functionality.  If you want to include software timer
-functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
-#endif /* configUSE_TIMERS == 1 */
-
-
-
diff --git a/osal/src/sugar/asm/jump_arm64_aapcs_elf_gas.S b/osal/src/sugar/asm/jump_arm64_aapcs_elf_gas.S
new file mode 100644
index 0000000..cefd183
--- /dev/null
+++ b/osal/src/sugar/asm/jump_arm64_aapcs_elf_gas.S
@@ -0,0 +1,114 @@
+/*
+       Copyright Edward Nevill + Oliver Kowalke 2015
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+/*******************************************************
+ *                                                     *
+ *  -------------------------------------------------  *
+ *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
+ *  -------------------------------------------------  *
+ *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
+ *  -------------------------------------------------  *
+ *  |    d8     |    d9     |    d10    |    d11    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
+ *  -------------------------------------------------  *
+ *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
+ *  -------------------------------------------------  *
+ *  |    d12    |    d13    |    d14    |    d15    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
+ *  -------------------------------------------------  *
+ *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
+ *  -------------------------------------------------  *
+ *  |    x19    |    x20    |    x21    |    x22    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
+ *  -------------------------------------------------  *
+ *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
+ *  -------------------------------------------------  *
+ *  |    x23    |    x24    |    x25    |    x26    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
+ *  -------------------------------------------------  *
+ *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
+ *  -------------------------------------------------  *
+ *  |    x27    |    x28    |    FP     |     LR    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  40 |  41 |  42 | 43  |           |           |  *
+ *  -------------------------------------------------  *
+ *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *
+ *  -------------------------------------------------  *
+ *  |     PC    |   align   |           |           |  *
+ *  -------------------------------------------------  *
+ *                                                     *
+ *******************************************************/
+
+.file "jump_arm64_aapcs_elf_gas.S"
+.text
+.align  2
+.global jump_fcontext
+.type   jump_fcontext, %function
+jump_fcontext:
+    # prepare stack for GP + FPU
+    sub  sp, sp, #0xb0
+
+    # save d8 - d15
+    stp  d8,  d9,  [sp, #0x00]
+    stp  d10, d11, [sp, #0x10]
+    stp  d12, d13, [sp, #0x20]
+    stp  d14, d15, [sp, #0x30]
+
+    # save x19-x30
+    stp  x19, x20, [sp, #0x40]
+    stp  x21, x22, [sp, #0x50]
+    stp  x23, x24, [sp, #0x60]
+    stp  x25, x26, [sp, #0x70]
+    stp  x27, x28, [sp, #0x80]
+    stp  x29, x30, [sp, #0x90]
+
+    # save LR as PC
+    str  x30, [sp, #0xa0]
+
+    # store RSP (pointing to context-data) in X0
+    mov  x4, sp
+
+    # restore RSP (pointing to context-data) from X1
+    mov  sp, x0
+
+    # load d8 - d15
+    ldp  d8,  d9,  [sp, #0x00]
+    ldp  d10, d11, [sp, #0x10]
+    ldp  d12, d13, [sp, #0x20]
+    ldp  d14, d15, [sp, #0x30]
+
+    # load x19-x30
+    ldp  x19, x20, [sp, #0x40]
+    ldp  x21, x22, [sp, #0x50]
+    ldp  x23, x24, [sp, #0x60]
+    ldp  x25, x26, [sp, #0x70]
+    ldp  x27, x28, [sp, #0x80]
+    ldp  x29, x30, [sp, #0x90]
+
+    # return transfer_t from jump
+    # pass transfer_t as first arg in context function
+    # X0 == FCTX, X1 == DATA
+    mov x0, x4
+
+    # load pc
+    ldr  x4, [sp, #0xa0]
+
+    # restore stack from GP + FPU
+    add  sp, sp, #0xb0
+
+    ret x4
+.size   jump_fcontext,.-jump_fcontext
+# Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/jump_arm_aapcs_elf_gas.S b/osal/src/sugar/asm/jump_arm_aapcs_elf_gas.S
new file mode 100644
index 0000000..86efe9d
--- /dev/null
+++ b/osal/src/sugar/asm/jump_arm_aapcs_elf_gas.S
@@ -0,0 +1,88 @@
+/*
+            Copyright Oliver Kowalke 2009.
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+/*******************************************************
+ *                                                     *
+ *  -------------------------------------------------  *
+ *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
+ *  -------------------------------------------------  *
+ *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
+ *  -------------------------------------------------  *
+ *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
+ *  -------------------------------------------------  *
+ *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
+ *  -------------------------------------------------  *
+ *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
+ *  -------------------------------------------------  *
+ *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
+ *  -------------------------------------------------  *
+ *  |hiddn|  v1 |  v2 |  v3 |  v4 |  v5 |  v6 |  v7 |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
+ *  -------------------------------------------------  *
+ *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
+ *  -------------------------------------------------  *
+ *  |  v8 |  lr |  pc | FCTX| DATA|                 |  *
+ *  -------------------------------------------------  *
+ *                                                     *
+ *******************************************************/
+
+.file "jump_arm_aapcs_elf_gas.S"
+.text
+.globl jump_fcontext
+.align 2
+.type jump_fcontext,%function
+.syntax unified
+jump_fcontext:
+    @ save LR as PC
+    push {lr}
+    @ save hidden,V1-V8,LR
+    push {a1,v1-v8,lr}
+
+    @ prepare stack for FPU
+    sub  sp, sp, #64
+#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
+    @ save S16-S31
+    vstmia sp, {d8-d15}
+#endif
+
+    @ store RSP (pointing to context-data) in A1
+    mov  a1, sp
+
+    @ restore RSP (pointing to context-data) from A2
+    mov  sp, a2
+
+#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
+    @ restore S16-S31
+    vldmia  sp, {d8-d15}
+#endif
+    @ prepare stack for FPU
+    add  sp, sp, #64
+
+    @ restore hidden,V1-V8,LR
+    pop {a4,v1-v8,lr}
+
+    @ return transfer_t from jump
+    str  a1, [a4, #0]
+    str  a3, [a4, #4]
+    @ pass transfer_t as first arg in context function
+    @ A1 == FCTX, A2 == DATA
+    mov  a2, a3
+
+    @ restore PC
+    pop {pc}
+.size jump_fcontext,.-jump_fcontext
+
+@ Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/jump_gas.S b/osal/src/sugar/asm/jump_gas.S
new file mode 100644
index 0000000..521a1f9
--- /dev/null
+++ b/osal/src/sugar/asm/jump_gas.S
@@ -0,0 +1,19 @@
+// Stub file for universal binary
+
+#if defined(_WIN32) || defined(__MINGW32__) || defined(__MINGW64__) || defined(__CYGWIN__) || defined(__MSYS__)
+    #include "jump_x86_64_ms_pe_gas.asm"
+#elif defined(__x86_64__)
+    #include "jump_x86_64_sysv_elf_gas.S"
+#elif defined(__aarch64__)
+    #include "jump_arm64_aapcs_elf_gas.S"
+#elif defined(__arm__)
+    #include "jump_arm_aapcs_elf_gas.S"
+#elif defined(__riscv)
+    #if defined __unix__ || defined __linux__
+        #include "jump_riscv64_sysv_elf_gas.S"
+    #else
+        #include "jump_riscv32_elf_gas.S"
+    #endif
+#else
+    #error "No arch's"
+#endif
diff --git a/osal/src/sugar/asm/jump_riscv32_elf_gas.S b/osal/src/sugar/asm/jump_riscv32_elf_gas.S
new file mode 100644
index 0000000..813cb7d
--- /dev/null
+++ b/osal/src/sugar/asm/jump_riscv32_elf_gas.S
@@ -0,0 +1,111 @@
+/*
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+
+.file "jump_riscv64_elf_gas.S"
+.text
+.align  1
+.global jump_fcontext
+.type   jump_fcontext, %function
+jump_fcontext:
+#ifdef __riscv_flen
+    # prepare stack for GP + FPU
+    addi  sp, sp, -0x68
+
+    # save fs0 - fs11
+    fsw  f0, 0x38(sp)
+    fsw  f1, 0x3c(sp)
+    fsw  f2, 0x40(sp)
+    fsw  f3, 0x44(sp)
+    fsw  f4, 0x48(sp)
+    fsw  f5, 0x4c(sp)
+    fsw  f6, 0x50(sp)
+    fsw  f7, 0x54(sp)
+    fsw  f8, 0x58(sp)
+    fsw  f9, 0x5c(sp)
+    fsw  f10, 0x60(sp)
+    fsw  f11, 0x64(sp)
+
+#else
+    # prepare stack for GP
+    addi  sp, sp, -0x38
+#endif
+
+    # save s0-s11, ra
+    sw  s0, 0x00(sp)
+    sw  s1, 0x04(sp)
+    sw  s2, 0x08(sp)
+    sw  s3, 0x0c(sp)
+    sw  s4, 0x10(sp)
+    sw  s5, 0x14(sp)
+    sw  s6, 0x18(sp)
+    sw  s7, 0x1c(sp)
+    sw  s8, 0x20(sp)
+    sw  s9, 0x24(sp)
+    sw  s10, 0x28(sp)
+    sw  s11, 0x2c(sp)
+    
+    sw  ra, 0x30(sp)
+
+    # save RA as PC
+    sw  ra, 0x34(sp)
+
+    # store SP (pointing to context-data) in A2
+    mv  a2, sp
+
+    # restore SP (pointing to context-data) from A0
+    mv  sp, a0
+
+#ifdef __riscv_flen
+    # load fs0 - fs11
+    flw  f0, 0x38(sp)
+    flw  f1, 0x3c(sp)
+    flw  f2, 0x40(sp)
+    flw  f3, 0x44(sp)
+    flw  f4, 0x48(sp)
+    flw  f5, 0x4c(sp)
+    flw  f6, 0x50(sp)
+    flw  f7, 0x54(sp)
+    flw  f8, 0x58(sp)
+    flw  f9, 0x5c(sp)
+    flw  f10, 0x60(sp)
+    flw  f11, 0x64(sp)
+#endif
+    
+    # load s0-s11,ra
+    lw  s0, 0x00(sp)
+    lw  s1, 0x04(sp)
+    lw  s2, 0x08(sp)
+    lw  s3, 0x0c(sp)
+    lw  s4, 0x10(sp)
+    lw  s5, 0x14(sp)
+    lw  s6, 0x18(sp)
+    lw  s7, 0x1c(sp)
+    lw  s8, 0x20(sp)
+    lw  s9, 0x24(sp)
+    lw  s10, 0x28(sp)
+    lw  s11, 0x2c(sp)
+    lw  ra, 0x30(sp)
+
+    # return transfer_t from jump
+    # pass transfer_t as first arg in context function
+    # a0 == FCTX, a1 == DATA
+    mv a0, a2
+
+    # load pc
+    lw  a2, 0x34(sp)
+
+    # restore stack from GP + FPU
+#ifdef __riscv_flen
+    addi  sp, sp, 0x68
+#else
+    addi  sp, sp, 0x38
+#endif
+
+    jr a2
+.size   jump_fcontext,.-jump_fcontext
+# Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/jump_riscv64_sysv_elf_gas.S b/osal/src/sugar/asm/jump_riscv64_sysv_elf_gas.S
new file mode 100644
index 0000000..5417e5d
--- /dev/null
+++ b/osal/src/sugar/asm/jump_riscv64_sysv_elf_gas.S
@@ -0,0 +1,150 @@
+/*
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+/*******************************************************
+ *                                                     *
+ *  -------------------------------------------------  *
+ *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
+ *  -------------------------------------------------  *
+ *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
+ *  -------------------------------------------------  *
+ *  |    fs0    |    fs1    |    fs2    |    fs3    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
+ *  -------------------------------------------------  *
+ *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
+ *  -------------------------------------------------  *
+ *  |    fs4    |    fs5    |    fs6    |    fs7    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
+ *  -------------------------------------------------  *
+ *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
+ *  -------------------------------------------------  *
+ *  |    fs8    |    fs9    |    fs10   |    fs11   |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
+ *  -------------------------------------------------  *
+ *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
+ *  -------------------------------------------------  *
+ *  |    s0     |    s1     |    s2     |    s3     |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
+ *  -------------------------------------------------  *
+ *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
+ *  -------------------------------------------------  *
+ *  |    s4     |    s5     |    s6     |     s7    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  40 |  41 |  42 | 43  |  44 | 45  |  46 | 47  |  *
+ *  -------------------------------------------------  *
+ *  | 0xa0| 0xa4| 0xa8| 0xac| 0xb0| 0xb4| 0xb8| 0xbc|  *
+ *  -------------------------------------------------  *
+ *  |     s8    |     s9    |    s10    |    s11    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  48 |  49 |  50 | 51  |     |     |     |     |  *
+ *  -------------------------------------------------  *
+ *  | 0xc0| 0xc4| 0xc8| 0xcc|     |     |     |     |  *
+ *  -------------------------------------------------  *
+ *  |     ra    |     pc    |           |           |  *
+ *  -------------------------------------------------  *
+ *                                                     *
+ *******************************************************/
+
+.file "jump_riscv64_sysv_elf_gas.S"
+.text
+.align  1
+.global jump_fcontext
+.type   jump_fcontext, %function
+jump_fcontext:
+    # prepare stack for GP + FPU
+    addi  sp, sp, -0xd0
+
+    # save fs0 - fs11
+    fsd  fs0, 0x00(sp)
+    fsd  fs1, 0x08(sp)
+    fsd  fs2, 0x10(sp)
+    fsd  fs3, 0x18(sp)
+    fsd  fs4, 0x20(sp)
+    fsd  fs5, 0x28(sp)
+    fsd  fs6, 0x30(sp)
+    fsd  fs7, 0x38(sp)
+    fsd  fs8, 0x40(sp)
+    fsd  fs9, 0x48(sp)
+    fsd  fs10, 0x50(sp)
+    fsd  fs11, 0x58(sp)
+
+    # save s0-s11, ra
+    sd  s0, 0x60(sp)
+    sd  s1, 0x68(sp)
+    sd  s2, 0x70(sp)
+    sd  s3, 0x78(sp)
+    sd  s4, 0x80(sp)
+    sd  s5, 0x88(sp)
+    sd  s6, 0x90(sp)
+    sd  s7, 0x98(sp)
+    sd  s8, 0xa0(sp)
+    sd  s9, 0xa8(sp)
+    sd  s10, 0xb0(sp)
+    sd  s11, 0xb8(sp)
+    sd  ra, 0xc0(sp)
+
+    # save RA as PC
+    sd  ra, 0xc8(sp)
+
+    # store SP (pointing to context-data) in A2
+    mv  a2, sp
+
+    # restore SP (pointing to context-data) from A0
+    mv  sp, a0
+
+    # load fs0 - fs11
+    fld  fs0, 0x00(sp)
+    fld  fs1, 0x08(sp)
+    fld  fs2, 0x10(sp)
+    fld  fs3, 0x18(sp)
+    fld  fs4, 0x20(sp)
+    fld  fs5, 0x28(sp)
+    fld  fs6, 0x30(sp)
+    fld  fs7, 0x38(sp)
+    fld  fs8, 0x40(sp)
+    fld  fs9, 0x48(sp)
+    fld  fs10, 0x50(sp)
+    fld  fs11, 0x58(sp)
+
+    # load s0-s11,ra
+    ld  s0, 0x60(sp)
+    ld  s1, 0x68(sp)
+    ld  s2, 0x70(sp)
+    ld  s3, 0x78(sp)
+    ld  s4, 0x80(sp)
+    ld  s5, 0x88(sp)
+    ld  s6, 0x90(sp)
+    ld  s7, 0x98(sp)
+    ld  s8, 0xa0(sp)
+    ld  s9, 0xa8(sp)
+    ld  s10, 0xb0(sp)
+    ld  s11, 0xb8(sp)
+    ld  ra, 0xc0(sp)
+
+    # return transfer_t from jump
+    # pass transfer_t as first arg in context function
+    # a0 == FCTX, a1 == DATA
+    mv a0, a2
+
+    # load pc
+    ld  a2, 0xc8(sp)
+
+    # restore stack from GP + FPU
+    addi  sp, sp, 0xd0
+
+    jr a2
+.size   jump_fcontext,.-jump_fcontext
+# Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/jump_x86_64_ms_pe_gas.asm b/osal/src/sugar/asm/jump_x86_64_ms_pe_gas.asm
new file mode 100644
index 0000000..ec4ecfe
--- /dev/null
+++ b/osal/src/sugar/asm/jump_x86_64_ms_pe_gas.asm
@@ -0,0 +1,209 @@
+/*
+            Copyright Oliver Kowalke 2009.
+            Copyright Thomas Sailer 2013.
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+            http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+/*************************************************************************************
+* ---------------------------------------------------------------------------------- *
+* |     0   |     1   |     2    |     3   |     4   |     5   |     6   |     7   | *
+* ---------------------------------------------------------------------------------- *
+* |    0x0  |    0x4  |    0x8   |    0xc  |   0x10  |   0x14  |   0x18  |   0x1c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |     8   |    9    |    10    |    11   |    12   |    13   |    14   |    15   | *
+* ---------------------------------------------------------------------------------- *
+* |   0x20  |  0x24   |   0x28   |   0x2c  |   0x30  |   0x34  |   0x38  |   0x3c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    16   |    17   |    18   |    19    |    20   |    21   |    22   |    23   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xe40  |   0x44 |   0x48  |   0x4c   |   0x50  |   0x54  |   0x58  |   0x5c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    24   |   25    |    26    |   27    |    28   |    29   |    30   |    31   | *
+* ---------------------------------------------------------------------------------- *
+* |   0x60  |   0x64  |   0x68   |   0x6c  |   0x70  |   0x74  |   0x78  |   0x7c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    32   |   32    |    33    |   34    |    35   |    36   |    37   |    38   | *
+* ---------------------------------------------------------------------------------- *
+* |   0x80  |   0x84  |   0x88   |   0x8c  |   0x90  |   0x94  |   0x98  |   0x9c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    39   |   40    |    41    |   42    |    43   |    44   |    45   |    46   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xa0  |   0xa4  |   0xa8   |   0xac  |   0xb0  |   0xb4  |   0xb8  |   0xbc  | *
+* ---------------------------------------------------------------------------------- *
+* | fc_mxcsr|fc_x87_cw|     <alignment>    |       fbr_strg    |      fc_dealloc   | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    47   |   48    |    49    |   50    |    51   |    52   |    53   |    54   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xc0  |   0xc4  |   0xc8   |   0xcc  |   0xd0  |   0xd4  |   0xd8  |   0xdc  | *
+* ---------------------------------------------------------------------------------- *
+* |        limit      |         base       |         R12       |         R13       | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    55   |   56    |    57    |   58    |    59   |    60   |    61   |    62   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xe0  |   0xe4  |   0xe8   |   0xec  |   0xf0  |   0xf4  |   0xf8  |   0xfc  | *
+* ---------------------------------------------------------------------------------- *
+* |        R14        |         R15        |         RDI       |        RSI        | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    63   |   64    |    65    |   66    |    67   |    68   |    69   |    70   | *
+* ---------------------------------------------------------------------------------- *
+* |  0x100  |  0x104  |  0x108   |  0x10c  |  0x110  |  0x114  |  0x118  |  0x11c  | *
+* ---------------------------------------------------------------------------------- *
+* |        RBX        |         RBP        |       hidden      |        RIP        | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    71   |   72    |    73    |   74    |    75   |    76   |    77   |    78   | *
+* ---------------------------------------------------------------------------------- *
+* |  0x120  |  0x124  |  0x128   |  0x12c  |  0x130  |  0x134  |  0x138  |  0x13c  | *
+* ---------------------------------------------------------------------------------- *
+* |                                   parameter area                               | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    79   |   80    |    81    |   82    |    83   |    84   |    85   |    86   | *
+* ---------------------------------------------------------------------------------- *
+* |  0x140  |  0x144  |  0x148   |  0x14c  |  0x150  |  0x154  |  0x158  |  0x15c  | *
+* ---------------------------------------------------------------------------------- *
+* |       FCTX        |        DATA        |                                       | *
+* ---------------------------------------------------------------------------------- *
+**************************************************************************************/
+
+.file	"jump_x86_64_ms_pe_gas.asm"
+.text
+.p2align 4,,15
+.globl	jump_fcontext
+.def	jump_fcontext;	.scl	2;	.type	32;	.endef
+.seh_proc	jump_fcontext
+jump_fcontext:
+.seh_endprologue
+
+    leaq  -0x118(%rsp), %rsp /* prepare stack */
+
+#if !defined(BOOST_USE_TSX)
+    /* save XMM storage */
+    movaps  %xmm6, 0x0(%rsp)
+    movaps  %xmm7, 0x10(%rsp)
+    movaps  %xmm8, 0x20(%rsp)
+    movaps  %xmm9, 0x30(%rsp)
+    movaps  %xmm10, 0x40(%rsp)
+    movaps  %xmm11, 0x50(%rsp)
+    movaps  %xmm12, 0x60(%rsp)
+    movaps  %xmm13, 0x70(%rsp)
+    movaps  %xmm14, 0x80(%rsp)
+    movaps  %xmm15, 0x90(%rsp)
+    stmxcsr  0xa0(%rsp)  /* save MMX control- and status-word */
+    fnstcw   0xa4(%rsp)  /* save x87 control-word */
+#endif
+
+    /* load NT_TIB */
+    movq  %gs:(0x30), %r10
+    /* save fiber local storage */
+    movq  0x20(%r10), %rax
+    movq  %rax, 0xb0(%rsp)
+    /* save current deallocation stack */
+    movq  0x1478(%r10), %rax
+    movq  %rax, 0xb8(%rsp)
+    /* save current stack limit */
+    movq  0x10(%r10), %rax
+    movq  %rax, 0xc0(%rsp)
+    /* save current stack base */
+    movq  0x08(%r10), %rax
+    movq  %rax, 0xc8(%rsp)
+
+    movq  %r12, 0xd0(%rsp)  /* save R12 */
+    movq  %r13, 0xd8(%rsp)  /* save R13 */
+    movq  %r14, 0xe0(%rsp)  /* save R14 */
+    movq  %r15, 0xe8(%rsp)  /* save R15 */
+    movq  %rdi, 0xf0(%rsp)  /* save RDI */
+    movq  %rsi, 0xf8(%rsp)  /* save RSI */
+    movq  %rbx, 0x100(%rsp)  /* save RBX */
+    movq  %rbp, 0x108(%rsp)  /* save RBP */
+
+    movq  %rcx, 0x110(%rsp)  /* save hidden address of transport_t */
+
+    /* preserve RSP (pointing to context-data) in R9 */
+    movq  %rsp, %r9
+
+    /* restore RSP (pointing to context-data) from RDX */
+    movq  %rdx, %rsp
+
+#if !defined(BOOST_USE_TSX)
+    /* restore XMM storage */
+    movaps  0x0(%rsp), %xmm6
+    movaps  0x10(%rsp), %xmm7
+    movaps  0x20(%rsp), %xmm8
+    movaps  0x30(%rsp), %xmm9
+    movaps  0x40(%rsp), %xmm10
+    movaps  0x50(%rsp), %xmm11
+    movaps  0x60(%rsp), %xmm12
+    movaps  0x70(%rsp), %xmm13
+    movaps  0x80(%rsp), %xmm14
+    movaps  0x90(%rsp), %xmm15
+ 	ldmxcsr 0xa0(%rsp) /* restore MMX control- and status-word */
+ 	fldcw   0xa4(%rsp) /* restore x87 control-word */
+#endif
+
+    /* load NT_TIB */
+    movq  %gs:(0x30), %r10
+    /* restore fiber local storage */
+    movq  0xb0(%rsp), %rax
+    movq  %rax, 0x20(%r10)
+    /* restore current deallocation stack */
+    movq  0xb8(%rsp), %rax
+    movq  %rax, 0x1478(%r10)
+    /* restore current stack limit */
+    movq  0xc0(%rsp), %rax
+    movq  %rax, 0x10(%r10)
+    /* restore current stack base */
+    movq  0xc8(%rsp), %rax
+    movq  %rax, 0x08(%r10)
+
+    movq  0xd0(%rsp),  %r12  /* restore R12 */
+    movq  0xd8(%rsp),  %r13  /* restore R13 */
+    movq  0xe0(%rsp),  %r14  /* restore R14 */
+    movq  0xe8(%rsp),  %r15  /* restore R15 */
+    movq  0xf0(%rsp),  %rdi  /* restore RDI */
+    movq  0xf8(%rsp),  %rsi  /* restore RSI */
+    movq  0x100(%rsp), %rbx  /* restore RBX */
+    movq  0x108(%rsp), %rbp  /* restore RBP */
+
+    movq  0x110(%rsp), %rax  /* restore hidden address of transport_t */
+
+    leaq  0x118(%rsp), %rsp /* prepare stack */
+
+    /* restore return-address */
+    popq  %r10
+
+    /* transport_t returned in RAX */
+    /* return parent fcontext_t */
+    movq  %r9, 0x0(%rax)
+    /* return data */
+    movq  %r8, 0x8(%rax)
+
+    /* transport_t as 1.arg of context-function */
+    movq  %rax, %rcx
+
+    /* indirect jump to context */
+    jmp  *%r10
+.seh_endproc
+
+.section .drectve
+.ascii " -export:\"jump_fcontext\""
diff --git a/osal/src/sugar/asm/jump_x86_64_sysv_elf_gas.S b/osal/src/sugar/asm/jump_x86_64_sysv_elf_gas.S
new file mode 100644
index 0000000..d0defc4
--- /dev/null
+++ b/osal/src/sugar/asm/jump_x86_64_sysv_elf_gas.S
@@ -0,0 +1,81 @@
+/*
+            Copyright Oliver Kowalke 2009.
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+            http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+/****************************************************************************************
+ *                                                                                      *
+ *  ----------------------------------------------------------------------------------  *
+ *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |        R15        |        RBX        |         RBP        |        RIP        |  *
+ *  ----------------------------------------------------------------------------------  *
+ *                                                                                      *
+ ****************************************************************************************/
+
+.file "jump_x86_64_sysv_elf_gas.S"
+.text
+.globl jump_fcontext
+.type jump_fcontext,@function
+.align 16
+jump_fcontext:
+    leaq  -0x38(%rsp), %rsp /* prepare stack */
+
+#if !defined(BOOST_USE_TSX)
+    stmxcsr  (%rsp)     /* save MMX control- and status-word */
+    fnstcw   0x4(%rsp)  /* save x87 control-word */
+#endif
+
+    movq  %r12, 0x8(%rsp)  /* save R12 */
+    movq  %r13, 0x10(%rsp)  /* save R13 */
+    movq  %r14, 0x18(%rsp)  /* save R14 */
+    movq  %r15, 0x20(%rsp)  /* save R15 */
+    movq  %rbx, 0x28(%rsp)  /* save RBX */
+    movq  %rbp, 0x30(%rsp)  /* save RBP */
+
+    /* store RSP (pointing to context-data) in RAX */
+    movq  %rsp, %rax
+
+    /* restore RSP (pointing to context-data) from RDI */
+    movq  %rdi, %rsp
+
+    movq  0x38(%rsp), %r8  /* restore return-address */
+
+#if !defined(BOOST_USE_TSX)
+    ldmxcsr  (%rsp)     /* restore MMX control- and status-word */
+    fldcw    0x4(%rsp)  /* restore x87 control-word */
+#endif
+
+    movq  0x8(%rsp), %r12  /* restore R12 */
+    movq  0x10(%rsp), %r13  /* restore R13 */
+    movq  0x18(%rsp), %r14  /* restore R14 */
+    movq  0x20(%rsp), %r15  /* restore R15 */
+    movq  0x28(%rsp), %rbx  /* restore RBX */
+    movq  0x30(%rsp), %rbp  /* restore RBP */
+
+    leaq  0x40(%rsp), %rsp /* prepare stack */
+
+    /* return transfer_t from jump */
+    /* RAX == fctx, RDX == data */
+    movq  %rsi, %rdx
+    /* pass transfer_t as first arg in context function */
+    /* RDI == fctx, RSI == data */
+    movq  %rax, %rdi
+
+    /* indirect jump to context */
+    jmp  *%r8
+.size jump_fcontext,.-jump_fcontext
+
+/* Mark that we don't need executable stack.  */
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/make_arm64_aapcs_elf_gas.S b/osal/src/sugar/asm/make_arm64_aapcs_elf_gas.S
new file mode 100644
index 0000000..66cfb2d
--- /dev/null
+++ b/osal/src/sugar/asm/make_arm64_aapcs_elf_gas.S
@@ -0,0 +1,85 @@
+/*
+            Copyright Edward Nevill + Oliver Kowalke 2015
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+/*******************************************************
+ *                                                     *
+ *  -------------------------------------------------  *
+ *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
+ *  -------------------------------------------------  *
+ *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
+ *  -------------------------------------------------  *
+ *  |    d8     |    d9     |    d10    |    d11    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
+ *  -------------------------------------------------  *
+ *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
+ *  -------------------------------------------------  *
+ *  |    d12    |    d13    |    d14    |    d15    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
+ *  -------------------------------------------------  *
+ *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
+ *  -------------------------------------------------  *
+ *  |    x19    |    x20    |    x21    |    x22    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
+ *  -------------------------------------------------  *
+ *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
+ *  -------------------------------------------------  *
+ *  |    x23    |    x24    |    x25    |    x26    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
+ *  -------------------------------------------------  *
+ *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
+ *  -------------------------------------------------  *
+ *  |    x27    |    x28    |    FP     |     LR    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  40 |  41 |  42 | 43  |           |           |  *
+ *  -------------------------------------------------  *
+ *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *
+ *  -------------------------------------------------  *
+ *  |     PC    |   align   |           |           |  *
+ *  -------------------------------------------------  *
+ *                                                     *
+ *******************************************************/
+
+.file "make_arm64_aapcs_elf_gas.S"
+.text
+.align  2
+.global make_fcontext
+.type   make_fcontext, %function
+make_fcontext:
+    # shift address in x0 (allocated stack) to lower 16 byte boundary
+    and x0, x0, ~0xF
+
+    # reserve space for context-data on context-stack
+    sub  x0, x0, #0xb0
+
+    # third arg of make_fcontext() == address of context-function
+    # store address as a PC to jump in
+    str  x2, [x0, #0xa0]
+
+    # save address of finish as return-address for context-function
+    # will be entered after context-function returns (LR register)
+    adr  x1, finish
+    str  x1, [x0, #0x98]
+
+    ret  x30 // return pointer to context-data (x0)
+
+finish:
+    # exit code is zero
+    mov  x0, #0
+    # exit application
+    bl  _exit
+
+.size   make_fcontext,.-make_fcontext
+# Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/make_arm_aapcs_elf_gas.S b/osal/src/sugar/asm/make_arm_aapcs_elf_gas.S
new file mode 100644
index 0000000..98ae64b
--- /dev/null
+++ b/osal/src/sugar/asm/make_arm_aapcs_elf_gas.S
@@ -0,0 +1,81 @@
+/*
+            Copyright Oliver Kowalke 2009.
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+/*******************************************************
+ *                                                     *
+ *  -------------------------------------------------  *
+ *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
+ *  -------------------------------------------------  *
+ *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
+ *  -------------------------------------------------  *
+ *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
+ *  -------------------------------------------------  *
+ *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
+ *  -------------------------------------------------  *
+ *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
+ *  -------------------------------------------------  *
+ *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
+ *  -------------------------------------------------  *
+ *  |hiddn|  v1 |  v2 |  v3 |  v4 |  v5 |  v6 |  v7 |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
+ *  -------------------------------------------------  *
+ *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
+ *  -------------------------------------------------  *
+ *  |  v8 |  lr |  pc | FCTX| DATA|                 |  *
+ *  -------------------------------------------------  *
+ *                                                     *
+ *******************************************************/
+
+.file "make_arm_aapcs_elf_gas.S"
+.text
+.globl make_fcontext
+.align 2
+.type make_fcontext,%function
+.syntax unified
+make_fcontext:
+    @ shift address in A1 to lower 16 byte boundary
+    bic  a1, a1, #15
+
+    @ reserve space for context-data on context-stack
+    sub  a1, a1, #124
+
+    @ third arg of make_fcontext() == address of context-function
+    str  a3, [a1, #104]
+
+    @ compute address of returned transfer_t
+    add  a2, a1, #108
+    mov  a3, a2
+    str  a3, [a1, #64]
+
+    @ compute abs address of label finish
+    adr  a2, finish
+    @ save address of finish as return-address for context-function
+    @ will be entered after context-function returns
+    str  a2, [a1, #100]
+
+#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
+#endif
+
+    bx  lr @ return pointer to context-data
+
+finish:
+    @ exit code is zero
+    mov  a1, #0
+    @ exit application
+    bl  _exit@PLT
+.size make_fcontext,.-make_fcontext
+
+@ Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/make_gas.S b/osal/src/sugar/asm/make_gas.S
new file mode 100644
index 0000000..82e3a95
--- /dev/null
+++ b/osal/src/sugar/asm/make_gas.S
@@ -0,0 +1,19 @@
+// Stub file for universal binary
+
+#if defined(_WIN32) || defined(__MINGW32__) || defined(__MINGW64__) || defined(__CYGWIN__) || defined(__MSYS__)
+    #include "make_x86_64_ms_pe_gas.asm"
+#elif defined(__x86_64__)
+    #include "make_x86_64_sysv_elf_gas.S"
+#elif defined(__aarch64__)
+    #include "make_arm64_aapcs_elf_gas.S"
+#elif defined(__arm__)
+    #include "make_arm_aapcs_elf_gas.S"
+#elif defined(__riscv)
+    #if defined __unix__ || defined __linux__
+        #include "make_riscv64_sysv_elf_gas.S"
+    #else
+        #include "make_riscv32_elf_gas.S"
+    #endif
+#else
+    #error "No arch's"
+#endif
diff --git a/osal/src/sugar/asm/make_riscv32_elf_gas.S b/osal/src/sugar/asm/make_riscv32_elf_gas.S
new file mode 100644
index 0000000..5d7ebb4
--- /dev/null
+++ b/osal/src/sugar/asm/make_riscv32_elf_gas.S
@@ -0,0 +1,42 @@
+/*
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+.file "make_riscv64_elf_gas.S"
+.text
+.align  1
+.global make_fcontext
+.type   make_fcontext, %function
+make_fcontext:
+    # shift address in a0 (allocated stack) to lower 4 byte boundary
+    andi a0, a0, ~0x3
+
+    # reserve space for context-data on context-stack
+#ifdef __riscv_flen
+    addi  a0, a0, -0x68
+#else
+    addi  a0, a0, -0x38
+#endif
+
+    # third arg of make_fcontext() == address of context-function
+    # store address as a PC to jump in
+    sw  a2, 0x34(a0)
+
+    # save address of finish as return-address for context-function
+    # will be entered after context-function returns (RA register)
+    lla  a4, finish
+    sw  a4, 0x30(a0)
+
+    ret // return pointer to context-data (a0)
+
+finish:
+    # exit code is zero
+    li  a0, 0
+    # exit application
+    tail  _exit@plt
+
+.size   make_fcontext,.-make_fcontext
+# Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/make_riscv64_sysv_elf_gas.S b/osal/src/sugar/asm/make_riscv64_sysv_elf_gas.S
new file mode 100644
index 0000000..5322e0f
--- /dev/null
+++ b/osal/src/sugar/asm/make_riscv64_sysv_elf_gas.S
@@ -0,0 +1,91 @@
+/*
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt)
+*/
+/*******************************************************
+ *                                                     *
+ *  -------------------------------------------------  *
+ *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
+ *  -------------------------------------------------  *
+ *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
+ *  -------------------------------------------------  *
+ *  |    fs0    |    fs1    |    fs2    |    fs3    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
+ *  -------------------------------------------------  *
+ *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
+ *  -------------------------------------------------  *
+ *  |    fs4    |    fs5    |    fs6    |    fs7    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
+ *  -------------------------------------------------  *
+ *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
+ *  -------------------------------------------------  *
+ *  |    fs8    |    fs9    |    fs10   |    fs11   |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
+ *  -------------------------------------------------  *
+ *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
+ *  -------------------------------------------------  *
+ *  |    s0     |    s1     |    s2     |    s3     |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
+ *  -------------------------------------------------  *
+ *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
+ *  -------------------------------------------------  *
+ *  |    s4     |    s5     |    s6     |     s7    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  40 |  41 |  42 | 43  |  44 | 45  |  46 | 47  |  *
+ *  -------------------------------------------------  *
+ *  | 0xa0| 0xa4| 0xa8| 0xac| 0xb0| 0xb4| 0xb8| 0xbc|  *
+ *  -------------------------------------------------  *
+ *  |     s8    |     s9    |    s10    |    s11    |  *
+ *  -------------------------------------------------  *
+ *  -------------------------------------------------  *
+ *  |  48 |  49 |  50 | 51  |     |     |     |     |  *
+ *  -------------------------------------------------  *
+ *  | 0xc0| 0xc4| 0xc8| 0xcc|     |     |     |     |  *
+ *  -------------------------------------------------  *
+ *  |     ra    |     pc    |           |           |  *
+ *  -------------------------------------------------  *
+ *                                                     *
+ *******************************************************/
+
+.file "make_riscv64_sysv_elf_gas.S"
+.text
+.align  1
+.global make_fcontext
+.type   make_fcontext, %function
+make_fcontext:
+    # shift address in a0 (allocated stack) to lower 16 byte boundary
+    andi a0, a0, ~0xF
+
+    # reserve space for context-data on context-stack
+    addi  a0, a0, -0xd0
+
+    # third arg of make_fcontext() == address of context-function
+    # store address as a PC to jump in
+    sd  a2, 0xc8(a0)
+
+    # save address of finish as return-address for context-function
+    # will be entered after context-function returns (RA register)
+    lla  a4, finish
+    sd  a4, 0xc0(a0)
+
+    ret // return pointer to context-data (a0)
+
+finish:
+    # exit code is zero
+    li  a0, 0
+    # exit application
+    tail  _exit@plt
+
+.size   make_fcontext,.-make_fcontext
+# Mark that we don't need executable stack.
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/asm/make_x86_64_ms_pe_gas.asm b/osal/src/sugar/asm/make_x86_64_ms_pe_gas.asm
new file mode 100644
index 0000000..958a2a7
--- /dev/null
+++ b/osal/src/sugar/asm/make_x86_64_ms_pe_gas.asm
@@ -0,0 +1,174 @@
+/*
+            Copyright Oliver Kowalke 2009.
+            Copyright Thomas Sailer 2013.
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+            http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+/*************************************************************************************
+* ---------------------------------------------------------------------------------- *
+* |     0   |     1   |     2    |     3   |     4   |     5   |     6   |     7   | *
+* ---------------------------------------------------------------------------------- *
+* |    0x0  |    0x4  |    0x8   |    0xc  |   0x10  |   0x14  |   0x18  |   0x1c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |     8   |    9    |    10    |    11   |    12   |    13   |    14   |    15   | *
+* ---------------------------------------------------------------------------------- *
+* |   0x20  |  0x24   |   0x28   |   0x2c  |   0x30  |   0x34  |   0x38  |   0x3c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    16   |    17   |    18   |    19    |    20   |    21   |    22   |    23   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xe40  |   0x44 |   0x48  |   0x4c   |   0x50  |   0x54  |   0x58  |   0x5c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    24   |   25    |    26    |   27    |    28   |    29   |    30   |    31   | *
+* ---------------------------------------------------------------------------------- *
+* |   0x60  |   0x64  |   0x68   |   0x6c  |   0x70  |   0x74  |   0x78  |   0x7c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    32   |   32    |    33    |   34    |    35   |    36   |    37   |    38   | *
+* ---------------------------------------------------------------------------------- *
+* |   0x80  |   0x84  |   0x88   |   0x8c  |   0x90  |   0x94  |   0x98  |   0x9c  | *
+* ---------------------------------------------------------------------------------- *
+* |                          SEE registers (XMM6-XMM15)                            | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    39   |   40    |    41    |   42    |    43   |    44   |    45   |    46   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xa0  |   0xa4  |   0xa8   |   0xac  |   0xb0  |   0xb4  |   0xb8  |   0xbc  | *
+* ---------------------------------------------------------------------------------- *
+* | fc_mxcsr|fc_x87_cw|     <alignment>    |       fbr_strg    |      fc_dealloc   | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    47   |   48    |    49    |   50    |    51   |    52   |    53   |    54   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xc0  |   0xc4  |   0xc8   |   0xcc  |   0xd0  |   0xd4  |   0xd8  |   0xdc  | *
+* ---------------------------------------------------------------------------------- *
+* |        limit      |         base       |         R12       |         R13       | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    55   |   56    |    57    |   58    |    59   |    60   |    61   |    62   | *
+* ---------------------------------------------------------------------------------- *
+* |   0xe0  |   0xe4  |   0xe8   |   0xec  |   0xf0  |   0xf4  |   0xf8  |   0xfc  | *
+* ---------------------------------------------------------------------------------- *
+* |        R14        |         R15        |         RDI       |        RSI        | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    63   |   64    |    65    |   66    |    67   |    68   |    69   |    70   | *
+* ---------------------------------------------------------------------------------- *
+* |  0x100  |  0x104  |  0x108   |  0x10c  |  0x110  |  0x114  |  0x118  |  0x11c  | *
+* ---------------------------------------------------------------------------------- *
+* |        RBX        |         RBP        |       hidden      |        RIP        | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    71   |   72    |    73    |   74    |    75   |    76   |    77   |    78   | *
+* ---------------------------------------------------------------------------------- *
+* |  0x120  |  0x124  |  0x128   |  0x12c  |  0x130  |  0x134  |  0x138  |  0x13c  | *
+* ---------------------------------------------------------------------------------- *
+* |                                   parameter area                               | *
+* ---------------------------------------------------------------------------------- *
+* ---------------------------------------------------------------------------------- *
+* |    79   |   80    |    81    |   82    |    83   |    84   |    85   |    86   | *
+* ---------------------------------------------------------------------------------- *
+* |  0x140  |  0x144  |  0x148   |  0x14c  |  0x150  |  0x154  |  0x158  |  0x15c  | *
+* ---------------------------------------------------------------------------------- *
+* |       FCTX        |        DATA        |                                       | *
+* ---------------------------------------------------------------------------------- *
+**************************************************************************************/
+
+.file	"make_x86_64_ms_pe_gas.asm"
+.text
+.p2align 4,,15
+.globl	make_fcontext
+.def	make_fcontext;	.scl	2;	.type	32;	.endef
+.seh_proc	make_fcontext
+make_fcontext:
+.seh_endprologue
+
+    /* first arg of make_fcontext() == top of context-stack */
+    movq  %rcx, %rax
+
+    /* shift address in RAX to lower 16 byte boundary */
+    /* == pointer to fcontext_t and address of context stack */
+    andq  $-16, %rax
+
+    /* reserve space for context-data on context-stack */
+    /* on context-function entry: (RSP -0x8) % 16 == 0 */
+    leaq  -0x150(%rax), %rax
+
+    /* third arg of make_fcontext() == address of context-function */
+    movq  %r8, 0x100(%rax)
+
+    /* first arg of make_fcontext() == top of context-stack */
+    /* save top address of context stack as 'base' */
+    movq  %rcx, 0xc8(%rax)
+    /* second arg of make_fcontext() == size of context-stack */
+    /* negate stack size for LEA instruction (== substraction) */
+    negq  %rdx
+    /* compute bottom address of context stack (limit) */
+    leaq  (%rcx,%rdx), %rcx
+    /* save bottom address of context stack as 'limit' */
+    movq  %rcx, 0xc0(%rax)
+    /* save address of context stack limit as 'dealloction stack' */
+    movq  %rcx, 0xb8(%rax)
+	/* set fiber-storage to zero */
+    xorq  %rcx, %rcx
+    movq  %rcx, 0xb0(%rax)
+
+	/* save MMX control- and status-word */
+    stmxcsr  0xa0(%rax)
+    /* save x87 control-word */
+    fnstcw   0xa4(%rax)
+
+    /* compute address of transport_t */
+    leaq  0x140(%rax), %rcx
+    /* store address of transport_t in hidden field */
+    movq %rcx, 0x110(%rax)
+
+    /* compute abs address of label trampoline */
+    leaq  trampoline(%rip), %rcx
+    /* save address of finish as return-address for context-function */
+    /* will be entered after jump_fcontext() first time */
+    movq  %rcx, 0x118(%rax)
+
+    /* compute abs address of label finish */
+    leaq  finish(%rip), %rcx
+    /* save address of finish as return-address for context-function */
+    /* will be entered after context-function returns */
+    movq  %rcx, 0x108(%rax)
+
+    ret /* return pointer to context-data */
+
+trampoline:
+    /* store return address on stack */
+    /* fix stack alignment */ 
+    pushq %rbp
+    /* jump to context-function */
+    jmp *%rbx
+
+finish:
+    /* 32byte shadow-space for _exit() */
+    andq  $-32, %rsp
+    /* 32byte shadow-space for _exit() are */
+    /* already reserved by make_fcontext() */
+    /* exit code is zero */
+    xorq  %rcx, %rcx
+    /* exit application */
+    call  _exit
+    hlt
+.seh_endproc
+
+.def	_exit;	.scl	2;	.type	32;	.endef  /* standard C library function */
+
+.section .drectve
+.ascii " -export:\"make_fcontext\""
diff --git a/osal/src/sugar/asm/make_x86_64_sysv_elf_gas.S b/osal/src/sugar/asm/make_x86_64_sysv_elf_gas.S
new file mode 100644
index 0000000..0ef3756
--- /dev/null
+++ b/osal/src/sugar/asm/make_x86_64_sysv_elf_gas.S
@@ -0,0 +1,82 @@
+/*
+            Copyright Oliver Kowalke 2009.
+   Distributed under the Boost Software License, Version 1.0.
+      (See accompanying file LICENSE_1_0.txt or copy at
+            http://www.boost.org/LICENSE_1_0.txt)
+*/
+
+/****************************************************************************************
+ *                                                                                      *
+ *  ----------------------------------------------------------------------------------  *
+ *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *
+ *  ----------------------------------------------------------------------------------  *
+ *  |        R15        |        RBX        |         RBP        |        RIP        |  *
+ *  ----------------------------------------------------------------------------------  *
+ *                                                                                      *
+ ****************************************************************************************/
+
+.file "make_x86_64_sysv_elf_gas.S"
+.text
+.globl make_fcontext
+.type make_fcontext,@function
+.align 16
+make_fcontext:
+    /* first arg of make_fcontext() == top of context-stack */
+    movq  %rdi, %rax
+
+    /* shift address in RAX to lower 16 byte boundary */
+    andq  $-16, %rax
+
+    /* reserve space for context-data on context-stack */
+    /* on context-function entry: (RSP -0x8) % 16 == 0 */
+    leaq  -0x40(%rax), %rax
+
+    /* third arg of make_fcontext() == address of context-function */
+    /* stored in RBX */
+    movq  %rdx, 0x28(%rax)
+
+    /* save MMX control- and status-word */
+    stmxcsr  (%rax)
+    /* save x87 control-word */
+    fnstcw   0x4(%rax)
+
+    /* compute abs address of label trampoline */
+    leaq  trampoline(%rip), %rcx
+    /* save address of trampoline as return-address for context-function */
+    /* will be entered after calling jump_fcontext() first time */
+    movq  %rcx, 0x38(%rax)
+
+    /* compute abs address of label finish */
+    leaq  finish(%rip), %rcx
+    /* save address of finish as return-address for context-function */
+    /* will be entered after context-function returns */
+    movq  %rcx, 0x30(%rax)
+
+    ret /* return pointer to context-data */
+
+trampoline:
+    /* store return address on stack */
+    /* fix stack alignment */
+    push %rbp
+    /* jump to context-function */
+    jmp *%rbx
+
+finish:
+    /* exit code is zero */
+    xorq  %rdi, %rdi
+    /* exit application */
+    call  _exit@PLT
+    hlt
+.size make_fcontext,.-make_fcontext
+
+/* Mark that we don't need executable stack. */
+.section .note.GNU-stack,"",%progbits
diff --git a/osal/src/sugar/mm.c b/osal/src/sugar/mm.c
deleted file mode 100644
index e69de29..0000000
diff --git a/osal/src/sugar/s_chan.c b/osal/src/sugar/s_chan.c
new file mode 100644
index 0000000..f53ac92
--- /dev/null
+++ b/osal/src/sugar/s_chan.c
@@ -0,0 +1,145 @@
+#include "s_task.h"
+#include <string.h>
+
+/*******************************************************************/
+/* chan                                                            */
+/*******************************************************************/
+
+uint16_t s_chan_put_(s_chan_t *chan, const void **in_object, uint16_t *number) {
+    uint16_t begin;
+    uint16_t end;
+    uint16_t count;
+
+    count = chan->max_count - chan->available_count;
+    if(count > *number)
+        count = *number;
+
+    begin = chan->begin + chan->available_count;
+    while (begin > chan->max_count)
+        begin -= chan->max_count;
+
+    end = begin + count;
+    if(end >= chan->max_count) {
+        uint16_t count0 = chan->max_count - begin;
+        memcpy((char *)&chan[1] + begin * (size_t)chan->element_size, *in_object, count0 * (size_t)chan->element_size);
+        *in_object = (const void *)((const char *)*in_object + count0 * (size_t)chan->element_size);
+
+        count0 = count - count0;
+        memcpy((char *)&chan[1], *in_object, count0 * (size_t)chan->element_size);
+        *in_object = (const void *)((const char *)*in_object + count0 * (size_t)chan->element_size);
+    }
+    else {
+        memcpy((char *)&chan[1] + begin * (size_t)chan->element_size, *in_object, count * (size_t)chan->element_size);
+        *in_object = (const void *)((const char *)*in_object + count * (size_t)chan->element_size);
+    }
+
+    chan->available_count += count;
+    *number -= count;
+
+    return count;
+}
+
+uint16_t s_chan_get_(s_chan_t *chan, void **out_object, uint16_t *number) {
+    uint16_t end;
+    uint16_t count;
+
+    count = chan->available_count;
+    if(count > *number)
+        count = *number;
+
+    end = chan->begin + count;
+    if(end >= chan->max_count) {
+        uint16_t count0 = chan->max_count - chan->begin;
+        memcpy(*out_object, (char *)&chan[1] + chan->begin * (size_t)chan->element_size, count0 * (size_t)chan->element_size);
+        *out_object = (void *)((char *)*out_object + count0 * (size_t)chan->element_size);
+
+        count0 = count - count0;
+        memcpy(*out_object, (char *)&chan[1], count0 * (size_t)chan->element_size);
+        *out_object = (void*)((char*)*out_object + count0 * (size_t)chan->element_size);
+
+        chan->begin = count0;
+    }
+    else {
+        memcpy(*out_object, (char *)&chan[1] + chan->begin * (size_t)chan->element_size, count * (size_t)chan->element_size);
+        *out_object = (void*)((char*)*out_object + count * (size_t)chan->element_size);
+
+        chan->begin = end;
+    }
+
+    chan->available_count -= count;
+    *number -= count;
+
+    return count;
+}
+
+/* Put element into chan */
+int s_chan_put(__async__, s_chan_t *chan, const void *in_object) {
+#if 1
+    return s_chan_put_n(__await__, chan, in_object, 1);
+#else
+    uint16_t end;
+    while (chan->available_count >= chan->max_count) {
+        int ret = s_event_wait(__await__, &chan->event);
+        if(ret != 0) return ret;
+    }
+
+    end = chan->begin + chan->available_count;
+    while (end > chan->max_count)
+        end -= chan->max_count;
+
+    memcpy((char*)&chan[1] + end * (size_t)chan->element_size, in_object, chan->element_size);
+    ++chan->available_count;
+
+    s_event_set(&chan->event);
+    return 0;
+#endif
+}
+
+/* Get element from chan */
+int s_chan_get(__async__, s_chan_t *chan, void *out_object) {
+#if 1
+    return s_chan_get_n(__await__, chan, out_object, 1);
+#else
+    while (chan->available_count <= 0) {
+        int ret = s_event_wait(__await__, &chan->event);
+        if(ret != 0) return ret;
+    }
+
+    memcpy(out_object, (char*)&chan[1] + chan->begin * (size_t)chan->element_size, chan->element_size);
+
+    ++chan->begin;
+    while (chan->begin > chan->max_count)
+        chan->begin -= chan->max_count;
+    --chan->available_count;
+
+    s_event_set(&chan->event);
+    return 0;
+#endif
+}
+
+/* Put count of elements into chan */
+int s_chan_put_n(__async__, s_chan_t *chan, const void *in_object, uint16_t number) {
+    while(number > 0) {
+        while (chan->available_count >= chan->max_count) {
+            int ret = s_event_wait(__await__, &chan->event);
+            if(ret != 0) return ret;
+        }
+        s_chan_put_(chan, &in_object, &number);
+        s_event_set(&chan->event);
+    }
+    return 0;
+}
+
+
+/* Get count of elements from chan */
+int s_chan_get_n(__async__, s_chan_t *chan, void *out_object, uint16_t number) {
+    while(number > 0) {
+        while (chan->available_count <= 0) {
+            int ret = s_event_wait(__await__, &chan->event);
+            if(ret != 0) return ret;
+        }
+        s_chan_get_(chan, &out_object, &number);
+        s_event_set(&chan->event);
+    }
+    return 0;
+}
diff --git a/osal/src/sugar/s_chan_embed.c b/osal/src/sugar/s_chan_embed.c
new file mode 100644
index 0000000..ec5f5dd
--- /dev/null
+++ b/osal/src/sugar/s_chan_embed.c
@@ -0,0 +1,164 @@
+#include "s_task.h"
+#include <string.h>
+
+#ifdef USE_IN_EMBEDDED
+
+/*******************************************************************/
+/* chan for communication between irq and task                     */
+/*******************************************************************/
+
+/* Task puts element into chan and waits interrupt to read the chan */
+void s_chan_put__to_irq(__async__, s_chan_t *chan, const void *in_object) {
+#if 1
+    s_chan_put_n__to_irq(__await__, chan, in_object, 1);
+#else
+    uint16_t end;
+
+    S_IRQ_DISABLE();
+
+    while (chan->available_count >= chan->max_count) {
+        s_event_wait__from_irq(__await__, &chan->event);
+    }
+
+    end = chan->begin + chan->available_count;
+    while (end > chan->max_count)
+        end -= chan->max_count;
+
+    memcpy((char*)&chan[1] + end * (size_t)chan->element_size, in_object, chan->element_size);
+    ++chan->available_count;
+
+    S_IRQ_ENABLE();
+#endif
+}
+
+/* Task waits interrupt to write the chan and then gets element from chan */
+void s_chan_get__from_irq(__async__, s_chan_t *chan, void *out_object) {
+#if 1
+    s_chan_get_n__from_irq(__await__, chan, out_object, 1);
+#else
+    S_IRQ_DISABLE();
+
+    while (chan->available_count <= 0) {
+        s_event_wait__from_irq(__await__, &chan->event);
+    }
+
+    memcpy(out_object, (char*)&chan[1] + chan->begin * (size_t)chan->element_size, chan->element_size);
+
+    ++chan->begin;
+    while (chan->begin > chan->max_count)
+        chan->begin -= chan->max_count;
+    --chan->available_count;
+
+    S_IRQ_ENABLE();
+#endif
+}
+
+
+/*
+ * Interrupt writes element into the chan,
+ * return number of element was written into chan
+ */
+uint16_t s_chan_put__in_irq(s_chan_t *chan, const void *in_object) {
+#if 1
+    return s_chan_put_n__in_irq(chan, in_object, 1);
+#else
+    uint16_t end;
+    if (chan->available_count >= chan->max_count) {
+        return 0;  /* chan buffer overflow */
+    }
+
+    end = chan->begin + chan->available_count;
+    while (end > chan->max_count)
+        end -= chan->max_count;
+
+    memcpy((char*)&chan[1] + end * chan->element_size, in_object, chan->element_size);
+    ++chan->available_count;
+
+    s_event_set__in_irq(&chan->event);
+    return 1;
+#endif
+}
+
+
+/*
+ * Interrupt reads element from chan,
+ * return number of element was read from chan
+ */
+uint16_t s_chan_get__in_irq(s_chan_t *chan, void *out_object) {
+#if 1
+    return s_chan_get_n__in_irq(chan, out_object, 1);
+#else
+    if (chan->available_count <= 0) {
+        return 0;  /* chan buffer is empty */
+    }
+
+    memcpy(out_object, (char*)&chan[1] + chan->begin * chan->element_size, chan->element_size);
+
+    ++chan->begin;
+    while (chan->begin > chan->max_count)
+        chan->begin -= chan->max_count;
+    --chan->available_count;
+
+    s_event_set__in_irq(&chan->event);
+    return 1;
+#endif
+}
+
+
+
+/* Task puts number of elements into chan and waits interrupt to read the chan */
+void s_chan_put_n__to_irq(__async__, s_chan_t *chan, const void *in_object, uint16_t number) {
+    while(number > 0) {
+        S_IRQ_DISABLE();
+        while (chan->available_count >= chan->max_count) {
+            s_event_wait__from_irq(__await__, &chan->event);
+        }
+        s_chan_put_(chan, &in_object, &number);
+        S_IRQ_ENABLE();
+    }
+}
+
+/* Task waits interrupt to write the chan and then gets number of elements from chan */
+void s_chan_get_n__from_irq(__async__, s_chan_t *chan, void *out_object, uint16_t number) {
+    while(number > 0) {
+        S_IRQ_DISABLE();
+        while (chan->available_count <= 0) {
+            s_event_wait__from_irq(__await__, &chan->event);
+        }
+        s_chan_get_(chan, &out_object, &number);
+        S_IRQ_ENABLE();
+    }
+}
+
+
+/*
+ * Interrupt writes number of elements into the chan,
+ * return number of element was written into chan
+ */
+uint16_t s_chan_put_n__in_irq(s_chan_t *chan, const void *in_object, uint16_t number) {
+    uint16_t count;
+    if (chan->available_count >= chan->max_count)
+        return 0;
+
+    count = s_chan_put_(chan, &in_object, &number);
+    s_event_set__in_irq(&chan->event);
+
+    return count;
+}
+
+/*
+ * Interrupt reads number of elements from chan,
+ * return number of element was read from chan
+ */
+uint16_t s_chan_get_n__in_irq(s_chan_t *chan, void *out_object, uint16_t number) {
+    uint16_t count;
+    if (chan->available_count <= 0)
+        return 0;
+
+    count = s_chan_get_(chan, &out_object, &number);
+    s_event_set__in_irq(&chan->event);
+
+	return count;
+}
+
+#endif
diff --git a/osal/src/sugar/s_event.c b/osal/src/sugar/s_event.c
new file mode 100644
index 0000000..7dbda39
--- /dev/null
+++ b/osal/src/sugar/s_event.c
@@ -0,0 +1,180 @@
+#include "s_task.h"
+
+/*******************************************************************/
+/* event                                                           */
+/*******************************************************************/
+
+/* Initialize a wait event */
+void s_event_init(s_event_t *event) {
+    s_list_init(&event->wait_list);
+#ifdef USE_DEAD_TASK_CHECKING
+    s_list_init(&event->self);
+#endif
+}
+
+/* Add the event to global waiting event list */
+static void s_event_add_to_waiting_list(s_event_t *event) {
+#ifdef USE_DEAD_TASK_CHECKING
+    if(s_list_is_empty(&event->wait_list)) {
+        s_list_detach(&event->self);
+        s_list_attach(&g_globals.waiting_events, &event->self);
+    }
+#endif
+}
+
+/* Remove the event from global waiting event list */
+static void s_event_remove_from_waiting_list(s_event_t *event) {
+#ifdef USE_DEAD_TASK_CHECKING
+    if(s_list_is_empty(&event->wait_list)) {
+        s_list_detach(&event->self);
+    }
+#endif
+}
+
+#ifdef USE_DEAD_TASK_CHECKING
+/* Cancel dead waiting tasks */
+unsigned int s_event_cancel_dead_waiting_tasks_() {
+    s_list_t *next_event;
+    s_list_t *this_event;
+    unsigned int ret = 0;
+    /* Check all events */
+    for(this_event = s_list_get_next(&g_globals.waiting_events);
+        this_event != &g_globals.waiting_events;
+        this_event = next_event) {
+        s_list_t *next_task;
+        s_list_t *this_task;
+        s_event_t *event;
+
+        next_event = s_list_get_next(this_event);
+        s_list_detach(this_event);
+        event = GET_PARENT_ADDR(this_event, s_event_t, self);
+
+        /* Check all tasks blocked on this event */
+        for(this_task = s_list_get_next(&event->wait_list);
+            this_task != &event->wait_list;
+            this_task = next_task) {
+            next_task = s_list_get_next(this_task);
+
+            s_task_t *task = GET_PARENT_ADDR(this_task, s_task_t, node);
+            s_task_cancel_wait(task);
+            ++ret;
+        }
+    }
+
+#ifndef NDEBUG
+    if (ret > 0) {
+        fprintf(stderr, "error: cancel dead tasks waiting on event!\n");
+    }
+#endif
+
+    return ret;
+}
+#endif
+
+/* Wait event
+ *  return 0 on event set
+ *  return -1 on event waiting cancelled
+ */
+int s_event_wait(__async__, s_event_t *event) {
+    int ret;
+    /* Put current task to the event's waiting list */
+    s_event_add_to_waiting_list(event);
+    s_list_detach(&g_globals.current_task->node);   /* no need, for safe */
+    s_list_attach(&event->wait_list, &g_globals.current_task->node);
+    s_task_next(__await__);
+    ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+
+/* Set event */
+void s_event_set(s_event_t *event) {
+    s_list_attach(&g_globals.active_tasks, &event->wait_list);
+    s_list_detach(&event->wait_list);
+    s_event_remove_from_waiting_list(event);
+}
+
+/* Wait event */
+#ifndef USE_LIST_TIMER_CONTAINER
+static int s_event_wait_ticks(__async__, s_event_t *event, my_clock_t ticks) {
+    my_clock_t current_ticks;
+    s_timer_t timer;
+    int ret;
+
+    current_ticks = my_clock();
+    timer.task = g_globals.current_task;
+    timer.wakeup_ticks = current_ticks + ticks;
+
+    if (!rbt_insert(&g_globals.timers, &timer.rbt_node)) {
+#ifndef NDEBUG
+        fprintf(stderr, "timer insert failed!\n");
+#endif
+        return -1;
+    }
+
+    s_event_add_to_waiting_list(event);
+    s_list_detach(&g_globals.current_task->node);   /* no need, for safe */
+    /* Put current task to the event's waiting list */
+    s_list_attach(&event->wait_list, &g_globals.current_task->node);
+    s_task_next(__await__);
+
+    if (timer.task != NULL) {
+        timer.task = NULL;
+        rbt_delete(&g_globals.timers, &timer.rbt_node);
+    }
+
+    ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+#else
+static int s_event_wait_ticks(__async__, s_event_t *event, my_clock_t ticks) {
+    my_clock_t current_ticks;
+    s_list_t *node;
+    s_timer_t timer;
+    int ret;
+
+    current_ticks = my_clock();
+    s_list_init(&timer.node);
+    timer.task = g_globals.current_task;
+    timer.wakeup_ticks = current_ticks + ticks;
+
+    for(node = s_list_get_next(&g_globals.timers);
+        node != &g_globals.timers;
+        node = s_list_get_next(node)) {
+        s_timer_t *timer = GET_PARENT_ADDR(node, s_timer_t, node);
+
+        my_clock_diff_t ticks_to_wakeup = (my_clock_diff_t)(timer->wakeup_ticks - current_ticks);
+        if (ticks_to_wakeup >= 0 && (my_clock_t)ticks_to_wakeup > ticks)
+            break;
+    }
+    s_list_attach(node, &timer.node);
+
+    s_event_add_to_waiting_list(event);
+    s_list_detach(&timer.task->node);   /* no need, for safe */
+    /* Put current task to the event's waiting list */
+    s_list_attach(&event->wait_list, &g_globals.current_task->node);
+    s_task_next(__await__);
+
+    if (timer.task != NULL) {
+        timer.task = NULL;
+        s_list_detach(&timer.node);
+    }
+
+    ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+#endif
+
+/* Wait event */
+int s_event_wait_msec(__async__, s_event_t *event, uint32_t msec) {
+    my_clock_t ticks = msec_to_ticks(msec);
+    return s_event_wait_ticks(__await__, event, ticks);
+}
+
+/* Wait event */
+int s_event_wait_sec(__async__, s_event_t *event, uint32_t sec) {
+    my_clock_t ticks = sec_to_ticks(sec);
+    return s_event_wait_ticks(__await__, event, ticks);
+}
diff --git a/osal/src/sugar/s_event_embed.c b/osal/src/sugar/s_event_embed.c
new file mode 100644
index 0000000..24fa6cf
--- /dev/null
+++ b/osal/src/sugar/s_event_embed.c
@@ -0,0 +1,135 @@
+#include "s_task.h"
+
+#ifdef USE_IN_EMBEDDED
+
+/*******************************************************************/
+/* event for communication between irq and task                    */
+/*******************************************************************/
+
+/* Wait event from irq, disable irq before call this function!
+ *   S_IRQ_DISABLE()
+ *   ...
+ *   s_event_wait__from_irq(...)
+ *   ...
+ *   S_IRQ_ENABLE()
+ */
+int s_event_wait__from_irq(__async__, s_event_t *event) {
+    int ret;
+    /* Put current task to the event's waiting list */
+    s_list_detach(&g_globals.current_task->node);   /* no need, for safe */
+    s_list_attach(&event->wait_list, &g_globals.current_task->node);
+    S_IRQ_ENABLE();
+    s_task_next(__await__);
+    S_IRQ_DISABLE();
+    ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+
+/* Set event in irq */
+void s_event_set__in_irq(s_event_t *event) {
+    s_list_attach(&g_globals.irq_active_tasks, &event->wait_list);
+    s_list_detach(&event->wait_list);
+    g_globals.irq_actived = 1;
+}
+
+/* Wait event */
+#ifndef USE_LIST_TIMER_CONTAINER
+static int s_event_wait_ticks__from_irq(__async__, s_event_t *event, my_clock_t ticks) {
+    my_clock_t current_ticks;
+    s_timer_t timer;
+
+    current_ticks = my_clock();
+    timer.task = g_globals.current_task;
+    timer.wakeup_ticks = current_ticks + ticks;
+
+    if (!rbt_insert(&g_globals.timers, &timer.rbt_node)) {
+#ifndef NDEBUG
+        fprintf(stderr, "timer insert failed!\n");
+#endif
+        return -1;
+    }
+
+    s_list_detach(&g_globals.current_task->node);   /* no need, for safe */
+    /* Put current task to the event's waiting list */
+    s_list_attach(&event->wait_list, &g_globals.current_task->node);
+    S_IRQ_ENABLE();
+    s_task_next(__await__);
+    S_IRQ_DISABLE();
+
+    if (timer.task != NULL) {
+        timer.task = NULL;
+        rbt_delete(&g_globals.timers, &timer.rbt_node);
+    }
+
+    int ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+#else
+static int s_event_wait_ticks__from_irq(__async__, s_event_t *event, my_clock_t ticks) {
+    my_clock_t current_ticks;
+    s_list_t *node;
+    s_timer_t timer;
+    int ret;
+
+    current_ticks = my_clock();
+    s_list_init(&timer.node);
+    timer.task = g_globals.current_task;
+    timer.wakeup_ticks = current_ticks + ticks;
+
+    for(node = s_list_get_next(&g_globals.timers);
+        node != &g_globals.timers;
+        node = s_list_get_next(node)) {
+        s_timer_t *timer = GET_PARENT_ADDR(node, s_timer_t, node);
+
+        my_clock_diff_t ticks_to_wakeup = (my_clock_diff_t)(timer->wakeup_ticks - current_ticks);
+        if (ticks_to_wakeup >= 0 && (my_clock_t)ticks_to_wakeup > ticks)
+            break;
+    }
+    s_list_attach(node, &timer.node);
+
+    s_list_detach(&timer.task->node);   /* no need, for safe */
+    /* Put current task to the event's waiting list */
+    s_list_attach(&event->wait_list, &g_globals.current_task->node);
+    S_IRQ_ENABLE();
+    s_task_next(__await__);
+    S_IRQ_DISABLE();
+
+    if (timer.task != NULL) {
+        timer.task = NULL;
+        s_list_detach(&timer.node);
+    }
+
+    ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+#endif
+
+/* Wait event from irq, disable irq before call this function!
+ *   S_IRQ_DISABLE()
+ *   ...
+ *   s_event_wait_msec__from_irq(...)
+ *   ...
+ *   S_IRQ_ENABLE()
+ */
+int s_event_wait_msec__from_irq(__async__, s_event_t *event, uint32_t msec) {
+    my_clock_t ticks = msec_to_ticks(msec);
+    return s_event_wait_ticks__from_irq(__await__, event, ticks);
+}
+
+/* Wait event from irq, disable irq before call this function!
+ *   S_IRQ_DISABLE()
+ *   ...
+ *   s_event_wait_sec__from_irq(...)
+ *   ...
+ *   S_IRQ_ENABLE()
+ */
+
+int s_event_wait_sec__from_irq(__async__, s_event_t *event, uint32_t sec) {
+    my_clock_t ticks = sec_to_ticks(sec);
+    return s_event_wait_ticks__from_irq(__await__, event, ticks);
+}
+
+#endif
diff --git a/osal/src/sugar/s_list.c b/osal/src/sugar/s_list.c
new file mode 100644
index 0000000..97d3e46
--- /dev/null
+++ b/osal/src/sugar/s_list.c
@@ -0,0 +1,72 @@
+/* Copyright xhawk, MIT license */
+
+#include "s_list.h"
+
+/*******************************************************************/
+/* list                                                            */
+/*******************************************************************/
+
+s_list_t *s_list_get_prev (s_list_t *list) {
+    return list->prev;
+}
+
+s_list_t *s_list_get_next (s_list_t *list) {
+    return list->next;
+}
+
+void s_list_set_prev (s_list_t *list, s_list_t *other) {
+    list->prev = other;
+}
+
+void s_list_set_next (s_list_t *list, s_list_t *other) {
+    list->next = other;
+}
+
+/* Initilization a list */
+void s_list_init(s_list_t *list) {
+    s_list_set_prev(list, list);
+    s_list_set_next(list, list);
+}
+
+/* Connect or disconnect two lists. */
+void s_list_toggle_connect(s_list_t *list1, s_list_t *list2) {
+    s_list_t *prev1 = s_list_get_prev(list1);
+    s_list_t *prev2 = s_list_get_prev(list2);
+    s_list_set_next(prev1, list2);
+    s_list_set_next(prev2, list1);
+    s_list_set_prev(list1, prev2);
+    s_list_set_prev(list2, prev1);
+}
+
+/* Connect two lists. */
+void s_list_connect (s_list_t *list1, s_list_t *list2) {
+    s_list_toggle_connect (list1, list2);
+}
+
+/* Disconnect tow lists. */
+void s_list_disconnect (s_list_t *list1, s_list_t *list2) {
+    s_list_toggle_connect (list1, list2);
+}
+
+/* Same as s_list_connect */
+void s_list_attach (s_list_t *node1, s_list_t *node2) {
+    s_list_connect (node1, node2);
+}
+
+/* Make node in detach mode */
+void s_list_detach (s_list_t *node) {
+    s_list_disconnect (node, s_list_get_next(node));
+}
+
+/* Check if list is empty */
+int s_list_is_empty (s_list_t *list) {
+    return (s_list_get_next(list) == list);
+}
+
+int s_list_size(s_list_t *list) {
+    int n = 0;
+    s_list_t *next;
+    for(next = s_list_get_next(list); next != list; next = s_list_get_next(next))
+        ++n;
+    return n;
+}
diff --git a/osal/src/sugar/s_mutex.c b/osal/src/sugar/s_mutex.c
new file mode 100644
index 0000000..14d53c0
--- /dev/null
+++ b/osal/src/sugar/s_mutex.c
@@ -0,0 +1,110 @@
+/* Copyright xhawk, MIT license */
+
+#include "s_task.h"
+
+/*******************************************************************/
+/* mutex                                                           */
+/*******************************************************************/
+
+
+/* Initialize a mutex */
+void s_mutex_init(s_mutex_t *mutex) {
+    s_list_init(&mutex->wait_list);
+#ifdef USE_DEAD_TASK_CHECKING
+    s_list_init(&mutex->self);
+#endif
+    mutex->locked = false;
+}
+
+/* Add the mutex to global waiting mutex list */
+static void s_mutex_add_to_waiting_list(s_mutex_t *mutex) {
+#ifdef USE_DEAD_TASK_CHECKING
+    if(s_list_is_empty(&mutex->wait_list)) {
+        s_list_detach(&mutex->self);
+        s_list_attach(&g_globals.waiting_mutexes, &mutex->self);
+    }
+#endif
+}
+
+/* Remove the mutex from global waiting mutex list */
+static void s_mutex_remove_from_waiting_list(s_mutex_t *mutex) {
+#ifdef USE_DEAD_TASK_CHECKING
+    if(s_list_is_empty(&mutex->wait_list)) {
+        s_list_detach(&mutex->self);
+    }
+#endif
+}
+
+#ifdef USE_DEAD_TASK_CHECKING
+/* Cancel dead waiting tasks */
+unsigned int s_mutex_cancel_dead_waiting_tasks_() {
+    s_list_t *next_mutex;
+    s_list_t *this_mutex;
+    unsigned int ret = 0;
+    /* Check all mutexs */
+    for(this_mutex = s_list_get_next(&g_globals.waiting_mutexes);
+        this_mutex != &g_globals.waiting_mutexes;
+        this_mutex = next_mutex) {
+        s_list_t *next_task;
+        s_list_t *this_task;
+        s_mutex_t *mutex;
+
+        next_mutex = s_list_get_next(this_mutex);
+        s_list_detach(this_mutex);
+        mutex = GET_PARENT_ADDR(this_mutex, s_mutex_t, self);
+
+        /* Check all tasks blocked on this mutex */
+        for(this_task = s_list_get_next(&mutex->wait_list);
+            this_task != &mutex->wait_list;
+            this_task = next_task) {
+            next_task = s_list_get_next(this_task);
+
+            s_task_t *task = GET_PARENT_ADDR(this_task, s_task_t, node);
+            s_task_cancel_wait(task);
+            ++ret;
+        }
+    }
+
+#ifndef NDEBUG
+    if (ret > 0) {
+        fprintf(stderr, "error: cancel dead tasks waiting on mutex!\n");
+    }
+#endif
+
+    return ret;
+}
+#endif
+
+/* Lock the mutex */
+int s_mutex_lock(__async__, s_mutex_t *mutex) {
+    if(mutex->locked) {
+        int ret;
+        /* Put current task to the mutex's waiting list */
+        s_mutex_add_to_waiting_list(mutex);
+        s_list_detach(&g_globals.current_task->node);   /* no need, for safe */
+        s_list_attach(&mutex->wait_list, &g_globals.current_task->node);
+        s_task_next(__await__);
+
+        ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+        g_globals.current_task->waiting_cancelled = false;
+        return ret;
+    }
+    else {
+        mutex->locked = true;
+        return 0;
+    }
+}
+
+/* Unlock the mutex */
+void s_mutex_unlock(s_mutex_t *mutex) {
+    if(s_list_is_empty(&mutex->wait_list))
+        mutex->locked = false;
+    else {
+        s_list_t *next = s_list_get_next(&mutex->wait_list);
+        s_list_detach(next);
+        s_list_attach(&g_globals.active_tasks, next);
+        s_mutex_remove_from_waiting_list(mutex);
+    }
+}
+
+
diff --git a/osal/src/sugar/s_port_armv6m.inc.h b/osal/src/sugar/s_port_armv6m.inc.h
new file mode 100644
index 0000000..57a0344
--- /dev/null
+++ b/osal/src/sugar/s_port_armv6m.inc.h
@@ -0,0 +1,93 @@
+#include PLATFORM_SPECIFIC_INCLUDE
+
+static my_clock_t g_ticks;
+void my_clock_tick_handle(void){
+    ++g_ticks;
+}
+
+/* 3. Implement the initilization function for clock. Leave it blank if not required. */
+void my_clock_init(){
+    SysTick_Config(SystemCoreClock / MY_CLOCKS_PER_SEC);
+}
+
+/* 4. Implement the function of getting current clock ticks. */
+my_clock_t my_clock() {
+    return g_ticks;
+}
+
+/* 5. Implement the idle delay function. */
+void my_on_idle(uint64_t max_idle_ms) {
+    __WFE();
+}
+
+#if defined __ARMCC_VERSION
+__asm static void swapcontext(ucontext_t *oucp, const ucontext_t *ucp) {
+    PUSH    {r4-r7}
+    MOV     r2, r8
+    MOV     r3, r9
+    MOV     r4, r10
+    MOV     r5, r11
+    MOV     r6, r12
+    MOV     r7, lr
+    PUSH    {r2-r7}
+    MOV     r2, sp
+    STM     r0, {r2}
+
+    LDM     r1, {r2}
+    MOV     sp, r2
+    POP     {r2-r7}
+    MOV     r8, r2
+    MOV     r9, r3
+    MOV     r10, r4
+    MOV     r11, r5
+    MOV     r12, r6
+    MOV     lr, r7
+    POP     {r4-r7}
+
+    BX      lr
+}
+
+#elif defined __GNUC__
+
+__attribute__((naked))
+static void swapcontext(ucontext_t *old_tcb, const ucontext_t *new_tcb) {
+    __asm__ __volatile__(
+        "PUSH    {r4-r7}\n"
+        "MOV     r2, r8\n"
+        "MOV     r3, r9\n"
+        "MOV     r4, r10\n"
+        "MOV     r5, r11\n"
+        "MOV     r6, r12\n"
+        "MOV     r7, lr\n"
+        "PUSH    {r2-r7}\n"
+        "MOV     r2, sp\n"
+        "STM     r0!, {r2}\n"
+
+        "LDM     r1!, {r2}\n"
+        "MOV     sp, r2\n"
+        "POP     {r2-r7}\n"
+        "MOV     r8, r2\n"
+        "MOV     r9, r3\n"
+        "MOV     r10, r4\n"
+        "MOV     r11, r5\n"
+        "MOV     r12, r6\n"
+        "MOV     lr, r7\n"
+        "POP     {r4-r7}\n"
+    );
+}
+
+#endif
+
+
+static void create_context(ucontext_t *oucp, void *stack, size_t stack_size) {
+    uint32_t *top_sp;
+    uint32_t int_sp;
+
+    int_sp = (int)((char *)stack + stack_size);
+    int_sp = int_sp / 4 * 4;  //alignment
+    top_sp = (uint32_t *)int_sp;
+
+    top_sp[-5] = (int)&s_task_context_entry;
+    oucp->sp = (int)&top_sp[-10];
+}
+
diff --git a/osal/src/sugar/s_port_armv7m.inc.h b/osal/src/sugar/s_port_armv7m.inc.h
new file mode 100644
index 0000000..b6fa6a3
--- /dev/null
+++ b/osal/src/sugar/s_port_armv7m.inc.h
@@ -0,0 +1,68 @@
+#include PLATFORM_SPECIFIC_INCLUDE
+
+static my_clock_t g_ticks;
+
+void my_clock_tick_handle(void){
+    ++g_ticks;
+}
+
+/* 3. Implement the initilization function for clock. Leave it blank if not required. */
+void my_clock_init(){
+    SysTick_Config(SystemCoreClock / MY_CLOCKS_PER_SEC);
+}
+
+/* 4. Implement the function of getting current clock ticks. */
+my_clock_t my_clock() {
+    return g_ticks;
+}
+
+/* 5. Implement the idle delay function. */
+void my_on_idle(uint64_t max_idle_ms) {
+    __WFE();
+}
+
+
+#if defined __ARMCC_VERSION
+__asm static void swapcontext(ucontext_t *oucp, const ucontext_t *ucp) {
+    PUSH    {r4-r12,lr}
+    STR     sp, [r0]
+
+    //LDR     r2, [r1]
+    //MOV     sp, r2
+    LDR     sp, [r1]
+    POP     {r4-r12,lr}
+
+    BX      lr
+}
+
+#elif defined __GNUC__
+
+__attribute__((naked))
+static void swapcontext(ucontext_t *old_tcb, const ucontext_t *new_tcb) {
+    __asm__ __volatile__(
+        "PUSH    {r4-r12,lr}\n"
+        "STR     sp, [r0]\n"
+        //"LDR     r2, [r1]\n"
+        //"MOV     sp, r2\n"
+        "LDR     sp, [r1]\n"
+        "POP     {r4-r12,lr}\n"
+
+        "BX      lr\n"
+    );
+}
+
+#endif
+
+
+static void create_context(ucontext_t *oucp, void *stack, size_t stack_size) {
+    uint32_t *top_sp;
+    uint32_t int_sp;
+
+    int_sp = (int )((char *)stack + stack_size);
+    int_sp = int_sp / 4 * 4;  //alignment
+    top_sp = (uint32_t *)int_sp;
+
+    top_sp[-1] = (int)&s_task_context_entry;
+    oucp->sp = (int)&top_sp[-10];
+}
+
diff --git a/osal/src/sugar/s_port_posix.inc.h b/osal/src/sugar/s_port_posix.inc.h
new file mode 100644
index 0000000..f22f01a
--- /dev/null
+++ b/osal/src/sugar/s_port_posix.inc.h
@@ -0,0 +1,52 @@
+/* Copyright xhawk, MIT license */
+
+/* Timer functions need to be implemented on a new porting. */
+
+void my_clock_init(){
+}
+
+my_clock_t my_clock() {
+    struct timespec tp;
+    clock_gettime(CLOCK_MONOTONIC, &tp);
+    return (my_clock_t)(tp.tv_sec * 1000 + tp.tv_nsec / 1000000);
+}
+
+void my_on_idle(uint64_t max_idle_ms) {
+    usleep(max_idle_ms * 1000);
+}
+
+
+#if (defined(i386) || defined(__i386__) || defined(__i386) \
+     || defined(__i486__) || defined(__i586__) || defined(__i686__) \
+     || defined(__X86__) || defined(_X86_) || defined(__THW_INTEL__) \
+     || defined(__I86__) || defined(__INTEL__) || defined(__IA32__) \
+     || defined(_M_IX86) || defined(_I86_)) && defined(_WIN32)
+# define BOOST_CONTEXT_CALLDECL __cdecl
+#else
+# define BOOST_CONTEXT_CALLDECL
+#endif
+
+
+#ifdef USE_SWAP_CONTEXT
+void create_context(ucontext_t *uc, void *stack, size_t stack_size) {
+    getcontext(uc);
+    uc->uc_stack.ss_sp = stack;
+    uc->uc_stack.ss_size = stack_size;
+    uc->uc_link = 0;
+    makecontext(uc, (void (*)(void))&s_task_context_entry, 0);
+}
+#endif
+
+
+#ifdef USE_JUMP_FCONTEXT
+extern
+transfer_t BOOST_CONTEXT_CALLDECL jump_fcontext( fcontext_t const to, void * vp);
+extern
+fcontext_t BOOST_CONTEXT_CALLDECL make_fcontext( void * sp, size_t size, void (* fn)( transfer_t) );
+
+void create_fcontext(fcontext_t *fc, void *stack, size_t stack_size, void (* fn)( transfer_t)) {
+    stack = (void *)((char *)stack + stack_size);
+    *fc = make_fcontext(stack, stack_size, fn);
+}
+#endif
+
diff --git a/osal/src/sugar/s_port_riscv.inc.h b/osal/src/sugar/s_port_riscv.inc.h
new file mode 100644
index 0000000..1025c6a
--- /dev/null
+++ b/osal/src/sugar/s_port_riscv.inc.h
@@ -0,0 +1,40 @@
+/* Copyright xhawk, MIT license */
+
+/* Timer functions need to be implemented on a new porting. */
+
+void my_clock_init(){
+    // Don't start measuruing until we see an mtime tick
+    uint64_t start_mtime;
+    uint64_t tmp = get_timer_value();
+    do {
+        start_mtime = get_timer_value();
+    } while (start_mtime == tmp);
+}
+
+my_clock_t my_clock() {
+    return get_timer_value();
+}
+
+void my_on_idle(uint64_t max_idle_ms) {
+    uint64_t start_mtime, delta_mtime;
+
+    start_mtime = get_timer_value();
+
+    do {
+        delta_mtime = get_timer_value() - start_mtime;
+    } while(delta_mtime < (MY_CLOCKS_PER_SEC * max_idle_ms / 1000));
+}
+
+
+#ifdef USE_JUMP_FCONTEXT
+extern
+transfer_t jump_fcontext( fcontext_t const to, void * vp);
+extern
+fcontext_t make_fcontext( void * sp, size_t size, void (* fn)( transfer_t) );
+
+void create_fcontext(fcontext_t *fc, void *stack, size_t stack_size, void (* fn)( transfer_t)) {
+    stack = (void *)((char *)stack + stack_size);
+    *fc = make_fcontext(stack, stack_size, fn);
+}
+#endif
+
diff --git a/osal/src/sugar/s_port_windows.inc.h b/osal/src/sugar/s_port_windows.inc.h
new file mode 100644
index 0000000..c2cca3f
--- /dev/null
+++ b/osal/src/sugar/s_port_windows.inc.h
@@ -0,0 +1,38 @@
+/* Copyright xhawk, MIT license */
+
+/* Timer functions need to be implemented on a new porting. */
+
+void my_clock_init(){
+}
+
+my_clock_t my_clock() {
+    return GetTickCount();
+}
+
+void my_on_idle(uint64_t max_idle_ms) {
+    Sleep((DWORD)max_idle_ms);
+}
+
+
+
+#if (defined(i386) || defined(__i386__) || defined(__i386) \
+     || defined(__i486__) || defined(__i586__) || defined(__i686__) \
+     || defined(__X86__) || defined(_X86_) || defined(__THW_INTEL__) \
+     || defined(__I86__) || defined(__INTEL__) || defined(__IA32__) \
+     || defined(_M_IX86) || defined(_I86_)) && defined(_WIN32)
+# define BOOST_CONTEXT_CALLDECL __cdecl
+#else
+# define BOOST_CONTEXT_CALLDECL
+#endif
+
+extern
+transfer_t BOOST_CONTEXT_CALLDECL jump_fcontext( fcontext_t const to, void * vp);
+extern
+fcontext_t BOOST_CONTEXT_CALLDECL make_fcontext( void * sp, size_t size, void (* fn)( transfer_t) );
+
+
+void create_fcontext(fcontext_t *fc, void * sp, size_t size, void (* fn)( transfer_t)) {
+    sp = (void *)((char *)sp + size);
+    *fc = make_fcontext(sp, size, fn);
+}
+
diff --git a/osal/src/sugar/s_rbtree.c b/osal/src/sugar/s_rbtree.c
new file mode 100644
index 0000000..c7e7bb2
--- /dev/null
+++ b/osal/src/sugar/s_rbtree.c
@@ -0,0 +1,960 @@
+/*-------------------------------------------------------------------------
+ *
+ * rbtree.c
+ *    implementation for PostgreSQL generic Red-Black binary tree package
+ *    Adopted from http://algolist.manual.ru/ds/rbtree.php
+ *
+ * This code comes from Thomas Niemann's "Sorting and Searching Algorithms:
+ * a Cookbook".
+ *
+ * See http://www.cs.auckland.ac.nz/software/AlgAnim/niemann/s_man.htm for
+ * license terms: "Source code, when part of a software project, may be used
+ * freely without reference to the author."
+ *
+ * Red-black trees are a type of balanced binary tree wherein (1) any child of
+ * a red node is always black, and (2) every path from root to leaf traverses
+ * an equal number of black nodes.  From these properties, it follows that the
+ * longest path from root to leaf is only about twice as long as the shortest,
+ * so lookups are guaranteed to run in O(lg n) time.
+ *
+ * Copyright (c) 2009-2020, PostgreSQL Global Development Group
+ *
+ * IDENTIFICATION
+ *    src/backend/lib/rbtree.c
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include "s_rbtree.h"
+
+
+/*
+ * Colors of nodes (values of RBTNode.color)
+ */
+#define RBTBLACK    (0)
+#define RBTRED      (1)
+
+
+/*
+ * all leafs are sentinels, use customized NIL name to prevent
+ * collision with system-wide constant NIL which is actually NULL
+ */
+/* #define RBTNIL (&g_sentinel) */
+
+RBTNode g_sentinel =
+{
+    RBTBLACK, RBTNIL, RBTNIL, NULL
+};
+
+
+/*
+ * rbt_create: create an empty RBTree
+ *
+ * Arguments are:
+ *  node_size: actual size of tree nodes (> sizeof(RBTNode))
+ *  The manipulation functions:
+ *  comparator: compare two RBTNodes for less/equal/greater
+ *  combiner: merge an existing tree entry with a new one
+ *  allocfunc: allocate a new RBTNode
+ *  freefunc: free an old RBTNode
+ *  arg: passthrough pointer that will be passed to the manipulation functions
+ *
+ * Note that the combiner's righthand argument will be a "proposed" tree node,
+ * ie the input to rbt_insert, in which the RBTNode fields themselves aren't
+ * valid.  Similarly, either input to the comparator may be a "proposed" node.
+ * This shouldn't matter since the functions aren't supposed to look at the
+ * RBTNode fields, only the extra fields of the struct the RBTNode is embedded
+ * in.
+ *
+ * The freefunc should just be pfree or equivalent; it should NOT attempt
+ * to free any subsidiary data, because the node passed to it may not contain
+ * valid data!  freefunc can be NULL if caller doesn't require retail
+ * space reclamation.
+ *
+ * The RBTree node is palloc'd in the caller's memory context.  Note that
+ * all contents of the tree are actually allocated by the caller, not here.
+ *
+ * Since tree contents are managed by the caller, there is currently not
+ * an explicit "destroy" operation; typically a tree would be freed by
+ * resetting or deleting the memory context it's stored in.  You can pfree
+ * the RBTree node if you feel the urge.
+ */
+RBTree *
+rbt_create(RBTree* tree,
+           rbt_comparator comparator,
+           void *comparator_arg)
+{
+    /* RBTree      *tree = (RBTree *) malloc(sizeof(RBTree)); */
+
+    /* assert(node_size > sizeof(RBTNode)); */
+
+    tree->root = RBTNIL;
+    /* tree->node_size = node_size; */
+    tree->comparator = comparator;
+    /* tree->combiner = combiner; */
+    /* tree->allocfunc = allocfunc; */
+    /* tree->freefunc = freefunc; */
+
+    tree->comparator_arg = comparator_arg;
+
+    return tree;
+}
+
+/* Copy the additional data fields from one RBTNode to another */
+/*
+static inline void
+rbt_copy_data(RBTree *rbt, RBTNode *dest, const RBTNode *src)
+{
+    memcpy(dest + 1, src + 1, rbt->node_size - sizeof(RBTNode));
+}
+*/
+
+static void
+rbt_swap_node(RBTNode *x, RBTNode *y) {
+    /* y,z */
+    char color = x->color;
+    x->color = y->color;
+    y->color = color;
+
+    if (x->parent == y) {
+        RBTNode *y_left;
+        RBTNode *y_right;
+
+        if (y->parent) {
+            RBTNode* node = y->parent;
+            if (node->left == y)
+                node->left = x;
+            if (node->right == y)
+                node->right = x;
+        }
+
+        x->parent = y->parent;
+        y->parent = x;
+
+        y_left = y->left;
+        y_right = y->right;
+        if (y_left == x)
+            y_left = y;
+        if (y_right == x)
+            y_right = y;
+
+        if (y->left != RBTNIL && y->left != x) {
+            RBTNode* node = y->left;
+            node->parent = x;
+        }
+        if (y->right != RBTNIL && y->right != x) {
+            RBTNode* node = y->right;
+            node->parent = x;
+        }
+        if (x->left != RBTNIL) {
+            RBTNode* node = x->left;
+            node->parent = y;
+        }
+        if (x->right != RBTNIL) {
+            RBTNode* node = x->right;
+            node->parent = y;
+        }
+
+        y->left = x->left;
+        y->right = x->left;
+
+        x->left = y_left;
+        x->right = y_right;
+    }
+    else if (y->parent == x) {
+        RBTNode *x_left;
+        RBTNode *x_right;
+
+        if (x->parent) {
+            RBTNode* node = x->parent;
+            if (node->left == x)
+                node->left = y;
+            if (node->right == x)
+                node->right = y;
+        }
+
+        y->parent = x->parent;
+        x->parent = y;
+
+        x_left = x->left;
+        x_right = x->right;
+        if (x_left == y)
+            x_left = x;
+        if (x_right == y)
+            x_right = x;
+
+        if (x->left != RBTNIL && x->left != y) {
+            RBTNode* node = x->left;
+            node->parent = y;
+        }
+        if (x->right != RBTNIL && x->right != y) {
+            RBTNode* node = x->right;
+            node->parent = y;
+        }
+        if (y->left != RBTNIL) {
+            RBTNode* node = y->left;
+            node->parent = x;
+        }
+        if (y->right != RBTNIL) {
+            RBTNode* node = y->right;
+            node->parent = x;
+        }
+
+        x->left = y->left;
+        x->right = y->left;
+
+        y->left = x_left;
+        y->right = x_right;
+    }
+    else {
+        RBTNode *left;
+        RBTNode *right;
+        RBTNode *parent;
+
+        if (x->parent) {
+            RBTNode* node = x->parent;
+            if (node->left == x) {
+                node->left = y;
+            }
+            if (node->right == x) {
+                node->right = y;
+            }
+        }
+
+        if (y->parent) {
+            RBTNode* node = y->parent;
+            if (node->left == y) {
+                node->left = x;
+            }
+            if (node->right == y) {
+                node->right = x;
+            }
+        }
+
+        if (x->left != RBTNIL) {
+            RBTNode* node = x->left;
+            node->parent = y;
+        }
+        if (x->right != RBTNIL) {
+            RBTNode* node = x->right;
+            node->parent = y;
+        }
+
+        if (y->left != RBTNIL) {
+            RBTNode* node = y->left;
+            node->parent = x;
+        }
+        if (y->right != RBTNIL) {
+            RBTNode* node = y->right;
+            node->parent = x;
+        }
+
+        left = x->left;
+        x->left = y->left;
+        y->left = left;
+
+        right = x->right;
+        x->right = y->right;
+        y->right = right;
+
+        parent = x->parent;
+        x->parent = y->parent;
+        y->parent = parent;
+    }
+}
+
+/**********************************************************************
+ *                        Search                                      *
+ **********************************************************************/
+
+/*
+ * rbt_find: search for a value in an RBTree
+ *
+ * data represents the value to try to find.  Its RBTNode fields need not
+ * be valid, it's the extra data in the larger struct that is of interest.
+ *
+ * Returns the matching tree entry, or NULL if no match is found.
+ */
+RBTNode *
+rbt_find(RBTree *rbt, const RBTNode *data)
+{
+    RBTNode    *node = rbt->root;
+
+    while (node != RBTNIL)
+    {
+        int         cmp = rbt->comparator(data, node, rbt->comparator_arg);
+
+        if (cmp == 0)
+            return node;
+        else if (cmp < 0)
+            node = node->left;
+        else
+            node = node->right;
+    }
+
+    return NULL;
+}
+
+RBTNode*
+rbt_find2(RBTree* rbt, rbt_find_comparator comparator, const void* data)
+{
+    RBTNode *node = rbt->root;
+
+    while (node != RBTNIL)
+    {
+        int cmp = comparator(data, node);
+
+        if (cmp == 0)
+            return node;
+        else if (cmp < 0)
+            node = node->left;
+        else
+            node = node->right;
+    }
+
+    return NULL;
+}
+
+
+
+/*
+ * rbt_leftmost: fetch the leftmost (smallest-valued) tree node.
+ * Returns NULL if tree is empty.
+ *
+ * Note: in the original implementation this included an unlink step, but
+ * that's a bit awkward.  Just call rbt_delete on the result if that's what
+ * you want.
+ */
+RBTNode *
+rbt_leftmost(RBTree *rbt)
+{
+    RBTNode    *node = rbt->root;
+    RBTNode    *leftmost = rbt->root;
+
+    while (node != RBTNIL)
+    {
+        leftmost = node;
+        node = node->left;
+    }
+
+    if (leftmost != RBTNIL)
+        return leftmost;
+
+    return NULL;
+}
+
+/**********************************************************************
+ *                            Insertion                               *
+ **********************************************************************/
+
+/*
+ * Rotate node x to left.
+ *
+ * x's right child takes its place in the tree, and x becomes the left
+ * child of that node.
+ */
+static void
+rbt_rotate_left(RBTree *rbt, RBTNode *x)
+{
+    RBTNode    *y = x->right;
+
+    /* establish x->right link */
+    x->right = y->left;
+    if (y->left != RBTNIL)
+        y->left->parent = x;
+
+    /* establish y->parent link */
+    if (y != RBTNIL)
+        y->parent = x->parent;
+    if (x->parent)
+    {
+        if (x == x->parent->left)
+            x->parent->left = y;
+        else
+            x->parent->right = y;
+    }
+    else
+    {
+        rbt->root = y;
+    }
+
+    /* link x and y */
+    y->left = x;
+    if (x != RBTNIL)
+        x->parent = y;
+}
+
+/*
+ * Rotate node x to right.
+ *
+ * x's left right child takes its place in the tree, and x becomes the right
+ * child of that node.
+ */
+static void
+rbt_rotate_right(RBTree *rbt, RBTNode *x)
+{
+    RBTNode    *y = x->left;
+
+    /* establish x->left link */
+    x->left = y->right;
+    if (y->right != RBTNIL)
+        y->right->parent = x;
+
+    /* establish y->parent link */
+    if (y != RBTNIL)
+        y->parent = x->parent;
+    if (x->parent)
+    {
+        if (x == x->parent->right)
+            x->parent->right = y;
+        else
+            x->parent->left = y;
+    }
+    else
+    {
+        rbt->root = y;
+    }
+
+    /* link x and y */
+    y->right = x;
+    if (x != RBTNIL)
+        x->parent = y;
+}
+
+/*
+ * Maintain Red-Black tree balance after inserting node x.
+ *
+ * The newly inserted node is always initially marked red.  That may lead to
+ * a situation where a red node has a red child, which is prohibited.  We can
+ * always fix the problem by a series of color changes and/or "rotations",
+ * which move the problem progressively higher up in the tree.  If one of the
+ * two red nodes is the root, we can always fix the problem by changing the
+ * root from red to black.
+ *
+ * (This does not work lower down in the tree because we must also maintain
+ * the invariant that every leaf has equal black-height.)
+ */
+static void
+rbt_insert_fixup(RBTree *rbt, RBTNode *x)
+{
+    /*
+     * x is always a red node.  Initially, it is the newly inserted node. Each
+     * iteration of this loop moves it higher up in the tree.
+     */
+    while (x != rbt->root && x->parent->color == RBTRED)
+    {
+        /*
+         * x and x->parent are both red.  Fix depends on whether x->parent is
+         * a left or right child.  In either case, we define y to be the
+         * "uncle" of x, that is, the other child of x's grandparent.
+         *
+         * If the uncle is red, we flip the grandparent to red and its two
+         * children to black.  Then we loop around again to check whether the
+         * grandparent still has a problem.
+         *
+         * If the uncle is black, we will perform one or two "rotations" to
+         * balance the tree.  Either x or x->parent will take the
+         * grandparent's position in the tree and recolored black, and the
+         * original grandparent will be recolored red and become a child of
+         * that node. This always leaves us with a valid red-black tree, so
+         * the loop will terminate.
+         */
+        if (x->parent == x->parent->parent->left)
+        {
+            RBTNode    *y = x->parent->parent->right;
+
+            if (y->color == RBTRED)
+            {
+                /* uncle is RBTRED */
+                x->parent->color = RBTBLACK;
+                y->color = RBTBLACK;
+                x->parent->parent->color = RBTRED;
+
+                x = x->parent->parent;
+            }
+            else
+            {
+                /* uncle is RBTBLACK */
+                if (x == x->parent->right)
+                {
+                    /* make x a left child */
+                    x = x->parent;
+                    rbt_rotate_left(rbt, x);
+                }
+
+                /* recolor and rotate */
+                x->parent->color = RBTBLACK;
+                x->parent->parent->color = RBTRED;
+
+                rbt_rotate_right(rbt, x->parent->parent);
+            }
+        }
+        else
+        {
+            /* mirror image of above code */
+            RBTNode    *y = x->parent->parent->left;
+
+            if (y->color == RBTRED)
+            {
+                /* uncle is RBTRED */
+                x->parent->color = RBTBLACK;
+                y->color = RBTBLACK;
+                x->parent->parent->color = RBTRED;
+
+                x = x->parent->parent;
+            }
+            else
+            {
+                /* uncle is RBTBLACK */
+                if (x == x->parent->left)
+                {
+                    x = x->parent;
+                    rbt_rotate_right(rbt, x);
+                }
+                x->parent->color = RBTBLACK;
+                x->parent->parent->color = RBTRED;
+
+                rbt_rotate_left(rbt, x->parent->parent);
+            }
+        }
+    }
+
+    /*
+     * The root may already have been black; if not, the black-height of every
+     * node in the tree increases by one.
+     */
+    rbt->root->color = RBTBLACK;
+}
+
+/*
+ * rbt_insert: insert a new value into the tree.
+ *
+ * data represents the value to insert.  Its RBTNode fields need not
+ * be valid, it's the extra data in the larger struct that is of interest.
+ *
+ * If the value represented by "data" is not present in the tree, then
+ * we copy "data" into a new tree entry and return that node, setting *isNew
+ * to true.
+ *
+ * If the value represented by "data" is already present, then we call the
+ * combiner function to merge data into the existing node, and return the
+ * existing node, setting *isNew to false.
+ *
+ * "data" is unmodified in either case; it's typically just a local
+ * variable in the caller.
+ */
+bool
+rbt_insert(RBTree *rbt, RBTNode *data)
+{
+    RBTNode    *current,
+               *parent;
+    int         cmp;
+
+    /* find where node belongs */
+    current = rbt->root;
+    parent = NULL;
+    cmp = 0;                    /* just to prevent compiler warning */
+
+    while (current != RBTNIL)
+    {
+        cmp = rbt->comparator(data, current, rbt->comparator_arg);
+        if (cmp == 0)
+        {
+            /*
+             * Found node with given key.  Apply combiner.
+             */
+            /*
+            rbt->combiner(current, data, rbt->arg);
+            *isNew = false;
+            return current;
+            */
+            return false;
+        }
+        parent = current;
+        current = (cmp < 0) ? current->left : current->right;
+    }
+
+    /*
+     * Value is not present, so create a new node containing data.
+     */
+    /* *isNew = true; */
+
+    /* x = rbt->allocfunc(rbt->arg); */
+
+    data->color = RBTRED;
+
+    data->left = RBTNIL;
+    data->right = RBTNIL;
+    data->parent = parent;
+    /* rbt_copy_data(rbt, x, data); */
+
+    /* insert node in tree */
+    if (parent)
+    {
+        if (cmp < 0)
+            parent->left = data;
+        else
+            parent->right = data;
+    }
+    else
+    {
+        rbt->root = data;
+    }
+
+    rbt_insert_fixup(rbt, data);
+
+    return true;
+}
+
+/**********************************************************************
+ *                          Deletion                                  *
+ **********************************************************************/
+
+/*
+ * Maintain Red-Black tree balance after deleting a black node.
+ */
+static void
+rbt_delete_fixup(RBTree *rbt, RBTNode *x)
+{
+    /*
+     * x is always a black node.  Initially, it is the former child of the
+     * deleted node.  Each iteration of this loop moves it higher up in the
+     * tree.
+     */
+    while (x != rbt->root && x->color == RBTBLACK)
+    {
+        /*
+         * Left and right cases are symmetric.  Any nodes that are children of
+         * x have a black-height one less than the remainder of the nodes in
+         * the tree.  We rotate and recolor nodes to move the problem up the
+         * tree: at some stage we'll either fix the problem, or reach the root
+         * (where the black-height is allowed to decrease).
+         */
+        if (x == x->parent->left)
+        {
+            RBTNode    *w = x->parent->right;
+
+            if (w->color == RBTRED)
+            {
+                w->color = RBTBLACK;
+                x->parent->color = RBTRED;
+
+                rbt_rotate_left(rbt, x->parent);
+                w = x->parent->right;
+            }
+
+            if (w->left->color == RBTBLACK && w->right->color == RBTBLACK)
+            {
+                w->color = RBTRED;
+
+                x = x->parent;
+            }
+            else
+            {
+                if (w->right->color == RBTBLACK)
+                {
+                    w->left->color = RBTBLACK;
+                    w->color = RBTRED;
+
+                    rbt_rotate_right(rbt, w);
+                    w = x->parent->right;
+                }
+                w->color = x->parent->color;
+                x->parent->color = RBTBLACK;
+                w->right->color = RBTBLACK;
+
+                rbt_rotate_left(rbt, x->parent);
+                x = rbt->root;  /* Arrange for loop to terminate. */
+            }
+        }
+        else
+        {
+            RBTNode    *w = x->parent->left;
+
+            if (w->color == RBTRED)
+            {
+                w->color = RBTBLACK;
+                x->parent->color = RBTRED;
+
+                rbt_rotate_right(rbt, x->parent);
+                w = x->parent->left;
+            }
+
+            if (w->right->color == RBTBLACK && w->left->color == RBTBLACK)
+            {
+                w->color = RBTRED;
+
+                x = x->parent;
+            }
+            else
+            {
+                if (w->left->color == RBTBLACK)
+                {
+                    w->right->color = RBTBLACK;
+                    w->color = RBTRED;
+
+                    rbt_rotate_left(rbt, w);
+                    w = x->parent->left;
+                }
+                w->color = x->parent->color;
+                x->parent->color = RBTBLACK;
+                w->left->color = RBTBLACK;
+
+                rbt_rotate_right(rbt, x->parent);
+                x = rbt->root;  /* Arrange for loop to terminate. */
+            }
+        }
+    }
+    x->color = RBTBLACK;
+}
+
+/*
+ * Delete node z from tree.
+ */
+static void
+rbt_delete_node(RBTree *rbt, RBTNode *z)
+{
+    RBTNode    *x,
+               *y;
+
+    /* This is just paranoia: we should only get called on a valid node */
+    if (!z || z == RBTNIL)
+        return;
+
+    /*
+     * y is the node that will actually be removed from the tree.  This will
+     * be z if z has fewer than two children, or the tree successor of z
+     * otherwise.
+     */
+    if (z->left == RBTNIL || z->right == RBTNIL)
+    {
+        /* y has a RBTNIL node as a child */
+        y = z;
+    }
+    else
+    {
+        /* find tree successor */
+        y = z->right;
+        while (y->left != RBTNIL)
+            y = y->left;
+    }
+
+    /* x is y's only child */
+    if (y->left != RBTNIL)
+        x = y->left;
+    else
+        x = y->right;
+
+    /*
+     * If we removed the tree successor of z rather than z itself, then move
+     * the data for the removed node to the one we were supposed to remove.
+     */
+    if (y != z) {
+        rbt_swap_node(z, y);
+        if (rbt->root == z)
+            rbt->root = y;
+        /* rbt_copy_data(rbt, z, y); */
+    }
+
+    /* Remove z from the tree. */
+    x->parent = z->parent;
+    if (z->parent)
+    {
+        if (z == z->parent->left)
+            z->parent->left = x;
+        else
+            z->parent->right = x;
+    }
+    else
+    {
+        rbt->root = x;
+    }
+
+
+    /*
+     * Removing a black node might make some paths from root to leaf contain
+     * fewer black nodes than others, or it might make two red nodes adjacent.
+     */
+    if (z->color == RBTBLACK)
+        rbt_delete_fixup(rbt, x);
+
+    /* Now we can recycle the z node */
+    /* if (rbt->freefunc)
+        rbt->freefunc(z, rbt->arg); */
+}
+
+/*
+ * rbt_delete: remove the given tree entry
+ *
+ * "node" must have previously been found via rbt_find or rbt_leftmost.
+ * It is caller's responsibility to free any subsidiary data attached
+ * to the node before calling rbt_delete.  (Do *not* try to push that
+ * responsibility off to the freefunc, as some other physical node
+ * may be the one actually freed!)
+ */
+void
+rbt_delete(RBTree *rbt, RBTNode *node)
+{
+    rbt_delete_node(rbt, node);
+}
+
+/**********************************************************************
+ *                        Traverse                                    *
+ **********************************************************************/
+
+static RBTNode *
+rbt_left_right_iterator(RBTreeIterator *iter)
+{
+    if (iter->last_visited == NULL)
+    {
+        iter->last_visited = iter->rbt->root;
+        while (iter->last_visited->left != RBTNIL)
+            iter->last_visited = iter->last_visited->left;
+
+        return iter->last_visited;
+    }
+
+    if (iter->last_visited->right != RBTNIL)
+    {
+        iter->last_visited = iter->last_visited->right;
+        while (iter->last_visited->left != RBTNIL)
+            iter->last_visited = iter->last_visited->left;
+
+        return iter->last_visited;
+    }
+
+    for (;;)
+    {
+        RBTNode    *came_from = iter->last_visited;
+
+        iter->last_visited = iter->last_visited->parent;
+        if (iter->last_visited == NULL)
+        {
+            iter->is_over = true;
+            break;
+        }
+
+        if (iter->last_visited->left == came_from)
+            break;              /* came from left sub-tree, return current
+                                 * node */
+
+        /* else - came from right sub-tree, continue to move up */
+    }
+
+    return iter->last_visited;
+}
+
+static RBTNode *
+rbt_right_left_iterator(RBTreeIterator *iter)
+{
+    if (iter->last_visited == NULL)
+    {
+        iter->last_visited = iter->rbt->root;
+        while (iter->last_visited->right != RBTNIL)
+            iter->last_visited = iter->last_visited->right;
+
+        return iter->last_visited;
+    }
+
+    if (iter->last_visited->left != RBTNIL)
+    {
+        iter->last_visited = iter->last_visited->left;
+        while (iter->last_visited->right != RBTNIL)
+            iter->last_visited = iter->last_visited->right;
+
+        return iter->last_visited;
+    }
+
+    for (;;)
+    {
+        RBTNode    *came_from = iter->last_visited;
+
+        iter->last_visited = iter->last_visited->parent;
+        if (iter->last_visited == NULL)
+        {
+            iter->is_over = true;
+            break;
+        }
+
+        if (iter->last_visited->right == came_from)
+            break;              /* came from right sub-tree, return current
+                                 * node */
+
+        /* else - came from left sub-tree, continue to move up */
+    }
+
+    return iter->last_visited;
+}
+
+/*
+ * rbt_begin_iterate: prepare to traverse the tree in any of several orders
+ *
+ * After calling rbt_begin_iterate, call rbt_iterate repeatedly until it
+ * returns NULL or the traversal stops being of interest.
+ *
+ * If the tree is changed during traversal, results of further calls to
+ * rbt_iterate are unspecified.  Multiple concurrent iterators on the same
+ * tree are allowed.
+ *
+ * The iterator state is stored in the 'iter' struct.  The caller should
+ * treat it as an opaque struct.
+ */
+void
+rbt_begin_iterate(RBTree *rbt, RBTOrderControl ctrl, RBTreeIterator *iter)
+{
+    /* Common initialization for all traversal orders */
+    iter->rbt = rbt;
+    iter->last_visited = NULL;
+    iter->is_over = (rbt->root == RBTNIL);
+
+    switch (ctrl)
+    {
+        case LeftRightWalk:     /* visit left, then self, then right */
+            iter->iterate = rbt_left_right_iterator;
+            break;
+        case RightLeftWalk:     /* visit right, then self, then left */
+            iter->iterate = rbt_right_left_iterator;
+            break;
+        default:;
+#ifndef NDEBUG
+            fprintf(stderr, "unrecognized rbtree iteration order: %d", ctrl);
+#endif
+    }
+}
+
+/*
+ * rbt_iterate: return the next node in traversal order, or NULL if no more
+ */
+RBTNode *
+rbt_iterate(RBTreeIterator *iter)
+{
+    if (iter->is_over)
+        return NULL;
+
+    return iter->iterate(iter);
+}
+
+bool rbt_is_empty(const RBTree* rbt) {
+    return rbt->root == RBTNIL;
+#if 0
+    bool ret1 = (rbt->root == RBTNIL);
+
+    RBTreeIterator itr;
+    RBTNode* node;
+    rbt_begin_iterate((RBTree *)rbt, LeftRightWalk, &itr);
+
+    node = rbt_iterate(&itr);
+    bool ret2 = (node == NULL);
+
+    if (ret1 != ret2) {
+#ifndef NDEBUG
+        fprintf(stderr, "is_empty\n");
+#endif
+        /* exit(0); */
+    }
+    return ret1;
+#endif
+}
diff --git a/osal/src/sugar/s_task.c b/osal/src/sugar/s_task.c
new file mode 100644
index 0000000..8e90afc
--- /dev/null
+++ b/osal/src/sugar/s_task.c
@@ -0,0 +1,371 @@
+/* Copyright xhawk, MIT license */
+
+#include <setjmp.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <limits.h>
+#include "s_task.h"
+#include "s_list.h"
+#include "s_rbtree.h"
+
+#define S_TASK_STACK_MAGIC ((int)0x5AA55AA5)
+THREAD_LOCAL s_task_globals_t g_globals;
+
+#if defined __GNUC__ && __USES_INITFINI__ && defined __ARM_ARCH
+#   if __ARM_ARCH == 7
+#       include "s_port_armv7m.inc.h"
+#   elif __ARM_ARCH == 6
+#       include "s_port_armv6m.inc.h"
+#   else
+#       error "no arch detected"
+#   endif
+#elif defined __ARMCC_VERSION
+#   if defined __TARGET_CPU_CORTEX_M0
+#       include "s_port_armv6m.inc.h"
+#   elif defined __TARGET_CPU_CORTEX_M3
+#       include "s_port_armv7m.inc.h"
+#   elif defined __TARGET_CPU_CORTEX_M4
+#       include "s_port_armv7m.inc.h"
+#   elif defined __TARGET_CPU_CORTEX_M4_FP
+#       include "s_port_armv7m.inc.h"
+#   else
+#       error "no arch detected"
+#   endif
+#elif defined __ICCSTM8__
+#   if defined STM8S103
+#       include "s_port_stm8s.inc.h"
+#   elif defined STM8L05X_LD_VL
+#       include "s_port_stm8l15x.inc.h"
+#   endif
+#elif defined _WIN32
+#   include "s_port_windows.inc.h"
+#elif defined __unix__ || defined __linux__ || defined __APPLE__
+#   include "s_port_posix.inc.h"
+#elif defined __AVR__
+#   include "s_port_avr.inc.h"
+#elif defined __riscv
+#   include "s_port_riscv.inc.h"
+#else
+#   error "no arch detected"
+#endif
+
+
+
+
+/*******************************************************************/
+/* tasks                                                           */
+/*******************************************************************/
+
+
+int s_task_msleep(__async__, uint32_t msec) {
+    my_clock_t ticks = msec_to_ticks(msec);
+    return s_task_sleep_ticks(__await__, ticks);
+}
+
+int s_task_sleep(__async__, uint32_t sec) {
+    my_clock_t ticks = sec_to_ticks(sec);
+    return s_task_sleep_ticks(__await__, ticks);
+}
+
+my_clock_t msec_to_ticks(uint32_t msec) {
+    uint64_t ret = (uint64_t)((uint64_t)msec * (1024 * (uint64_t)MY_CLOCKS_PER_SEC / 1000) / 1024);
+    if(ret >= ((my_clock_t)-1))
+        return (my_clock_t)-1;
+    else
+        return (my_clock_t)ret;
+}
+
+my_clock_t sec_to_ticks(uint32_t sec) {
+    uint64_t ret = (uint64_t)((uint64_t)sec * (uint64_t)MY_CLOCKS_PER_SEC);
+    if(ret >= (my_clock_t)-1)
+        return (my_clock_t)-1;
+    else
+        return (my_clock_t)ret;
+}
+
+#define TICKS_DEVIDER   (uint32_t)(4096*1024)
+#define TICKS_PER_SEC_1 (uint32_t)(TICKS_DEVIDER / MY_CLOCKS_PER_SEC)
+
+uint32_t ticks_to_msec(my_clock_t ticks) {
+#if INT_MAX < 65536 /* it seems that stm8 uint64 is uint32 */
+    uint32_t msec = 1000 * (uint32_t)ticks / MY_CLOCKS_PER_SEC;
+    return msec;
+#else
+    uint64_t u64_msec = 1000 * (uint64_t)ticks * TICKS_PER_SEC_1 / TICKS_DEVIDER;
+    uint32_t msec = (u64_msec > (uint64_t)~(uint32_t)0
+        ? ~(uint32_t)0 : (uint32_t)u64_msec);
+    return msec;
+#endif
+}
+
+uint32_t ticks_to_sec(my_clock_t ticks) {
+#if INT_MAX < 65536 /* it seems that stm8 uint64 is uint32 */
+    uint32_t sec = (uint32_t)ticks / MY_CLOCKS_PER_SEC;
+    return sec;
+#else
+    uint64_t u64_sec = (uint64_t)ticks * TICKS_PER_SEC_1 / TICKS_DEVIDER;
+    uint32_t sec = (u64_sec > (uint64_t)~(uint32_t)0
+        ? ~(uint32_t)0 : (uint32_t)u64_sec);
+    return sec;
+#endif
+}
+
+/*
+    *timeout, wait timeout
+    return, true on task run
+ */
+static void s_task_call_next(__async__) {
+    /* get next task and run it */
+    s_list_t* next;
+    s_task_t* old_task;
+
+    (void)__awaiter_dummy__;
+
+    /* Check active tasks */
+    if (s_list_is_empty(&g_globals.active_tasks)) {
+#ifndef NDEBUG
+        fprintf(stderr, "error: must has one task to run\n");
+#endif
+        return;
+    }
+
+    old_task = g_globals.current_task;
+    next = s_list_get_next(&g_globals.active_tasks);
+
+    /* printf("next = %p %p\n", g_globals.current_task, next); */
+
+    g_globals.current_task = GET_PARENT_ADDR(next, s_task_t, node);
+    s_list_detach(next);
+
+    if (old_task != g_globals.current_task) {
+#if defined   USE_SWAP_CONTEXT
+        swapcontext(&old_task->uc, &g_globals.current_task->uc);
+#elif defined USE_JUMP_FCONTEXT
+        s_jump_t jump;
+        jump.from = &old_task->fc;
+        jump.to = &g_globals.current_task->fc;
+        transfer_t t = jump_fcontext(g_globals.current_task->fc, (void*)&jump);
+        s_jump_t* ret = (s_jump_t*)t.data;
+        *ret->from = t.fctx;
+#endif
+    }
+
+#ifdef USE_STACK_DEBUG
+    if(g_globals.current_task->stack_size > 0) {
+        s_task_t* task = g_globals.current_task;
+        void *real_stack = (void *)&task[1];
+        size_t real_stack_size = task->stack_size - sizeof(task[0]);
+        size_t int_stack_size = real_stack_size / sizeof(int);
+        if(((int *)real_stack)[0] != S_TASK_STACK_MAGIC) {
+#ifndef NDEBUG
+            fprintf(stderr, "stack overflow in lower bits");
+#endif
+            while(1);   /* dead */
+        }
+        if(((int *)real_stack)[int_stack_size - 1] != S_TASK_STACK_MAGIC) {
+#ifndef NDEBUG
+            fprintf(stderr, "stack overflow in higher bits");
+#endif
+            while(1);   /* dead */
+        }
+    }
+#endif
+}
+
+void s_task_next(__async__) {
+    g_globals.current_task->waiting_cancelled = false;
+    while (true) {
+#ifdef USE_IN_EMBEDDED
+        if(g_globals.irq_actived){
+            S_IRQ_DISABLE();
+            g_globals.irq_actived = 0;
+            s_list_attach(&g_globals.active_tasks, &g_globals.irq_active_tasks);
+            s_list_detach(&g_globals.irq_active_tasks);
+            S_IRQ_ENABLE();
+        }
+#endif
+
+        s_timer_run();
+        if (!s_list_is_empty(&g_globals.active_tasks)) {
+            s_task_call_next(__await__);
+            return;
+        }
+
+        /* Check timers */
+#ifndef USE_LIST_TIMER_CONTAINER
+        if (!rbt_is_empty(&g_globals.timers)) {
+#else
+        if (!s_list_is_empty(&g_globals.timers)) {
+#endif
+            /* Wait for the recent timer */
+            uint64_t timeout = s_timer_wait_recent();
+            my_on_idle(timeout);
+        }
+        else if(s_task_cancel_dead() == 0) {
+
+#ifndef NDEBUG
+            fprintf(stderr, "error: must not wait so long!\n");
+#endif
+            my_on_idle((uint64_t)-1);
+        }
+    }
+}
+
+void s_task_yield(__async__) {
+    /* Put current task to the waiting list */
+    s_list_attach(&g_globals.active_tasks, &g_globals.current_task->node);
+    s_task_next(__await__);
+    g_globals.current_task->waiting_cancelled = false;
+}
+
+void s_task_init_system_()
+{
+
+#if defined USE_IN_EMBEDDED
+    s_list_init(&g_globals.irq_active_tasks);
+    g_globals.irq_actived = 0;
+#endif
+
+    s_list_init(&g_globals.active_tasks);
+#ifdef USE_DEAD_TASK_CHECKING
+    s_list_init(&g_globals.waiting_mutexes);
+    s_list_init(&g_globals.waiting_events);
+#endif
+
+#ifndef USE_LIST_TIMER_CONTAINER
+    rbt_create(&g_globals.timers,
+        s_timer_comparator,
+        NULL
+    );
+#else
+    s_list_init(&g_globals.timers);
+#endif
+
+    my_clock_init();
+
+    s_list_init(&g_globals.main_task.node);
+    s_event_init(&g_globals.main_task.join_event);
+    g_globals.main_task.stack_size = 0;
+    g_globals.main_task.closed = false;
+    g_globals.main_task.waiting_cancelled = false;
+    g_globals.current_task = &g_globals.main_task;
+}
+
+void s_task_create(void *stack, size_t stack_size, s_task_fn_t task_entry, void *task_arg) {
+    void *real_stack;
+    size_t real_stack_size;
+
+    s_task_t *task = (s_task_t *)stack;
+    s_list_init(&task->node);
+    s_event_init(&task->join_event);
+    task->task_entry = task_entry;
+    task->task_arg   = task_arg;
+    task->stack_size = stack_size;
+    task->closed = false;
+    task->waiting_cancelled = false;
+    s_list_attach(&g_globals.active_tasks, &task->node);
+
+    real_stack = (void *)&task[1];
+    real_stack_size = stack_size - sizeof(task[0]);
+#ifdef USE_STACK_DEBUG
+    {
+        /* Fill magic number so as to check stack size */
+        size_t int_stack_size = real_stack_size / sizeof(int);
+        if(int_stack_size <= 2) {
+#ifndef NDEBUG
+            fprintf(stderr, "stack size too small");
+            return;
+#endif
+        }
+        ((int *)real_stack)[0] = S_TASK_STACK_MAGIC;
+        ((int *)real_stack)[int_stack_size - 1] = S_TASK_STACK_MAGIC;
+        real_stack = (char *)real_stack + sizeof(int);
+        real_stack_size = (int_stack_size - 2) * sizeof(int);
+    }
+#endif
+
+#if defined   USE_SWAP_CONTEXT
+    create_context(&task->uc, real_stack, real_stack_size);
+#elif defined USE_JUMP_FCONTEXT
+    create_fcontext(&task->fc, real_stack, real_stack_size, s_task_fcontext_entry);
+#endif
+}
+
+int s_task_join(__async__, void *stack) {
+    s_task_t *task = (s_task_t *)stack;
+    while (!task->closed) {
+        int ret = s_event_wait(__await__, &task->join_event);
+        if (ret != 0)
+            return ret;
+    }
+    return 0;
+}
+
+/* timer conflict with this function!!!
+   Do NOT call s_task_kill, and let the task exit by itself! */
+void s_task_kill__remove(void *stack) {
+    s_task_t *task = (s_task_t *)stack;
+    s_list_detach(&task->node);
+}
+
+void s_task_cancel_wait(void* stack) {
+    s_task_t* task = (s_task_t*)stack;
+
+    task->waiting_cancelled = true;
+    s_list_detach(&task->node);
+    s_list_attach(&g_globals.active_tasks, &task->node);
+}
+
+unsigned int s_task_cancel_dead() {
+#ifdef USE_DEAD_TASK_CHECKING
+    return s_event_cancel_dead_waiting_tasks_()
+         + s_mutex_cancel_dead_waiting_tasks_();
+#else
+    return 0;
+#endif
+}
+
+static size_t s_task_get_stack_free_size_ex_by_stack(void *stack) {
+    uint32_t *check;
+    for(check = (uint32_t *)stack; ; ++check){
+        if(*check != 0xFFFFFFFF)
+            return (char *)check - (char *)stack;
+    }
+}
+
+static size_t s_task_get_stack_free_size_by_task(s_task_t *task) {
+    return s_task_get_stack_free_size_ex_by_stack(&task[1]);
+}
+
+size_t s_task_get_stack_free_size() {
+    return s_task_get_stack_free_size_by_task(g_globals.current_task);
+}
+
+void s_task_context_entry() {
+    struct tag_s_task_t *task = g_globals.current_task;
+    s_task_fn_t task_entry = task->task_entry;
+    void *task_arg         = task->task_arg;
+
+    __async__ = 0;
+    (*task_entry)(__await__, task_arg);
+
+    task->closed = true;
+    s_event_set(&task->join_event);
+    s_task_next(__await__);
+}
+
+
+#ifdef USE_JUMP_FCONTEXT
+void s_task_fcontext_entry(transfer_t arg) {
+    /* printf("=== s_task_helper_entry = %p\n", arg.fctx); */
+
+    s_jump_t* jump = (s_jump_t*)arg.data;
+    *jump->from = arg.fctx;
+    /* printf("%p %p %p\n", jump, jump->to, g_globals.current_task); */
+
+    s_task_context_entry();
+}
+#endif
+
+
diff --git a/osal/src/sugar/s_timer_fast.c b/osal/src/sugar/s_timer_fast.c
new file mode 100644
index 0000000..6fe3a22
--- /dev/null
+++ b/osal/src/sugar/s_timer_fast.c
@@ -0,0 +1,144 @@
+/* Copyright xhawk, MIT license */
+
+#include "s_task.h"
+
+#ifndef USE_LIST_TIMER_CONTAINER
+
+/*******************************************************************/
+/* timer                                                           */
+/*******************************************************************/
+
+int s_timer_comparator(const RBTNode* a, const RBTNode* b, void* arg) {
+    s_timer_t* timer_a = GET_PARENT_ADDR(a, s_timer_t, rbt_node);
+    s_timer_t* timer_b = GET_PARENT_ADDR(b, s_timer_t, rbt_node);
+    (void)arg;
+
+    my_clock_diff_t diff = (my_clock_diff_t)(timer_a->wakeup_ticks - timer_b->wakeup_ticks);
+    if (diff != 0) {
+        return (int)diff;
+    }
+    else {
+        if (timer_a->task < timer_b->task)
+            return -1;
+        else if (timer_b->task < timer_a->task)
+            return 1;
+        else
+            return 0;
+    }
+}
+
+void dump_timers(int line) {
+#if 0
+    RBTreeIterator itr;
+    RBTNode* node;
+    RBTNode* node_next;
+    my_clock_t current_ticks = my_clock();
+    printf("=========================== %d\n", line);
+    rbt_begin_iterate(&g_globals.timers, LeftRightWalk, &itr);
+    node_next = rbt_iterate(&itr);
+    while ((node = node_next) != NULL) {
+        s_timer_t* timer = GET_PARENT_ADDR(node, s_timer_t, rbt_node);
+        printf("timer: %p %d %d\n", timer->task, (int)timer->wakeup_ticks, (int)(timer->wakeup_ticks - current_ticks));
+        node_next = rbt_iterate(&itr);
+    }
+
+    s_list_t* list;
+    for (list = &g_globals.active_tasks.next; list != &g_globals.active_tasks; list = list->next) {
+        s_task_t *task = GET_PARENT_ADDR(list, s_task_t, node);
+        printf("task: %p\n", task);
+    }
+#else
+    (void)line;
+#endif
+}
+
+void s_timer_run(void) {
+    my_clock_t current_ticks = my_clock();
+
+    RBTreeIterator itr;
+    RBTNode* node;
+    RBTNode* node_next;
+
+    dump_timers(__LINE__);
+
+    rbt_begin_iterate(&g_globals.timers, LeftRightWalk, &itr);
+    node_next = rbt_iterate(&itr);
+    while ((node = node_next) != NULL) {
+
+        s_timer_t* timer = GET_PARENT_ADDR(node, s_timer_t, rbt_node);
+
+        my_clock_diff_t ticks_to_wakeup = (my_clock_diff_t)(timer->wakeup_ticks - current_ticks);
+        if (ticks_to_wakeup > 0) break;
+
+        node_next = rbt_iterate(&itr);
+
+        s_list_detach(&timer->task->node);
+        s_list_attach(&g_globals.active_tasks, &timer->task->node);
+
+        timer->task = NULL;
+        rbt_delete(&g_globals.timers, node);
+    }
+
+    dump_timers(__LINE__);
+
+}
+
+uint64_t s_timer_wait_recent(void) {
+    my_clock_t current_ticks = my_clock();
+
+    RBTreeIterator itr;
+    RBTNode* node;
+    rbt_begin_iterate(&g_globals.timers, LeftRightWalk, &itr);
+
+    if ((node = rbt_iterate(&itr)) != NULL) {
+        s_timer_t* timer = GET_PARENT_ADDR(node, s_timer_t, rbt_node);
+
+        my_clock_diff_t ticks_to_wakeup = (my_clock_diff_t)(timer->wakeup_ticks - current_ticks);
+        /* printf("ticks_to_wakeup = %d %d %d \n", ticks_to_wakeup, (int)current_ticks, (int)timer->wakeup_ticks); */
+        if (ticks_to_wakeup > 0) {
+            uint64_t wait = ((uint64_t)ticks_to_wakeup * 1000 / MY_CLOCKS_PER_SEC);
+            return wait;
+        }
+        else
+            return 0;
+    }
+    return (uint64_t)-1;    /* max value */
+}
+
+int s_task_sleep_ticks(__async__, my_clock_t ticks) {
+    my_clock_t current_ticks;
+    s_timer_t timer;
+
+    current_ticks = my_clock();
+
+    timer.task = g_globals.current_task;
+    timer.wakeup_ticks = current_ticks + ticks;
+
+    dump_timers(__LINE__);
+
+    if (!rbt_insert(&g_globals.timers, &timer.rbt_node)) {
+#ifndef NDEBUG
+        fprintf(stderr, "timer insert failed!\n");
+#endif
+        return -1;
+    }
+
+    dump_timers(__LINE__);
+
+    s_list_detach(&timer.task->node);   /* no need, for safe */
+    s_task_next(__await__);
+
+    dump_timers(__LINE__);
+
+    if (timer.task != NULL) {
+        timer.task = NULL;
+        rbt_delete(&g_globals.timers, &timer.rbt_node);
+    }
+
+    int ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+
+
+#endif
diff --git a/osal/src/sugar/s_timer_small.c b/osal/src/sugar/s_timer_small.c
new file mode 100644
index 0000000..cac62de
--- /dev/null
+++ b/osal/src/sugar/s_timer_small.c
@@ -0,0 +1,88 @@
+/* Copyright xhawk, MIT license */
+
+#include "s_task.h"
+
+#ifdef USE_LIST_TIMER_CONTAINER
+
+/*******************************************************************/
+/* timer                                                           */
+/*******************************************************************/
+
+void s_timer_run() {
+    my_clock_t current_ticks = my_clock();
+
+    s_list_t *node = s_list_get_next(&g_globals.timers);
+    while (node != &g_globals.timers) {
+        s_list_t *node_next;
+        s_timer_t *timer = GET_PARENT_ADDR(node, s_timer_t, node);
+
+        my_clock_diff_t ticks_to_wakeup = (my_clock_diff_t)(timer->wakeup_ticks - current_ticks);
+        if (ticks_to_wakeup > 0) break;
+
+        node_next = s_list_get_next(node);
+
+        s_list_detach(&timer->task->node);
+        s_list_attach(&g_globals.active_tasks, &timer->task->node);
+
+        timer->task = NULL;
+        s_list_detach(node);
+        node = node_next;
+    }
+}
+
+uint64_t s_timer_wait_recent() {
+    my_clock_t current_ticks = my_clock();
+    s_list_t *node = s_list_get_next(&g_globals.timers);
+    if (node != &g_globals.timers) {
+        s_timer_t *timer = GET_PARENT_ADDR(node, s_timer_t, node);
+
+        my_clock_diff_t ticks_to_wakeup = (my_clock_diff_t)(timer->wakeup_ticks - current_ticks);
+        /* printf("ticks_to_wakeup = %d %d %d \n", ticks_to_wakeup, (int)current_ticks, (int)timer->wakeup_ticks); */
+        if (ticks_to_wakeup > 0) {
+            uint64_t wait = ((uint64_t)ticks_to_wakeup * 1000 / MY_CLOCKS_PER_SEC);
+            return wait;
+        }
+        else
+            return 0;
+    }
+    return (uint64_t)-1;    /* max value */
+}
+
+int s_task_sleep_ticks(__async__, my_clock_t ticks) {
+    my_clock_t current_ticks;
+    s_list_t *node;
+    s_timer_t timer;
+    int ret;
+
+    current_ticks = my_clock();
+
+    s_list_init(&timer.node);
+    timer.task = g_globals.current_task;
+    timer.wakeup_ticks = current_ticks + ticks;
+
+    for(node = s_list_get_next(&g_globals.timers);
+        node != &g_globals.timers;
+        node = s_list_get_next(node)) {
+        s_timer_t *timer = GET_PARENT_ADDR(node, s_timer_t, node);
+
+        my_clock_diff_t ticks_to_wakeup = (my_clock_diff_t)(timer->wakeup_ticks - current_ticks);
+        if (ticks_to_wakeup >= 0 && (my_clock_t)ticks_to_wakeup > ticks)
+            break;
+    }
+    s_list_attach(node, &timer.node);
+
+    s_list_detach(&timer.task->node);   /* no need, for safe */
+    s_task_next(__await__);
+
+    if (timer.task != NULL) {
+        timer.task = NULL;
+        s_list_detach(&timer.node);
+    }
+
+    ret = (g_globals.current_task->waiting_cancelled ? -1 : 0);
+    g_globals.current_task->waiting_cancelled = false;
+    return ret;
+}
+
+
+#endif
-- 
2.32.0.windows.1

